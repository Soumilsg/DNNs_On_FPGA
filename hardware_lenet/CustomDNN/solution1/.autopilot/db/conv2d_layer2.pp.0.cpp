# 1 "conv2d_layer2.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 395 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\etc/autopilot_ssdm_op.h" 1
# 108 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\etc/autopilot_ssdm_op.h"
extern "C" {






    void _ssdm_op_IfRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_IfWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_StreamRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_StreamWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned _ssdm_StreamSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_ReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Read(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_WriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Write(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_CanReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_NbWriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_CanWriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_op_MemShiftRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_PrintNone(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_PrintInt(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_PrintDouble(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Wait(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Poll(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Return(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecSynModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecTopModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDecl(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDef(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecConnection(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecChannel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecSensitive(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecModuleInst(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPortMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecReset(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPlatform(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecClockDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPowerDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecRegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecRegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopName(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopTripCount(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecStateBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecStateEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecInterface(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecDataflowPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecLatency(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecParallel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProtocol(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecOccurrence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecResource(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecResourceLimit(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecCHCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecFUCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIFCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIPCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecMemCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecExt(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_SpecArrayDimSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_RegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_RegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_Unroll(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_UnrollRegion(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_InlineAll(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineLoop(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_Inline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineSelf(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineRegion(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecArrayMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayPartition(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayReshape(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecStream(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecStable(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecStableContent(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBindPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipoDepth(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecExpr(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecExprBalance(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecDependence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecLoopMerge(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopFlatten(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopRewind(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecFuncInstantiation(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncBuffer(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncExtract(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecConstant(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_DataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecDataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBitsMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecLicense(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void __xilinx_ip_top(...) __attribute__ ((nothrow)) __attribute__((overloadable));


}
# 2 "<built-in>" 2
# 1 "conv2d_layer2.cpp" 2

# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int.h" 1
# 10 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_common.h" 1
# 41 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_common.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_decl.h" 1
# 54 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_decl.h"
enum ap_q_mode {
  AP_RND,
  AP_RND_ZERO,
  AP_RND_MIN_INF,
  AP_RND_INF,
  AP_RND_CONV,
  AP_TRN,
  AP_TRN_ZERO,
};
# 76 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_decl.h"
enum ap_o_mode {
  AP_SAT,
  AP_SAT_ZERO,
  AP_SAT_SYM,
  AP_WRAP,
  AP_WRAP_SM,
};
# 133 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_decl.h"
template <int _AP_W, bool _AP_S>
struct ap_int_base;

template <int _AP_W>
struct ap_int;

template <int _AP_W>
struct ap_uint;

template <int _AP_W, bool _AP_S>
struct ap_range_ref;

template <int _AP_W, bool _AP_S>
struct ap_bit_ref;

template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref;

template <int _AP_W, int _AP_I, bool _AP_S = true, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed_base;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_ufixed;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref;


enum BaseMode { AP_BIN = 2, AP_OCT = 8, AP_DEC = 10, AP_HEX = 16 };
# 187 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_decl.h"
typedef signed long long ap_slong;
typedef unsigned long long ap_ulong;


enum {
  _AP_SIZE_char = 8,
  _AP_SIZE_short = sizeof(short) * 8,
  _AP_SIZE_int = sizeof(int) * 8,
  _AP_SIZE_long = sizeof(long) * 8,
  _AP_SIZE_ap_slong = sizeof(ap_slong) * 8
};
# 42 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_common.h" 2
# 164 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_common.h"
enum { CHAR_IS_SIGNED = (char)-1 < 0 };


namespace _ap_type {
template <typename _Tp>
struct is_signed {
  static const bool value = _Tp(-1) < _Tp(1);
};

template <typename _Tp>
struct is_integral {
  static const bool value = false;
};





template <> struct is_integral<bool> { static const bool value = true; };
template <> struct is_integral<char> { static const bool value = true; };
template <> struct is_integral<signed char> { static const bool value = true; };
template <> struct is_integral<unsigned char> { static const bool value = true; };
template <> struct is_integral<short> { static const bool value = true; };
template <> struct is_integral<unsigned short> { static const bool value = true; };
template <> struct is_integral<int> { static const bool value = true; };
template <> struct is_integral<unsigned int> { static const bool value = true; };
template <> struct is_integral<long> { static const bool value = true; };
template <> struct is_integral<unsigned long> { static const bool value = true; };
template <> struct is_integral<ap_slong> { static const bool value = true; };
template <> struct is_integral<ap_ulong> { static const bool value = true; };


template <bool, typename _Tp = void>
struct enable_if {};

template <typename _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const<_Tp const> {
  typedef _Tp type;
};
}
# 507 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_common.h"
template <int _AP_N, bool _AP_S>
struct ssdm_int;

template <int _AP_N>
struct ssdm_int<_AP_N, true> {
  typedef int __attribute__((bitwidth(_AP_N))) DataType;
  int V __attribute__((bitwidth(_AP_N)));
  inline __attribute__((always_inline)) ssdm_int<_AP_N, true>(){};
                inline __attribute__((always_inline)) ssdm_int<_AP_N, true>(int o __attribute__((bitwidth(_AP_N)))):V(o){};
};

template <int _AP_N>
struct ssdm_int<_AP_N, false> {
  typedef unsigned __attribute__((bitwidth(_AP_N))) DataType;
  unsigned V __attribute__((bitwidth(_AP_N)));
  inline __attribute__((always_inline)) ssdm_int<_AP_N, false>(){};
                inline __attribute__((always_inline)) ssdm_int<_AP_N, false>(unsigned o __attribute__((bitwidth(_AP_N)))):V(o){};
};
# 575 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_common.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/etc/autopilot_ssdm_bits.h" 1
# 576 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_common.h" 2

extern "C" void _ssdm_string2bits(...);
# 587 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_common.h"
static inline unsigned char guess_radix(const char* s) {
  unsigned char rd = 10;
  const char* p = s;

  if (p[0] == '-' || p[0] == '+') ++p;

  if (p[0] == '0') {
    if (p[1] == 'b' || p[1] == 'B') {
      rd = 2;
    } else if (p[1] == 'o' || p[1] == 'O') {
      rd = 8;
    } else if (p[1] == 'x' || p[1] == 'X') {
      rd = 16;
    } else if (p[1] == 'd' || p[1] == 'D') {
      rd = 10;
    }
  }
  return rd;
}







typedef __fp16 half;
# 718 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_common.h"
inline __attribute__((always_inline)) ap_ulong doubleToRawBits(double pf) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned int floatToRawBits(float pf) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline __attribute__((always_inline)) unsigned short halfToRawBits(half pf) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__D = pf;
  return LD.__L;



}


inline __attribute__((always_inline)) double rawBitsToDouble(ap_ulong pi) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) float rawBitsToFloat(unsigned long pi) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline __attribute__((always_inline)) half rawBitsToHalf(unsigned short pi) {

  union {
    unsigned short __L;
    half __D;
  } LD;
  LD.__L = pi;
  return LD.__D;






}
# 11 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h" 1
# 40 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_N, bool _AP_S>
struct retval;


template <int _AP_N>
struct retval<_AP_N, true> {
  typedef ap_slong Type;
};

template <int _AP_N>
struct retval<_AP_N, false> {
  typedef ap_ulong Type;
};


template <>
struct retval<1, true> {
  typedef signed char Type;
};

template <>
struct retval<1, false> {
  typedef unsigned char Type;
};


template <>
struct retval<2, true> {
  typedef short Type;
};

template <>
struct retval<2, false> {
  typedef unsigned short Type;
};


template <>
struct retval<3, true> {
  typedef long Type;
};

template <>
struct retval<3, false> {
  typedef unsigned long Type;
};

template <>
struct retval<4, true> {
  typedef long Type;
};

template <>
struct retval<4, false> {
  typedef unsigned long Type;
};




template <int _AP_W2, bool _AP_S2>
struct _ap_int_factory;
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,true> { typedef ap_int<_AP_W2> type; };
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,false> { typedef ap_uint<_AP_W2> type; };

template <int _AP_W, bool _AP_S>
struct ap_int_base : public ssdm_int<_AP_W, _AP_S> {
 private:
                inline __attribute__((always_inline)) int countLeadingOnes() const {




    return 0;

  }

 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;







  typedef typename retval<(((_AP_W + 7) / 8) > (8) ? ((_AP_W + 7) / 8) : (8)), _AP_S>::Type RetType;

  static const int width = _AP_W;
  static const bool sign_flag = _AP_S;

  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };


    typedef ap_int_base<mult_w, mult_s> mult_base;
    typedef ap_int_base<plus_w, plus_s> plus_base;
    typedef ap_int_base<minus_w, minus_s> minus_base;
    typedef ap_int_base<logic_w, logic_s> logic_base;
    typedef ap_int_base<div_w, div_s> div_base;
    typedef ap_int_base<mod_w, mod_s> mod_base;
    typedef ap_int_base<_AP_W, _AP_S> arg1_base;

    typedef typename _ap_int_factory<mult_w, mult_s>::type mult;
    typedef typename _ap_int_factory<plus_w, plus_s>::type plus;
    typedef typename _ap_int_factory<minus_w, minus_s>::type minus;
    typedef typename _ap_int_factory<logic_w, logic_s>::type logic;
    typedef typename _ap_int_factory<div_w, div_s>::type div;
    typedef typename _ap_int_factory<mod_w, mod_s>::type mod;
    typedef typename _ap_int_factory<_AP_W, _AP_S>::type arg1;
    typedef bool reduce;
  };





  inline __attribute__((always_inline)) ap_int_base() {





  }


  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) ap_int_base(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op.V) {
    Base::V = op.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }
# 208 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) ap_int_base(const bool op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const signed char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned char op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const short op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned short op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const int op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned int op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const long op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const unsigned long op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const ap_slong op):Base(op) { Base::V = op; }
  inline __attribute__((always_inline)) ap_int_base(const ap_ulong op):Base(op) { Base::V = op; }




  inline __attribute__((always_inline)) ap_int_base(half op) {
    ap_int_base<_AP_W, _AP_S> t((float)op);
    Base::V = t.V;
  }


  inline __attribute__((always_inline)) ap_int_base(float op) {
    const int BITS = 23 + 8 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = floatToRawBits(op);
    bool is_neg = ({ typeof(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<8 + 1, true> exp = 0;
    exp.V = ({ typename _ap_type::remove_const<typeof(reg.V)>::type __Result__ = 0; typeof(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 23, BITS - 2); __Result__; });
    exp = exp - ((1L << (8 - 1L)) - 1L);

    ap_int_base<23 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<typeof(reg.V)>::type __Result__ = 0; typeof(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 23 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<typeof(man.V)>::type __Result__ = 0; typeof(man.V) __Val2__ = man.V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23); __Result__; });


    if ((reg.V & 0x7ffffffful) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 23 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 23 + 2) {
          ap_int_base<23 + 2, true> man_shift;
          man_shift.V = (man.V >> sh_amt);






          Base::V = man_shift.V;
        } else {



            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {



          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  inline __attribute__((always_inline)) ap_int_base(double op) {
    const int BITS = 52 + 11 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = doubleToRawBits(op);
    bool is_neg = ({ typeof(reg.V) __Val2__ = reg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), BITS - 1); __Result__; });

    ap_int_base<11 + 1, true> exp = 0;
    exp.V = ({ typename _ap_type::remove_const<typeof(reg.V)>::type __Result__ = 0; typeof(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, BITS - 2); __Result__; });
    exp = exp - ((1L << (11 - 1L)) - 1L);

    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<typeof(reg.V)>::type __Result__ = 0; typeof(reg.V) __Val2__ = reg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });

    (static_cast<void>(0));


    man.V = ({ typename _ap_type::remove_const<typeof(man.V)>::type __Result__ = 0; typeof(man.V) __Val2__ = man.V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });


    if ((reg.V & 0x7fffffffffffffffull) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 52 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 52 + 2) {
          ap_int_base<23 + 2, true> man_shift;
          man_shift.V = (man.V >> sh_amt);






          Base::V = man_shift.V;
        } else {



           Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {



          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_int_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    op.checkOverflowCsimFix(_AP_W, _AP_S);
    Base::V = op.to_ap_int_base().V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const ap_range_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = (ref.get()).V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base(const ap_bit_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = ref.operator bool();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {
    const ap_int_base<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>::_AP_WR,
                      false>
        tmp = ref.get();
    Base::V = tmp.V;
  }
# 385 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) ap_int_base(const char* s) {
    typeof(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) ap_int_base(const char* s, signed char rd) {
    typeof(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_W, _AP_S,
                      AP_TRN, AP_WRAP, 0, true);
    Base::V = t;
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = (val.get()).V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = val.operator bool();
  }

  inline __attribute__((always_inline)) ap_int_base read() volatile {

    ap_int_base ret;
    ret.V = Base::V;
    return ret;
  }

  inline __attribute__((always_inline)) void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {

    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) void operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) void operator=(
      const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) void operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) void operator=(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
    *((volatile typename Base::DataType *)(&(Base::V))) = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) ap_int_base& operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline __attribute__((always_inline)) ap_int_base& operator=(const volatile ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }


  ap_int_base& operator=(const ap_int_base<_AP_W, _AP_S>& op2) = default;
# 479 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) ap_int_base& operator=(bool op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(signed char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned char op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned short op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned int op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(unsigned long op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(ap_slong op) { Base::V = op; return *this; }
  inline __attribute__((always_inline)) ap_int_base& operator=(ap_ulong op) { Base::V = op; return *this; }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (bool)op2;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_int_base& operator=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
    return *this;
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op2) {
    Base::V = op2.get().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = (bool)op;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_int_base& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
    return *this;
  }





                inline __attribute__((always_inline)) operator RetType() const { return (RetType)(Base::V); }




                inline __attribute__((always_inline)) bool to_bool() const { return (bool)(Base::V); }
                inline __attribute__((always_inline)) char to_char() const { return (char)(Base::V); }
                inline __attribute__((always_inline)) signed char to_schar() const { return (signed char)(Base::V); }
                inline __attribute__((always_inline)) unsigned char to_uchar() const { return (unsigned char)(Base::V); }
                inline __attribute__((always_inline)) short to_short() const { return (short)(Base::V); }
                inline __attribute__((always_inline)) unsigned short to_ushort() const { return (unsigned short)(Base::V); }
                inline __attribute__((always_inline)) int to_int() const { return (int)(Base::V); }
                inline __attribute__((always_inline)) unsigned to_uint() const { return (unsigned)(Base::V); }
                inline __attribute__((always_inline)) long to_long() const { return (long)(Base::V); }
                inline __attribute__((always_inline)) unsigned long to_ulong() const { return (unsigned long)(Base::V); }
                inline __attribute__((always_inline)) ap_slong to_int64() const { return (ap_slong)(Base::V); }
                inline __attribute__((always_inline)) ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
  inline __attribute__((always_inline)) half to_half() const { return (float)(Base::V); }
                inline __attribute__((always_inline)) float to_float() const { return (float)(Base::V); }
                inline __attribute__((always_inline)) double to_double() const { return (double)(Base::V); }
# 584 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) int length() const volatile { return _AP_W; }
                inline __attribute__((always_inline)) int length() const { return _AP_W; }


                inline __attribute__((always_inline)) bool iszero() const { return Base::V == 0; }


                inline __attribute__((always_inline)) bool is_zero() const { return Base::V == 0; }


                      inline __attribute__((always_inline)) bool sign() const {
    if (_AP_S &&
        ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }))
      return true;
    else
      return false;
  }


  inline __attribute__((always_inline)) void clear(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) void invert(int i) {
                                                           ;
    bool val = ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    if (val)
      Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(0) __Repl2__ = !!0; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
    else
      Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }

  inline __attribute__((always_inline)) bool test(int i) const {
                                                           ;
    return ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


                inline __attribute__((always_inline)) ap_int_base& get() { return *this; }


  inline __attribute__((always_inline)) void set(int i) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) void set(int i, bool v) {
                                                           ;
    Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }



  inline __attribute__((always_inline)) ap_int_base& lrotate(int n) {
                                                              ;


    typeof(Base::V) l_p = Base::V << n;
    typeof(Base::V) r_p = Base::V >> (_AP_W - n);
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) ap_int_base& rrotate(int n) {
                                                              ;


    typeof(Base::V) l_p = Base::V << (_AP_W - n);
    typeof(Base::V) r_p = Base::V >> n;
    Base::V = l_p | r_p;



    return *this;
  }



  inline __attribute__((always_inline)) ap_int_base& reverse() {
    Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
    return *this;
  }


  inline __attribute__((always_inline)) void set_bit(int i, bool v) {
    Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(v) __Repl2__ = !!v; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), i, i); __Result__; });
  }


  inline __attribute__((always_inline)) bool get_bit(int i) const {
    return (bool)({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
  }


  inline __attribute__((always_inline)) void b_not() { Base::V = ~Base::V; }

  template<typename T>
                inline __attribute__((always_inline)) void checkOverflowBaseC(T val) {
# 755 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
    (void)val;

    return;
  }

                inline __attribute__((always_inline)) bool checkOverflowCsim(int _ap_w2, bool _ap_s2,
          bool print = true) const {
# 805 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
      (void)_ap_w2;
      (void)_ap_s2;
      (void)print;

      return 0;
  }
# 839 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator *=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V *= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator +=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V += op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator -=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V -= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator /=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V /= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator %=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V %= op2.V; return *this; }
# 857 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator &=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V &= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator |=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V |= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base& operator ^=(const ap_int_base<_AP_W2, _AP_S2>& op2) { (static_cast<void>(0)); Base::V ^= op2.V; return *this; }





  inline __attribute__((always_inline)) ap_int_base& operator++() {
    operator+=((ap_int_base<1, false>)1);
    return *this;
  }
  inline __attribute__((always_inline)) ap_int_base& operator--() {
    operator-=((ap_int_base<1, false>)1);
    return *this;
  }




  inline __attribute__((always_inline)) const typename RType<_AP_W,_AP_S>::arg1 operator++(int) {
    ap_int_base t = *this;
    operator+=((ap_int_base<1, false>)1);
    return t;
  }
  inline __attribute__((always_inline)) const typename RType<_AP_W,_AP_S>::arg1 operator--(int) {
    ap_int_base t = *this;
    operator-=((ap_int_base<1, false>)1);
    return t;
  }




                inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator+() const { return *this; }


                inline __attribute__((always_inline)) typename RType<1, false>::minus operator-() const {
    return ap_int_base<1, false>(0) - *this;
  }




                inline __attribute__((always_inline)) bool operator!() const { return Base::V == 0; }





                inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator~() const {
    ap_int_base<_AP_W, _AP_S> r(0);
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_W2>
                      inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ typeof(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>(sh);
    } else
      return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r(0);
    r.V = Base::V << op2.to_uint();
    return r;
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = ({ typeof(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<(sh);
    }
    return operator>>(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r(0);
    r.V = Base::V >> op2.to_uint();
    return r;
  }
# 968 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ typeof(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>=(sh);
    } else
      return operator<<=(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_int_base& operator<<=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V <<= op2.to_uint();
    return *this;
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = ({ typeof(op2.V) __Val2__ = op2.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<=(sh);
    }
    return operator>>=(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_int_base& operator>>=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V >>= op2.to_uint();
    return *this;
  }
# 1017 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator==(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V == op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator!=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return !(Base::V == op2.V);
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator<(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V < op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator>=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V >= op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator>(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V > op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) bool operator<=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V <= op2.V;
  }




  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ap_range_ref<_AP_W, _AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }
# 1126 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> operator[](int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) bool operator[](int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator[](const ap_int_base<_AP_W2, _AP_S2>& index) const {
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index.to_int());
    return br.to_bool();
  }

  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> bit(int index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref<_AP_W, _AP_S> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline __attribute__((always_inline)) bool bit(int index) const {
                                                                       ;
                                                                 ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool bit(const ap_int_base<_AP_W2, _AP_S2>& index) const {
    return bit(index.to_int());
  }
# 1193 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
                inline __attribute__((always_inline)) int countLeadingZeros() const {

    if (_AP_W <= 32) {
      ap_int_base<32, false> t(-1UL), x;
      x.V = ({ typename _ap_type::remove_const<typeof(this->V)>::type __Result__ = 0; typeof(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
      t.V = ({ typename _ap_type::remove_const<typeof(t.V)>::type __Result__ = 0; typeof(t.V) __Val2__ = t.V; typeof(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, _AP_W - 1); __Result__; });
      return __builtin_ctz(t.V);
    } else if (_AP_W <= 64) {
      ap_int_base<64, false> t(-1ULL);
      ap_int_base<64, false> x;
      x.V = ({ typename _ap_type::remove_const<typeof(this->V)>::type __Result__ = 0; typeof(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - 1, 0); __Result__; });
      t.V = ({ typename _ap_type::remove_const<typeof(t.V)>::type __Result__ = 0; typeof(t.V) __Val2__ = t.V; typeof(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, _AP_W - 1); __Result__; });
      return __builtin_ctzll(t.V);
    } else {
      enum { __N = (_AP_W + 63) / 64 };
      int NZeros = 0;
      int i = 0;
      bool hitNonZero = false;
      VITIS_LOOP_1211_1: for (i = 0; i < __N - 1; ++i) {
        ap_int_base<64, false> t;
        t.V = ({ typename _ap_type::remove_const<typeof(this->V)>::type __Result__ = 0; typeof(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - i * 64 - 64, _AP_W - i * 64 - 1); __Result__; });
        NZeros += hitNonZero ? 0 : __builtin_clzll(t.V);
        hitNonZero |= (t.V != 0);
      }
      if (!hitNonZero) {
        ap_int_base<64, false> t(-1ULL);
        enum { REST = (_AP_W - 1) % 64 };
        ap_int_base<64, false> x;
        x.V = ({ typename _ap_type::remove_const<typeof(this->V)>::type __Result__ = 0; typeof(this->V) __Val2__ = this->V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, REST); __Result__; });
        t.V = ({ typename _ap_type::remove_const<typeof(t.V)>::type __Result__ = 0; typeof(t.V) __Val2__ = t.V; typeof(x.V) __Repl2__ = x.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 63 - REST, 63); __Result__; });
        NZeros += __builtin_clzll(t.V);
      }
      return NZeros;
    }



  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(const ap_int_base<_AP_W2, _AP_S2>& a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(ap_int_base<_AP_W2, _AP_S2>& a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this), a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator&(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this & a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator|(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this | a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator^(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this ^ a2.get();
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    Base::V = val.V;
  }





  inline __attribute__((always_inline)) bool and_reduce() const { return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_and_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool nand_reduce() const { return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_nand_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool or_reduce() const { return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool nor_reduce() const { return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_or_reduce((void*)(&__what2__)); })); }
  inline __attribute__((always_inline)) bool xor_reduce() const { return ({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }); }
  inline __attribute__((always_inline)) bool xnor_reduce() const {
    return !(({ typeof(Base::V) __what2__ = Base::V; __builtin_bit_xor_reduce((void*)(&__what2__)); }));
  }
# 1433 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
  inline __attribute__((always_inline)) char* to_string(signed char rd = 2, bool sign = _AP_S) const {
    (void)(rd);
    (void)(sign);
    return 0;
  }

};
# 1494 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base ret(0); ret.V = lhs.V * rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base ret(0); ret.V = lhs.V + rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base ret(0); ret.V = lhs.V - rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V & rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V | rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret(0); ret.V = lhs.V ^ rhs.V; return ret; }
# 1513 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::div_base ret(0); ret.V = op.V / op2.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mod_base ret(0); ret.V = op.V % op2.V; return ret; }
# 1541 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator +(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline __attribute__((always_inline)) PTR_TYPE* operator -(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 - i_op; }
# 1570 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator *(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator *(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator /(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator /(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator +(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator +(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator -(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float operator -(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator *(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator *(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator /(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator /(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator +(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator +(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator -(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double operator -(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1595 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator *(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator *(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator /(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator /(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator +(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator +(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator -(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half operator -(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1627 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op * ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op + ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op - ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op / ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op % ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op & ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op | ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op ^ ap_int_base<1, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op * ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op + ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op - ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op / ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op % ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op & ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op | ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op ^ ap_int_base<8, CHAR_IS_SIGNED>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op * ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op + ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op - ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op / ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op % ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op & ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op | ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op ^ ap_int_base<8, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op * ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op + ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op - ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op / ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op % ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op & ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op | ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op ^ ap_int_base<8, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op * ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op + ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op - ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op / ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op % ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op & ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op | ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op ^ ap_int_base<_AP_SIZE_short, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op * ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op + ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op - ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op / ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op % ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op & ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op | ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op ^ ap_int_base<_AP_SIZE_short, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op * ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op + ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op - ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op / ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op % ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op & ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op | ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op ^ ap_int_base<_AP_SIZE_int, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op * ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op + ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op - ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op / ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op % ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op & ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op | ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op ^ ap_int_base<_AP_SIZE_int, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op * ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op + ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op - ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op / ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op % ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op & ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op | ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op ^ ap_int_base<_AP_SIZE_long, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op * ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op + ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op - ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op / ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op % ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op & ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op | ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op ^ ap_int_base<_AP_SIZE_long, false>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, true>(i_op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, false>(i_op); }
# 1666 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r(0); if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
# 1690 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r(0); r.V = op.V >> op2; return r; }
# 1721 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op += ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op -= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op *= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op /= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op %= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op &= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op |= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op ^= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >>= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <<= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op += ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op -= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op *= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op /= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op %= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op &= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op |= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op ^= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >>= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <<= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op += ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op -= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op *= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op /= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op %= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op &= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op |= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op ^= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >>= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <<= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op += ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op -= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op *= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op /= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op %= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op &= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op |= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op ^= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >>= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <<= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op += ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op -= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op *= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op /= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op %= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op &= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op |= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op ^= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >>= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <<= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op += ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op -= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op *= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op /= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op %= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op &= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op |= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op ^= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >>= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <<= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op += ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op -= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op *= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op /= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op %= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op &= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op |= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op ^= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >>= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <<= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op += ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op -= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op *= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op /= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op %= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op &= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op |= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op ^= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >>= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <<= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op += ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op -= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op *= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op /= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op %= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op &= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op |= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op ^= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >>= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <<= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op += ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op -= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op *= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op /= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op %= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op &= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op |= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op ^= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >>= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <<= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1754 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator +=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator -=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator *=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) half& operator /=( half& op2, ap_int_base<_AP_W, _AP_S>& op) { half op_rt = op.to_half(); return op2 /= op_rt; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator +=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator -=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator *=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) float& operator /=( float& op2, ap_int_base<_AP_W, _AP_S>& op) { float op_rt = op.to_float(); return op2 /= op_rt; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator +=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 += op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator -=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 -= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator *=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 *= op_rt; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) double& operator /=( double& op2, ap_int_base<_AP_W, _AP_S>& op) { double op_rt = op.to_double(); return op2 /= op_rt; }
# 1782 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1819 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; }
# 1849 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) + op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) - op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) * op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) / op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) % op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) & op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) | op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) ^ op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) >> op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) << op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<_AP_W2, false>(op2); }
# 1880 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator +=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator -=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator *=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator /=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator %=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator >>=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator <<=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1912 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator &=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator |=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_range_ref<_AP_W1, _AP_S1>& operator ^=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1931 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_int_base<_AP_W2, false>()); }
# 1958 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) + op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) - op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) * op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) / op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) % op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) & op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) | op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) ^ op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >> op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) << op2; }
# 1989 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator +=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator -=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator *=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator /=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator %=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator >>=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator <<=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 2021 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator &=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator |=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_bit_ref<_AP_W1, _AP_S1>& operator ^=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 2040 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 == ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) == op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 != ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) != op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 > ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) > op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >= op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 < ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) < op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) <= op2; }
# 2147 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_base.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 == op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() == op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 != op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() != op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 > op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() > op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 >= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() >= op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 < op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() < op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 <= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() <= op2; }
# 12 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h" 1
# 27 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
  enum {
    _AP_WR = _AP_W1 + _AP_W2,
  };

  _AP_T1& mbv1;
  _AP_T2& mbv2;

  inline __attribute__((always_inline)) ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& ref)
      : mbv1(ref.mbv1), mbv2(ref.mbv2) {}

  inline __attribute__((always_inline)) ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) {}

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> Part1;
    Part1.V = ({ typename _ap_type::remove_const<typeof(vval.V)>::type __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(Part1);
    ap_int_base<_AP_W2, false> Part2;
    Part2.V = ({ typename _ap_type::remove_const<typeof(vval.V)>::type __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(Part2);
    return *this;
  }
# 70 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) ap_concat_ref& operator=(bool val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(signed char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(unsigned long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(ap_slong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(ap_ulong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(half val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(float val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline __attribute__((always_inline)) ap_concat_ref& operator=(double val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }





  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }
  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(const ap_range_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((const ap_int_base<_AP_W3, false>)(val));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&
          val) {
    return operator=(val.to_ap_int_base());
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref& operator=(
      const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((ap_ulong)(bool)(val));
  }

  inline __attribute__((always_inline)) operator ap_int_base<_AP_WR, false>() const { return get(); }

  inline __attribute__((always_inline)) operator ap_ulong() const { return get().to_uint64(); }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                       ap_range_ref<_AP_W3, _AP_S3> >
  operator,(const ap_range_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_range_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_range_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(*this, a2);
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(volatile ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const volatile ap_int_base<_AP_W3, _AP_S3> &a2) {

    ap_int_base<_AP_W3, _AP_S3> op(a2);
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(op));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
  operator,(const ap_bit_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_bit_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                       ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >
  operator,(const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                         ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >(
        *this, const_cast<ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_WR, ap_concat_ref, _AP_W3,
      af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
  operator,(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, _AP_W3,
        af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<
            af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_WR, ap_concat_ref, 1,
                    af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
      operator,(const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>
                    &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, 1,
        af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(
            a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator&(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() & a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator|(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() | a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator^(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() ^ a2;
  }
# 258 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) ap_int_base<_AP_WR, false> get() const {
    ap_int_base<_AP_WR, false> tmpVal(0);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W2, false> v2(mbv2);
    ap_int_base<_AP_W1, false> v1(mbv1);
    tmpVal.V = ({ typename _ap_type::remove_const<typeof(tmpVal.V)>::type __Result__ = 0; typeof(tmpVal.V) __Val2__ = tmpVal.V; typeof(v2.V) __Repl2__ = v2.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 0, W_ref2 - 1); __Result__; });
    tmpVal.V =
        ({ typename _ap_type::remove_const<typeof(tmpVal.V)>::type __Result__ = 0; typeof(tmpVal.V) __Val2__ = tmpVal.V; typeof(v1.V) __Repl2__ = v1.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    return tmpVal;
  }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> tmpVal1;
    tmpVal1.V = ({ typename _ap_type::remove_const<typeof(vval.V)>::type __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), W_ref2, W_ref1 + W_ref2 - 1); __Result__; });
    mbv1.set(tmpVal1);
    ap_int_base<_AP_W2, false> tmpVal2;
    tmpVal2.V = ({ typename _ap_type::remove_const<typeof(vval.V)>::type __Result__ = 0; typeof(vval.V) __Val2__ = vval.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, W_ref2 - 1); __Result__; });
    mbv2.set(tmpVal2);
  }

  inline __attribute__((always_inline)) int length() const { return mbv1.length() + mbv2.length(); }
};




template <int _AP_W, bool _AP_S>
struct ap_range_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:
  inline __attribute__((always_inline)) ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

  inline __attribute__((always_inline)) ap_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) ap_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {}

  inline __attribute__((always_inline)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) operator ap_ulong() const { return to_uint64(); }
# 339 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) ap_range_ref& operator=(bool val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(signed char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(unsigned long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(ap_slong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(ap_ulong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(half val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(float val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_range_ref& operator=(double val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }




  inline __attribute__((always_inline)) ap_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_range_ref& val) {
    return operator=((const ap_int_base<_AP_W, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    return operator=(val.to_ap_int_base());
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  inline __attribute__((always_inline))
  ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W, _AP_S> >
  operator,(ap_int_base<_AP_W, _AP_S>& a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                         ap_int_base<_AP_W, _AP_S> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      _AP_W, ap_range_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, ap_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop == hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop < hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop <= hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<=(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= op2.V;
    return *this;
  };



  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator~() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (~ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator!() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (!ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator+() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator-() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (-ret);
  }


  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline __attribute__((always_inline)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned to_uint() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (unsigned)(({ typename _ap_type::remove_const<typeof(t.V)>::type __Result__ = 0; typeof(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned long to_ulong() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (unsigned long)(({ typename _ap_type::remove_const<typeof(t.V)>::type __Result__ = 0; typeof(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_ulong to_uint64() const {
    ap_int_base<_AP_W, false> t;
    t.V = d_bv.V;
    return (ap_ulong)(({ typename _ap_type::remove_const<typeof(t.V)>::type __Result__ = 0; typeof(t.V) __Val2__ = t.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) bool and_reduce() const {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_676_1: for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret &= ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) bool or_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_690_1: for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret |= ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }

  inline __attribute__((always_inline)) bool xor_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    VITIS_LOOP_704_1: for (unsigned i = low; i != high; ++i) {

#pragma HLS unroll

 ret ^= ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), i); __Result__; });
    }
    return ret;
  }
# 720 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) char* to_string(signed char radix = 2) const {
    (void)(radix);
    return 0;
  }

};
# 760 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S>
struct ap_bit_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int d_index;

 public:

  inline __attribute__((always_inline)) ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}

  inline __attribute__((always_inline)) ap_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) ap_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}

  inline __attribute__((always_inline)) operator bool() const { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
  inline __attribute__((always_inline)) bool to_bool() const { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }
# 798 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) ap_bit_ref& operator=(bool val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(char val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(signed char val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned char val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(short val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned short val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(int val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned int val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(long val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(unsigned long val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(ap_slong val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(ap_ulong val) { d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
# 820 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
  inline __attribute__((always_inline)) ap_bit_ref& operator=(half val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(float val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) ap_bit_ref& operator=(double val) { bool tmp_val = val; d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp_val) __Repl2__ = !!tmp_val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; }); return *this; }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(val.V != 0));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_int_base<_AP_W2, false>)val);
  }



  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_bit_ref& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      1, ap_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        1, ap_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() != op.get();
  }

  inline __attribute__((always_inline)) bool get() const { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) bool get() { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  template <int _AP_W3>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W3, false>& val) {
    operator=(val);
  }

  inline __attribute__((always_inline)) bool operator~() const {
    bool bit = ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) int length() const { return 1; }





  inline __attribute__((always_inline)) char* to_string() const { return 0; }

};
# 1018 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator >=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator <=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }






template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator ==(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) bool operator !=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1077 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::div operator /(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::div operator /(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::div operator /(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
# 1100 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
# 1128 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())+( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())-( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())*( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())/( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())%( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())&( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())|( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())^( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())>>( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())<<( rhs.operator ap_int_base<_AP_W2, false>()); }
# 1177 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::plus operator +( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() + rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::minus operator -( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() - rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mult operator *( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() * rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::div operator /( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() / rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mod operator %( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() % rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator &( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() & rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator |( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() | rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator ^( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() ^ rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator >>( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() >> rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline __attribute__((always_inline)) typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator <<( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() << rhs.get(); }
# 1324 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op2); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op1); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 1, false> operator,( bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 1, false> operator,( bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op2); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op1); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op2); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op1); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + 1, true> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<8 + 1, false> operator,( unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op2); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op1); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + 8, false> operator,( unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_short + 1, false> operator,( unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_short, false> operator,( unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_int + 1, false> operator,( unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_int, false> operator,( unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_long + 1, false> operator,( unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_long, false> operator,( unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline __attribute__((always_inline)) ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
# 1348 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_ref.h"
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }

template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline __attribute__((always_inline)) ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
# 13 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int.h" 2




template <int _AP_W>
struct ap_int : ap_int_base<_AP_W, true> {
  typedef ap_int_base<_AP_W, true> Base;

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int() {}
  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_int<_AP_W2>& op): Base((ap_int_base<_AP_W2, true>)op){



    op.checkOverflowCsim(_AP_W, true);

    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const volatile ap_int<_AP_W2>& op) {
    const_cast<const ap_int<_AP_W2>& >(op).checkOverflowCsim(_AP_W, true);
    Base::V = op.V;
  }

  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_uint<_AP_W2>& op): Base((ap_int_base<_AP_W2, false>)op){



    op.checkOverflowCsim(_AP_W, true);

    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const volatile ap_uint<_AP_W2>& op) {
    const_cast<const ap_uint<_AP_W2>& >(op).checkOverflowCsim(_AP_W, true);
    Base::V = op.V;
  }




                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned V __attribute__((bitwidth(_AP_W))), bool raw): Base(0) {
    Base::V = V;
    (void)(raw);
  }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op) {

  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}







  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(bool val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(signed char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned char val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(short val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned short val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(int val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned int val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(long val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(unsigned long val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(ap_slong val):Base(val){ this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(ap_ulong val):Base(val){ this->checkOverflowBaseC(val); }

                ap_int(double val) : Base(val) {}
                ap_int(float val) : Base(val) {}
  ap_int(half val) : Base(val) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int(const char* s, signed char rd) : Base(s, rd) {}




  ap_int &operator=(const ap_int<_AP_W> &op2) = default;
# 161 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_int& operator=(const volatile ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const ap_int<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const volatile ap_int<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

};




template <int _AP_W>
struct ap_uint : ap_int_base<_AP_W, false> {
  typedef ap_int_base<_AP_W, false> Base;

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint() {}
  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_uint<_AP_W2>& op):Base((ap_int_base<_AP_W2, false>)op) {
    op.checkOverflowCsim(_AP_W, false);

  }

  template <int _AP_W2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_int<_AP_W2>& op):Base((ap_int_base<_AP_W2, true>)op) {
    op.checkOverflowCsim(_AP_W, false);

  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const volatile ap_uint<_AP_W2>& op) {
    const_cast<const ap_uint<_AP_W2>& >(op).checkOverflowCsim(_AP_W, false);
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const volatile ap_int<_AP_W2>& op) {
    const_cast<const ap_int<_AP_W2>& >(op).checkOverflowCsim(_AP_W, false);
    Base::V = op.V;
  }




                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned V __attribute__((bitwidth(_AP_W))), bool raw):Base(0) {
    Base::V = V;
    (void)(raw);
  }



  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
                inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op) {

  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}






  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(bool val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(signed char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned char val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(short val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned short val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(int val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned int val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(long val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(unsigned long val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(ap_slong val):Base(val) { this->checkOverflowBaseC(val); }
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(ap_ulong val):Base(val) { this->checkOverflowBaseC(val); }

                ap_uint(double val) : Base(val) {}
                ap_uint(float val) : Base(val) {}
  ap_uint(half val) : Base(val) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint(const char* s, signed char rd) : Base(s, rd) {}





  ap_uint &operator=(const ap_uint<_AP_W> &op2) = default;
# 317 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_uint& operator=(const volatile ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const ap_uint<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const volatile ap_uint<_AP_W>& op2) volatile {
    *((volatile typename Base::Base::DataType *)(&(Base::V))) = op2.V;
  }

};
# 352 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_special.h" 1
# 15 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 43 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_special.h"
template <int _AP_W>
class complex<ap_int<_AP_W> > {
 public:
  typedef ap_int<_AP_W> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 176 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int_special.h"
template <int _AP_W>
inline bool operator==(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W>
inline bool operator==(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W>
inline bool operator!=(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W>
inline bool operator!=(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 353 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int.h" 2







# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h" 1
# 10 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h" 1
# 16 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int.h" 1
# 17 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h" 2
# 87 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
template <int _AP_W2, int _AP_I2, bool _AP_S2>
struct _ap_fixed_factory;
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, true> {
  typedef ap_fixed<_AP_W2, _AP_I2> type;
};
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, false> {
  typedef ap_ufixed<_AP_W2, _AP_I2> type;
};
# 108 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct ap_fixed_base : ssdm_int<_AP_W, _AP_S> {
 public:
  typedef ssdm_int<_AP_W, _AP_S> Base;
  static const int width = _AP_W;
  static const int iwidth = _AP_I;
  static const ap_q_mode qmode = _AP_Q;
  static const ap_o_mode omode = _AP_O;


  template <int _AP_W2, int _AP_I2, bool _AP_S2>
  struct RType {
    enum {
      _AP_F = _AP_W - _AP_I,
      F2 = _AP_W2 - _AP_I2,
      mult_w = _AP_W + _AP_W2,
      mult_i = _AP_I + _AP_I2,
      mult_s = _AP_S || _AP_S2,
      plus_w = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
               1 + ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      plus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1 +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      minus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,

      div_w = _AP_S2 + _AP_W + ((F2) > (0) ? (F2) : (0)),



      div_i = _AP_S2 + _AP_I + F2,
      div_s = _AP_S || _AP_S2,
      logic_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      logic_i = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };

    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> lhs;
    typedef ap_fixed_base<_AP_W2, _AP_I2, _AP_S2> rhs;

    typedef ap_fixed_base<mult_w, mult_i, mult_s> mult_base;
    typedef ap_fixed_base<plus_w, plus_i, plus_s> plus_base;
    typedef ap_fixed_base<minus_w, minus_i, minus_s> minus_base;
    typedef ap_fixed_base<logic_w, logic_i, logic_s> logic_base;
    typedef ap_fixed_base<div_w, div_i, div_s> div_base;
    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1_base;

    typedef typename _ap_fixed_factory<mult_w, mult_i, mult_s>::type mult;
    typedef typename _ap_fixed_factory<plus_w, plus_i, plus_s>::type plus;
    typedef typename _ap_fixed_factory<minus_w, minus_i, minus_s>::type minus;
    typedef typename _ap_fixed_factory<logic_w, logic_i, logic_s>::type logic;
    typedef typename _ap_fixed_factory<div_w, div_i, div_s>::type div;
    typedef typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type arg1;
  };

 private:
# 295 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
                      inline __attribute__((always_inline)) void report() {}




                      inline __attribute__((always_inline)) void overflow_adjust(bool underflow, bool overflow, bool lD,
                              bool sign) {
    if (!underflow && !overflow) return;
    if (_AP_O == AP_WRAP) {
      if (_AP_N == 0) return;
      if (_AP_S) {


        Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        if (_AP_N > 1) {

          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
      } else {

        ap_int_base<_AP_W, false> mask(-1);
        Base::V =
            ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 1); __Result__; });
      }
    } else if (_AP_O == AP_SAT_ZERO) {
      Base::V = 0;
    } else if (_AP_O == AP_WRAP_SM && _AP_S) {
      bool Ro = ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      if (_AP_N == 0) {
        if (lD != Ro) {
          Base::V = ~Base::V;
          Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(lD) __Repl2__ = !!lD; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
        }
      } else {
        if (_AP_N == 1 && sign != Ro) {
          Base::V = ~Base::V;
        } else if (_AP_N > 1) {
          bool lNo = ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - _AP_N); __Result__; });
          if (lNo == sign) Base::V = ~Base::V;
          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(mask.V) __Repl2__ = mask.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - _AP_N, _AP_W - 2); __Result__; });
        }
        Base::V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; typeof(sign) __Repl2__ = !!sign; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), _AP_W - 1, _AP_W - 1); __Result__; });
      }
    } else {
      if (_AP_S) {
        if (overflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          Base::V = ~Base::V;
        } else if (underflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          if (_AP_O == AP_SAT_SYM) Base::V |= 1;
        }
      } else {
        if (overflow)
          Base::V = ~(ap_int_base<_AP_W, false>(0).V);
        else if (underflow)
          Base::V = 0;
      }
    }
  }

                      inline __attribute__((always_inline)) bool quantization_adjust(bool qb, bool r, bool s) {
    bool carry = (bool)({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    if (_AP_Q == AP_TRN) return false;
    if (_AP_Q == AP_RND_ZERO)
      qb &= s || r;
    else if (_AP_Q == AP_RND_MIN_INF)
      qb &= r;
    else if (_AP_Q == AP_RND_INF)
      qb &= !s || r;
    else if (_AP_Q == AP_RND_CONV)
      qb &= ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 0); __Result__; }) || r;
    else if (_AP_Q == AP_TRN_ZERO)
      qb = s && (qb || r);
    Base::V += qb;
    return carry && (!(bool)({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }));
  }


                      inline __attribute__((always_inline)) int countLeadingOnes() const {




    return 0;

  }

 public:



  inline __attribute__((always_inline)) ap_fixed_base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op):Base(op.V) {

    operator=(op);



    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) ap_fixed_base(const ap_int_base<_AP_W2, _AP_S2>& op):Base(op.V) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp(0);
    tmp.V = op.V;

    operator=(tmp);



    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }
# 456 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
  inline __attribute__((always_inline)) ap_fixed_base(const char* s) {
    typeof(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), 10, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }
  inline __attribute__((always_inline)) ap_fixed_base(const char* s, signed char rd) {
    typeof(Base::V) t;
    _ssdm_string2bits((void*)(&t), (const char*)(s), rd, _AP_I, _AP_S, _AP_Q,
                      _AP_O, _AP_N, true);
    Base::V = t;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    *this = ((bool)op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_fixed_base(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
    *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (bool(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }
# 524 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
  inline __attribute__((always_inline)) ap_fixed_base(const bool x) { ap_fixed_base<(1), (1), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const char x) { ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const signed char x) { ap_fixed_base<(8), (8), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned char x) { ap_fixed_base<(8), (8), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const unsigned long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const ap_slong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)> tmp; tmp.V = x; *this = tmp; }
  inline __attribute__((always_inline)) ap_fixed_base(const ap_ulong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)> tmp; tmp.V = x; *this = tmp; }







          ap_fixed_base(double d) {
    ap_int_base<64, false> ireg;
    ireg.V = doubleToRawBits(d);
    bool isneg = ({ typeof(ireg.V) __Val2__ = ireg.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 63); __Result__; });

    ap_int_base<11 + 1, true> exp;
    ap_int_base<11, false> exp_tmp;
    exp_tmp.V =
        ({ typename _ap_type::remove_const<typeof(ireg.V)>::type __Result__ = 0; typeof(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 52, 52 + 11 - 1); __Result__; });
    exp = exp_tmp - ((1L << (11 - 1L)) - 1L);
    ap_int_base<52 + 2, true> man;
    man.V = ({ typename _ap_type::remove_const<typeof(ireg.V)>::type __Result__ = 0; typeof(ireg.V) __Val2__ = ireg.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, 52 - 1); __Result__; });

    (static_cast<void>(0));

    man.V = ({ typename _ap_type::remove_const<typeof(man.V)>::type __Result__ = 0; typeof(man.V) __Val2__ = man.V; typeof(1) __Repl2__ = !!1; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52); __Result__; });
    if (isneg) man = -man;
    if ((ireg.V & 0x7fffffffffffffffLL) == 0) {
      Base::V = 0;
    } else {
      int _AP_W2 = 52 + 2, _AP_I2 = exp.V + 2, _AP_F = _AP_W - _AP_I,
          F2 = _AP_W2 - _AP_I2;
      bool _AP_S2 = true,
           QUAN_INC = F2 > _AP_F &&
                      !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));
      bool carry = false;

      unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
      if (F2 == _AP_F)
        Base::V = man.V;
      else if (F2 > _AP_F) {
        if (sh_amt < 52 + 2)
          Base::V = man.V >> sh_amt;
        else {
          Base::V = isneg ? -1 : 0;
        }
        if ((_AP_Q != AP_TRN) && !((_AP_Q == AP_TRN_ZERO) && !_AP_S2)) {
          bool qb = (F2 - _AP_F > _AP_W2) ? isneg : (bool)({ typeof(man.V) __Val2__ = man.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });

          bool r =
              (F2 > _AP_F + 1)
                  ? ({ typename _ap_type::remove_const<typeof(man.V)>::type __Result__ = 0; typeof(man.V) __Val2__ = man.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, (F2 - _AP_F - 2 < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1)); __Result__; }) != 0


                  : false;
          carry = quantization_adjust(qb, r, isneg);
        }
      } else {
        Base::V = man.V;
        if (sh_amt < _AP_W)
          Base::V = Base::V << sh_amt;
        else
          Base::V = 0;
      }

      if ((_AP_O != AP_WRAP || _AP_N != 0) &&
          ((!_AP_S && _AP_S2) ||
           _AP_I - _AP_S <
               _AP_I2 - _AP_S2 +
                   (QUAN_INC ||
                    (_AP_S2 && (_AP_O == AP_SAT_SYM))))) {
        bool deleted_zeros = _AP_S2 ? true : !carry, deleted_ones = true;
        bool neg_src = isneg;
        bool lD = false;
        int pos1 = F2 - _AP_F + _AP_W;
        int pos2 = F2 - _AP_F + _AP_W + 1;
        bool newsignbit = ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
        if (pos1 < _AP_W2 && pos1 >= 0)

          lD = (man.V >> pos1) & 1;
        if (pos1 < _AP_W2) {
          bool Range1_all_ones = true;
          bool Range1_all_zeros = true;
          bool Range2_all_ones = true;
          ap_int_base<52 + 2, false> Range2;
          ap_int_base<52 + 2, false> all_ones(-1);

          if (pos2 >= 0 && pos2 < _AP_W2) {


            Range2.V = man.V;
            Range2.V >>= pos2;
            Range2_all_ones = Range2 == (all_ones >> pos2);
          } else if (pos2 < 0)
            Range2_all_ones = false;
          if (pos1 >= 0 && pos2 < _AP_W2) {
            Range1_all_ones = Range2_all_ones && lD;
            Range1_all_zeros = !Range2.V && !lD;
          } else if (pos2 == _AP_W2) {
            Range1_all_ones = lD;
            Range1_all_zeros = !lD;
          } else if (pos1 < 0) {
            Range1_all_zeros = !man.V;
            Range1_all_ones = false;
          }

          deleted_zeros =
              deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
          deleted_ones =
              carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
          neg_src = isneg && !(carry && Range1_all_ones);
        } else
          neg_src = isneg && newsignbit;
        bool neg_trg = _AP_S && newsignbit;
        bool overflow = (neg_trg || !deleted_zeros) && !isneg;
        bool underflow = (!neg_trg || !deleted_ones) && neg_src;
        if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
          underflow |=
              neg_src &&
              (_AP_W > 1 ? ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                         : true);
        overflow_adjust(underflow, overflow, lD, neg_src);
      }
    }
    report();
  }


  inline __attribute__((always_inline)) ap_fixed_base(float d) { *this = ap_fixed_base(double(d)); }


  inline __attribute__((always_inline)) ap_fixed_base(half d) { *this = ap_fixed_base(double(d)); }
# 798 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {

    const int _AP_F = _AP_W - _AP_I;
    const int F2 = _AP_W2 - _AP_I2;
    const int QUAN_INC =
          F2 > _AP_F && !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));

    if (!op) Base::V = 0;
    bool carry = false;
    bool signbit = ({ typeof(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W2 - 1); __Result__; });
    bool isneg = signbit && _AP_S2;
    if (F2 == _AP_F)
      Base::V = op.V;
    else if (F2 > _AP_F) {
      unsigned int sh_amt = F2 - _AP_F;

      if (sh_amt < _AP_W2) {
        Base::V = op.V >> sh_amt;
      } else {
        Base::V = isneg ? -1 : 0;
      }
      if (_AP_Q != AP_TRN && !(_AP_Q == AP_TRN_ZERO && !_AP_S2)) {
        bool qbit = ({ typeof(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), F2 - _AP_F - 1); __Result__; });

        bool qb = (F2 - _AP_F > _AP_W2) ? _AP_S2 && signbit : qbit;
        enum { hi = ((F2 - _AP_F - 2) < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1) };

        bool r = (F2 > _AP_F + 1) ? (({ typename _ap_type::remove_const<typeof(op.V)>::type __Result__ = 0; typeof(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, hi); __Result__; }) != 0) : false;
        carry = quantization_adjust(qb, r, isneg);
      }
    } else {
      unsigned sh_amt = _AP_F - F2;

      if (sh_amt < _AP_W) {
        if (_AP_W > _AP_W2) {

          Base::V = op.V;
          Base::V <<= sh_amt;
        } else {

          Base::V = op.V << sh_amt;
        }
      } else {
        Base::V = 0;
      }
    }

    if ((_AP_O != AP_WRAP || _AP_N != 0) &&
        ((!_AP_S && _AP_S2) ||
         _AP_I - _AP_S <
             _AP_I2 - _AP_S2 +
                 (QUAN_INC || (_AP_S2 && _AP_O == AP_SAT_SYM)))) {
      bool deleted_zeros = _AP_S2 ? true : !carry;
      bool deleted_ones = true;
      bool neg_src = isneg;
      bool newsignbit = ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
      enum { pos1 = F2 - _AP_F + _AP_W, pos2 = F2 - _AP_F + _AP_W + 1 };
      bool lD = (pos1 < _AP_W2 && pos1 >= 0) ? ({ typeof(op.V) __Val2__ = op.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), pos1); __Result__; })
                                             : false;
      if (pos1 < _AP_W2) {
        bool Range1_all_ones = true;
        bool Range1_all_zeros = true;
        bool Range2_all_ones = true;
        ap_int_base<_AP_W2, false> all_ones(-1);

        if (pos2 < _AP_W2 && pos2 >= 0) {
          ap_int_base<_AP_W2, false> Range2(0);
          Range2.V = ({ typename _ap_type::remove_const<typeof(op.V)>::type __Result__ = 0; typeof(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos2, _AP_W2 - 1); __Result__; });
          Range2_all_ones = Range2 == (all_ones >> pos2);
        } else if (pos2 < 0) {
          Range2_all_ones = false;
        }

        if (pos1 >= 0 && pos2 < _AP_W2) {
          ap_int_base<_AP_W2, false> Range1(0);
          Range1.V = ({ typename _ap_type::remove_const<typeof(op.V)>::type __Result__ = 0; typeof(op.V) __Val2__ = op.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), pos1, _AP_W2 - 1); __Result__; });
          Range1_all_ones = Range1 == (all_ones >> pos1);
          Range1_all_zeros = !Range1.V;
        } else if (pos2 == _AP_W2) {
          Range1_all_ones = lD;
          Range1_all_zeros = !lD;
        } else if (pos1 < 0) {
          Range1_all_zeros = !op.V;
          Range1_all_ones = false;
        }

        deleted_zeros =
            deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
        deleted_ones =
            carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
        neg_src = isneg && !(carry && Range1_all_ones);
      } else
        neg_src = isneg && newsignbit;
      bool neg_trg = _AP_S && newsignbit;
      bool overflow = (neg_trg || !deleted_zeros) && !isneg;
      bool underflow = (!neg_trg || !deleted_ones) && neg_src;
      if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
        underflow |=
            neg_src &&
            (_AP_W > 1 ? ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 2); __Result__; }) == 0
                       : true);

      overflow_adjust(underflow, overflow, lD, neg_src);
    }
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_fixed_base& operator=(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(const_cast<const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op));
    return *this;
  }


                      inline __attribute__((always_inline)) ap_fixed_base& setBits(ap_ulong bv) {

    Base::V = bv;
    return *this;
  }


  static inline __attribute__((always_inline)) ap_fixed_base bitsToFixed(ap_ulong bv) {

    ap_fixed_base t;

    t.V = bv;



    return t;
  }

                      inline __attribute__((always_inline)) void checkOverflowCsimFix(int _ap_w2, bool _ap_s2) const {
# 971 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
      (void)_ap_w2;
      (void)_ap_s2;

      return;
  }





                      inline __attribute__((always_inline)) ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> to_ap_int_base(
      bool Cnative = true) const {
    ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> ret(0);
    if (_AP_I == 0) {
      ret.V = 0;
    } else if (_AP_I > 0 && _AP_I <= _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), _AP_W - _AP_I, _AP_W - 1); __Result__; });
    } else if (_AP_I > _AP_W) {
      ret.V = ({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_W - 1); __Result__; });
      ret.V <<= (_AP_I - _AP_W);
    }
# 1000 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
    if (Cnative && _AP_I < _AP_W) {

      if (_AP_S && ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; }) && (_AP_I < _AP_W) &&
          (({ typename _ap_type::remove_const<typeof(Base::V)>::type __Result__ = 0; typeof(Base::V) __Val2__ = Base::V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, _AP_I < 0 ? _AP_W - 1 : _AP_W - _AP_I - 1); __Result__; }) != (unsigned long)0))


        ret = ret + 1;
    } else {

    }
    return ret;
  };

 public:
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) operator ap_int_base<_AP_W2, _AP_S2>() const {
    return ap_int_base<_AP_W2, _AP_S2>(to_ap_int_base());
  }


                      inline __attribute__((always_inline)) char to_char() const { return to_ap_int_base().to_char(); }

                      inline __attribute__((always_inline)) int to_int() const { return to_ap_int_base().to_int(); }

                      inline __attribute__((always_inline)) unsigned to_uint() const { return to_ap_int_base().to_uint(); }

                      inline __attribute__((always_inline)) ap_slong to_int64() const { return to_ap_int_base().to_int64(); }

                      inline __attribute__((always_inline)) ap_ulong to_uint64() const { return to_ap_int_base().to_uint64(); }

                      inline __attribute__((always_inline)) ap_int<_AP_I> to_ap_int() const { return ap_int<_AP_I>(to_ap_int_base()); }



  inline __attribute__((always_inline)) double to_double() const {




    enum { BITS = 52 + 11 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp(0);
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (11 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 52;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<typeof(tmp.V)>::type __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ typeof(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    ap_ulong m = 0;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (ap_ulong)(tmp.V >> (lsb_index - 1))
                           : (ap_ulong)(tmp.V << (1 - lsb_index));
    } else {
      m = (ap_ulong)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;


    if (({ typeof(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 52 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });

    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 52, 52 + 11 - 1); __Result__; });


    return rawBitsToDouble(m);
  }



  inline __attribute__((always_inline)) float to_float() const {




    enum { BITS = 23 + 8 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (8 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 23;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<typeof(tmp.V)>::type __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ typeof(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned long m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned long)(tmp.V >> (lsb_index - 1))
                           : (unsigned long)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned long)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ typeof(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 23 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 23, 23 + 8 - 1); __Result__; });

    return rawBitsToFloat(m);
  }



  inline __attribute__((always_inline)) half to_half() const {




    enum { BITS = 10 + 5 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; });
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (5 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 10;

    bool a = (lsb_index >=2) ?
        (({ typename _ap_type::remove_const<typeof(tmp.V)>::type __Result__ = 0; typeof(tmp.V) __Val2__ = tmp.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), 0, lsb_index - 2); __Result__; }) != 0) : 0;

    a |= (lsb_index >=0) ? ({ typeof(tmp.V) __Val2__ = tmp.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), lsb_index); __Result__; }) : 0;

    unsigned short m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned short)(tmp.V >> (lsb_index - 1))
                           : (unsigned short)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned short)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (({ typeof(m) __Val2__ = m; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), 10 + 1); __Result__; })) {
      e += 1;
    }

    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(s) __Repl2__ = !!s; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), BITS - 1, BITS - 1); __Result__; });
    m = ({ typename _ap_type::remove_const<typeof(m)>::type __Result__ = 0; typeof(m) __Val2__ = m; typeof(e) __Repl2__ = e; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), 10, 10 + 5 - 1); __Result__; });

    return rawBitsToHalf(m);
  }


  inline __attribute__((always_inline)) operator long double() const { return (long double)to_double(); }

  inline __attribute__((always_inline)) operator double() const { return to_double(); }

  inline __attribute__((always_inline)) operator float() const { return to_float(); }

  inline __attribute__((always_inline)) operator half() const { return to_half(); }

                      inline __attribute__((always_inline)) operator bool() const { return (bool)Base::V != 0; }

                      inline __attribute__((always_inline)) operator char() const { return (char)to_int(); }

                      inline __attribute__((always_inline)) operator signed char() const { return (signed char)to_int(); }

                      inline __attribute__((always_inline)) operator unsigned char() const { return (unsigned char)to_uint(); }

                      inline __attribute__((always_inline)) operator short() const { return (short)to_int(); }

                      inline __attribute__((always_inline)) operator unsigned short() const { return (unsigned short)to_uint(); }

                      inline __attribute__((always_inline)) operator int() const { return to_int(); }

                      inline __attribute__((always_inline)) operator unsigned int() const { return to_uint(); }



                      inline __attribute__((always_inline)) operator long() const { return (long)to_int64(); }

                      inline __attribute__((always_inline)) operator unsigned long() const { return (unsigned long)to_uint64(); }






                      inline __attribute__((always_inline)) operator ap_ulong() const { return to_uint64(); }

                      inline __attribute__((always_inline)) operator ap_slong() const { return to_int64(); }

                      inline __attribute__((always_inline)) int length() const { return _AP_W; };
# 1229 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
                      inline __attribute__((always_inline)) int countLeadingZeros() const {


    if (_AP_W <= 32) {
      ap_int_base<32, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return __builtin_ctz(t.V);
    } else if (_AP_W <= 64) {
      ap_int_base<64, false> t(-1ULL);
      t.range(_AP_W - 1, 0) = this->range(0, _AP_W - 1);
      return __builtin_ctzll(t.V);
    } else {
      enum {__N = (_AP_W + 63) / 64};
      int NZeros = 0;
      int i = 0;
      bool hitNonZero = false;
      VITIS_LOOP_1245_1: for (i = 0; i < __N - 1; ++i) {
        ap_int_base<64, false> t;
        t.range(0, 63) = this->range(_AP_W - i * 64 - 64, _AP_W - i * 64 - 1);
        NZeros += hitNonZero ? 0 : __builtin_clzll(t.V);
        hitNonZero |= (t != 0);
      }
      if (!hitNonZero) {
        ap_int_base<64, false> t(-1ULL);
        t.range(63 - (_AP_W - 1) % 64, 63) = this->range(0, (_AP_W - 1) % 64);
        NZeros += __builtin_clzll(t.V);
      }
      return NZeros;
    }



  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::mult operator*(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::mult_base r(0), t(0);
    r.V = Base::V;
    t.V = op2.V;
    r.V *= op2.V;
    return r;
  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::div operator/(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::div_base r;
# 1299 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
        ap_fixed_base<_AP_W + ((_AP_W2 - _AP_I2) > (0) ? (_AP_W2 - _AP_I2) : (0)),_AP_I, _AP_S> t(*this);



        r.V = t.V / op2.V;
# 1332 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
    return r;
  }
# 1347 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::plus_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V + rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::minus_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V - rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V & rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V | rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret(0), lhs(*this), rhs(op2); ret.V = lhs.V ^ rhs.V; return ret; }
# 1365 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator *=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator *(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator /=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator /(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator +=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator +(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator -=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator -(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator &=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator &(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator |=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator |(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) ap_fixed_base& operator ^=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator ^(op2); return *this; }





  inline __attribute__((always_inline)) ap_fixed_base& operator++() {
    operator+=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) ap_fixed_base& operator--() {
    operator-=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline __attribute__((always_inline)) const ap_fixed_base operator++(int) {
    ap_fixed_base r(*this);
    operator++();
    return r;
  }


  inline __attribute__((always_inline)) const ap_fixed_base operator--(int) {
    ap_fixed_base r(*this);
    operator--();
    return r;
  }



  inline __attribute__((always_inline)) typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type operator+() { return *this; }

                      inline __attribute__((always_inline)) typename _ap_fixed_factory<_AP_W + 1, _AP_I + 1, true>::type operator-() const {
    ap_fixed_base<_AP_W + 1, _AP_I + 1, true> r(*this);
    r.V = -r.V;
    return r;
  }

                      inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> getNeg() {
    ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> r(*this);
    r.V = -r.V;
    return r;
  }



                      inline __attribute__((always_inline)) bool operator!() const { return Base::V == (unsigned long)0; }




                      inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S> operator~() const {
    ap_fixed_base<_AP_W, _AP_I, _AP_S> r(0);
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_SHIFT>
                      inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift() const {
    ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r(0);
    r.V = Base::V;
    return r;
  }

  template <int _AP_SHIFT>
                      inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift() const {
    ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r(0);
    r.V = Base::V;
    return r;
  }





                      inline __attribute__((always_inline)) ap_fixed_base operator<<(unsigned int sh) const {
    ap_fixed_base r(0);
    r.V = Base::V << sh;
# 1483 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
    return r;
  }

                      inline __attribute__((always_inline)) ap_fixed_base operator>>(unsigned int sh) const {
    ap_fixed_base r(0);
    r.V = Base::V >> sh;
# 1505 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
    return r;
  }


                      inline __attribute__((always_inline)) ap_fixed_base operator<<(int sh) const {
    ap_fixed_base r(0);
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator>>(ush);
    } else {
      return operator<<(ush);
    }
  }

                      inline __attribute__((always_inline)) ap_fixed_base operator>>(int sh) const {
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator<<(ush);
    } else {
      return operator>>(ush);
    }
  }


  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, true>& op2) const {


    int sh = op2.to_int();
    return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    int sh = op2.to_int();
    return operator>>(sh);
  }


  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_fixed_base operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator<<(sh);
  }

  template <int _AP_W2>
                      inline __attribute__((always_inline)) ap_fixed_base operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator>>(sh);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base operator<<(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator<<(op2.to_ap_int_base());
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base operator>>(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator>>(op2.to_ap_int_base());
  }





                      inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const int sh) {
    *this = operator<<(sh);
    return *this;
  }

                      inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const unsigned int sh) {
    *this = operator<<(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) ap_fixed_base& operator<<=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base& operator<<=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }


                      inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const int sh) {
    *this = operator>>(sh);
    return *this;
  }

                      inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const unsigned int sh) {
    *this = operator>>(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) ap_fixed_base& operator>>=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) ap_fixed_base& operator>>=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }
# 1649 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator >(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V > op2.V; else if (_AP_F > F2) return Base::V > ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V > op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator <(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V < op2.V; else if (_AP_F > F2) return Base::V < ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V < op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator >=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V >= op2.V; else if (_AP_F > F2) return Base::V >= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V >= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator <=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V <= op2.V; else if (_AP_F > F2) return Base::V <= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V <= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator ==(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V == op2.V; else if (_AP_F > F2) return Base::V == ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V == op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline __attribute__((always_inline)) bool operator !=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V != op2.V; else if (_AP_F > F2) return Base::V != ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V != op2.V; return false; }





  inline __attribute__((always_inline)) bool operator >(double d) const { return to_double() > d; }
  inline __attribute__((always_inline)) bool operator <(double d) const { return to_double() < d; }
  inline __attribute__((always_inline)) bool operator >=(double d) const { return to_double() >= d; }
  inline __attribute__((always_inline)) bool operator <=(double d) const { return to_double() <= d; }
  inline __attribute__((always_inline)) bool operator ==(double d) const { return to_double() == d; }
  inline __attribute__((always_inline)) bool operator !=(double d) const { return to_double() != d; }


  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

                      inline __attribute__((always_inline)) bool operator[](unsigned index) const {
    (static_cast<void>(0));
    return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      unsigned index) {
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

                      inline __attribute__((always_inline)) bool bit(unsigned index) const {
    (static_cast<void>(0));
    return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index); __Result__; });
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> get_bit(
      const ap_int_base<_AP_W2, true>& index) {
    (static_cast<void>(0));

    (static_cast<void>(0));
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        this, index.to_int() + _AP_W - _AP_I);
  }

                      inline __attribute__((always_inline)) bool get_bit(int index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index + _AP_W - _AP_I); __Result__; });

  }
# 1735 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
  template <int _AP_W2>
                      inline __attribute__((always_inline)) bool get_bit(const ap_int_base<_AP_W2, true>& index) const {
    (static_cast<void>(0));
    (static_cast<void>(0));
    return ({ typeof(const_cast<ap_fixed_base*>(this)->V) __Val2__ = const_cast<ap_fixed_base*>(this)->V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), index.to_int() + _AP_W - _AP_I); __Result__; });

  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(int Hi,
                                                                      int Lo) {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
  }


  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      int Hi, int Lo) const {
    (static_cast<void>(0));
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        const_cast<ap_fixed_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

                      inline __attribute__((always_inline)) bool is_zero() const { return Base::V == (unsigned long)0; }

                      inline __attribute__((always_inline)) bool is_neg() const {
    if (_AP_S && ({ typeof(Base::V) __Val2__ = Base::V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), _AP_W - 1); __Result__; })) return true;
    return false;
  }

                      inline __attribute__((always_inline)) int wl() const { return _AP_W; }

                      inline __attribute__((always_inline)) int iwl() const { return _AP_I; }

                      inline __attribute__((always_inline)) ap_q_mode q_mode() const { return _AP_Q; }

                      inline __attribute__((always_inline)) ap_o_mode o_mode() const { return _AP_O; }

                      inline __attribute__((always_inline)) int n_bits() const { return _AP_N; }
# 1918 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
  inline __attribute__((always_inline)) char* to_string(unsigned char radix = 2, bool sign = _AP_S) const {
    (void)(radix);
    (void)(sign);
    return 0;
  }

};

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) void b_not(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
  ret.V = ~op.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) void b_and(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V & op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) void b_or(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V | op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) void b_xor(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V ^ op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) void neg(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
  ap_fixed_base<_AP_W2 + !_AP_S2, _AP_I2 + !_AP_S2, true, _AP_Q2, _AP_O2,
                _AP_N2>
      t(0);
  t.V = -op.V;
  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) void lshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F2 = _AP_W2 - _AP_I2,
    _AP_I3 = ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)),
    _AP_W3 = _AP_I3 + F2,
  };

  ap_fixed_base<_AP_W3, _AP_I3, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t(0);
  t.V = op.V;
  t.V <<= i;

  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
                    inline __attribute__((always_inline)) void rshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F = _AP_W - _AP_I,
    F2 = _AP_W2 - _AP_I2,
    F3 = ((F) > (F2) ? (F) : (F2)),
    _AP_W3 = _AP_I2 + F3,
    sh = F - F2,
  };

  ap_fixed_base<_AP_W3, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t(0);
  t.V = op.V;
  if (sh >= 0)
    t.V <<= (int) sh;
  t.V >>= i;

  ret = t;
}
# 2370 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ==(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator !=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator !=(op); }
# 2458 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::plus operator +( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::minus operator -( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::mult operator *( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::div operator /( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator &( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator |( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator ^( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator +=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator +=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator -=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator -=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator *=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator *=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator /=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator /=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator &=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator &=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator |=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator |=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) ap_int_base<_AP_W2, _AP_S2>& operator ^=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator ^=(op.to_ap_int_base()); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ==(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ==(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator !=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <=(op); }




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator==(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator==(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator!=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator!=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator>(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator>=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator<(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
                    inline __attribute__((always_inline)) bool operator<=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>=(op1);
}
# 11 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_ref.h" 1
# 25 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int d_index;

 public:
  inline __attribute__((always_inline)) af_bit_ref(
      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {






  }

  inline __attribute__((always_inline)) af_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline __attribute__((always_inline)) af_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}


  inline __attribute__((always_inline)) operator bool() const { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }



  inline __attribute__((always_inline)) af_bit_ref& operator=(bool val) {
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val) __Repl2__ = !!val; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), d_index, d_index); __Result__; });
    return *this;
  }



  inline __attribute__((always_inline)) af_bit_ref& operator=(const af_bit_ref& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=(val != 0);
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) af_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=(ap_int_base<_AP_W2 + _AP_W3, false>(val));
  }




  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(*this,
                                                                        op);
  }

  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<
      1, af_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        1, af_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator==(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator!=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() != op.get();
  }


  inline __attribute__((always_inline)) bool operator~() const {
    bool bit = ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; });
    return bit ? false : true;
  }

  inline __attribute__((always_inline)) bool get() const { return ({ typeof(d_bv.V) __Val2__ = d_bv.V; bool __Result__ = __builtin_bit_select((void*)(&__Val2__), d_index); __Result__; }); }

  inline __attribute__((always_inline)) int length() const { return 1; }





  inline __attribute__((always_inline)) char* to_string() const { return 0; }

};
# 212 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:

  inline __attribute__((always_inline)) af_range_ref(
      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}




  inline __attribute__((always_inline)) af_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {
# 242 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_ref.h"
  }

  inline __attribute__((always_inline)) af_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {
# 254 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_ref.h"
  }
# 266 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_ref.h"
  inline __attribute__((always_inline)) af_range_ref& operator=(const bool val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const signed char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const unsigned long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_slong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_ulong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const half val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const float val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }
  inline __attribute__((always_inline)) af_range_ref& operator=(const double val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(loc.V) __Repl2__ = loc.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; }); return *this; }



  inline __attribute__((always_inline)) af_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(tmp.V) __Repl2__ = tmp.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }



  template <int _AP_W3, bool _AP_S3>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) af_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
    return *this;
  }




  inline __attribute__((always_inline)) af_range_ref& operator=(const af_range_ref& val) {
    ap_int_base<_AP_W, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) af_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    const ap_int_base<_AP_W2 + _AP_W3, false> tmp(val);
    return operator=(tmp);
  }




  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator==(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator!=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator<(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator>(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator<=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) bool operator>=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator<(op2));
  }





  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, op);
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, int _AP_S2>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                    af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline))
      ap_concat_ref<_AP_W, af_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  inline __attribute__((always_inline)) operator ap_ulong() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret.to_uint64();
  }

  inline __attribute__((always_inline)) operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> to_ap_int_base() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }


  inline __attribute__((always_inline)) char to_char() const {
    return (char)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) int to_int() const {
    return (int)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned to_uint() const {
    return (unsigned)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) long to_long() const {
    return (long)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) unsigned long to_ulong() const {
    return (unsigned long)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_slong to_int64() const {
    return (ap_slong)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }

  inline __attribute__((always_inline)) ap_ulong to_uint64() const {
    return (ap_ulong)(({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; }));
  }



  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator~() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (~ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator!() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (!ret);
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator+() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> operator-() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return (-ret);
  }


  inline __attribute__((always_inline)) ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; __builtin_bit_part_select((void*)(&__Result__), (void*)(&__Val2__), l_index, h_index); __Result__; });
    return ret;
  }

  template <int _AP_W2>
  inline __attribute__((always_inline)) void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = ({ typename _ap_type::remove_const<typeof(d_bv.V)>::type __Result__ = 0; typeof(d_bv.V) __Val2__ = d_bv.V; typeof(val.V) __Repl2__ = val.V; __builtin_bit_part_set((void*)(&__Result__), (void*)(&__Val2__), (void*)(&__Repl2__), l_index, h_index); __Result__; });
  }

  inline __attribute__((always_inline)) int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }
# 615 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_ref.h"
  inline __attribute__((always_inline)) char* to_string(signed char rd = 2) const {
     (void)(rd);
    return 0;
  }

};
# 679 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator >=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator <=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator ==( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline __attribute__((always_inline)) bool operator !=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
# 725 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline __attribute__((always_inline)) bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<1, false>(op); }
# 12 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h" 2





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed : ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                      _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                               _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 66 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }
# 101 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}





                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(bool v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(signed char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(unsigned long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(ap_slong v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed(const char* s, signed char rd) : Base(s, rd) {}







  ap_fixed &
  operator=(const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &op) = default;
# 168 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_fixed& operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }
};





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_ufixed : ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                       _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                                _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 237 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}




  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned V __attribute__((bitwidth(_AP_W))), bool raw) {
    Base::V = V;
    (void)(raw);
  }
# 269 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}




                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(bool v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(signed char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned char v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned short v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned int v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(unsigned long v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(ap_slong v) : Base(v) {}
                      inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(ap_ulong v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(half v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(float v) : Base(v) {}
  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(double v) : Base(v) {}


  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const char* s) : Base(s) {}

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed(const char* s, signed char rd) : Base(s, rd) {}



  ap_ufixed &
  operator=(const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &op) = default;
# 327 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h"
  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) ap_ufixed& operator=(
      const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline __attribute__((always_inline)) __attribute__((nodebug)) void operator=(const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                                 _AP_N>& op) volatile {
    Base::V = op.V;
  }
};
# 365 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_special.h" 1
# 20 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_special.h"
namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 48 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  __attribute__((nodebug)) complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  __attribute__((nodebug)) complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  __attribute__((nodebug)) complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const __attribute__((nodebug)) _Tp& real() const { return _M_real; }
  const __attribute__((nodebug)) _Tp& imag() const { return _M_imag; }







  __attribute__((nodebug)) void real(_Tp __val) { _M_real = __val; }

  __attribute__((nodebug)) void imag(_Tp __val) { _M_imag = __val; }



  __attribute__((nodebug)) complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator=(const complex<_Up> &__z) {
    auto tmp1 = __z;
    complex<_Tp> tmp2 = {tmp1.real(), tmp1.imag()};
    *this = tmp2;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 190 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  __attribute__((nodebug)) complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  __attribute__((nodebug)) complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  __attribute__((nodebug)) complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const __attribute__((nodebug)) _Tp& real() const { return _M_real; }
  const __attribute__((nodebug)) _Tp& imag() const { return _M_imag; }







  __attribute__((nodebug)) void real(_Tp __val) { _M_real = __val; }

  __attribute__((nodebug)) void imag(_Tp __val) { _M_imag = __val; }



  __attribute__((nodebug)) complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  __attribute__((nodebug)) complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator=(const complex<_Up> &__z) {
    auto tmp1 = __z;
    complex<_Tp> tmp2 = {tmp1.real(), tmp1.imag()};
    *this = tmp2;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  __attribute__((nodebug)) complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 323 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator==(
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline __attribute__((nodebug)) bool operator!=(
    const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 366 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_fixed.h" 2
# 361 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\ap_int.h" 2
# 3 "conv2d_layer2.cpp" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 1
# 40 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 1 3
# 40 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3

# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 1 3
# 236 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 258 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 508 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/os_defines.h" 1 3
# 509 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 2 3


# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/cpu_defines.h" 1 3
# 512 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\x86_64-w64-mingw32\\bits/c++config.h" 2 3
# 42 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 2 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cpp_type_traits.h" 1 3
# 36 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cpp_type_traits.h" 3
# 67 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cpp_type_traits.h" 3
extern "C++" {

namespace std
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 261 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 278 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 408 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 2 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/type_traits.h" 1 3
# 33 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 44 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 2 3

# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 1 3
# 11 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3


# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 1 3
# 10 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 1 3
# 12 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include/_mingw_mac.h" 1 3
# 13 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include/_mingw_secapi.h" 1 3
# 44 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include/_mingw_secapi.h" 3
extern "C++" {
template <bool __test, typename __dsttype>
  struct __if_array;
template <typename __dsttype>
  struct __if_array <true, __dsttype> {
    typedef __dsttype __type;
};
}
# 14 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 282 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
# 1 "D:\\xilinx\\Vitis_HLS\\2022.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\vadefs.h" 1 3
# 26 "D:\\xilinx\\Vitis_HLS\\2022.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\vadefs.h" 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\vadefs.h" 1 3








# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 1 3
# 595 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include/sdks/_mingw_directx.h" 1 3
# 596 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include/sdks/_mingw_ddk.h" 1 3
# 597 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 10 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\vadefs.h" 2 3




#pragma pack(push,_CRT_PACKING)



extern "C" {





  typedef __builtin_va_list __gnuc_va_list;






  typedef __gnuc_va_list va_list;
# 99 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\vadefs.h" 3
}



#pragma pack(pop)
# 27 "D:\\xilinx\\Vitis_HLS\\2022.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\vadefs.h" 2 3
# 283 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 2 3
# 558 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
extern "C" {
# 569 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\_mingw.h" 3
void __attribute__((__cdecl__)) __debugbreak(void);
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void __attribute__((__cdecl__)) __debugbreak(void)
{
  __asm__ __volatile__("int {$}3":);
}




const char *__mingw_get_crt_info (void);


}
# 11 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 2 3




#pragma pack(push,_CRT_PACKING)
# 35 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef unsigned long size_t;
# 45 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef long ssize_t;






typedef size_t rsize_t;
# 62 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef long intptr_t;
# 75 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef unsigned long uintptr_t;
# 88 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
__extension__ typedef long ptrdiff_t;
# 106 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
typedef unsigned short wint_t;
typedef unsigned short wctype_t;





typedef int errno_t;




typedef long __time32_t;




__extension__ typedef long __time64_t;
# 138 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
typedef __time64_t time_t;
# 422 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\crtdefs.h" 3
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct {
  pthreadlocinfo locinfo;
  pthreadmbcinfo mbcinfo;
} _locale_tstruct,*_locale_t;



typedef struct tagLC_ID {
  unsigned short wLanguage;
  unsigned short wCountry;
  unsigned short wCodePage;
} LC_ID,*LPLC_ID;




typedef struct threadlocaleinfostruct {
  int refcount;
  unsigned int lc_codepage;
  unsigned int lc_collate_cp;
  unsigned long lc_handle[6];
  LC_ID lc_id[6];
  struct {
    char *locale;
    wchar_t *wlocale;
    int *refcount;
    int *wrefcount;
  } lc_category[6];
  int lc_clike;
  int mb_cur_max;
  int *lconv_intl_refcount;
  int *lconv_num_refcount;
  int *lconv_mon_refcount;
  struct lconv *lconv;
  int *ctype1_refcount;
  unsigned short *ctype1;
  const unsigned short *pctype;
  const unsigned char *pclmap;
  const unsigned char *pcumap;
  struct __lc_time_data *lc_time_curr;
} threadlocinfo;







#pragma pack(pop)
# 14 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 2 3

struct _exception;

#pragma pack(push,_CRT_PACKING)
# 77 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
extern "C++" {
template <typename type1, typename type2> struct __mingw_types_compatible_p {
  static const bool result = false;
};

template <typename type1> struct __mingw_types_compatible_p<type1, type1> {
 static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<const type1, type1> {
  static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<type1, const type1> {
  static const bool result = true;
};
}
# 111 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
extern "C" {







  typedef union __mingw_dbl_type_t {
    double x;
    unsigned long long val;
    __extension__ struct {
      unsigned int low, high;
    } lh;
  } __mingw_dbl_type_t;

  typedef union __mingw_flt_type_t {
    float x;
    unsigned int val;
  } __mingw_flt_type_t;

  typedef union __mingw_ldbl_type_t
  {
    long double x;
    __extension__ struct {
      unsigned int low, high;
      int sign_exponent : 16;
      int res1 : 16;
      int res0 : 32;
    } lh;
  } __mingw_ldbl_type_t;

  typedef union __mingw_fp_types_t
  {
    long double *ld;
    double *d;
    float *f;
    __mingw_ldbl_type_t *ldt;
    __mingw_dbl_type_t *dt;
    __mingw_flt_type_t *ft;
  } __mingw_fp_types_t;




  extern double * __imp__HUGE;
# 168 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  struct _exception {
    int type;
    const char *name;
    double arg1;
    double arg2;
    double retval;
  };

  void __mingw_raise_matherr (int typ, const char *name, double a1, double a2,
         double rslt);
  void __mingw_setusermatherr (int (__attribute__((__cdecl__)) *)(struct _exception *));
  __attribute__ ((__dllimport__)) void __setusermatherr(int (__attribute__((__cdecl__)) *)(struct _exception *));



  double __attribute__((__cdecl__)) sin(double _X);
  double __attribute__((__cdecl__)) cos(double _X);
  double __attribute__((__cdecl__)) tan(double _X);
  double __attribute__((__cdecl__)) sinh(double _X);
  double __attribute__((__cdecl__)) cosh(double _X);
  double __attribute__((__cdecl__)) tanh(double _X);
  double __attribute__((__cdecl__)) asin(double _X);
  double __attribute__((__cdecl__)) acos(double _X);
  double __attribute__((__cdecl__)) atan(double _X);
  double __attribute__((__cdecl__)) atan2(double _Y,double _X);
  double __attribute__((__cdecl__)) exp(double _X);
  double __attribute__((__cdecl__)) log(double _X);
  double __attribute__((__cdecl__)) log10(double _X);
  double __attribute__((__cdecl__)) pow(double _X,double _Y);
  double __attribute__((__cdecl__)) sqrt(double _X);
  double __attribute__((__cdecl__)) ceil(double _X);
  double __attribute__((__cdecl__)) floor(double _X);


  extern float __attribute__((__cdecl__)) fabsf (float x);
  extern long double __attribute__((__cdecl__)) fabsl (long double);
  extern double __attribute__((__cdecl__)) fabs (double _X);
# 243 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  double __attribute__((__cdecl__)) ldexp(double _X,int _Y);
  double __attribute__((__cdecl__)) frexp(double _X,int *_Y);
  double __attribute__((__cdecl__)) modf(double _X,double *_Y);
  double __attribute__((__cdecl__)) fmod(double _X,double _Y);

  void __attribute__((__cdecl__)) sincos (double __x, double *p_sin, double *p_cos);
  void __attribute__((__cdecl__)) sincosl (long double __x, long double *p_sin, long double *p_cos);
  void __attribute__((__cdecl__)) sincosf (float __x, float *p_sin, float *p_cos);



  int __attribute__((__cdecl__)) abs(int _X);
  long __attribute__((__cdecl__)) labs(long _X);



  double __attribute__((__cdecl__)) atof(const char *_String);
  double __attribute__((__cdecl__)) _atof_l(const char *_String,_locale_t _Locale);
# 270 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  struct _complex {
    double x;
    double y;
  };


  double __attribute__((__cdecl__)) _cabs(struct _complex _ComplexA);
  double __attribute__((__cdecl__)) _hypot(double _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _jn(int _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _yn(int _X,double _Y);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _matherr (struct _exception *);
# 297 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _chgsign (double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _copysign (double _Number,double _Sign);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _logb (double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _nextafter (double, double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _scalb (double, long);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclass (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnan (double);






__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) jn (int, double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) yn (int, double) ;

__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) chgsign (double);
# 327 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) fpclass (double);
# 372 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
typedef float float_t;
typedef double double_t;
# 407 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern int __attribute__((__cdecl__)) __fpclassifyl (long double);
  extern int __attribute__((__cdecl__)) __fpclassifyf (float);
  extern int __attribute__((__cdecl__)) __fpclassify (double);
# 520 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern int __attribute__((__cdecl__)) __isnan (double);
  extern int __attribute__((__cdecl__)) __isnanf (float);
  extern int __attribute__((__cdecl__)) __isnanl (long double);
# 607 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern int __attribute__((__cdecl__)) __signbit (double);
  extern int __attribute__((__cdecl__)) __signbitf (float);
  extern int __attribute__((__cdecl__)) __signbitl (long double);
# 664 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern float __attribute__((__cdecl__)) sinf(float _X);
  extern long double __attribute__((__cdecl__)) sinl(long double);

  extern float __attribute__((__cdecl__)) cosf(float _X);
  extern long double __attribute__((__cdecl__)) cosl(long double);

  extern float __attribute__((__cdecl__)) tanf(float _X);
  extern long double __attribute__((__cdecl__)) tanl(long double);
  extern float __attribute__((__cdecl__)) asinf(float _X);
  extern long double __attribute__((__cdecl__)) asinl(long double);

  extern float __attribute__((__cdecl__)) acosf (float);
  extern long double __attribute__((__cdecl__)) acosl (long double);

  extern float __attribute__((__cdecl__)) atanf (float);
  extern long double __attribute__((__cdecl__)) atanl (long double);

  extern float __attribute__((__cdecl__)) atan2f (float, float);
  extern long double __attribute__((__cdecl__)) atan2l (long double, long double);


  extern float __attribute__((__cdecl__)) sinhf(float _X);



  extern long double __attribute__((__cdecl__)) sinhl(long double);

  extern float __attribute__((__cdecl__)) coshf(float _X);



  extern long double __attribute__((__cdecl__)) coshl(long double);

  extern float __attribute__((__cdecl__)) tanhf(float _X);



  extern long double __attribute__((__cdecl__)) tanhl(long double);



  extern double __attribute__((__cdecl__)) acosh (double);
  extern float __attribute__((__cdecl__)) acoshf (float);
  extern long double __attribute__((__cdecl__)) acoshl (long double);


  extern double __attribute__((__cdecl__)) asinh (double);
  extern float __attribute__((__cdecl__)) asinhf (float);
  extern long double __attribute__((__cdecl__)) asinhl (long double);


  extern double __attribute__((__cdecl__)) atanh (double);
  extern float __attribute__((__cdecl__)) atanhf (float);
  extern long double __attribute__((__cdecl__)) atanhl (long double);



  extern float __attribute__((__cdecl__)) expf(float _X);



  extern long double __attribute__((__cdecl__)) expl(long double);


  extern double __attribute__((__cdecl__)) exp2(double);
  extern float __attribute__((__cdecl__)) exp2f(float);
  extern long double __attribute__((__cdecl__)) exp2l(long double);



  extern double __attribute__((__cdecl__)) expm1(double);
  extern float __attribute__((__cdecl__)) expm1f(float);
  extern long double __attribute__((__cdecl__)) expm1l(long double);


  extern float frexpf(float _X,int *_Y);



  extern long double __attribute__((__cdecl__)) frexpl(long double,int *);




  extern int __attribute__((__cdecl__)) ilogb (double);
  extern int __attribute__((__cdecl__)) ilogbf (float);
  extern int __attribute__((__cdecl__)) ilogbl (long double);


  extern float __attribute__((__cdecl__)) ldexpf(float _X,int _Y);



  extern long double __attribute__((__cdecl__)) ldexpl (long double, int);


  extern float __attribute__((__cdecl__)) logf (float);
  extern long double __attribute__((__cdecl__)) logl(long double);


  extern float __attribute__((__cdecl__)) log10f (float);
  extern long double __attribute__((__cdecl__)) log10l(long double);


  extern double __attribute__((__cdecl__)) log1p(double);
  extern float __attribute__((__cdecl__)) log1pf(float);
  extern long double __attribute__((__cdecl__)) log1pl(long double);


  extern double __attribute__((__cdecl__)) log2 (double);
  extern float __attribute__((__cdecl__)) log2f (float);
  extern long double __attribute__((__cdecl__)) log2l (long double);


  extern double __attribute__((__cdecl__)) logb (double);
  extern float __attribute__((__cdecl__)) logbf (float);
  extern long double __attribute__((__cdecl__)) logbl (long double);
# 863 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern float __attribute__((__cdecl__)) modff (float, float*);
  extern long double __attribute__((__cdecl__)) modfl (long double, long double*);


  extern double __attribute__((__cdecl__)) scalbn (double, int);
  extern float __attribute__((__cdecl__)) scalbnf (float, int);
  extern long double __attribute__((__cdecl__)) scalbnl (long double, int);

  extern double __attribute__((__cdecl__)) scalbln (double, long);
  extern float __attribute__((__cdecl__)) scalblnf (float, long);
  extern long double __attribute__((__cdecl__)) scalblnl (long double, long);



  extern double __attribute__((__cdecl__)) cbrt (double);
  extern float __attribute__((__cdecl__)) cbrtf (float);
  extern long double __attribute__((__cdecl__)) cbrtl (long double);


  extern double __attribute__((__cdecl__)) hypot (double, double) ;
  extern float __attribute__((__cdecl__)) hypotf (float x, float y);



  extern long double __attribute__((__cdecl__)) hypotl (long double, long double);


  extern float __attribute__((__cdecl__)) powf(float _X,float _Y);



  extern long double __attribute__((__cdecl__)) powl (long double, long double);


  extern float __attribute__((__cdecl__)) sqrtf (float);
  extern long double sqrtl(long double);


  extern double __attribute__((__cdecl__)) erf (double);
  extern float __attribute__((__cdecl__)) erff (float);
  extern long double __attribute__((__cdecl__)) erfl (long double);


  extern double __attribute__((__cdecl__)) erfc (double);
  extern float __attribute__((__cdecl__)) erfcf (float);
  extern long double __attribute__((__cdecl__)) erfcl (long double);


  extern double __attribute__((__cdecl__)) lgamma (double);
  extern float __attribute__((__cdecl__)) lgammaf (float);
  extern long double __attribute__((__cdecl__)) lgammal (long double);

  extern int signgam;


  extern double __attribute__((__cdecl__)) tgamma (double);
  extern float __attribute__((__cdecl__)) tgammaf (float);
  extern long double __attribute__((__cdecl__)) tgammal (long double);


  extern float __attribute__((__cdecl__)) ceilf (float);
  extern long double __attribute__((__cdecl__)) ceill (long double);


  extern float __attribute__((__cdecl__)) floorf (float);
  extern long double __attribute__((__cdecl__)) floorl (long double);


  extern double __attribute__((__cdecl__)) nearbyint ( double);
  extern float __attribute__((__cdecl__)) nearbyintf (float);
  extern long double __attribute__((__cdecl__)) nearbyintl (long double);



extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);


extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);

__extension__ long long __attribute__((__cdecl__)) llrint (double);
__extension__ long long __attribute__((__cdecl__)) llrintf (float);
__extension__ long long __attribute__((__cdecl__)) llrintl (long double);
# 1030 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern double __attribute__((__cdecl__)) round (double);
  extern float __attribute__((__cdecl__)) roundf (float);
  extern long double __attribute__((__cdecl__)) roundl (long double);


  extern long __attribute__((__cdecl__)) lround (double);
  extern long __attribute__((__cdecl__)) lroundf (float);
  extern long __attribute__((__cdecl__)) lroundl (long double);
  __extension__ long long __attribute__((__cdecl__)) llround (double);
  __extension__ long long __attribute__((__cdecl__)) llroundf (float);
  __extension__ long long __attribute__((__cdecl__)) llroundl (long double);



  extern double __attribute__((__cdecl__)) trunc (double);
  extern float __attribute__((__cdecl__)) truncf (float);
  extern long double __attribute__((__cdecl__)) truncl (long double);


  extern float __attribute__((__cdecl__)) fmodf (float, float);
  extern long double __attribute__((__cdecl__)) fmodl (long double, long double);


  extern double __attribute__((__cdecl__)) remainder (double, double);
  extern float __attribute__((__cdecl__)) remainderf (float, float);
  extern long double __attribute__((__cdecl__)) remainderl (long double, long double);


  extern double __attribute__((__cdecl__)) remquo(double, double, int *);
  extern float __attribute__((__cdecl__)) remquof(float, float, int *);
  extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);


  extern double __attribute__((__cdecl__)) copysign (double, double);
  extern float __attribute__((__cdecl__)) copysignf (float, float);
  extern long double __attribute__((__cdecl__)) copysignl (long double, long double);
# 1087 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern double __attribute__((__cdecl__)) nan(const char *tagp);
  extern float __attribute__((__cdecl__)) nanf(const char *tagp);
  extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
# 1098 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
  extern double __attribute__((__cdecl__)) nextafter (double, double);
  extern float __attribute__((__cdecl__)) nextafterf (float, float);
  extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);


  extern double __attribute__((__cdecl__)) nexttoward (double, long double);
  extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
  extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);



  extern double __attribute__((__cdecl__)) fdim (double x, double y);
  extern float __attribute__((__cdecl__)) fdimf (float x, float y);
  extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);







  extern double __attribute__((__cdecl__)) fmax (double, double);
  extern float __attribute__((__cdecl__)) fmaxf (float, float);
  extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);


  extern double __attribute__((__cdecl__)) fmin (double, double);
  extern float __attribute__((__cdecl__)) fminf (float, float);
  extern long double __attribute__((__cdecl__)) fminl (long double, long double);



  extern double __attribute__((__cdecl__)) fma (double, double, double);
  extern float __attribute__((__cdecl__)) fmaf (float, float, float);
  extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
# 1181 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _copysignf (float _Number,float _Sign);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _chgsignf (float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _logbf(float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _nextafterf(float _X,float _Y);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finitef(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnanf(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclassf(float _X);



   extern long double __attribute__((__cdecl__)) _chgsignl (long double);
# 1576 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\math.h" 3
}




#pragma pack(pop)
# 46 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 2 3

# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/std_abs.h" 1 3
# 34 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/std_abs.h" 3




# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 1 3
# 10 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
# 1 "D:\\xilinx\\Vitis_HLS\\2022.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\limits.h" 1 3
# 37 "D:\\xilinx\\Vitis_HLS\\2022.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\limits.h" 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\limits.h" 1 3
# 38 "D:\\xilinx\\Vitis_HLS\\2022.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\limits.h" 2 3
# 11 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 2 3
# 25 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 49 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  typedef int (__attribute__((__cdecl__)) *_onexit_t)(void);
# 59 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  typedef struct _div_t {
    int quot;
    int rem;
  } div_t;

  typedef struct _ldiv_t {
    long quot;
    long rem;
  } ldiv_t;





#pragma pack(4)
 typedef struct {
    unsigned char ld[10];
  } _LDOUBLE;
#pragma pack()



 typedef struct {
    double x;
  } _CRT_DOUBLE;

  typedef struct {
    float f;
  } _CRT_FLOAT;




  typedef struct {
    long double x;
  } _LONGDOUBLE;



#pragma pack(4)
 typedef struct {
    unsigned char ld12[12];
  } _LDBL12;
#pragma pack()
# 115 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
 extern int * __imp___mb_cur_max;




__attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) ___mb_cur_max_func(void);
# 142 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  typedef void (__attribute__((__cdecl__)) *_purecall_handler)(void);

  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _set_purecall_handler(_purecall_handler _Handler);
  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _get_purecall_handler(void);

  typedef void (__attribute__((__cdecl__)) *_invalid_parameter_handler)(const wchar_t *,const wchar_t *,const wchar_t *,unsigned int,uintptr_t);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _get_invalid_parameter_handler(void);



  __attribute__ ((__dllimport__)) extern int *__attribute__((__cdecl__)) _errno(void);

  errno_t __attribute__((__cdecl__)) _set_errno(int _Value);
  errno_t __attribute__((__cdecl__)) _get_errno(int *_Value);

  __attribute__ ((__dllimport__)) unsigned long *__attribute__((__cdecl__)) __doserrno(void);

  errno_t __attribute__((__cdecl__)) _set_doserrno(unsigned long _Value);
  errno_t __attribute__((__cdecl__)) _get_doserrno(unsigned long *_Value);
# 172 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern __attribute__((dllimport)) char *_sys_errlist[1];
  extern __attribute__((dllimport)) int _sys_nerr;





  __attribute__ ((__dllimport__)) char ***__attribute__((__cdecl__)) __p___argv(void);
  __attribute__ ((__dllimport__)) int *__attribute__((__cdecl__)) __p__fmode(void);
# 190 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  errno_t __attribute__((__cdecl__)) _get_pgmptr(char **_Value);
  errno_t __attribute__((__cdecl__)) _get_wpgmptr(wchar_t **_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_fmode(int _Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_fmode(int *_PMode);
# 281 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  extern int * __imp___argc;



  extern char *** __imp___argv;



  extern wchar_t *** __imp___wargv;





  extern char *** __imp__environ;




  extern wchar_t *** __imp__wenviron;





  extern char ** __imp__pgmptr;




  extern wchar_t ** __imp__wpgmptr;




  extern unsigned int * __imp__osplatform;




  extern unsigned int * __imp__osver;




  extern unsigned int * __imp__winver;




  extern unsigned int * __imp__winmajor;




  extern unsigned int * __imp__winminor;





  errno_t __attribute__((__cdecl__)) _get_osplatform(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_osver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winmajor(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winminor(unsigned int *_Value);




  extern "C++" {
    template <typename _CountofType,size_t _SizeOfArray> char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

  }





  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit(int _Code) __attribute__ ((__noreturn__));
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit(int _Code) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) _Exit(int) __attribute__ ((__noreturn__));
# 374 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  void __attribute__((__cdecl__)) __attribute__ ((__noreturn__)) abort(void);




  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_abort_behavior(unsigned int _Flags,unsigned int _Mask);







  __extension__ long __attribute__((__cdecl__)) _abs64(long);

  extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) long __attribute__((__cdecl__)) _abs64(long x) {
    return __builtin_llabs(x);
  }


  int __attribute__((__cdecl__)) atexit(void (__attribute__((__cdecl__)) *)(void));





  int __attribute__((__cdecl__)) atoi(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoi_l(const char *_Str,_locale_t _Locale);
  long __attribute__((__cdecl__)) atol(const char *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atol_l(const char *_Str,_locale_t _Locale);


  void *__attribute__((__cdecl__)) bsearch(const void *_Key,const void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));
  void __attribute__((__cdecl__)) qsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));

  unsigned short __attribute__((__cdecl__)) _byteswap_ushort(unsigned short _Short);
  unsigned long __attribute__((__cdecl__)) _byteswap_ulong (unsigned long _Long);
  __extension__ unsigned long __attribute__((__cdecl__)) _byteswap_uint64(unsigned long _Int64);
  div_t __attribute__((__cdecl__)) div(int _Numerator,int _Denominator);
  char *__attribute__((__cdecl__)) getenv(const char *_VarName) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _itoa(int _Value,char *_Dest,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _i64toa(long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ui64toa(unsigned long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atoi64(const char *_String);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atoi64_l(const char *_String,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtoi64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtoi64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoui64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoui64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  ldiv_t __attribute__((__cdecl__)) ldiv(long _Numerator,long _Denominator);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ltoa(long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) mblen(const char *_Ch,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mblen_l(const char *_Ch,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen(const char *_Str);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen_l(const char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen(const char *_Str,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen_l(const char *_Str,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mbtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mbtowc_l(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) mbstowcs(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstowcs_l(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mkstemp(char *template_name);
  int __attribute__((__cdecl__)) rand(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_error_mode(int _Mode);
  void __attribute__((__cdecl__)) srand(unsigned int _Seed);
# 449 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
inline __attribute__((__cdecl__))
double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtod(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  return __mingw_strtod( _Str, _EndPtr);
}

inline __attribute__((__cdecl__))
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  return __mingw_strtof( _Str, _EndPtr);
}






  long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold(const char * __restrict__ , char ** __restrict__ );


  extern double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
  __strtod (const char * __restrict__ , char ** __restrict__);







  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  long double __attribute__((__cdecl__)) __mingw_strtold(const char * __restrict__, char ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _strtod_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) strtol(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtol_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) strtoul(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoul_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);


  int __attribute__((__cdecl__)) system(const char *_Command);

  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ultoa(unsigned long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) wctomb(char *_MbCh,wchar_t _WCh) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wctomb_l(char *_MbCh,wchar_t _WCh,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcstombs(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcstombs_l(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale) ;



  void *__attribute__((__cdecl__)) calloc(size_t _NumOfElements,size_t _SizeOfElements);
  void __attribute__((__cdecl__)) free(void *_Memory);
  void *__attribute__((__cdecl__)) malloc(size_t _Size);
  void *__attribute__((__cdecl__)) realloc(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _recalloc(void *_Memory,size_t _Count,size_t _Size);






  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _aligned_free(void *_Memory);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_malloc(size_t _Size,size_t _Alignment);



  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_malloc(size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_realloc(void *_Memory,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_realloc(void *_Memory,size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment,size_t _Offset);





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _itow(int _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ltow(long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ultow(unsigned long _Value,wchar_t *_Dest,int _Radix) ;

  double __attribute__((__cdecl__)) __mingw_wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) __mingw_wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);
  long double __attribute__((__cdecl__)) __mingw_wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);


  inline __attribute__((__cdecl__))
  double __attribute__((__cdecl__)) wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstod(_Str,_EndPtr);
  }
  inline __attribute__((__cdecl__))
  float __attribute__((__cdecl__)) wcstof(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstof(_Str,_EndPtr);
  }






  long double __attribute__((__cdecl__)) wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wcstod_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) wcstol(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstol_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) wcstoul(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoul_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetenv(const wchar_t *_VarName) ;


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsystem(const wchar_t *_Command);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol_l(const wchar_t *_Str,_locale_t _Locale);

  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _i64tow(long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ui64tow(unsigned long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtoi64(const wchar_t *_Str);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtoi64_l(const wchar_t *_Str,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstoi64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstoi64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoui64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoui64_l(const wchar_t *_Str ,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putenv(const char *_EnvString);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fullpath(char *_FullPath,const char *_Path,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl(_CRT_DOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl(_LDOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt(_CRT_FLOAT *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl_l(_CRT_DOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl_l(_LDOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale);
# 609 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
unsigned long __attribute__((__cdecl__)) _lrotl(unsigned long,int);
unsigned long __attribute__((__cdecl__)) _lrotr(unsigned long,int);





  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _makepath(char *_Path,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  _onexit_t __attribute__((__cdecl__)) _onexit(_onexit_t _Func);



  void __attribute__((__cdecl__)) perror(const char *_ErrMsg);





  __extension__ unsigned long __attribute__((__cdecl__)) _rotl64(unsigned long _Val,int _Shift);
  __extension__ unsigned long __attribute__((__cdecl__)) _rotr64(unsigned long Value,int Shift);






  unsigned int __attribute__((__cdecl__)) _rotr(unsigned int _Val,int _Shift);
  unsigned int __attribute__((__cdecl__)) _rotl(unsigned int _Val,int _Shift);


  __extension__ unsigned long __attribute__((__cdecl__)) _rotr64(unsigned long _Val,int _Shift);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _searchenv(const char *_Filename,const char *_EnvVar,char *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _splitpath(const char *_FullPath,char *_Drive,char *_Dir,char *_Filename,char *_Ext) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _swab(char *_Buf1,char *_Buf2,int _SizeInBytes);



  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wfullpath(wchar_t *_FullPath,const wchar_t *_Path,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wmakepath(wchar_t *_ResultPath,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wperror(const wchar_t *_ErrMsg);

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsearchenv(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsplitpath(const wchar_t *_FullPath,wchar_t *_Drive,wchar_t *_Dir,wchar_t *_Filename,wchar_t *_Ext) ;


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _beep(unsigned _Frequency,unsigned _Duration) __attribute__ ((__deprecated__));

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _seterrormode(int _Mode) __attribute__ ((__deprecated__));
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _sleep(unsigned long _Duration) __attribute__ ((__deprecated__));
# 680 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
  char *__attribute__((__cdecl__)) ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  char *__attribute__((__cdecl__)) itoa(int _Val,char *_DstBuf,int _Radix) ;
  char *__attribute__((__cdecl__)) ltoa(long _Val,char *_DstBuf,int _Radix) ;
  int __attribute__((__cdecl__)) putenv(const char *_EnvString) ;



  void __attribute__((__cdecl__)) swab(char *_Buf1,char *_Buf2,int _SizeInBytes) ;


  char *__attribute__((__cdecl__)) ultoa(unsigned long _Val,char *_Dstbuf,int _Radix) ;
  _onexit_t __attribute__((__cdecl__)) onexit(_onexit_t _Func);





  typedef struct { __extension__ long long quot, rem; } lldiv_t;

  __extension__ lldiv_t __attribute__((__cdecl__)) lldiv(long long, long long);

  __extension__ long long __attribute__((__cdecl__)) llabs(long long);




  __extension__ long long __attribute__((__cdecl__)) strtoll(const char * __restrict__, char ** __restrict, int);
  __extension__ unsigned long long __attribute__((__cdecl__)) strtoull(const char * __restrict__, char ** __restrict__, int);


  __extension__ long long __attribute__((__cdecl__)) atoll (const char *);


  __extension__ long long __attribute__((__cdecl__)) wtoll (const wchar_t *);
  __extension__ char *__attribute__((__cdecl__)) lltoa (long long, char *, int);
  __extension__ char *__attribute__((__cdecl__)) ulltoa (unsigned long long , char *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) lltow (long long, wchar_t *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) ulltow (unsigned long long, wchar_t *, int);
# 735 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 3
}


#pragma pack(pop)


# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\sec_api/stdlib_s.h" 1 3








# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 1 3
# 30 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 1 3
# 31 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 2 3
# 10 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\sec_api/stdlib_s.h" 2 3
# 741 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 2 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 1 3
# 11 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 46 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
  typedef struct _heapinfo {
    int *_pentry;
    size_t _size;
    int _useflag;
  } _HEAPINFO;


  extern unsigned int _amblksiz;
# 103 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
void * __mingw_aligned_malloc (size_t _Size, size_t _Alignment);
void __mingw_aligned_free (void *_Memory);
void * __mingw_aligned_offset_realloc (void *_Memory, size_t _Size, size_t _Alignment, size_t _Offset);
void * __mingw_aligned_realloc (void *_Memory, size_t _Size, size_t _Offset);



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _resetstkoflw (void);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _set_malloc_crt_max_wait(unsigned long _NewValue);

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _expand(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _msize(void *_Memory);






  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _get_sbh_threshold(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_sbh_threshold(size_t _NewValue);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_amblksiz(size_t _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_amblksiz(size_t *_Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapadd(void *_Memory,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapchk(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapmin(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapset(unsigned int _Fill);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapwalk(_HEAPINFO *_EntryInfo);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _heapused(size_t *_Used,size_t *_Commit);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _get_heap_handle(void);
# 144 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
  static __inline void *_MarkAllocaS(void *_Ptr,unsigned int _Marker) {
    if(_Ptr) {
      *((unsigned int*)_Ptr) = _Marker;
      _Ptr = (char*)_Ptr + 16;
    }
    return _Ptr;
  }
# 163 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
  static __inline void __attribute__((__cdecl__)) _freea(void *_Memory) {
    unsigned int _Marker;
    if(_Memory) {
      _Memory = (char*)_Memory - 16;
      _Marker = *(unsigned int *)_Memory;
      if(_Marker==0xDDDD) {
 free(_Memory);
      }





    }
  }
# 206 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\malloc.h" 3
}


#pragma pack(pop)
# 742 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdlib.h" 2 3
# 39 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/std_abs.h" 2 3







extern "C++"
{
namespace std
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }







  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 107 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\bits/std_abs.h" 3
}
}
# 48 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 2 3
# 77 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
extern "C++"
{
namespace std
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 0x0400 : 0x4000; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1889 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cmath" 3
}





}
# 41 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_half.h" 1
# 42 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_fpo.h" 1
# 17 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_fpo.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 1 3
# 17 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 1 3
# 36 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 1 3
# 40 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
# 121 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
extern "C++"
{
namespace std
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
namespace __gnu_cxx
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;
# 51 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\stdlib.h" 3
using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 18 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 2 3



extern "C" {
# 45 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\assert.h" 3
extern void __attribute__((__cdecl__))
_wassert(const wchar_t *_Message,const wchar_t *_File,unsigned _Line);
extern void __attribute__((__cdecl__))
_assert (const char *_Message, const char *_File, unsigned _Line);


}
# 18 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_fpo.h" 2
# 43 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:\\xilinx\\Vitis_HLS\\2022.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stdint.h" 1 3
# 63 "D:\\xilinx\\Vitis_HLS\\2022.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stdint.h" 3
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdint.h" 1 3
# 32 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdint.h" 3
# 1 "D:\\xilinx\\Vitis_HLS\\2022.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stddef.h" 1 3
# 33 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\x86_64-w64-mingw32\\include\\stdint.h" 2 3


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
__extension__ typedef long long int64_t;
__extension__ typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
__extension__ typedef long long int_least64_t;
__extension__ typedef unsigned long long uint_least64_t;





typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
__extension__ typedef long long int_fast64_t;
__extension__ typedef unsigned long long uint_fast64_t;


__extension__ typedef long long intmax_t;
__extension__ typedef unsigned long long uintmax_t;
# 64 "D:\\xilinx\\Vitis_HLS\\2022.2\\win64\\tools\\clang-3.9-csynth\\lib\\clang\\7.0.0\\include\\stdint.h" 2 3
# 44 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2

namespace hls {


  int signbit(double);
  int signbit(float);
  int signbit(half);
  int signbitf(float);
  int half_signbit(half);


  double nan(const char*);
  float nanf(const char*);
  half half_nan(const char *);


  int isfinite(double);
  int isfinite(float);
  int isfinite(half);
  int isfinitef(float);
  int half_isfinite(half);


  int __isfinite(double);
  int __isfinite(float);
  int __isfinite(half);
  int __isfinitef(float);


  int isinf(double);
  int isinf(float);
  int isinf(half);
  int isinff(float);
  int half_isinf(half);


  int __isinf(double);
  int __isinf(float);
  int __isinf(half);
  int __isinff(float);


  int isnan(double);
  int isnan(float);
  int isnan(half);
  int _isnanf(float);
  int half_isnan(half);


  int __isnan(double);
  int __isnan(float);
  int __isnan(half);
  int __isnanf(float);


  int isnormal(double);
  int isnormal(float);
  int isnormal(half);
  int isnormalf(float);
  int half_isnormal(half);


  int __isnormal(double);
  int __isnormal(float);
  int __isnormal(half);
  int __isnormalf(float);


  int fpclassify(double);
  int fpclassify(float);
  int fpclassify(half);
  int fpclassifyf(float);
  int half_fpclassify(half);


  int __fpclassify(double);
  int __fpclassify(float);
  int __fpclassify(half);
  int __fpclassifyf(float);


  double copysign(double, double);
  float copysign(float, float);
  half copysign(half, half);
  float copysignf(float, float);
  half half_copysign(half, half);
  int8_t copysign(int8_t, int8_t);
  uint8_t copysign(uint8_t, uint8_t);
  int16_t copysign(int16_t, int16_t);
  uint16_t copysign(uint16_t, uint16_t);
  int32_t copysign(int32_t, int32_t);
  uint32_t copysign(uint32_t, uint32_t);


  double fabs(double);
  float fabs(float);
  half fabs(half);
  float fabsf(float);
  half half_fabs(half);
  int8_t fabs(int8_t);
  uint8_t fabs(uint8_t);
  int16_t fabs(int16_t);
  uint16_t fabs(uint16_t);
  int32_t fabs(int32_t);
  uint32_t fabs(uint32_t);


  double abs(double);
  float abs(float);
  half abs(half);
  float absf(float);
  half half_abs(half);
  int8_t abs(int8_t);
  uint8_t abs(uint8_t);
  int16_t abs(int16_t);
  uint16_t abs(uint16_t);
  int32_t abs(int32_t);
  uint32_t abs(uint32_t);


  double fma(double, double, double);
  float fma(float, float, float);
  half fma(half, half, half);
  float fmaf(float, float, float);
  half half_fma(half, half, half);


  double mad(double, double, double);
  float mad(float, float, float);
  half mad(half, half, half);
  float madf(float, float, float);
  half half_mad(half, half, half);


  int isequal(double, double);
  int isequal(float, float);
  int isequal(half, half);
  int isequalf(float, float);
  int half_isequal(half, half);


  int isgreater(double, double);
  int isgreater(float, float);
  int isgreater(half, half);
  int isgreaterf(float, float);
  int half_isgreater(half, half);


  int isgreaterequal(double, double);
  int isgreaterequal(float, float);
  int isgreaterequal(half, half);
  int isgreaterequalf(float, float);
  int half_isgreaterequal(half, half);


  int isless(double, double);
  int isless(float, float);
  int isless(half, half);
  int islessf(float, float);
  int half_isless(half, half);


  int islessequal(double, double);
  int islessequal(float, float);
  int islessequal(half, half);
  int islessequalf(float, float);
  int half_islessequal(half, half);


  int islessgreater(double, double);
  int islessgreater(float, float);
  int islessgreater(half, half);
  int islessgreaterf(float, float);
  int half_islessgreater(half, half);


  int isnotequal(double, double);
  int isnotequal(float, float);
  int isnotequal(half, half);
  int isnotequalf(float, float);
  int half_isnotequal(half, half);


  double fmax(double, double);
  float fmax(float, float);
  half fmax(half, half);
  float fmaxf(float, float);
  half half_fmax(half, half);
  int8_t fmax(int8_t,int8_t);
  uint8_t fmax(uint8_t, uint8_t);
  int16_t fmax(int16_t, int16_t);
  uint16_t fmax(uint16_t, uint16_t);
  int32_t fmax(int32_t, int32_t);
  uint32_t fmax(uint32_t, uint32_t);


  double fmin(double, double);
  float fmin(float, float);
  half fmin(half, half);
  float fminf(float, float);
  half half_fmin(half, half);
  int8_t fmin(int8_t,int8_t);
  uint8_t fmin(uint8_t, uint8_t);
  int16_t fmin(int16_t, int16_t);
  uint16_t fmin(uint16_t, uint16_t);
  int32_t fmin(int32_t, int32_t);
  uint32_t fmin(uint32_t, uint32_t);


  template <class T>
  T max(T x, T y){
 return (x > y) ? x : y;
  }


  template <class T>
  T min(T x, T y){
 return (x < y) ? x : y;
  }


  double fdim(double, double);
  float fdim(float, float);
  half fdim(half, half);
  float fdimf(float, float);
  half half_fdim(half, half);
  int8_t fdim(int8_t,int8_t);
  uint8_t fdim(uint8_t, uint8_t);
  int16_t fdim(int16_t, int16_t);
  uint16_t fdim(uint16_t, uint16_t);
  int32_t fdim(int32_t, int32_t);
  uint32_t fdim(uint32_t, uint32_t);


  double maxmag(double, double);
  float maxmag(float, float);
  half maxmag(half, half);
  float maxmagf(float, float);
  half half_maxmag(half, half);
  int8_t maxmag(int8_t,int8_t);
  uint8_t maxmag(uint8_t, uint8_t);
  int16_t maxmag(int16_t, int16_t);
  uint16_t maxmag(uint16_t, uint16_t);
  int32_t maxmag(int32_t, int32_t);
  uint32_t maxmag(uint32_t, uint32_t);


  double minmag(double, double);
  float minmag(float, float);
  half minmag(half, half);
  float minmagf(float, float);
  half half_minmag(half, half);
  int8_t minmag(int8_t,int8_t);
  uint8_t minmag(uint8_t, uint8_t);
  int16_t minmag(int16_t, int16_t);
  uint16_t minmag(uint16_t, uint16_t);
  int32_t minmag(int32_t, int32_t);
  uint32_t minmag(uint32_t, uint32_t);



  double frexp(double, int*);
  float frexp(float, int*);
  half frexp(half, int*);
  float frexpf(float, int*);
  half half_frexp(half, int*);


  double ldexp(double, int);
  float ldexp(float, int);
  half ldexp(half, int);
  float ldexpf(float, int);
  half half_ldexp(half, int);


  int ilogb(double);
  int ilogb(float);
  int ilogb(half);
  int ilogbf(float);
  int half_ilogb(half);


  double scalbn(double, int);
  float scalbn(float, int);
  half scalbn(half, int);
  float scalbnf(float, int);
  half half_scalbn(half, int);


  double scalbln(double, long int);
  float scalbln(float, long int);
  half scalbln(half, long int);
  float scalblnf(float, long int);
  half half_scalbln(half, long int);


  double ceil(double);
  float ceil(float);
  half ceil(half);
  float ceilf(float);
  half half_ceil(half);


  double floor(double);
  float floor(float);
  half floor(half);
  float floorf(float);
  half half_floor(half);


  double trunc(double);
  float trunc(float);
  half trunc(half);
  float truncf(float);
  half half_trunc(half);


  double round(double);
  float round(float);
  half round(half);
  float roundf(float);
  half half_round(half);


  double rint(double);
  float rint(float);
  half rint(half);
  float rintf(float);
  half half_rint(half);


  long int lround(double);
  long int lround(float);
  long int lround(half);
  long int lroundf(float);
  long int half_lround(half);


  long long int llround(double);
  long long int llround(float);
  long long int llround(half);
  long long int llroundf(float);
  long long int half_llround(half);


  long int lrint(double);
  long int lrint(float);
  long int lrint(half);
  long int lrintf(float);
  long int half_lrint(half);


  long long int llrint(double);
  long long int llrint(float);
  long long int llrint(half);
  long long int llrintf(float);
  long long int half_llrint(half);


  template<class T>
  T cast_IEEE754(double, bool);
  template<class T>
  T cast_IEEE754(float, bool);
  template<class T>
  T cast_IEEE754(half, bool);

  template<class T>
  T cast_IEEE754(double);
  template<class T>
  T cast_IEEE754(float);
  template<class T>
  T cast_IEEE754(half);



  template<>
  char cast_IEEE754<char>(double, bool);
  template<>
  char cast_IEEE754<char>(float, bool);
  template<>
  char cast_IEEE754<char>(half, bool);
  template<>
  char cast_IEEE754<char>(double);
  template<>
  char cast_IEEE754<char>(float);
  template<>
  char cast_IEEE754<char>(half);


  template<>
  int8_t cast_IEEE754<int8_t>(double, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(float, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(half, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(double);
  template<>
  int8_t cast_IEEE754<int8_t>(float);
  template<>
  int8_t cast_IEEE754<int8_t>(half);


  template<>
  uint8_t cast_IEEE754<uint8_t>(double, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(float, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(half, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(double);
  template<>
  uint8_t cast_IEEE754<uint8_t>(float);
  template<>
  uint8_t cast_IEEE754<uint8_t>(half);


  template<>
  int16_t cast_IEEE754<int16_t>(double, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(float, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(half, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(double);
  template<>
  int16_t cast_IEEE754<int16_t>(float);
  template<>
  int16_t cast_IEEE754<int16_t>(half);


  template<>
  uint16_t cast_IEEE754<uint16_t>(double, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(float, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(half, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(double);
  template<>
  uint16_t cast_IEEE754<uint16_t>(float);
  template<>
  uint16_t cast_IEEE754<uint16_t>(half);


  template<>
  int32_t cast_IEEE754<int32_t>(double, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(float, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(half, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(double);
  template<>
  int32_t cast_IEEE754<int32_t>(float);
  template<>
  int32_t cast_IEEE754<int32_t>(half);


  template<>
  uint32_t cast_IEEE754<uint32_t>(double, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(float, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(half, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(double);
  template<>
  uint32_t cast_IEEE754<uint32_t>(float);
  template<>
  uint32_t cast_IEEE754<uint32_t>(half);


  template<>
  int64_t cast_IEEE754<int64_t>(double, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(float, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(half, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(double);
  template<>
  int64_t cast_IEEE754<int64_t>(float);
  template<>
  int64_t cast_IEEE754<int64_t>(half);


  template<>
  uint64_t cast_IEEE754<uint64_t>(double, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(float, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(half, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(double);
  template<>
  uint64_t cast_IEEE754<uint64_t>(float);
  template<>
  uint64_t cast_IEEE754<uint64_t>(half);



  double nearbyint(double);
  float nearbyint(float);
  half nearbyint(half);
  float nearbyintf(float);
  half half_nearbyint(half);


  double modf(double, double*);
  float modf(float, float*);
  half modf(half, half*);
  float modff(float, float*);
  half half_modf(half, half*);


  double fract(double, double*);
  float fract(float, float*);
  half fract(half, half*);
  float fractf(float, float*);
  half half_fract(half, half*);


  int isordered(double, double);
  int isordered(float, float);
  int isordered(half, half);
  int isorderedf(float, float);
  int half_isordered(half, half);


  int isunordered(double, double);
  int isunordered(float, float);
  int isunordered(half, half);
  int isunorderedf(float, float);
  int half_isunordered(half, half);


  double bitselect(double, double, double);
  float bitselect(float, float, float);
  int bitselect(int, int, int);
  uint32_t bitselect(uint32_t, uint32_t, uint32_t);
  half bitselect(half, half, half);
  float bitselectf(float, float, float);
  half half_bitselect(half, half, half);


  namespace hotbm {
 double sin(double);
 float sin(float);
 half sin(half);
 float sinf(float);
 half half_sin(half);

 double cos(double);
 float cos(float);
 half cos(half);
 float cosf(float);
 half half_cos(half);

 void sincos(double, double*, double*);
 void sincos(float, float*, float*);
 void sincos(half, half*, half*);
 void sincosf(float, float*, float*);
 void half_sincos(half, half*, half*);
  }


  namespace cordic {
 double sin(double);
 float sin(float);
 half sin(half);
 float sinf(float);
 half half_sin(half);

 double cos(double);
 float cos(float);
 half cos(half);
 float cosf(float);
 half half_cos(half);

 void sincos(double, double*, double*);
 void sincos(float, float*, float*);
 void sincos(half, half*, half*);
 void sincosf(float, float*, float*);
 void half_sincos(half, half*, half*);
  }


  double sin(double);
  float sin(float);
  half sin(half);
  float sinf(float);
  half half_sin(half);

  double cos(double);
  float cos(float);
  half cos(half);
  float cosf(float);
  half half_cos(half);


  void sincos(double, double*, double*);
  void sincos(float, float*, float*);
  void sincos(half, half*, half*);
  void sincosf(float, float*, float*);
  void half_sincos(half, half*, half*);


  double sinpi(double);
  float sinpi(float);
  half sinpi(half);
  float sinpif(float);
  half half_sinpi(half);


  double cospi(double);
  float cospi(float);
  half cospi(half);
  float cospif(float);
  half half_cospi(half);


  double tanpi(double);
  float tanpi(float);
  half tanpi(half);
  float tanpif(float);
  half half_tanpi(half);


  double atan(double);
  float atan(float);
  half atan(half);
  float atanf(float);
  half half_atan(half);


  double atan2(double, double);
  float atan2(float, float);
  half atan2(half, half);
  float atan2f(float, float);
  half half_atan2(half, half);


  double tan(double);
  float tan(float);
  half tan(half);
  float tanf(float);
  half half_tan(half);


  double sinh(double);
  float sinh(float);
  half sinh(half);
  float sinhf(float);
  half half_sinh(half);


  double cosh(double);
  float cosh(float);
  half cosh(half);
  float coshf(float);
  half half_cosh(half);


  double exp(double);
  float exp(float);
  half exp(half);
  float expf(float);
  half half_exp(half);
  int8_t exp(int8_t);
  uint8_t exp(uint8_t);
  int16_t exp(int16_t);
  uint16_t exp(uint16_t);
  int32_t exp(int32_t);
  uint32_t exp(uint32_t);


  double exp2(double);
  float exp2(float);
  half exp2(half);
  float exp2f(float);
  half half_exp2(half);


  double exp10(double);
  float exp10(float);
  half exp10(half);
  float exp10f(float);
  half half_exp10(half);


  double expm1(double);
  float expm1(float);
  half expm1(half);
  float expm1f(float);
  half half_expm1(half);


  double log(double);
  float log(float);
  half log(half);
  float logf(float);
  half half_log(half);
  int8_t log(int8_t);
  uint8_t log(uint8_t);
  int16_t log(int16_t);
  uint16_t log(uint16_t);
  int32_t log(int32_t);
  uint32_t log(uint32_t);


  double log2(double);
  float log2(float);
  half log2(half);
  float log2f(float);
  half half_log2(half);


  double log10(double);
  float log10(float);
  half log10(half);
  float log10f(float);
  half half_log10(half);
  int8_t log10(int8_t);
  uint8_t log10(uint8_t);
  int16_t log10(int16_t);
  uint16_t log10(uint16_t);
  int32_t log10(int32_t);
  uint32_t log10(uint32_t);


  double logb(double);
  float logb(float);
  half logb(half);
  float logbf(float);
  half half_logb(half);

  double log1p(double);
  float log1p(float);
  half log1p(half);
  float log1pf(float);
  half half_log1p(half);


  half pow(half, half);
  float pow(float, float);
  double pow(double, double);
  float powf(float, float);
  half half_pow(half, half);
  int8_t pow(int8_t, int8_t);
  uint8_t pow(uint8_t, uint8_t);
  int16_t pow(int16_t, int16_t);
  uint16_t pow(uint16_t, uint16_t);
  int32_t pow(int32_t, int32_t);
  uint32_t pow(uint32_t, uint32_t);
  int8_t powr(int8_t, int8_t);
  uint8_t powr(uint8_t, uint8_t);
  int16_t powr(int16_t, int16_t);
  uint16_t powr(uint16_t, uint16_t);
  int32_t powr(int32_t, int32_t);
  uint32_t powr(uint32_t, uint32_t);


  half powr(half, half);
  float powr(float, float);
  double powr(double, double);
  float powrf(float, float);
  half half_powr(half, half);


  half pown(half, int);
  float pown(float, int);
  double pown(double, int);
  float pownf(float, int);
  half half_pown(half, int);


  half rootn(half, int);
  float rootn(float, int);
  double rootn(double, int);
  float rootnf(float, int);
  half half_rootn(half, int);


  double sqrt(double);
  float sqrt(float);
  half sqrt(half);
  float sqrtf(float);
  half half_sqrt(half);
  int8_t sqrt(int8_t);
  uint8_t sqrt(uint8_t);
  int16_t sqrt(int16_t);
  uint16_t sqrt(uint16_t);
  int32_t sqrt(int32_t);
  uint32_t sqrt(uint32_t);
# 858 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h"
  double recip(double);
  float recip(float);
  half recip(half);
  float recipf(float);
  half half_recip(half);
  int8_t recip(int8_t);
  uint8_t recip(uint8_t);
  int16_t recip(int16_t);
  uint16_t recip(uint16_t);
  int32_t recip(int32_t);
  uint32_t recip(uint32_t);


  double rsqrt(double);
  float rsqrt(float);
  half rsqrt(half);
  float rsqrtf(float);
  half half_rsqrt(half);
  int8_t rsqrt(int8_t);
  uint8_t rsqrt(uint8_t);
  int16_t rsqrt(int16_t);
  uint16_t rsqrt(uint16_t);
  int32_t rsqrt(int32_t);
  uint32_t rsqrt(uint32_t);


  double cbrt(double);
  float cbrt(float);
  half cbrt(half);
  float cbrtf(float);
  half half_cbrt(half);


  double hypot(double, double);
  float hypot(float, float);
  half hypot(half, half);
  float hypotf(float, float);
  half half_hypot(half, half);


  double erf(double);
  float erf(float);
  half erf(half);
  float erff(float);
  half half_erf(half);
  int8_t erf(int8_t);
  uint8_t erf(uint8_t);
  int16_t erf(int16_t);
  uint16_t erf(uint16_t);
  int32_t erf(int32_t);
  uint32_t erf(uint32_t);


  double erfc(double);
  float erfc(float);
  half erfc(half);
  float erfcf(float);
  half half_erfc(half);
  int8_t erfc(int8_t);
  uint8_t erfc(uint8_t);
  int16_t erfc(int16_t);
  uint16_t erfc(uint16_t);
  int32_t erfc(int32_t);
  uint32_t erfc(uint32_t);


  double lgamma(double);
  float lgamma(float);
  half lgamma(half);
  float lgammaf(float);
  half half_lgamma(half);
  int8_t lgamma(int8_t);
  uint8_t lgamma(uint8_t);
  int16_t lgamma(int16_t);
  uint16_t lgamma(uint16_t);
  int32_t lgamma(int32_t);
  uint32_t lgamma(uint32_t);


  double lgamma_r(double, int*);
  float lgamma_r(float, int*);
  half lgamma_r(half, int*);
  float lgamma_rf(float, int*);
  half half_lgamma_r(half, int*);
  int8_t lgamma_r(int8_t);
  uint8_t lgamma_r(uint8_t);
  int16_t lgamma_r(int16_t);
  uint16_t lgamma_r(uint16_t);
  int32_t lgamma_r(int32_t);
  uint32_t lgamma_r(uint32_t);


  double tgamma(double);
  float tgamma(float);
  half tgamma(half);
  float tgammaf(float);
  half half_tgamma(half);
  int8_t tgamma(int8_t);
  uint8_t tgamma(uint8_t);
  int16_t tgamma(int16_t);
  uint16_t tgamma(uint16_t);
  int32_t tgamma(int32_t);
  uint32_t tgamma(uint32_t);

  double tgamma_p_reduce(double);
  float tgamma_p_reduce(float);
  float tgammaf_p_reduce(float);


  double fmod(double, double);
  float fmod(float, float);
  half fmod(half, half);
  float fmodf(float, float);
  half half_fmod(half, half);


  double remainder(double, double);
  float remainder(float, float);
  half remainder(half, half);
  float remainderf(float, float);
  half half_remainder(half, half);


  double remquo(double, double, int*);
  float remquo(float, float, int*);
  half remquo(half, half, int*);
  float remquof(float, float, int*);
  half half_remquo(half, half, int*);


  double divide(double, double);
  float divide(float, float);
  half divide(half, half);
  float dividef(float, float);
  half half_divide(half, half);


  double nextafter(double, double);
  float nextafter(float, float);
  half nextafter(half, half);
  float nextafterf(float, float);
  half half_nextafter(half, half);


  double tanh(double);
  float tanh(float);
  half tanh(half);
  float tanhf(float);
  half half_tanh(half);


  double atanh(double);
  float atanh(float);
  half atanh(half);
  float atanhf(float);
  half half_atanh(half);


  double asinh(double);
  float asinh(float);
  half asinh(half);
  float asinhf(float);
  half half_asinh(half);


  double acosh(double);
  float acosh(float);
  half acosh(half);
  float acoshf(float);
  half half_acosh(half);


  double asin(double);
  float asin(float);
  half asin(half);
  float asinf(float);
  half half_asin(half);


  double acos(double);
  float acos(float);
  half acos(half);
  float acosf(float);
  half half_acos(half);


  double asinpi(double);
  float asinpi(float);
  half asinpi(half);
  float asinpif(float);
  half half_asinpi(half);


  double acospi(double);
  float acospi(float);
  half acospi(half);
  float acospif(float);
  half half_acospi(half);


  double atanpi(double);
  float atanpi(float);
  half atanpi(half);
  float atanpif(float);
  half half_atanpi(half);
}


# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hotbm_apfixed.h" 1
# 43 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hotbm_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 44 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hotbm_apfixed.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_defines.h" 1
# 40 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_defines.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 41 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_defines.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/hls_version.h" 1
# 42 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_defines.h" 2
# 109 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_defines.h"
template<int M, int E>
struct float_struct {
    ap_uint<M> mant;
    ap_uint<E> exp;
    ap_uint<1> sign;
};




template<int M, int E>
struct float_struct2 {
    ap_int<M> mant;
    ap_uint<E> exp;
};
# 45 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hotbm_apfixed.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h" 1
# 38 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 1 3
# 41 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
# 158 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
namespace std
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 382 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -9223372036854775807L - 1; }

      static constexpr long
      max() noexcept { return 9223372036854775807L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 9223372036854775807L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1570 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1593 "D:/xilinx/Vitis_HLS/2022.2/tps/mingw/8.3.0/win64.o/nt\\lib\\gcc\\x86_64-w64-mingw32\\8.3.0\\include\\c++\\limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435e-38F; }

      static constexpr float
      max() noexcept { return 3.40282347e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282347e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209290e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return 2.2250738585072014e-308; }

      static constexpr double
      max() noexcept { return 1.7976931348623157e+308; }


      static constexpr double
      lowest() noexcept { return -1.7976931348623157e+308; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return 2.2204460492503131e-16; }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return 4.9406564584124654e-324; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 2.2250738585072014e-308L; }

      static constexpr long double
      max() noexcept { return 1.7976931348623157e+308L; }


      static constexpr long double
      lowest() noexcept { return -1.7976931348623157e+308L; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 2.2204460492503131e-16L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 4.9406564584124654e-324L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 39 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h" 2
# 69 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
namespace hls {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hls::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


namespace hlstmp {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hlstmp::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


static inline
const
uint32_t pow2(uint32_t e)
{
    switch(e) {
        case 0: return 1; break;
        case 1: return 2; break;
        case 2: return 4; break;
        case 3: return 8; break;
        case 4: return 16; break;
        case 5: return 32; break;
        case 6: return 64; break;
        case 7: return 128; break;
        case 8: return 256; break;
        case 9: return 512; break;
        case 10: return 1024; break;
        case 11: return 2048; break;
        default: return 0;
    }
}

template<typename T>


__attribute__((hls_preserve))


T reg(T d)
{
#pragma HLS PIPELINE II=1
#pragma HLS LATENCY min=1 max=1
#pragma HLS INLINE off
 return d;
}
# 271 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
static inline
float to_float(float v)
{
    return v;
}

template<int _W, int _I>
float to_float(ap_fixed<_W, _I> v)
{
    return v.to_float();
}
# 290 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
template <typename T>
class fp_struct
{
};

union single_cast {
    float f;
    uint32_t i;
};

template <>
class fp_struct<float>
{
public:
    const static int EXP_INFNAN = 255;
    const static int EXP_BIAS = 127;
    const static int EXP_BITS = 8;
    const static int SIG_BITS = 23;
    const static int BITS = 32;

    fp_struct() {
    }
    fp_struct(float f) {


        union single_cast dc;
        dc.f = f;
        ap_uint<32> data = dc.i;





        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(ap_uint<32> data) {
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(uint32_t i) {
        ap_uint<32> data = i;
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    inline ap_uint<32> data() const {
        ap_uint<32> t;
        t[31] = sign[0];
        t(30,23) = exp(7,0);
        t(22,0) = sig(22,0);
        return t;
    }
    inline int expv() const {
        return exp-127;
    }
    inline int32_t to_int() const {
        return data().to_int();
    }
    inline float to_float() const {


        union single_cast ret;
        ret.i = data().to_uint();
        return ret.f;







    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline float to_ieee() const {
        return to_float();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static float infinity() {
        fp_struct<float> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static float minus_infinity() {
        fp_struct<float> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint32_t inttype;
    typedef ap_uint<32> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 420 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castSingle(
    float din,
    fp_struct<float> &dout)
{
    fp_struct<float> t(din);
    dout = t;
}

static inline
float
castSingle(
    fp_struct<float> din)
{
    return din.to_float();
}

static inline
void
dumpSingle(
    float da,
    fp_struct<float> ds)
{
# 457 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}







union double_cast {
    double d;
    uint64_t i;
};

template <>
class fp_struct<double>
{
public:
    const static int EXP_INFNAN = 2047;
    const static int EXP_BIAS = 1023;
    const static int EXP_BITS = 11;
    const static int SIG_BITS = 52;
    const static int BITS = 64;

    fp_struct() {
    }
    fp_struct(double f) {
        union double_cast dc;
        dc.d = f;
        ap_uint<64> data = dc.i;
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(ap_uint<64> data) {
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(uint64_t i) {
        ap_uint<64> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<64> data() const {
        ap_uint<64> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int64_t to_int() const {
        return data().to_int64();
    }
    inline int expv() const {
        return exp-1023;
    }
    inline ap_uint<20> sig_msb() const {
        return sig(51,32);
    }
    inline ap_uint<32> sig_lsb() const {
        return sig(31,0);
    }
    inline double to_double() const {
        union double_cast ret;
        ret.i = data().to_uint64();
        return ret.d;
    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline double to_ieee() const {
        return to_double();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static double infinity() {
        fp_struct<double> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static double minus_infinity() {
        fp_struct<double> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint64_t inttype;
    typedef ap_uint<64> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 581 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castDouble(
    double din,
    fp_struct<double> &dout)
{
    fp_struct<double> t(din);
    dout = t;
}

static inline
double
castDouble(
    fp_struct<double> din)
{
    return din.to_double();
}

static inline
void
dumpDouble(
    double da,
    fp_struct<double> ds)
{
# 618 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}
# 631 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
union half_cast {
    half d;
    uint16_t i;
};


template <>
class fp_struct<half>
{
public:
    const static int EXP_INFNAN = 31;
    const static int EXP_BIAS = 15;
    const static int EXP_BITS = 5;
    const static int SIG_BITS = 10;
    const static int BITS = 16;

    fp_struct() {
    }
    fp_struct(half f) {

        union half_cast dc;
        dc.d = f;
        ap_uint<16> data = dc.i;



        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(ap_uint<16> data) {
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(uint16_t i) {
        ap_uint<16> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<16> data() const {
        ap_uint<16> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int expv() const {
        return exp-EXP_BIAS;
    }
    inline int16_t to_int() const {
        return uint16_t(data().to_int());
    }
    inline half to_half() const {

        union half_cast ret;
        ret.i = data().to_uint64();
        return ret.d;





    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline half to_ieee() const {
        return to_half();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static half infinity() {
        fp_struct<half> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static half minus_infinity() {
        fp_struct<half> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint16_t inttype;
    typedef ap_uint<16> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};
# 749 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
static inline
void
castHalf(
    half din,
    fp_struct<half> &dout)
{
    fp_struct<half> t(din);
    dout = t;
}

static inline
half
castHalf(
    fp_struct<half> din)
{
    return din.to_half();
}

static inline
void
dumpHalf(
    half da,
    fp_struct<half> ds)
{
# 786 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
   (void)(da);
   (void)(ds);

}
# 804 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Base, unsigned int _Num >
class Power
{
public:
    static const unsigned int Value = _Base * Power< _Base, _Num - 1 >::Value;
};

template < unsigned int _Base >
class Power< _Base, 0 >
{
public:
    static const unsigned int Value = 1;
};
# 826 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class BitWidth
{
public:
    static const unsigned int Value = 1 + BitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class BitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 2;
};
# 848 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class UnsignedBitWidth
{
public:
    static const unsigned int Value = 1 + UnsignedBitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class UnsignedBitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 1;
};
# 869 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
template < typename T >
class Type_BitWidth
{
public:
    static const unsigned int Value = 8*sizeof(T);
};

template <int W >
class Type_BitWidth< ap_uint<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W >
class Type_BitWidth< ap_int<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_ufixed<W, I> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_fixed<W, I> >
{
public:
    static const unsigned int Value = W;
};
# 917 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I=_Num-1>
class Table : public Table<_T, _Num, _I-1>
{
public:
    typedef typename _T::TableType TableType;
    static const typename _T::TableType dummy;
    static const int size = _Num;

};

template <typename _T, int _Num>
class Table<_T, _Num, 0>
{
public:
    static const typename _T::TableType dummy;
    static typename _T::TableType array[_Num];
};
# 944 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I>
const typename _T::TableType Table<_T, _Num, _I>::dummy
    = Table<_T, _Num, 0>::array[_I] = _T::apply(_I,_Num) + 0*Table<_T, _Num, _I-1>::dummy;

template <typename _T, int _Num>
const typename _T::TableType Table<_T, _Num, 0>::dummy
    = Table<_T, _Num, 0>::array[0] = _T::apply(0,_Num);




template <typename _T, int _Num>
typename _T::TableType Table<_T, _Num, 0>::array[_Num];



template <class T>
struct is_fptype { static const bool value = false; };
template <> struct is_fptype<float> { static const bool value = true; };
template <> struct is_fptype<double> { static const bool value = true; };
template <> struct is_fptype<half> { static const bool value = true; };

template <class T>
struct is_integraltype { static const bool value = false; };
template <> struct is_integraltype<int> { static const bool value = true; };
template <> struct is_integraltype<unsigned int> { static const bool value = true; };
template <> struct is_integraltype<char> { static const bool value = true; };
template <> struct is_integraltype<signed char> { static const bool value = true; };
template <> struct is_integraltype<unsigned char> { static const bool value = true; };
template <> struct is_integraltype<short> { static const bool value = true; };
template <> struct is_integraltype<unsigned short> { static const bool value = true; };
template <> struct is_integraltype<long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long> { static const bool value = true; };
template <> struct is_integraltype<long long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long long> { static const bool value = true; };
template <int W> struct is_integraltype<ap_int<W> > { static const bool value = true; };
template <int W> struct is_integraltype<ap_uint<W> > { static const bool value = true; };

template <class T>
struct is_fixedtype { static const bool value = false; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_fixed<W,I,Q,O> > { static const bool value = true; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_ufixed<W,I,Q,O> > { static const bool value = true; };

namespace hls {
    template<bool B, class T = void>
    struct enable_if {};

    template<class T>
    struct enable_if<true, T> { typedef T type; };
    template<typename T, T _v>
    struct integral_constant
    {
        static const T value = _v;
        typedef T value_type;
        typedef integral_constant<T,_v> type;
        operator value_type() { return value; }
    };

    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;

    template<typename T1, typename T2>
    struct is_same;

    template<typename T1, typename T2>
    struct is_same : public false_type { };

    template<typename T1>
    struct is_same<T1,T1> : public true_type { };

    template<typename T>
    struct is_arithmetic : public integral_constant<bool, (is_integraltype<T>::value || is_fptype<T>::value)> { };
}

template<typename T1, typename T2>
struct enable_or { static const bool value = T1::value || T2::value; };

template<typename T1, typename T2>
struct enable_and { static const bool value = T1::value && T2::value; };



template<typename T, bool = is_integraltype<T>::value>
struct __promote { typedef double type; };

template<typename T>
struct __promote<T, false> { };

template<>
struct __promote<double> { typedef double type; };

template<>
struct __promote<float> { typedef float type; };

template<>
struct __promote<half> { typedef half type; };
# 46 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hotbm_apfixed.h" 2






namespace hotbm_apfixed
{

  namespace first_order_fixed_16{
 extern const ap_fixed<19,2> sin_cos_K0[256];
 extern const ap_fixed<11,2> sin_cos_K1[256];
  };

  namespace second_order_float{
 extern const ap_fixed<29,0> cos_K0[128];
 extern const ap_fixed<23,1> cos_K1[128];
 extern const ap_fixed<15,0> cos_K2[128];
 extern const ap_fixed<30,1> sin_K0[128];
 extern const ap_fixed<21,-1> sin_K1[128];
 extern const ap_fixed<13,-2> sin_K2[128];
 extern const ap_ufixed<30,1> sin_cos_K0[256];
 extern const ap_fixed<23,1> sin_cos_K1[256];
 extern const ap_fixed<15,0> sin_cos_K2[256];
  };

  namespace fourth_order_double{
 extern const ap_fixed<59,0> cos_K0[128];
 extern const ap_fixed<53,1> cos_K1[128];
 extern const ap_fixed<45,0> cos_K2[128];
 extern const ap_fixed<35,-3> cos_K3[128];
 extern const ap_fixed<27,-4> cos_K4[128];
 extern const ap_fixed<60,1> sin_K0[128];
 extern const ap_fixed<51,-1> sin_K1[128];
 extern const ap_fixed<43,-2> sin_K2[128];
 extern const ap_fixed<33,-5> sin_K3[128];
 extern const ap_fixed<24,-7> sin_K4[128];
 extern const ap_fixed<59,1> sin_cos_K0[256];
 extern const ap_fixed<52,1> sin_cos_K1[256];
 extern const ap_fixed<44,0> sin_cos_K2[256];
 extern const ap_fixed<34,-3> sin_cos_K3[256];
 extern const ap_fixed<26,-4> sin_cos_K4[256];
  };

  template<class T>
  struct value_list{
  };

  template<>
  struct value_list<double>{
    typedef double T;
 static const int g = 10;
 static const int p1 = 61;
 static const int alpha = 7;

 static const int beta1 = 0;

 static const int beta2 = alpha;

    static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
    static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

    template <int Wx, int Wr>
    static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
              ap_uint<3> &k,
              ap_ufixed<Wx, 0> &x,
              ap_ufixed<Wr, 0> &Mx,
              ap_int<fp_struct<double>::EXP_BITS> &Ex){

   const bool swap_table[8] = {0,1,1,0,0,1,1,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_cos_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_cos_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_cos_K2 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_cos_K3 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_cos_K4 type=ROM_1P impl=LUTRAM

 (void)(Ex);
   ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
   ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
   ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

   bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
   A[alpha] = sin_basis;

   ap_fixed<Wx, 1> t1 = fourth_order_double::sin_cos_K0[A];
   ap_fixed<Wx, 1> t2 = B*fourth_order_double::sin_cos_K1[A];
   ap_fixed<Wx, 1> t3 = B_squared*fourth_order_double::sin_cos_K2[A];
   ap_fixed<Wx, 1> t4 = B_third_power*fourth_order_double::sin_cos_K3[A];
   ap_fixed<Wx, 1> t5 = B_fourth_power*fourth_order_double::sin_cos_K4[A];
   ap_ufixed<Wx, 1> result = Mx*(t1+t2+t3+t4+t5);
   return result;
    }

    template <int Wx, int Wr>
    static void sincos_approximation(ap_uint<3> &k,
          ap_ufixed<Wx, 0> &x,
          ap_ufixed<Wr, 0> Mx,
          ap_int<fp_struct<double>::EXP_BITS> Ex,
          ap_ufixed<Wr, 1> &sin_result,
          ap_ufixed<Wr, 1> &cos_result
          ) {
#pragma HLS BIND_STORAGE variable=fourth_order_double::cos_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::cos_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::cos_K2 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::cos_K3 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::cos_K4 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_K2 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_K3 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=fourth_order_double::sin_K4 type=ROM_1P impl=LUTRAM

 (void)(k);
          (void)(Ex);
   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
         x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
   ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
   ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

   ap_fixed<Wx, 1> cos_t1 = fourth_order_double::cos_K0[A];
   ap_fixed<Wx, 1> cos_t2 = B*fourth_order_double::cos_K1[A];
   ap_fixed<Wx, 1> cos_t3 = B_squared*fourth_order_double::cos_K2[A];
   ap_fixed<Wx, 1> cos_t4 = B_third_power*fourth_order_double::cos_K3[A];
   ap_fixed<Wx, 1> cos_t5 = B_fourth_power*fourth_order_double::cos_K4[A];
   cos_result = 1 - (cos_t1 + cos_t2 + cos_t3 + cos_t4 + cos_t5);

   ap_fixed<Wx, 1> sin_t1 = fourth_order_double::sin_K0[A];
   ap_fixed<Wx, 1> sin_t2 = B*fourth_order_double::sin_K1[A];
   ap_fixed<Wx, 1> sin_t3 = B_squared*fourth_order_double::sin_K2[A];
   ap_fixed<Wx, 1> sin_t4 = B_third_power*fourth_order_double::sin_K3[A];
   ap_fixed<Wx, 1> sin_t5 = B_fourth_power*fourth_order_double::sin_K4[A];
   sin_result = Mx * (sin_t1 + sin_t2 + sin_t3 + sin_t4 + sin_t5);
    }
  };

  template<>
  struct value_list<float> {
 typedef float T;
 static const int g = 5;
 static const int p1 = 29;
 static const int alpha = 7;
 static const int beta1 = 0;
 static const int beta2 = 7;

 static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
 static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

 template <int Wx, int Wr>
 static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
              ap_uint<3> &k,
              ap_ufixed<Wx, 0> &x,
              ap_ufixed<Wr, 0> &Mx,
              ap_int<fp_struct<float>::EXP_BITS> &Ex){

   const bool swap_table[8] = {0,1,1,0,0,1,1,0};

#pragma HLS array_partition variable=swap_table complete
#pragma HLS BIND_STORAGE variable=second_order_float::sin_cos_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::sin_cos_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::sin_cos_K2 type=ROM_1P impl=LUTRAM

 (void)(Ex);
   ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;

   bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
   A[alpha] = sin_basis;

   ap_fixed<Wx, 1> t1 = second_order_float::sin_cos_K0[A];
   ap_fixed<Wx, 1> t2 = B*second_order_float::sin_cos_K1[A];
   ap_fixed<Wx, 1> t3 = B_squared*second_order_float::sin_cos_K2[A];
   ap_ufixed<Wx, 1> result = (t1+t2+t3) * Mx;

   return result;
 }

 template <int Wx, int Wr>
 static void sincos_approximation(ap_uint<3> &k,
          ap_ufixed<Wx, 0> &x,
          ap_ufixed<Wr, 0> &Mx,
          ap_int<fp_struct<float>::EXP_BITS> &Ex,
          ap_ufixed<Wr, 1> &sin_result,
          ap_ufixed<Wr, 1> &cos_result
          ) {
#pragma HLS BIND_STORAGE variable=second_order_float::cos_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::cos_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::cos_K2 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::sin_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::sin_K1 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=second_order_float::sin_K2 type=ROM_1P impl=LUTRAM

 (void)(k);
          (void)(Ex);
   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
         x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;


   ap_ufixed<Wx, 1> cos_t1 = second_order_float::cos_K0[A];
   ap_ufixed<Wx, 1> cos_t2 = B*second_order_float::cos_K1[A];
   ap_ufixed<Wx, 1> cos_t3 = B_squared*second_order_float::cos_K2[A];
   cos_result = 1 - (cos_t1 + cos_t2 + cos_t3);

   ap_fixed<Wx, 1> sin_t1 = second_order_float::sin_K0[A];
   ap_fixed<Wx, 1> sin_t2 = B*second_order_float::sin_K1[A];
   ap_fixed<Wx, 1> sin_t3 = B_squared*second_order_float::sin_K2[A];
   sin_result = Mx * (sin_t1 + sin_t2 + sin_t3);
 }
  };

  struct sin_cos_fixed_16 {

 typedef half T;
 static const int g = 3;
 static const int p1 = 12;
 static const int alpha = 8;
 static const int beta1 = 4;

 template <int W_dout>
 static ap_ufixed<W_dout, 1> sin_or_cos_approximation(bool do_cos,
               ap_uint<2> &k,
               ap_ufixed<W_dout, 0> &x){

#pragma HLS BIND_STORAGE variable=first_order_fixed_16::sin_cos_K0 type=ROM_1P impl=LUTRAM
#pragma HLS BIND_STORAGE variable=first_order_fixed_16::sin_cos_K1 type=ROM_1P impl=LUTRAM
 (void)(do_cos);
          (void)(k);

   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);

   const int BW = (W_dout-alpha-beta1)>1 ? W_dout-alpha-beta1 : 2;
   ap_ufixed<BW, -alpha> B = x;

   ap_fixed<W_dout, 1> t1 = first_order_fixed_16::sin_cos_K0[A];
   ap_fixed<W_dout, 1> t2 = B*first_order_fixed_16::sin_cos_K1[A];
   ap_ufixed<W_dout, 1> result = (t1+t2);

   return result;
 };
  };

  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<(W > 16) && (W <= 32), bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 3;

 const bool swap_table[8] = {0,1,1,0,0,1,1,0};
 const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
 const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};

#pragma HLS array_partition variable=swap_table complete
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 (void)(dummy);
 ap_uint<3> k;
 ap_ufixed<WO+1+g, 0> x;
 ap_ufixed<WO+1+g, 0> Mx;
 ap_int<fp_struct<float>::EXP_BITS> Ex = 0;

 int exactly_pi_over_4 = 0;
 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*4;
   x = din*4;
   ap_ufixed<W, 1> Mx_bits_extended = din*4;



   exactly_pi_over_4 = (Mx_bits_extended == 1);
 } else {
   ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }




 if(k[0] == 1) {
   x = 1-x;
 }
 Mx = x;

 bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
 if(cos_basis) {


   Mx = ap_ufixed<value_list<float>::W_dout, 0, AP_RND, AP_SAT>(1);
   Ex = 0;
 }

 ap_ufixed<WO+1+g, 1> result = value_list<float>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

 if(exactly_pi_over_4) {
   result = 0.7071067811865475244008443;
 }

 ap_uint<4> index = k;
 index[3] = is_negative;

 if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
   return -result;
 } else {
   return result;
 }
  }


  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<(W > 32) && (W <= 64), bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 3;

 const bool swap_table[8] = {0,1,1,0,0,1,1,0};
 const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
 const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 (void)(dummy);
 ap_uint<3> k;
 ap_ufixed<WO+1+g, 0> x;
 ap_ufixed<WO+1+g, 0> Mx;
 ap_int<fp_struct<double>::EXP_BITS> Ex = 0;

 int exactly_pi_over_4 = 0;
 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*4;
   x = din*4;
   ap_ufixed<W, 1> Mx_bits_extended = din*4;



   exactly_pi_over_4 = (Mx_bits_extended == 1);
 } else {
   ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }




 if(k[0] == 1) {
   x = 1-x;
 }
 Mx = x;

 bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
 if(cos_basis) {


   Mx = ap_ufixed<value_list<double>::W_dout, 0, AP_RND, AP_SAT>(1);
   Ex = 0;
 }

 ap_ufixed<WO+1+g, 1> result = value_list<double>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

 if(exactly_pi_over_4) {
   result = 0.7071067811865475244008443;
 }

 ap_uint<4> index = k;
 index[3] = is_negative;

 if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
   return -result;
 } else {
   return result;
 }
  };


  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<W <= 16, bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 4;

 const bool neg_sin_table[8] = {0,0,1,1, 1,1,0,0};
 const bool neg_cos_table[8] = {0,1,1,0, 0,1,1,0};
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 (void)(dummy);
 ap_uint<2> k;
 ap_ufixed<WO+1+g, 0> x;

 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*2;
   x = din*2;
   ap_ufixed<W, 1> Mx_bits_extended = din*2;
 }
 else {
   ap_ufixed<WO+1+g+2, 2> Wx = din * ap_ufixed<W+1+g,2>(2/3.14159265358979323846);
   k = Wx;
   x = Wx;
 }

 bool is_special_case = false;

 if((k[0] == 1) ^ !do_cos) {
   ap_ufixed<WO+1+g+1, 1> Wx = 1-x;
   x = Wx;
   is_special_case = (Wx[Wx.wl()-1] == 1);
 }

 ap_ufixed<WO+1+g, 1> result = sin_cos_fixed_16::sin_or_cos_approximation(do_cos,k,x);

 if(is_special_case) {
   ap_uint<3> index = k;
   index[2] = do_cos;
   const bool special_case_table[8] = {0,1,0,1,1,0,1,0};
   result(result.wl()-2,0) = 0;
   result[result.wl()-1] = special_case_table[index];
 }

 {
   ap_uint<3> index = k;
   index[2] = is_negative;

   if(do_cos ? neg_cos_table[index] : neg_sin_table[index]) {
  return -result;
   } else {
  return result;
   }
 }
  };

};
# 1066 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cordic_apfixed.h" 1
# 41 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cordic_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 42 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cordic_apfixed.h" 2





namespace cordic_apfixed {

  extern const ap_ufixed<128,2> circ_table_arctan_128[128];
  extern const int hyperb_table_tau_128[128];
  extern const ap_ufixed<128,4> hyperb_table_arctanh_128[128];





  template<int W, int I, int Wo>
  void circ_range_redux( ap_ufixed<W,I> x,
                         ap_uint<2> &k,
                         ap_ufixed<Wo,1> &r) {

    ap_ufixed<(Wo+I),0> inv_pi2("0x0.A2F9836E4E43FC715BBF");
    ap_ufixed<Wo+1,1> pi2("1.5707963267948966192313216916397514420985846996876");
    ap_ufixed<Wo+I,I> prod = x * inv_pi2;
    ap_uint<I> kint = prod;

    k = kint;
    r = x - kint * pi2;
  };






  template<int W, int I, int MODE>
  void cordic_circ_apfixed( ap_fixed<W,I> &x,
                            ap_fixed<W,I> &y,
                            ap_fixed<W,I> &z) {

    const int Nmax = W;

    ap_fixed<W,I> tx, ty, tz;
    ap_fixed<W,I> x_s, y_s, z_s;
    ap_uint<1> d;

    VITIS_LOOP_87_1: for (int n=0; n<Nmax; n++){
#pragma HLS pipeline

 if(MODE == 1) {
        d = ~y[W-1];
      }
      else {
        d = z[W-1];
      }

      x_s = x >> n;
      y_s = y >> n;
      z_s = circ_table_arctan_128[n];

      if(d){
        tx = x + y_s;
        ty = y - x_s;
        tz = z + z_s;
      }
      else{
        tx = x - y_s;
        ty = y + x_s;
        tz = z - z_s;
      }

      x = tx;
      y = ty;
      z = tz;
# 126 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  };







  template<int W, int I, int MODE, int INTYPE>
  void doublecordic_apfixed( ap_fixed<W,I> &x,
                             ap_fixed<W,I> &y,
                             ap_fixed<W,I> &z,
                             ap_fixed<W,I> &t) {

    const int Nmax = W - I + 1;

    VITIS_LOOP_143_1: for (int n=0; n<Nmax; n++){

      if(INTYPE==64){
#pragma HLS pipeline II=5
 }
      else if(INTYPE==32){
#pragma HLS pipeline II=3
 }
      else if(INTYPE==16){
#pragma HLS pipeline II=1
 }
      else{
#pragma HLS pipeline II=4
 }

      ap_uint<1> d;
      if(MODE == 0) {
        if(y<=t){
          d = x[W-1];
        }
        else{
          d = ~x[W-1];
        }
      }
      else {
        if(x>=t){
          d = y[W-1];
        }
        else{
          d = ~y[W-1];
        }
      }

      ap_fixed<W,I> x_s = x >> (n-1);
      ap_fixed<W,I> y_s = y >> (n-1);
      ap_fixed<W,I> x_s2 = x_s >> (n+1);
      ap_fixed<W,I> y_s2 = y_s >> (n+1);

      x = x - x_s2;
      y = y - y_s2;
      if(d){
        x = x + y_s;
        y = y - x_s;
      }
      else{
        x = x - y_s;
        y = y + x_s;
      }


      ap_fixed<W,I> t_s;
      int n2 = (n << 1);
      if(n2<W){
        t_s = (t >> n2);
        t = t + t_s;
      }


      ap_fixed<W,I> ca = circ_table_arctan_128[n];
      ap_fixed<W,I> z_s = (ca << 1);
      ap_fixed<W,I> tz;
      if(d){
        tz = z - z_s;
      }
      else{
        tz = z + z_s;
      }
      z = tz;
# 221 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  };



  template<int W, int I>
  void generic_sincos(ap_fixed<W,I> in,
                      ap_fixed<W-I+2,2> & outsin, ap_fixed<W-I+2,2> & outcos){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_ufixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    const int Fr = (W - I) + I + 1;
    ap_uint<2> k;
    ap_ufixed<Fr,1> r;
    circ_range_redux(inabs, k, r);

    ap_fixed<W+2,3> x, y, z;

    const ap_fixed<W+2,3> K1("0x0.9B74EDA8435E47F277F7");
    x = K1;
    y = 0;

    if(k==1 or k==3){
      ap_ufixed<Fr,1> pi2("0x1.921FB54442D1846");

      z = pi2 - r;
    }
    else{
      z = r;
    }







    cordic_circ_apfixed<W+2,3,0>(x,y,z);







    if(k==0){
      outsin = y;
      outcos = x;
    }
    else if(k==1){
      outsin = y;
      outcos = -x;
    }
    else if(k==2){
      outsin = -y;
      outcos = -x;
    }
    else{
      outsin = -y;
      outcos = x;
    }

    if(sign0==0)
      outsin = -outsin;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_tan(ap_fixed<W,I> x){

    const int Ix = I;
    const int Fx = (((W-I)>(I-1)) ? (W-I): (I-1)) + I;
    const int Wx = I + Fx;

    ap_fixed<Wx,Ix> xs = x;

    ap_fixed<Wx-Ix+2,2> outsin;
    ap_fixed<Wx-Ix+2,2> outcos;
    generic_sincos(xs, outsin, outcos);

    ap_fixed<W,I> out = outsin / outcos;


    if(I==1){
      if(out[W-1]==1){
        out[W-1] = 0;
        VITIS_LOOP_315_1: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 out[i] = 1;
        }
      }
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,I> generic_tan(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_tan(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_tan(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_tan(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_tan(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_tan(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };
# 366 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cordic_apfixed.h"
  template<int W, int I, int Wo>
  void circ_range_redux_pi( ap_ufixed<W,I> x,
                             ap_uint<2> &k,
                             ap_ufixed<Wo,1> &r) {

    ap_ufixed<Wo+1,1> pi2("1.5707963267948966192313216916397514420985846996876");
    ap_ufixed<W+1,I+1> prod = x << 1;
    ap_uint<I+1> kint = prod;

    k = kint;
    r = (prod - kint) * pi2;
  };

  template<int W, int I>
  void generic_sincospi(ap_fixed<W,I> in,
                      ap_fixed<W-I+2,2> & outsin, ap_fixed<W-I+2,2> & outcos){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_ufixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    const int Fr = (W - I) + I + 1;
    ap_uint<2> k;
    ap_ufixed<Fr,1> r;
    circ_range_redux_pi(inabs, k, r);

    ap_fixed<W+2,3> x, y, z;

    const ap_fixed<W+2,3> K1("0x0.9B74EDA8435E47F277F7");
    x = K1;
    y = 0;

    if(k==1 or k==3){
      ap_ufixed<Fr,1> pi2("0x1.921FB54442D1846");
      z = pi2 - r;
    }
    else{
      z = r;
    }







    cordic_circ_apfixed<W+2,3,0>(x,y,z);







    if(k==0){
      outsin = y;
      outcos = x;
    }
    else if(k==1){
      outsin = y;
      outcos = -x;
    }
    else if(k==2){
      outsin = -y;
      outcos = -x;
    }
    else{
      outsin = -y;
      outcos = x;
    }

    if(sign0==0)
      outsin = -outsin;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_tanpi(ap_fixed<W,I> x){

    const int Ix = I;
    const int Fx = (((W-I)>(I-1)) ? (W-I): (I-1)) + I;
    const int Wx = I + Fx;

    ap_fixed<Wx,Ix> xs = x;

    ap_fixed<Wx-Ix+2,2> outsin;
    ap_fixed<Wx-Ix+2,2> outcos;
    generic_sincospi(xs, outsin, outcos);

    ap_fixed<W,I> out;
    ap_int<1> bpoint=0;
    if(!outcos){
        bpoint = 1;
    }else{
        out = outsin / outcos;
    }




    if(I==1||bpoint){
      if( out[W-1]==1 ){
        out[W-1] = 0;
        VITIS_LOOP_475_1: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 out[i] = 1;
        }
      }
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,I> generic_tanpi(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_tanpi(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_tanpi(ap_int<I> in) {
    (void)(in);
    return ap_int<I>(0);
  };


  template<int I>
  ap_uint<I> generic_tanpi(ap_uint<I> in) {
    (void)(in);
    return ap_uint<I>(0);
  };


  template<int W, int I>
  ap_fixed<W,2> generic_atan(ap_fixed<W,I> in){

    ap_uint<1> sign0 = (in > 0) ? 1: 0;


    ap_fixed<W+1,I+1> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;


    ap_uint<1> sign1 = (inabs > 1) ? 1: 0;

    ap_fixed<W+2,3> x, y, z;
    if(sign1){
      x = 1;

      y = 1.0 / inabs.to_double();
      z = 0;
    }
    else{
      x = 1;
      y = inabs;
      z = 0;
    }
    cordic_circ_apfixed<W+2,3,1>(x,y,z);

    ap_fixed<W,2> out;
    if(sign1){
      const ap_fixed<W,2> pi2("0x1.921FB54442D1846");
      out = pi2 - z;
    }
    else{
      out = z;
    }


    if(sign0){
      return out;
    }
    else{
      return -out;
    }
  };


  template<int W, int I>
  ap_ufixed<W,2> generic_atan(ap_ufixed<W,I> in){
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,2> fout = generic_atan(fin);
    ap_ufixed<W,2> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<2> generic_atan(ap_int<I> in){
    if(in<-1)
      return ap_int<2>(-1);
    else if(in>1)
      return ap_int<2>(1);
    else
      return ap_int<2>(0);
  };


  template<int I>
  ap_uint<1> generic_atan(ap_uint<I> in){
    if(in>1)
      return ap_uint<1>(1);
    else
      return ap_uint<1>(0);
  };


  template<int W, int I>
  ap_fixed<W,3> generic_atan2(ap_fixed<W,I> in1,
                              ap_fixed<W,I> in2){

    const ap_fixed<W+1,3> pi("0x3.243F6A8885A308D3");
    const ap_fixed<W+2,3> pi2("0x1.921FB54442D1846");
    const ap_fixed<W+1,3> pi4("0x0.C90FDAA22168C23");
    const ap_fixed<W+1,3> pi3_("-0x2.5B2F8FE6643A469");

    ap_uint<2> signin1 = (in1 > 0) ? 2: (in1==0) ? 1: 0;
    ap_uint<2> signin2 = (in2 > 0) ? 2: (in2==0) ? 1: 0;

    ap_fixed<W,3> out;



    if(signin1==1 and signin2==2){
      out = 0;
      return out;
    }
    else if(signin1==1 and signin2==0){
      out = pi;
      return out;
    }
    else if(signin1==2 and signin2==1){
      out = pi2;
      return out;
    }
    else if(signin1==0 and signin2==1){
      out = -pi2;
      return out;
    }
    else if(in1==in2){
      if(signin1==2){
        out = pi4;
        return out;
      }
      else if(signin1==1){
        out = 0;
        return out;
      }
      else{
        out = pi3_;
        return out;
      }
    }



    ap_fixed<W+1,I+1> in1abs;
    if(signin1==0)
      in1abs = -in1;
    else
      in1abs = in1;

    ap_fixed<W+1,I+1> in2abs;
    if(signin2==0)
      in2abs = -in2;
    else
      in2abs = in2;

    ap_fixed<W+1,2> in1abs_sft;
    ap_fixed<W+1,2> in2abs_sft;
    VITIS_LOOP_655_1: for(int i=0;i<W+1;i++){
#pragma HLS UNROLL
 in1abs_sft[i] = in1abs[i];
    }
    VITIS_LOOP_659_2: for(int i=0;i<W+1;i++){
#pragma HLS UNROLL
 in2abs_sft[i] = in2abs[i];
    }

    ap_fixed<W+7,3> x, y, z;
    if(in1abs > in2abs){
      x = in1abs_sft;
      y = in2abs_sft;
      z = 0;
    }
    else{
      x = in2abs_sft;
      y = in1abs_sft;
      z = 0;
    }
    cordic_circ_apfixed<W+7,3,1>(x,y,z);

    if(in1abs > in2abs){
      z = pi2 - z;
    }

    if(signin2==0 and signin1==2){
      out = pi - z;
    }
    else if(signin2==0 and signin1==0){
      out = z - pi;
    }
    else if(signin2==2 and signin1==0){
      out = -z;
    }
    else{
      out = z;
    }

    return out;
  };


  template<int W, int I>
  ap_ufixed<W,3> generic_atan2(ap_ufixed<W,I> in1,
                               ap_ufixed<W,I> in2){
    ap_fixed<W+1,I+1> fin1 = in1;
    ap_fixed<W+1,I+1> fin2 = in2;
    ap_fixed<W+1,3> fout = generic_atan2(fin1, fin2);
    ap_ufixed<W,3> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  }


  template<int I>
  ap_int<3> generic_atan2(ap_int<I> in1,
                          ap_int<I> in2){
    ap_fixed<I+1,I+1> fin1 = in1;
    ap_fixed<I+1,I+1> fin2 = in2;
    ap_fixed<I+1,3> fout = generic_atan2(fin1, fin2);
    ap_int<3> out = fout;
    return out;
  }


  template<int I>
  ap_uint<2> generic_atan2(ap_uint<I> in1,
                           ap_uint<I> in2){
    ap_fixed<I+1,I+1> fin1 = in1;
    ap_fixed<I+1,I+1> fin2 = in2;
    ap_fixed<I+1,3> fout = generic_atan2(fin1, fin2);
    ap_uint<2> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  }





  template<int W, int I, int Wo>
  void hyperb_range_redux( ap_ufixed<W,I> x,
                           ap_uint<I+1> &k,
                           ap_ufixed<Wo,0> &r) {

    ap_ufixed<(Wo+I)+1,1> inv_ln2("0x1.71547652b82fe1777d0ffda0d23a7d11d6aef551cp0");
    ap_ufixed<Wo,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    ap_ufixed<Wo+(I+1),I+1> prod = x * inv_ln2;
    ap_ufixed<Wo,0> prod_dec = prod;
    k = prod;
    r = prod_dec * ln2;
  };






  template<int W, int I, int MODE>
  void cordic_hyperb_apfixed( ap_fixed<W,I> &x,
                              ap_fixed<W,I> &y,
                              ap_fixed<W,I> &z) {

    const int Nmax = W + 1;

    ap_fixed<W,I> tx, ty, tz;
    ap_fixed<W,I> x_s, y_s, z_s;
    ap_uint<1> d;

    VITIS_LOOP_769_1: for (int n=0; n<Nmax; n++){

      int k = hyperb_table_tau_128[n];

      if(MODE == 1) {
        d = ~y[W-1];
      }
      else {
        d = z[W-1];
      }

      x_s = x >> k;
      y_s = y >> k;
      z_s = hyperb_table_arctanh_128[k-1];

      if(d){
        tx = x - y_s;
        ty = y - x_s;
        tz = z + z_s;
      }
      else{
        tx = x + y_s;
        ty = y + x_s;
        tz = z - z_s;
      }

      x = tx;
      y = ty;
      z = tz;
# 806 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cordic_apfixed.h"
    }
  }


  template <int W, int I>
  void sinh_cosh_range_redux_cordic( ap_fixed<W,I> in,
                                     ap_fixed<W,I> &s_out,
                                     ap_fixed<W,I> &c_out){

    ap_uint<1> sign0 = in[W-1];

    ap_ufixed<W,I> inabs;
    if(sign0 == 0)
      inabs = in;
    else
      inabs = -in;

    const int Fr = (W - I) + I;

    if(in==0){
      s_out = 0;
      c_out = 1;
      return;
    }


    ap_uint<I+1> k;
    ap_ufixed<Fr,0> r;
    hyperb_range_redux(inabs, k, r);

    ap_fixed<Fr+2,2> x("1.20749706776307212887772");
    ap_fixed<Fr+2,2> y(0);
    ap_fixed<Fr+2,2> z(r);




    cordic_hyperb_apfixed<Fr+2,2,0>(x,y,z);



    ap_fixed<Fr+(I+2),I+2> er, e_r;
    er = x + y;
    e_r = x - y;



    er <<= (k-1);
    e_r >>= (k+1);



    ap_fixed<W+1,I+1> s_out_tmp = er - e_r;
    ap_fixed<W+1,I+1> c_out_tmp = er + e_r;




    if(s_out_tmp[W-1]==1){
      s_out_tmp[W-1] = 0;
      VITIS_LOOP_866_1: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 s_out_tmp[i] = 1;
      }
    }


    if(sign0 == 0){
      s_out = s_out_tmp;
    }
    else{
      s_out = -s_out_tmp;
    }




    if(c_out_tmp[W-1]==1){
      c_out[W-1] = 0;
      VITIS_LOOP_885_2: for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
 c_out[i] = 1;
      }
    }
    else{
      c_out = c_out_tmp;
    }
  };

    template<int W, int I>
    void tanh_range_redux_cordic(ap_fixed<W,I> in, ap_fixed<W,I> &tan_out) {

        ap_uint<1> sign0 = in[W-1];

        ap_ufixed<W,I> inabs;
        if(sign0 == 0)
            inabs = in;
        else
            inabs = -in;

        const int Fr = (W - I) + I;

        if(in==0){
            tan_out = 0;
            return;
        }

        ap_uint<I+1> k;
        ap_ufixed<Fr,0> r;
        hyperb_range_redux(inabs, k, r);

        ap_fixed<Fr+2,2> x("1.20749706776307212887772");
        ap_fixed<Fr+2,2> y(0);
        ap_fixed<Fr+2,2> z(r);

        cordic_hyperb_apfixed<Fr+2,2,0>(x,y,z);
        ap_fixed<Fr+(I+2),I+2> er, e_r;
        er = x + y;
        e_r = x - y;
        er <<= k;
        e_r >>= k;
        tan_out = (er/(er+e_r))*2 - 1;
    }

    template<int W, int I>
    ap_fixed<W,I> generic_tanh(ap_fixed<W,I> in) {
        ap_fixed<W,I> tan_out;
        tanh_range_redux_cordic(in, tan_out);
        return tan_out;
    }

    template<int W, int I>
    ap_ufixed<W,I> generic_tanh(ap_ufixed<W,I> in) {
        ap_fixed<W+1,I+1> fin = in;
        ap_fixed<W+1,I+1> fout = generic_tanh(fin);
        ap_ufixed<W,I> tan_out = fout;
        return tan_out;
    }

    template<int I>
    ap_int<I> generic_tanh(ap_int<I> in) {
        ap_fixed<I,I> fin = in;
        ap_fixed<I,I> fout = generic_tanh(fin);
        ap_int<I> tan_out = fout;
        return tan_out;
    }

    template<int I>
    ap_uint<I> generic_tanh(ap_uint<I> in) {
        ap_fixed<I+1,I+1> fin = in;
        ap_fixed<I+1,I+1> fout = generic_tanh(fin);
        ap_uint<I> tan_out = fout;
        return tan_out;
    }

  template<int W, int I>
  ap_fixed<W,I> generic_sinh(ap_fixed<W,I> in) {
    ap_fixed<W,I> s_out, c_out;
    sinh_cosh_range_redux_cordic(in,s_out,c_out);
    return s_out;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_sinh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_sinh(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_sinh(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_sinh(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_sinh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_sinh(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };


  template<int W, int I>
  ap_fixed<W, I> generic_cosh(ap_fixed<W,I> in) {
    ap_fixed<W,I> s_out, c_out;
    sinh_cosh_range_redux_cordic(in,s_out,c_out);
    return c_out;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_cosh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> fin = in;
    ap_fixed<W+1,I+1> fout = generic_cosh(fin);
    ap_ufixed<W,I> out = 0;
    if(fout[W]==0){
        out = fout;
    }
    return out;
  };


  template<int I>
  ap_int<I> generic_cosh(ap_int<I> in) {
    ap_fixed<I,I> fin = in;
    ap_fixed<I,I> fout = generic_cosh(fin);
    ap_int<I> out = fout;
    return out;
  };


  template<int I>
  ap_uint<I> generic_cosh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> fin = in;
    ap_fixed<I+1,I+1> fout = generic_cosh(fin);
    ap_uint<I> out = 0;
    if(fout[I]==0){
        out = fout;
    }
    return out;
  };



  template<int W, int I>
  ap_fixed<W-I+3,3> generic_asin(ap_fixed<W,I> in){

    const int I0 = 3;
    const int W0 = W - I + I0 + 6;

    const ap_fixed<W+1,I+1> cst1("0x1");
    const ap_fixed<W,I> cst0("0x0");
    const ap_fixed<W,I> cst_1("-0x1");
# 1064 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cordic_apfixed.h"
    ap_fixed<W-I+3,3> out;


    if(in==cst1){
      out = ap_fixed<W-I+3,3>("0x1.921FB54442D1846");
      return out;
    }
    else if(in==cst_1){
      out = ap_fixed<W-I+3,3>("-0x1.921FB54442D1846");
      return out;
    }
    else if(in==cst0){
      out = ap_fixed<W-I+3,3>("0x0");
      return out;
    }


    ap_uint<1> sign0 = (in >= 0) ? 1: 0;


    ap_fixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;

    ap_fixed<W,I> absout;


    if(inabs[W-I-1]==0){
      ap_fixed<W0,I0> x("0x1");
      ap_fixed<W0,I0> y("0x0");
      ap_fixed<W0,I0> z("0x0");
      ap_fixed<W0,I0> t = inabs;
      doublecordic_apfixed<W0,I0,0,0>(x,y,z,t);
      absout = z;
    }
    else{
      const int F1 = W - I;
      const int W1 = F1 + F1 + I;
      ap_fixed<W1,I> one("0x1");
      ap_fixed<W1,I> onex = one - inabs * inabs;
      ap_fixed<W1,I> sqrtonex = ::__builtin_sqrt(onex.to_double());
      ap_fixed<W1,I> xsqrtonex = inabs / (one + sqrtonex);
      absout = generic_atan(xsqrtonex) << 1;
    }


    if(sign0)
      out = absout;
    else
      out = -absout;

    return out;
  }



  template<int W, int I>
  ap_fixed<W-I+3,3> generic_acos(ap_fixed<W,I> in){

    const int I0 = 3;
    const int W0 = W - I + I0;
# 1142 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cordic_apfixed.h"
    const ap_fixed<W0,I0> pi2("0x1.921FB54442D1846");
    ap_fixed<W0,I0> out = pi2 - generic_asin(in);

    if(out[W0-1]==1){
      out = -out;
    }

    return out;
  }

  template<int W, int I>
  void cordic_semi_recovery_asinh(ap_fixed<W,I> in_top, ap_fixed<W,I>& out) {

    if(in_top == 0) {
      out = 0;
      return;
    }

    ap_fixed<W,I> in;
    if(in_top >= 0) {
      in = in_top;
    }
    else {
      in = -in_top;
    }

    int m = in.countLeadingZeros();
    int k = I-m;

    if(W-I-2 >= k) {

      ap_fixed<W,I> boundk = 1.0;
      ap_fixed<W,I> bound_k_2 = 1.0;
      boundk <<= k;
      bound_k_2 >>= k;
      bound_k_2 >>= 2;

      if(in >= (boundk - bound_k_2)) {
        k+=1;
      }

    }

    if(k < 0) {
      k = 0;
    }

    const int Nmax = W - I + 1;
    int tau;
    ap_fixed<W,I> x_r(1);
    ap_fixed<W,I> y_r(0);
    ap_fixed<W,I> z_r(0);
    ap_fixed<W,I> x1_tau, x_2tau, y1_tau, y_2tau, z_s;
    ap_fixed<W,I> xk, x_k, yk, y_k;
    ap_fixed<W,I> y_semi_recovery;
    ap_fixed<W,I> in_s;

    VITIS_LOOP_1199_1: for(int i=0; i<Nmax; i++) {

      xk = x_r << k;
      x_k = x_r >> k;
      yk = y_r << k;
      y_k = y_r >> k;

      y_semi_recovery = (xk - x_k + yk + y_k) >> 1;

      tau = hyperb_table_tau_128[i+1];
      z_s = hyperb_table_arctanh_128[tau-1] << 1;

      x1_tau = ((x_r >> tau) << 1);
      x_2tau = (x_r >> (tau << 1));
      y1_tau = ((y_r >> tau) << 1);
      y_2tau = (y_r >> (tau << 1));

      if(y_semi_recovery <= in) {
        x_r += x_2tau + y1_tau;
        y_r += y_2tau + x1_tau;
        z_r += z_s;
      }
      else {
        x_r += x_2tau - y1_tau;
        y_r += y_2tau - x1_tau;
        z_r -= z_s;
      }

      in_s = in >> (tau << 1);
      in -= in_s;
    }

    ap_ufixed<W,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    if(in_top >= 0) {
      out = z_r + k*ln2;
    }
    else {
      out = -z_r - k*ln2;
    }
  }

  template<int W, int I>
  void cordic_semi_recovery_acosh(ap_fixed<W,I> in, ap_fixed<W,I>& out) {






    if(in == 1) {
      out = 0;
      return;
    }

    int m = in.countLeadingZeros();
    int k = I-m;


    ap_fixed<W,I> boundk = 1.0;
    ap_fixed<W,I> bound_k_1 = 1.0;
    boundk <<= k;
    boundk >>= 1;
    bound_k_1 >>= k;
    bound_k_1 >>= 1;

      if(in < (boundk - bound_k_1)) {
        k-=1;
      }

    if(k < 0) {
      k = 0;
    }

    const int Nmax = W - I + 1;
    int tau;
    ap_fixed<W,I> x_r(1);
    ap_fixed<W,I> y_r(0);
    ap_fixed<W,I> z_r(0);
    ap_fixed<W,I> x1_tau, x_2tau, y1_tau, y_2tau, z_s;
    ap_fixed<W,I> xk, x_k, yk, y_k;
    ap_fixed<W,I> x_semi_recovery;
    ap_fixed<W,I> in_s;

    VITIS_LOOP_1282_1: for(int i=0; i<Nmax; i++) {

      xk = x_r << k;
      x_k = x_r >> k;
      yk = y_r << k;
      y_k = y_r >> k;

      x_semi_recovery = (xk + x_k + yk - y_k) >> 1;

      tau = hyperb_table_tau_128[i+1];
      z_s = hyperb_table_arctanh_128[tau-1] << 1;

      x1_tau = ((x_r >> tau) << 1);
      x_2tau = (x_r >> (tau << 1));
      y1_tau = ((y_r >> tau) << 1);
      y_2tau = (y_r >> (tau << 1));

      if(x_semi_recovery <= in) {
        x_r += x_2tau + y1_tau;
        y_r += y_2tau + x1_tau;
        z_r += z_s;
      }
      else {
        x_r += x_2tau - y1_tau;
        y_r += y_2tau - x1_tau;
        z_r -= z_s;
      }

      in_s = in >> (tau << 1);
      in -= in_s;
    }

    ap_ufixed<W,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    out = z_r + k*ln2;
  }


  template<int W, int I>
  ap_fixed<W,I> generic_asinh(ap_fixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output; input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_asinh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int I>
  ap_int<I> generic_asinh(ap_int<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int I>
  ap_uint<I> generic_asinh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_acosh(ap_fixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_acosh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int I>
  ap_int<I> generic_acosh(ap_int<I> in) {
    ap_fixed<I,I> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int I>
  ap_uint<I> generic_acosh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_asinpi(ap_fixed<W,I> x) {
      const static int we = I < 3? 3: I;
      ap_fixed<W-I+we, we> xi = x;
      ap_fixed<W-I+3,3> asin_x = generic_asin(xi);






      static const int F = W - I;





      static const int wf = F < 1? 0: F - 1;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;





      ap_fixed<W,I> r = asin_x/pi;





      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_asinpi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_asinpi(xi);
  }
  template<int I>
  ap_int<I> generic_asinpi(ap_int<I> x) {

      if(x==-1){

        return -1;
      }else if(x==0){
        return 0;
      }else if(x==1){

        return 1;
      }else{




        return 0;
      };
  }
  template<int I>
  ap_uint<I> generic_asinpi(ap_uint<I> x) {

      if(x==0){
        return 0;

      } else if(x==1){
        return 1;
      } else{




        return 0;
      };
  }

  template<int W, int I>
  ap_fixed<W,I> generic_acospi(ap_fixed<W,I> x) {





      const static int we = I < 3? 3 : I;
      ap_fixed<W-I+we,we> xi = x;
      ap_fixed<W-I+3,3> acos_x = generic_acos(xi);





      static const int F = W - I;





      static const int wf = F;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;





      ap_fixed<W,I> r = acos_x/pi;





      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_acospi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_acospi(xi);
  }
  template<int I>
  ap_int<I> generic_acospi(ap_int<I> x) {

      if(x==-1){
        return 1;

      } else if(x==0){
        return 1;
      } else if(x==1){
        return 0;
      } else{




        return 0;
      };
  }
  template<int I>
  ap_uint<I> generic_acospi(ap_uint<I> x) {

      if(x==0){
        return 1;
      } else if(x==1){
        return 0;
      } else{




        return 0;
      };
  }

  template<int W, int I>
  ap_fixed<W,I> generic_atanpi(ap_fixed<W,I> x) {
      ap_fixed<W-I+3,3> atan_x = generic_atan(x);





      static const int F = W - I;





      static const int wf = F < 1? 0: F - 1;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;
      ap_fixed<W,I> r = atan_x/pi;






      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_atanpi(ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      return generic_atanpi(xi);
  }
  template<int I>
  ap_int<I> generic_atanpi(ap_int<I> x) {

      (void)(x);
      return 0;
  }
  template<int I>
  ap_uint<I> generic_atanpi(ap_uint<I> x) {

      (void)(x);
      return 0;
  }

  template<int W, int I>
  ap_fixed<W,I> generic_atan2pi(ap_fixed<W,I> y, ap_fixed<W, I> x) {
      ap_fixed<W-I+3,3> atan2_x = generic_atan2(y, x);
      static const int F = W - I;





      static const int wf = F;
      ap_ufixed<2+wf,2> pi = 3.14159265358979323846;
      ap_fixed<W,I> r = atan2_x/pi;
      return r;
  }
  template<int W, int I>
  ap_ufixed<W,I> generic_atan2pi(ap_ufixed<W,I> y, ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xi = x;
      ap_fixed<W+1,I+1> yi = y;
      return generic_atan2pi(yi, xi);
  }
  template<int I>
  ap_int<I> generic_atan2pi(ap_int<I> y, ap_int<I> x) {

      bool x_sig = x[I-1];
      bool y_sig = y[I-1];
      if(y==0 && x==0) return 0;


      else if(y_sig && x==0) return -1;

      else if(!y_sig && x==0) return 1;

      else if(!y_sig && x_sig) return 1;

      else if(y_sig && x_sig) return -1;
      else return 0;
  }
  template<int I>
  ap_uint<I> generic_atan2pi(ap_uint<I> y, ap_uint<I> x) {


      if(y!=0 && x==0) return 1;
      else return 0;
  }

}
# 1067 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_exp_apfixed.h" 1
# 36 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_exp_apfixed.h"
namespace exp_reduce {

template<int W_, int I_>
ap_fixed<W_,I_> exp(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline

 int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;




    int I_s_;
    int M_ = (I_-1>F_) ? (I_-1) : F_;
    if (M_==1) I_s_ = 1;
    else if (M_==2) I_s_ = 2;
    else if (M_<6) I_s_ = 3;
    else if (M_<12) I_s_ = 4;
    else if (M_<24) I_s_ = 5;
    else I_s_ = 6;

    ap_fixed<W_,I_> r;
    if (I_s_==1) {
        ap_fixed<3,2> x_l = x;
        ap_ufixed<2,1> y = 0;
        if (x_l[2]!=x_l[1]) {
            if (!x_l[2]) y = "0x1.8p0";
        } else {
            if (!x_l[2]) y[1] = 1;
            if (x_l[2]|x_l[0]) y[0] = 1;
        }
        if (I_<2) {
            if (y[1]) {
                y[1] = 0;
                y[0] = 1;
            }
        }
        r = y;
    } else if (I_s_==2) {
        ap_fixed<5,3> x_l = x;
        ap_ufixed<4,2> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(3,2);
        ap_ufixed<2,0> x_l_fract;
        x_l_fract(1,0) = x_l(1,0);

        if ((x_l[4]!=x_l[3])||((x_l_int==1)&&(x_l_fract>=ap_ufixed<2,0>("0x0.8p0")))) {
            if (!x_l[4]) y = "0x3.cp0";
        } else {
            if (!x_l[4]&((x_l[1]&x_l[0])|x_l[2])) y[3] = 1;
            if (!x_l[4]&((!x_l[2]&!x_l[0])|(!x_l[1]&x_l[0]))) y[2] = 1;
            if ((!x_l[4]&x_l[1]&!x_l[0])|(!x_l[4]&x_l[2])|(x_l[2]&x_l[0])|(x_l[2]&x_l[1])) y[1] = 1;
            if ((!x_l[2]&!x_l[1]&x_l[0])|(!x_l[2]&x_l[1]&!x_l[0])|(x_l[2]&!x_l[1]&!x_l[0])|(x_l[2]&x_l[1]&x_l[0])|(x_l[4]&!x_l[3])) y[0] = 1;
        }
        if (I_<3) {
            bool overf = 0;
            VITIS_LOOP_94_1: for (int j = 3; j >= I_+1; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_100_2: for (int j = 3; j >= I_+1; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_104_3: for (int j = I_; j >= 0; j--){
#pragma HLS unroll
 y[j] = 1;
               }
            }
        }
        r = y;
    } else if (I_s_==3) {
        ap_fixed<11,6> x_l = x;
        ap_ufixed<10,5> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(7,5);
        ap_ufixed<5,0> x_l_fract;
        x_l_fract(4,0) = x_l(4,0);

        if ((x_l[10]!=x_l[9])||(x_l[10]!=x_l[8])||(x_l[10]!=x_l[7])||((x_l_int==3)&&(x_l_fract>ap_fixed<5,0>("0x0.7p0")))) {
            if (!x_l[10]) y = "0x1f.f8p0";
        } else {





            ap_uint<4> x_msb_ind;
            x_msb_ind[3] = x_l[10];
            x_msb_ind(2,0) = x_l(6,4);
            ap_uint<4> x_lsb_ind;
            x_lsb_ind(3,0) = x_l(3,0);
            ap_ufixed<4,-1> x_lsb = x_l;
# 153 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_exp_apfixed.h"
            const static ap_ufixed<12,0> exp_x_lsb_m_1_table[16] = {
                "0x0.0p0", "0x0.082p0", "0x0.108p0", "0x0.193p0", "0x0.221p0", "0x0.2b5p0", "0x0.34dp0", "0x0.3eap0",
                "0x0.48bp0", "0x0.532p0", "0x0.5dfp0", "0x0.69p0", "0x0.748p0", "0x0.805p0", "0x0.8c8p0", "0x0.991p0",
            };
            ap_ufixed<12, 0> exp_x_lsb_m_1 = exp_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<12,5> exp_x_msb_table[16] = {
                "0x1.0p0", "0x1.a6p0", "0x2.b8p0", "0x4.7cp0", "0x7.64p0", "0xc.2ep0", "0x14.16p0", "0x21.1ep0",
                "0x0.04p0", "0x0.08p0", "0x0.0cp0", "0x0.16p0", "0x0.22p0", "0x0.3ap0", "0x0.5ep0", "0x0.9cp0",
            };
            ap_ufixed<12,5> exp_x_msb = exp_x_msb_table[x_msb_ind];
            ap_ufixed<24,5> y_lo = exp_x_msb * exp_x_lsb_m_1;
            ap_ufixed<12,5> y_lo_s = y_lo;
            ap_ufixed<12,5> y_l = y_lo_s + exp_x_msb;
            y = y_l;
        }
        if (I_<6) {
            bool overf = 0;
            VITIS_LOOP_171_4: for (int j = 9; j >= I_+4; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_177_5: for (int j = 9; j >= I_+4; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_181_6: for (int j = I_+3; j >= 0; j--){
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    } else if (I_s_==4) {
        ap_fixed<23,12> x_l = x;
        ap_ufixed<22,11> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(14,11);
        ap_ufixed<11,0> x_l_fract;
        x_l_fract(10,0) = x_l(10,0);
        bool overf = 0;
        VITIS_LOOP_196_7: for (int j = 14; j < 22; j++){
#pragma HLS unroll
 if (x_l[22]!=x_l[j])
                overf = 1;
        }

        if (overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<11,0>("0x0.ap0")))) {
            if (!x_l[22]) {
                VITIS_LOOP_204_8: for (int j = 0; j < 22; j++){
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1[4] = x_l[22];
            x_msb_ind_1(3,0) = x_l(13,10);
            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(9,5);
            ap_ufixed<5,-1> x_msb_2 = x_l;
            ap_uint<5> x_lsb_ind;
            x_lsb_ind(4,0) = x_l(4,0);


            const static ap_ufixed<11,-13> f_x_lsb_table[32] = {
                "0x0.0p0", "0x0.000002p0", "0x0.000008p0", "0x0.000012p0",
                "0x0.00002p0", "0x0.000032p0", "0x0.000048p0", "0x0.000062p0",
                "0x0.00008p0", "0x0.0000a2p0", "0x0.0000c9p0", "0x0.0000f3p0",
                "0x0.000121p0", "0x0.000153p0", "0x0.000189p0", "0x0.0001c3p0",
                "0x0.000202p0", "0x0.000244p0", "0x0.00028ap0", "0x0.0002d4p0",
                "0x0.000323p0", "0x0.000375p0", "0x0.0003ccp0", "0x0.000426p0",
                "0x0.000485p0", "0x0.0004e7p0", "0x0.00054ep0", "0x0.0005b9p0",
                "0x0.000627p0", "0x0.00069ap0", "0x0.000711p0", "0x0.00078cp0",
            };
            ap_ufixed<11,-13> f_x_lsb = f_x_lsb_table[x_lsb_ind];
            ap_ufixed<18, -6> exp_x_lsb_m_1 = 0;
            exp_x_lsb_m_1(17,13) = x_lsb_ind(4,0);
            exp_x_lsb_m_1(10,0) = f_x_lsb(10,0);

            const static ap_ufixed<25,0> exp_x_msb_2_m_1_table[32] = {
                "0x0.0000000p0", "0x0.04080a8p0", "0x0.0820560p0", "0x0.0c49238p0",
                "0x0.1082b58p0", "0x0.14cd500p0", "0x0.1929370p0", "0x0.1d96b10p0",
                "0x0.2216048p0", "0x0.26a7790p0", "0x0.2b4b588p0", "0x0.3001ed0p0",
                "0x0.34cb818p0", "0x0.39a8628p0", "0x0.3e98de8p0", "0x0.439d440p0",
                "0x0.48b5e40p0", "0x0.4de30f0p0", "0x0.5325180p0", "0x0.587c540p0",
                "0x0.5de9178p0", "0x0.636bb98p0", "0x0.6904930p0", "0x0.6eb3fc8p0",
                "0x0.747a510p0", "0x0.7a57ee0p0", "0x0.804d300p0", "0x0.865a778p0",
                "0x0.8c80248p0", "0x0.92be998p0", "0x0.99163b0p0", "0x0.9f876e8p0",
            };
            ap_ufixed<25, 0> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];

            ap_ufixed<43,-6> f_x_msb_2_lsb = exp_x_msb_2_m_1 * exp_x_lsb_m_1;
            ap_ufixed<19,-6> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<25, 0> exp_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_s + exp_x_lsb_m_1 + exp_x_msb_2_m_1;

            const static ap_ufixed<25,11> exp_x_msb_1_table[32] = {
                "0x1.0000p0", "0x1.a614p0", "0x2.b7e0p0", "0x4.7b50p0",
                "0x7.6398p0", "0xc.2eb8p0", "0x14.15e4p0", "0x21.1d90p0",
                "0x36.9920p0", "0x5a.0464p0", "0x94.69c4p0", "0xf4.b124p0",
                "0x193.6dc4p0", "0x299.2444p0", "0x448.a218p0", "0x710.0adcp0",
                "0x0.0014p0", "0x0.0024p0", "0x0.003cp0", "0x0.0064p0",
                "0x0.00a4p0", "0x0.010cp0", "0x0.01b8p0", "0x0.02d8p0",
                "0x0.04b0p0", "0x0.07bcp0", "0x0.0cc0p0", "0x0.1504p0",
                "0x0.22a4p0", "0x0.3920p0", "0x0.5e2cp0", "0x0.9b44p0",
            };
            ap_ufixed<25,11> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<50,11> y_lo = exp_x_msb_1 * exp_x_msb_2_lsb_m_1;
            ap_ufixed<25,11> y_lo_s = y_lo;
            ap_ufixed<25,11> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<12) {
            bool overf = 0;
            VITIS_LOOP_269_9: for (int j = 21; j >= I_+10; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_275_10: for (int j = 21; j >= I_+10; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_279_11: for (int j = I_+9; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    } else if (I_s_==5) {
        ap_fixed<47,24> x_l = x;
        ap_ufixed<46,23> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(27,23);
        ap_ufixed<23,0> x_l_fract;
        x_l_fract(22,0) = x_l(22,0);
        bool overf = 0;
        VITIS_LOOP_294_12: for (int j = 27; j < 46; j++){
#pragma HLS unroll
 if (x_l[46]!=x_l[j])
                overf = 1;
        }

        if (overf||((x_l_int==15)&&(x_l_fract>=ap_ufixed<23,0>("0x0.f14028p0")))) {
            if (!x_l[46]) {
                VITIS_LOOP_302_13: for (int j = 0; j < 46; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[46];
            x_msb_ind_1(6,0) = x_l(26,20);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(19,12);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(11,7);
            ap_uint<3> x_msb_ind_4;
            x_msb_ind_4(2,0) = x_l(6,4);
            ap_uint<4> x_lsb_ind;
            x_lsb_ind(3,0) = x_l(3,0);

            ap_ufixed<8, -3> x_msb_2 = x_l;
            ap_ufixed<5,-11> x_msb_3 = x_l;
            ap_ufixed<3,-16> x_msb_4 = x_l;
            ap_ufixed<4,-19> x_lsb = x_l;

            const static ap_ufixed< 6,-33> f_x_msb_4_h_table[8] = {
"0x0.0000000000p0", "0x0.0000000002p0", "0x0.0000000008p0", "0x0.0000000012p0",
"0x0.0000000020p0", "0x0.0000000032p0", "0x0.0000000048p0", "0x0.0000000062p0",
            };
            const static ap_ufixed< 7,-51> f_x_msb_4_l_table[8] = {
"0x0.000000000000000p0", "0x0.000000000000000p0", "0x0.00000000000000cp0", "0x0.000000000000024p0",
"0x0.000000000000054p0", "0x0.0000000000000a8p0", "0x0.000000000000120p0", "0x0.0000000000001c8p0",
            };
            ap_ufixed< 6,-33> f_x_msb_4_h = f_x_msb_4_h_table[x_msb_ind_4];
            ap_ufixed< 7,-51> f_x_msb_4_l = f_x_msb_4_l_table[x_msb_ind_4];

            const static ap_ufixed< 8,-39> f_x_lsb_table[16] = {
"0x0.000000000000p0", "0x0.000000000002p0", "0x0.000000000008p0", "0x0.000000000012p0",
"0x0.000000000020p0", "0x0.000000000032p0", "0x0.000000000048p0", "0x0.000000000062p0",
"0x0.000000000080p0", "0x0.0000000000a2p0", "0x0.0000000000c8p0", "0x0.0000000000f2p0",
"0x0.000000000120p0", "0x0.000000000152p0", "0x0.000000000188p0", "0x0.0000000001c2p0",
            };
            ap_ufixed< 8,-39> f_x_lsb = f_x_lsb_table[x_lsb_ind];

            ap_ufixed< 7,-35> f_x_msb_4_lsb = x_msb_4 * x_lsb;

            ap_ufixed<10,-32> exp_x_msb_4_lsb_m_1_m = 0;
            exp_x_msb_4_lsb_m_1_m(8,3) = f_x_msb_4_h(5,0);
            exp_x_msb_4_lsb_m_1_m(2,0) = f_x_lsb(7,5);
            exp_x_msb_4_lsb_m_1_m = exp_x_msb_4_lsb_m_1_m + f_x_msb_4_lsb;

            ap_ufixed<42,-16> exp_x_msb_4_lsb_m_1 = 0;
            exp_x_msb_4_lsb_m_1(41,35) = x_l(6,0);
            exp_x_msb_4_lsb_m_1(25,16) = exp_x_msb_4_lsb_m_1_m(9,0);
            exp_x_msb_4_lsb_m_1(15,11) = f_x_lsb(4,0);
            exp_x_msb_4_lsb_m_1( 6, 0) = f_x_msb_4_l(6,0);


            const static ap_ufixed<32,-23> f_x_msb_3_table[32] = {
"0x0.00000000000000p0", "0x0.0000000080002ap0", "0x0.00000002000156p0", "0x0.00000004800480p0",
"0x0.00000008000aaap0", "0x0.0000000c8014d6p0", "0x0.00000012002400p0", "0x0.0000001880392cp0",
"0x0.00000020005556p0", "0x0.00000028807982p0", "0x0.0000003200a6acp0", "0x0.0000003c80ddd8p0",
"0x0.00000048012004p0", "0x0.00000054816e30p0", "0x0.0000006201c95cp0", "0x0.00000070823288p0",
"0x0.0000008002aab6p0", "0x0.000000908332e2p0", "0x0.000000a203cc12p0", "0x0.000000b4847740p0",
"0x0.000000c8053570p0", "0x0.000000dc8607a0p0", "0x0.000000f206eed0p0", "0x0.0000010887ec02p0",
"0x0.00000120090036p0", "0x0.000001388a2c6ap0", "0x0.000001520b71a0p0", "0x0.0000016c8cd0d6p0",
"0x0.000001880e4b0ep0", "0x0.000001a48fe148p0", "0x0.000001c2119484p0", "0x0.000001e09365c0p0",
            };

            ap_ufixed<32,-23> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<44,-11> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(43,39) = x_msb_3(4,0);
            exp_x_msb_3_m_1(31, 0) = f_x_msb_3(31,0);

            ap_ufixed<86,-27> f_x_msb_3_4_lsb = exp_x_msb_3_m_1 * exp_x_msb_4_lsb_m_1;
            ap_ufixed<31,-27> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<48,-10> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_lsb_m_1;


            const static ap_ufixed<46,-6> f_x_msb_2_table[256] = {
"0x0", "0x0.0000020015560p0", "0x0.00000800AAB55p0", "0x0.0000120240360p0",
"0x0.0000200556001p0", "0x0.0000320A6C4B8p0", "0x0.0000481203608p0", "0x0.0000621C9B971p0",
"0x0.0000802AB5577p0", "0x0.0000A23CD119Dp0", "0x0.0000C8536F668p0", "0x0.0000F26F10D5Dp0",
"0x0.0001209036103p0", "0x0.000152B75FCE3p0", "0x0.000188E50ED86p0", "0x0.0001C319C4077p0",
"0x0.0002015600445p0", "0x0.0002439A4487Ep0", "0x0.000289E711DB3p0", "0x0.0002D43CE9577p0",
"0x0.0003229C4C260p0", "0x0.00037505BB805p0", "0x0.0003CB79B8B01p0", "0x0.000425F8C50F2p0",
"0x0.0004848362076p0", "0x0.0004E71A11131p0", "0x0.00054DBD53BC8p0", "0x0.0005B86DAB9E3p0",
"0x0.0006272B9A630p0", "0x0.000699F7A1C5Dp0", "0x0.000710D24391Ep0", "0x0.00078BBC01A29p0",
"0x0.00080AB55DE39p0", "0x0.00088DBEDA50Bp0", "0x0.000914D8F8F63p0", "0x0.0009A0043BF07p0",
"0x0.000A2F41256C2p0", "0x0.000AC29037A63p0", "0x0.000B59F1F4EBDp0", "0x0.000BF566DF9AAp0",
"0x0.000C94EF7A206p0", "0x0.000D388C46FB4p0", "0x0.000DE03DC8B9Bp0", "0x0.000E8C0481FA7p0",
"0x0.000F3BE0F56CAp0", "0x0.000FEFD3A5CFAp0", "0x0.0010A7DD15F36p0", "0x0.001163FDC8B7Fp0",
"0x0.00122436410DDp0", "0x0.0012E88701F5Ep0", "0x0.0013B0F08E817p0", "0x0.00147D7369D22p0",
"0x0.00154E101719Fp0", "0x0.001622C7199B7p0", "0x0.0016FB98F4A96p0", "0x0.0017D8862BA72p0",
"0x0.0018B98F42084p0", "0x0.00199EB4BB511p0", "0x0.001A87F71B161p0", "0x0.001B7556E4FC4p0",
"0x0.001C66D49CB93p0", "0x0.001D5C70C612Dp0", "0x0.001E562BE4DFAp0", "0x0.001F54067D067p0",
"0x0.00205601127ECp0", "0x0.00215C1C29507p0", "0x0.0022665845940p0", "0x0.002374B5EB724p0",
"0x0.002487359F24Cp0", "0x0.00259DD7E4F57p0", "0x0.0026B89D413EFp0", "0x0.0027D786386C4p0",
"0x0.0028FA934EF90p0", "0x0.002A21C509717p0", "0x0.002B4D1BEC726p0", "0x0.002C7C987CA92p0",
"0x0.002DB03B3ED3Ap0", "0x0.002EE804B7C07p0", "0x0.003023F56C4ECp0", "0x0.0031640DE16E3p0",
"0x0.0032A84E9C1F5p0", "0x0.0033F0B821730p0", "0x0.00353D4AF68B0p0", "0x0.00368E07A0999p0",
"0x0.0037E2EEA4E19p0", "0x0.00393C0088B6Cp0", "0x0.003A993DD17D5p0", "0x0.003BFAA704AA3p0",
"0x0.003D603CA7C32p0", "0x0.003EC9FF405E6p0", "0x0.004037EF54230p0", "0x0.0041AA0D68C8Cp0",
"0x0.0043205A04182p0", "0x0.00449AD5ABEA5p0", "0x0.00461980E6294p0", "0x0.00479C5C38CF9p0",
"0x0.0049236829E8Bp0", "0x0.004AAEA53F90Ep0", "0x0.004C3E13FFF51p0", "0x0.004DD1B4F152Fp0",
"0x0.004F698899F90p0", "0x0.0051058F8046Ap0", "0x0.0052A5CA2AABFp0", "0x0.00544A391FA9Cp0",
"0x0.0055F2DCE5D1Ep0", "0x0.00579FB603C6Ep0", "0x0.005950C5003C2p0", "0x0.005B060A61F5Dp0",
"0x0.005CBF86AFC91p0", "0x0.005E7D3A709BEp0", "0x0.00603F262B650p0", "0x0.0062054A672C2p0",
"0x0.0063CFA7AB09Dp0", "0x0.00659E3E7E278p0", "0x0.0067710F67BFAp0", "0x0.0069481AEF1D5p0",
"0x0.006B23619B9CFp0", "0x0.006D02E3F4AB7p0", "0x0.006EE6A281C6Fp0", "0x0.0070CE9DCA7E6p0",
"0x0.0072BAD65671Bp0", "0x0.0074AB4CAD51Cp0", "0x0.0076A00156E07p0", "0x0.007898F4DAF09p0",
"0x0.007A9627C165Fp0", "0x0.007C979A92356p0", "0x0.007E9D4DD564Ap0", "0x0.0080A742130A8p0",
"0x0.0082B577D34EDp0", "0x0.0084C7EF9E6A7p0", "0x0.0086DEA9FCA73p0", "0x0.0088F9A776601p0",
"0x0.008B18E894010p0", "0x0.008D3C6DDE06Fp0", "0x0.008F6437DD000p0", "0x0.00919047198B6p0",
"0x0.0093C09C1C595p0", "0x0.0095F5376E2B2p0", "0x0.00982E1997D33p0", "0x0.009A6B4322352p0",
"0x0.009CACB496458p0", "0x0.009EF26E7D0A2p0", "0x0.00A13C715F99Ep0", "0x0.00A38ABDC71CEp0",
"0x0.00A5DD543CCC4p0", "0x0.00A8343549F26p0", "0x0.00AA8F6177EADp0", "0x0.00ACEED950222p0",
"0x0.00AF529D5C165p0", "0x0.00B1BAAE25566p0", "0x0.00B4270C3582Ap0", "0x0.00B697B8164C7p0",
"0x0.00B90CB25176Ap0", "0x0.00BB85FB70D50p0", "0x0.00BE0393FE4CCp0", "0x0.00C0857C83D44p0",
"0x0.00C30BB58B732p0", "0x0.00C5963F9F424p0", "0x0.00C8251B496BEp0", "0x0.00CAB849142B5p0",
"0x0.00CD4FC989CD6p0", "0x0.00CFEB9D34B00p0", "0x0.00D28BC49F428p0", "0x0.00D5304054059p0",
"0x0.00D7D910DD8B1p0", "0x0.00DA8636C6764p0", "0x0.00DD37B2997BCp0", "0x0.00DFED84E1618p0",
"0x0.00E2A7AE28FECp0", "0x0.00E5662EFB3C3p0", "0x0.00E82907E313Dp0", "0x0.00EAF0396B910p0",
"0x0.00EDBBC41FD08p0", "0x0.00F08BA88B009p0", "0x0.00F35FE73860Bp0", "0x0.00F63880B341Ep0",
"0x0.00F9157587069p0", "0x0.00FBF6C63F228p0", "0x0.00FEDC73671B0p0", "0x0.0101C67D8A86Cp0",
"0x0.0104B4E5350DFp0", "0x0.0107A7AAF26A2p0", "0x0.010A9ECF4E667p0", "0x0.010D9A52D4DF8p0",
"0x0.01109A3611C34p0", "0x0.01139E7991116p0", "0x0.0116A71DDEDADp0", "0x0.0119B42387423p0",
"0x0.011CC58B167B9p0", "0x0.011FDB5518CCAp0", "0x0.0122F5821A8C7p0", "0x0.01261412A823Cp0",
"0x0.012937074E0CDp0", "0x0.012C5E6098D37p0", "0x0.012F8A1F15151p0", "0x0.0132BA434F80Ap0",
"0x0.0135EECDD4D6Cp0", "0x0.013927BF31E98p0", "0x0.013C6517F39CCp0", "0x0.013FA6D8A6E5Dp0",
"0x0.0142ED01D8CBCp0", "0x0.0146379416673p0", "0x0.0149868FECE26p0", "0x0.014CD9F5E9795p0",
"0x0.015031C699799p0", "0x0.01538E028A426p0", "0x0.0156EEAA4944Bp0", "0x0.015A53BE64033p0",
"0x0.015DBD3F68122p0", "0x0.01612B2DE3178p0", "0x0.01649D8A62CB1p0", "0x0.0168145574F65p0",
"0x0.016B8F8FA7745p0", "0x0.016F0F3988321p0", "0x0.01729353A52E4p0", "0x0.01761BDE8C792p0",
"0x0.0179A8DACC350p0", "0x0.017D3A48F295Dp0", "0x0.0180D0298DE13p0", "0x0.01846A7D2C6ECp0",
"0x0.018809445CA7Bp0", "0x0.018BAC7FAD074p0", "0x0.018F542FAC1A4p0", "0x0.01930054E87F8p0",
"0x0.0196B0EFF0E79p0", "0x0.019A66015414Dp0", "0x0.019E1F89A0DBAp0", "0x0.01A1DD8966221p0",
"0x0.01A5A00132E02p0", "0x0.01A966F1961FCp0", "0x0.01AD325B1EFC9p0", "0x0.01B1023E5CA45p0",
"0x0.01B4D69BDE569p0", "0x0.01B8AF743364Cp0", "0x0.01BC8CC7EB323p0", "0x0.01C06E9795345p0",
"0x0.01C454E3C0F24p0", "0x0.01C83FACFE054p0", "0x0.01CC2EF3DC187p0", "0x0.01D022B8EAE8Fp0",
"0x0.01D41AFCBA45Ep0", "0x0.01D817BFDA104p0", "0x0.01DC1902DA3B1p0", "0x0.01E01EC64ACB7p0",
"0x0.01E4290ABBD87p0", "0x0.01E837D0BD8B2p0", "0x0.01EC4B18E01E9p0", "0x0.01F062E3B3DFEp0",
"0x0.01F47F31C92E4p0", "0x0.01F8A003B07AFp0", "0x0.01FCC559FA492p0", "0x0.0200EF35372E4p0",
"0x0.02051D95F7D1Cp0", "0x0.0209507CCCED1p0", "0x0.020D87EA474BEp0", "0x0.0211C3DEF7CBDp0",
            };
            ap_ufixed<46,-6> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 5,-6> f_x_msb_2_h;
            f_x_msb_2_h(4,0) = f_x_msb_2(45,41);
            ap_ufixed< 9,-2> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<50,-2> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(49,41) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(40, 0) = f_x_msb_2(40,0);

            ap_ufixed<98,-12> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<46,-12> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<50,-2> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<50,23> exp_x_msb_1_table[256] = {
"0x1.0000000p0", "0x1.2216045p0", "0x1.48B5E3Cp0", "0x1.747A513p0",
"0x1.A61298Ep0", "0x1.DE455DFp0", "0x2.1DF3B68p0", "0x2.661CB0Fp0",
"0x2.B7E1516p0", "0x3.1489176p0", "0x3.7D871DBp0", "0x3.F47FE87p0",
"0x4.7B4FF99p0", "0x5.1413452p0", "0x5.C12DA41p0", "0x6.855466Ep0",
"0x7.63992E3p0", "0x8.5F7635Bp0", "0x9.7CDC417p0", "0xA.C042667p0",
"0xC.2EB7EC9p0", "0xD.CDF892Ep0", "0xF.A48385Ep0", "0x11.B9B5652p0",
"0x14.15E5BF6p0", "0x16.C2887C1p0", "0x19.CA53B78p0", "0x1D.396AA97p0",
"0x21.1D8E427p0", "0x25.865441Cp0", "0x2A.8565A14p0", "0x30.2EC550Bp0",
"0x36.99205C4p0", "0x3D.DE28BF3p0", "0x46.1AFC4DBp0", "0x4F.7099532p0",
"0x5A.0462B78p0", "0x66.00B5BC9p0", "0x73.9593ABBp0", "0x82.F9621ADp0",
"0x94.69C4CB8p0", "0xA8.2C948C1p0", "0xBE.90F6F83p0", "0xD7.F09B78Cp0",
"0xF4.B122790p0", "0x115.45B4704p0", "0x13A.30CF1CCp0", "0x164.0650296p0",
"0x193.6DC5690p0", "0x1C9.250BEDCp0", "0x206.03487A3p0", "0x24A.FC4533Cp0",
"0x299.2442102p0", "0x2F1.B447462p0", "0x356.0F0B0F9p0", "0x3C7.C67E5BEp0",
"0x448.A216ABBp0", "0x4DA.A5EE46Ap0", "0x580.1AD754Fp0", "0x63B.9782341p0",
"0x710.0ADBAC7p0", "0x800.C7CC8E3p0", "0x911.9289C39p0", "0xA46.AFAA2ADp0",
"0xBA4.F53EA38p0", "0xD31.DE30C52p0", "0xEF3.A035D57p0", "0x10F1.44ADE60p0",
"0x1332.C4D2B7Cp0", "0x15C1.29A744Cp0", "0x18A6.B027DA0p0", "0x1BEE.F24BB12p0",
"0x1FA7.157C470p0", "0x23DD.FF3C8BAp0", "0x28A4.90D2CCEp0", "0x2E0D.EAE454Bp0",
"0x342F.BA11823p0", "0x3B22.8DC5359p0", "0x4302.3A933EEp0", "0x4BEE.49AFCDCp0",
"0x560A.773E541p0", "0x617F.4171BF9p0", "0x6E7A.8ABB4A8p0", "0x7D30.5191764p0",
"0x8DDB.80AF426p0", "0xA0BE.DB0DB10p0", "0xB626.0748BAEp0", "0xCE66.BE9EAADp0",
"0xE9E2.2447727p0", "0x10906.4A831F8p0", "0x12C4F.EB75B2Ap0", "0x1544C.5CB6133p0",
"0x1819B.C560F61p0", "0x1B4F3.9F8AF64p0", "0x1EF21.8F1B001p0", "0x2310E.996C40Fp0",
"0x27BC2.CA9A6F9p0", "0x2D069.571279Ap0", "0x33055.49F35D9p0", "0x39D06.D2FEF17p0",
"0x41831.49596E9p0", "0x4A3C1.FB2AC39p0", "0x541E7.E56949Dp0", "0x5F51C.72B7532p0",
"0x6C02D.645AB25p0", "0x7A648.0CFF534p0", "0x8AB06.0A3EE9Fp0", "0x9D27B.AFE4CF1p0",
"0xB2148.5EAE56Cp0", "0xC9CA9.07F86EFp0", "0xE4A8D.2881EDBp0", "0x1031AE.8E4996Cp0",
"0x1259AC.48BF05Dp0", "0x14CB29.2F2B31Fp0", "0x178FEE.7792E44p0", "0x1AB312.E89CD0Dp0",
"0x1E4127.437732Bp0", "0x224868.979FC2Ep0", "0x26D8F9.4A204BEp0", "0x2C0521.B4A8E0Bp0",
"0x31E199.5F5A550p0", "0x3885D9.FA89D00p0", "0x400C7D.64D3386p0", "0x4893A8.361032Dp0",
"0x523D82.79EDAEFp0", "0x5D30C0.7DAB686p0", "0x69993D.D4F2D95p0", "0x77A8AD.02A7C71p0",
"0x0.000001Ep0", "0x0.0000022p0", "0x0.0000026p0", "0x0.000002Bp0",
"0x0.0000031p0", "0x0.0000038p0", "0x0.000003Fp0", "0x0.0000048p0",
"0x0.0000052p0", "0x0.000005Dp0", "0x0.0000069p0", "0x0.0000077p0",
"0x0.0000087p0", "0x0.0000099p0", "0x0.00000ADp0", "0x0.00000C4p0",
"0x0.00000DFp0", "0x0.00000FCp0", "0x0.000011Ep0", "0x0.0000144p0",
"0x0.0000170p0", "0x0.00001A1p0", "0x0.00001D8p0", "0x0.0000217p0",
"0x0.000025Ep0", "0x0.00002AFp0", "0x0.000030Bp0", "0x0.0000372p0",
"0x0.00003E8p0", "0x0.000046Dp0", "0x0.0000504p0", "0x0.00005AFp0",
"0x0.0000671p0", "0x0.000074Cp0", "0x0.0000845p0", "0x0.000095Fp0",
"0x0.0000A9Fp0", "0x0.0000C09p0", "0x0.0000DA3p0", "0x0.0000F74p0",
"0x0.0001183p0", "0x0.00013D8p0", "0x0.000167Cp0", "0x0.000197Bp0",
"0x0.0001CDFp0", "0x0.00020B7p0", "0x0.0002513p0", "0x0.0002A02p0",
"0x0.0002F9Ap0", "0x0.00035F1p0", "0x0.0003D20p0", "0x0.0004543p0",
"0x0.0004E7Cp0", "0x0.00058F0p0", "0x0.00064C7p0", "0x0.0007232p0",
"0x0.0008167p0", "0x0.00092A2p0", "0x0.000A628p0", "0x0.000BC48p0",
"0x0.000D55Ap0", "0x0.000F1C2p0", "0x0.00111F3p0", "0x0.001366Cp0",
"0x0.0015FC2p0", "0x0.0018E98p0", "0x0.001C3AAp0", "0x0.001FFCEp0",
"0x0.00243F3p0", "0x0.002912Bp0", "0x0.002E8ABp0", "0x0.0034BD2p0",
"0x0.003BC2Dp0", "0x0.0043B7Dp0", "0x0.004CBC1p0", "0x0.0056F3Ap0",
"0x0.0062878p0", "0x0.006FA5Fp0", "0x0.007E83Ap0", "0x0.008F5C0p0",
"0x0.00A2728p0", "0x0.00B813Bp0", "0x0.00D0963p0", "0x0.00EC5C1p0",
"0x0.010BD4Ap0", "0x0.012F7DEp0", "0x0.0157E6Bp0", "0x0.0185B0Fp0",
"0x0.01B993Fp0", "0x0.01F45F9p0", "0x0.0236FF5p0", "0x0.02827E0p0",
"0x0.02D80A0p0", "0x0.0338F9Fp0", "0x0.03A6D22p0", "0x0.04234A7p0",
"0x0.04B0556p0", "0x0.0550280p0", "0x0.0605424p0", "0x0.06D279Ap0",
"0x0.07BB040p0", "0x0.08C284Cp0", "0x0.09ED1B4p0", "0x0.0B3F736p0",
"0x0.0CBED86p0", "0x0.0E7149Cp0", "0x0.105D938p0", "0x0.128B697p0",
"0x0.150385Cp0", "0x0.17CFCC2p0", "0x0.1AFB718p0", "0x0.1E9328Bp0",
"0x0.22A5554p0", "0x0.2742456p0", "0x0.2C7C72Fp0", "0x0.3268CDBp0",
"0x0.391F0EEp0", "0x0.40BA188p0", "0x0.495860Dp0", "0x0.531C6C9p0",
"0x0.5E2D58Dp0", "0x0.6AB7782p0", "0x0.78ED03Ap0", "0x0.8906E49p0",
"0x0.9B4597Ep0", "0x0.AFF230Ap0", "0x0.C75F7CFp0", "0x0.E1EB512p0",
            };
            ap_ufixed<50,23> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<100,21> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<48,21> y_lo_s = y_lo;
            ap_ufixed<50,23> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<24) {
            bool overf = 0;
            VITIS_LOOP_531_14: for (int j = 45; j >= I_+22; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_537_15: for (int j = 45; j >= I_+22; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_541_16: for (int j = I_+21; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    } else {

        ap_fixed<65,33> x_l = 0;
        VITIS_LOOP_551_17: for (int j = 32-F_; j < 32+I_; j++){
#pragma HLS unroll
 x_l[j] = x[j-(32-F_)];
        }
        VITIS_LOOP_555_18: for (int j = 32+I_; j <= 64; j++){
#pragma HLS unroll
 x_l[j] = x[W_-1];
        }
        ap_ufixed<64,32> y = 0;
        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(37,32);
        ap_ufixed<32,0> x_l_fract;
        x_l_fract(31,0) = x_l(31,0);
        bool overf = 0;
        VITIS_LOOP_565_19: for (int j = 37; j < 64; j++) {
#pragma HLS unroll
 if (x_l[64]!=x_l[j])
                overf = 1;
        }

        if (overf||(x_l_int>22)||((x_l_int==22)&&(x_l_fract>=ap_ufixed<32,0>("0x0.2e42fefap0")))) {
            if (!x_l[64]) {
                VITIS_LOOP_573_20: for (int j = 0; j < 64; j++){
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[64];
            x_msb_ind_1(6,0) = x_l(36,30);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(29,22);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(21,14);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(13,6);
            ap_uint<6> x_lsb_ind;
            x_lsb_ind(5,0) = x_l(5,0);

            ap_ufixed<8, -2> x_msb_2 = x_l;
            ap_ufixed<8,-10> x_msb_3 = x_l;
            ap_ufixed<8,-18> x_msb_4 = x_l;
            ap_ufixed<6,-26> x_lsb = x_l;

            const static ap_ufixed<31,-37> f_x_msb_4_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000080000p0", "0x0.000000000000200000p0", "0x0.000000000000480000p0",
"0x0.000000000000800000p0", "0x0.000000000000C80000p0", "0x0.000000000001200000p0", "0x0.000000000001880000p0",
"0x0.000000000002000001p0", "0x0.000000000002880001p0", "0x0.000000000003200002p0", "0x0.000000000003C80003p0",
"0x0.000000000004800004p0", "0x0.000000000005480005p0", "0x0.000000000006200007p0", "0x0.000000000007080008p0",
"0x0.00000000000800000Ap0", "0x0.00000000000908000Cp0", "0x0.00000000000A20000Fp0", "0x0.00000000000B480011p0",
"0x0.00000000000C800014p0", "0x0.00000000000DC80018p0", "0x0.00000000000F20001Bp0", "0x0.00000000001088001Fp0",
"0x0.000000000012000024p0", "0x0.000000000013880028p0", "0x0.00000000001520002Dp0", "0x0.000000000016C80033p0",
"0x0.000000000018800039p0", "0x0.00000000001A48003Fp0", "0x0.00000000001C200046p0", "0x0.00000000001E08004Dp0",
"0x0.000000000020000055p0", "0x0.00000000002208005Dp0", "0x0.000000000024200066p0", "0x0.00000000002648006Fp0",
"0x0.000000000028800079p0", "0x0.00000000002AC80083p0", "0x0.00000000002D20008Ep0", "0x0.00000000002F88009Ap0",
"0x0.0000000000320000A6p0", "0x0.0000000000348800B3p0", "0x0.0000000000372000C0p0", "0x0.000000000039C800CFp0",
"0x0.00000000003C8000DDp0", "0x0.00000000003F4800EDp0", "0x0.0000000000422000FDp0", "0x0.00000000004508010Ep0",
"0x0.000000000048000120p0", "0x0.00000000004B080132p0", "0x0.00000000004E200145p0", "0x0.000000000051480159p0",
"0x0.00000000005480016Ep0", "0x0.000000000057C80183p0", "0x0.00000000005B20019Ap0", "0x0.00000000005E8801B1p0",
"0x0.0000000000620001C9p0", "0x0.0000000000658801E2p0", "0x0.0000000000692001FCp0", "0x0.00000000006CC80216p0",
"0x0.000000000070800232p0", "0x0.00000000007448024Fp0", "0x0.00000000007820026Cp0", "0x0.00000000007C08028Bp0",
"0x0.0000000000800002AAp0", "0x0.0000000000840802CBp0", "0x0.0000000000882002ECp0", "0x0.00000000008C48030Fp0",
"0x0.000000000090800332p0", "0x0.000000000094C80357p0", "0x0.00000000009920037Dp0", "0x0.00000000009D8803A4p0",
"0x0.0000000000A20003CCp0", "0x0.0000000000A68803F5p0", "0x0.0000000000AB20041Fp0", "0x0.0000000000AFC8044Ap0",
"0x0.0000000000B4800477p0", "0x0.0000000000B94804A4p0", "0x0.0000000000BE2004D3p0", "0x0.0000000000C3080503p0",
"0x0.0000000000C8000535p0", "0x0.0000000000CD080567p0", "0x0.0000000000D220059Bp0", "0x0.0000000000D74805D1p0",
"0x0.0000000000DC800607p0", "0x0.0000000000E1C8063Fp0", "0x0.0000000000E7200678p0", "0x0.0000000000EC8806B2p0",
"0x0.0000000000F20006EEp0", "0x0.0000000000F788072Bp0", "0x0.0000000000FD20076Ap0", "0x0.000000000102C807AAp0",
"0x0.0000000001088007EBp0", "0x0.00000000010E48082Ep0", "0x0.000000000114200872p0", "0x0.00000000011A0808B8p0",
"0x0.000000000120000900p0", "0x0.000000000126080948p0", "0x0.00000000012C200993p0", "0x0.0000000001324809DEp0",
"0x0.000000000138800A2Cp0", "0x0.00000000013EC80A7Bp0", "0x0.000000000145200ACBp0", "0x0.00000000014B880B1Dp0",
"0x0.000000000152000B71p0", "0x0.000000000158880BC6p0", "0x0.00000000015F200C1Dp0", "0x0.000000000165C80C76p0",
"0x0.00000000016C800CD0p0", "0x0.000000000173480D2Cp0", "0x0.00000000017A200D8Ap0", "0x0.000000000181080DE9p0",
"0x0.000000000188000E4Ap0", "0x0.00000000018F080EADp0", "0x0.000000000196200F12p0", "0x0.00000000019D480F78p0",
"0x0.0000000001A4800FE0p0", "0x0.0000000001ABC8104Ap0", "0x0.0000000001B32010B6p0", "0x0.0000000001BA881124p0",
"0x0.0000000001C2001194p0", "0x0.0000000001C9881205p0", "0x0.0000000001D1201278p0", "0x0.0000000001D8C812EEp0",
"0x0.0000000001E0801365p0", "0x0.0000000001E84813DEp0", "0x0.0000000001F0201459p0", "0x0.0000000001F80814D6p0",
"0x0.000000000200001555p0", "0x0.0000000002080815D6p0", "0x0.000000000210201659p0", "0x0.0000000002184816DEp0",
"0x0.000000000220801765p0", "0x0.000000000228C817EEp0", "0x0.000000000231201879p0", "0x0.000000000239881907p0",
"0x0.000000000242001996p0", "0x0.00000000024A881A28p0", "0x0.000000000253201ABBp0", "0x0.00000000025BC81B51p0",
"0x0.000000000264801BE9p0", "0x0.00000000026D481C84p0", "0x0.000000000276201D20p0", "0x0.00000000027F081DBFp0",
"0x0.000000000288001E60p0", "0x0.000000000291081F03p0", "0x0.00000000029A201FA8p0", "0x0.0000000002A3482050p0",
"0x0.0000000002AC8020FAp0", "0x0.0000000002B5C821A6p0", "0x0.0000000002BF202255p0", "0x0.0000000002C8882306p0",
"0x0.0000000002D20023B9p0", "0x0.0000000002DB88246Fp0", "0x0.0000000002E5202527p0", "0x0.0000000002EEC825E1p0",
"0x0.0000000002F880269Ep0", "0x0.00000000030248275Dp0", "0x0.00000000030C20281Fp0", "0x0.0000000003160828E3p0",
"0x0.0000000003200029AAp0", "0x0.00000000032A082A73p0", "0x0.000000000334202B3Fp0", "0x0.00000000033E482C0Dp0",
"0x0.000000000348802CDEp0", "0x0.000000000352C82DB2p0", "0x0.00000000035D202E88p0", "0x0.000000000367882F60p0",
"0x0.00000000037200303Cp0", "0x0.00000000037C883119p0", "0x0.0000000003872031FAp0", "0x0.000000000391C832DDp0",
"0x0.00000000039C8033C3p0", "0x0.0000000003A74834ABp0", "0x0.0000000003B2203596p0", "0x0.0000000003BD083684p0",
"0x0.0000000003C8003775p0", "0x0.0000000003D3083868p0", "0x0.0000000003DE20395Ep0", "0x0.0000000003E9483A57p0",
"0x0.0000000003F4803B53p0", "0x0.0000000003FFC83C52p0", "0x0.00000000040B203D53p0", "0x0.000000000416883E57p0",
"0x0.000000000422003F5Ep0", "0x0.00000000042D884068p0", "0x0.000000000439204175p0", "0x0.000000000444C84285p0",
"0x0.000000000450804397p0", "0x0.00000000045C4844ADp0", "0x0.0000000004682045C5p0", "0x0.0000000004740846E1p0",
"0x0.000000000480004800p0", "0x0.00000000048C084921p0", "0x0.000000000498204A46p0", "0x0.0000000004A4484B6Dp0",
"0x0.0000000004B0804C98p0", "0x0.0000000004BCC84DC5p0", "0x0.0000000004C9204EF6p0", "0x0.0000000004D588502Ap0",
"0x0.0000000004E2005161p0", "0x0.0000000004EE88529Bp0", "0x0.0000000004FB2053D8p0", "0x0.000000000507C85518p0",
"0x0.00000000051480565Cp0", "0x0.0000000005214857A3p0", "0x0.00000000052E2058EDp0", "0x0.00000000053B085A3Ap0",
"0x0.000000000548005B8Ap0", "0x0.000000000555085CDEp0", "0x0.000000000562205E35p0", "0x0.00000000056F485F8Fp0",
"0x0.00000000057C8060ECp0", "0x0.000000000589C8624Dp0", "0x0.0000000005972063B1p0", "0x0.0000000005A4886519p0",
"0x0.0000000005B2006684p0", "0x0.0000000005BF8867F2p0", "0x0.0000000005CD206963p0", "0x0.0000000005DAC86AD8p0",
"0x0.0000000005E8806C51p0", "0x0.0000000005F6486DCDp0", "0x0.000000000604206F4Cp0", "0x0.0000000006120870CFp0",
"0x0.000000000620007255p0", "0x0.00000000062E0873DFp0", "0x0.00000000063C20756Cp0", "0x0.00000000064A4876FDp0",
"0x0.000000000658807891p0", "0x0.000000000666C87A29p0", "0x0.000000000675207BC4p0", "0x0.000000000683887D64p0",
"0x0.000000000692007F06p0", "0x0.0000000006A08880ADp0", "0x0.0000000006AF208256p0", "0x0.0000000006BDC88404p0",
"0x0.0000000006CC8085B5p0", "0x0.0000000006DB48876Ap0", "0x0.0000000006EA208923p0", "0x0.0000000006F9088ADFp0",
"0x0.000000000708008CA0p0", "0x0.000000000717088E63p0", "0x0.00000000072620902Bp0", "0x0.0000000007354891F6p0",
"0x0.0000000007448093C6p0", "0x0.000000000753C89599p0", "0x0.000000000763209770p0", "0x0.00000000077288994Ap0",
"0x0.000000000782009B29p0", "0x0.000000000791889D0Bp0", "0x0.0000000007A1209EF2p0", "0x0.0000000007B0C8A0DCp0",
"0x0.0000000007C080A2CAp0", "0x0.0000000007D048A4BCp0", "0x0.0000000007E020A6B2p0", "0x0.0000000007F008A8ACp0",
            };
            ap_ufixed<31,-37> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            const static ap_ufixed<12,-53> f_x_lsb_table[64] = {
"0x0.00000000000000000p0", "0x0.00000000000000008p0", "0x0.00000000000000020p0", "0x0.00000000000000048p0",
"0x0.00000000000000080p0", "0x0.000000000000000c8p0", "0x0.00000000000000120p0", "0x0.00000000000000188p0",
"0x0.00000000000000200p0", "0x0.00000000000000288p0", "0x0.00000000000000320p0", "0x0.000000000000003c8p0",
"0x0.00000000000000480p0", "0x0.00000000000000548p0", "0x0.00000000000000620p0", "0x0.00000000000000708p0",
"0x0.00000000000000800p0", "0x0.00000000000000908p0", "0x0.00000000000000a20p0", "0x0.00000000000000b48p0",
"0x0.00000000000000c80p0", "0x0.00000000000000dc8p0", "0x0.00000000000000f20p0", "0x0.00000000000001088p0",
"0x0.00000000000001200p0", "0x0.00000000000001388p0", "0x0.00000000000001520p0", "0x0.000000000000016c8p0",
"0x0.00000000000001880p0", "0x0.00000000000001a48p0", "0x0.00000000000001c20p0", "0x0.00000000000001e08p0",
"0x0.00000000000002000p0", "0x0.00000000000002208p0", "0x0.00000000000002420p0", "0x0.00000000000002648p0",
"0x0.00000000000002880p0", "0x0.00000000000002ac8p0", "0x0.00000000000002d20p0", "0x0.00000000000002f88p0",
"0x0.00000000000003200p0", "0x0.00000000000003488p0", "0x0.00000000000003720p0", "0x0.000000000000039c8p0",
"0x0.00000000000003c80p0", "0x0.00000000000003f48p0", "0x0.00000000000004220p0", "0x0.00000000000004508p0",
"0x0.00000000000004800p0", "0x0.00000000000004b08p0", "0x0.00000000000004e20p0", "0x0.00000000000005148p0",
"0x0.00000000000005480p0", "0x0.000000000000057c8p0", "0x0.00000000000005b20p0", "0x0.00000000000005e88p0",
"0x0.00000000000006200p0", "0x0.00000000000006588p0", "0x0.00000000000006920p0", "0x0.00000000000006cc8p0",
"0x0.00000000000007080p0", "0x0.00000000000007448p0", "0x0.00000000000007820p0", "0x0.00000000000007c08p0",
            };
            ap_ufixed<12,-53> f_x_lsb = f_x_lsb_table[x_lsb_ind];

            ap_ufixed<14,-44> f_x_msb_4_lsb = x_msb_4 * x_lsb;

            ap_ufixed<15,-43> exp_x_msb_4_lsb_m_1_m1 = 0;
            exp_x_msb_4_lsb_m_1_m1(4,0) = f_x_lsb(11,7);
            exp_x_msb_4_lsb_m_1_m1 = exp_x_msb_4_lsb_m_1_m1 + f_x_msb_4_lsb;

            ap_ufixed<22,-43> exp_x_msb_4_lsb_m_1_m2 = exp_x_msb_4_lsb_m_1_m1;
            exp_x_msb_4_lsb_m_1_m2(6,0) = f_x_lsb(6,0);

            ap_ufixed<29,-36> exp_x_msb_4_lsb_m_1_m3 = 0;
            exp_x_msb_4_lsb_m_1_m3(27,0) = f_x_msb_4(30,3);
            exp_x_msb_4_lsb_m_1_m3 = exp_x_msb_4_lsb_m_1_m3 + exp_x_msb_4_lsb_m_1_m2;

            ap_ufixed<32,-36> exp_x_msb_4_lsb_m_1_m = exp_x_msb_4_lsb_m_1_m3;
            exp_x_msb_4_lsb_m_1_m(2,0) = f_x_msb_4(2,0);

            ap_ufixed<50,-18> exp_x_msb_4_lsb_m_1 = 0;
            exp_x_msb_4_lsb_m_1(49,36) = x_l(13,0);
            exp_x_msb_4_lsb_m_1(31, 0) = exp_x_msb_4_lsb_m_1_m(31,0);


            const static ap_ufixed<51,-21> f_x_msb_3_table[256] = {
"0x0", "0x0.00000000080000AAAAp0", "0x0.000000002000055556p0", "0x0.000000004800120003p0",
"0x0.0000000080002AAAB5p0", "0x0.00000000C80053556Fp0", "0x0.000000012000900036p0", "0x0.000000018800E4AB0Ep0",
"0x0.000000020001555600p0", "0x0.000000028801E60111p0", "0x0.0000000320029AAC4Bp0", "0x0.00000003C8037757B7p0",
"0x0.000000048004800360p0", "0x0.000000054805B8AF50p0", "0x0.000000062007255B96p0", "0x0.000000070808CA083Dp0",
"0x0.00000008000AAAB555p0", "0x0.00000009080CCB62EDp0", "0x0.0000000A200F301116p0", "0x0.0000000B4811DCBFE0p0",
"0x0.0000000C8014D56F60p0", "0x0.0000000DC8181E1FA7p0", "0x0.0000000F201BBAD0CBp0", "0x0.00000010881FAF82E1p0",
"0x0.000000120024003600p0", "0x0.000000138828B0EA3Fp0", "0x0.00000015202DC59FB6p0", "0x0.00000016C83342567Fp0",
"0x0.0000001880392B0EB5p0", "0x0.0000001A483F83C874p0", "0x0.0000001C20465083D6p0", "0x0.0000001E084D9540FBp0",
"0x0.000000200055560001p0", "0x0.00000022085D96C106p0", "0x0.0000002420665B842Cp0", "0x0.00000026486FA84995p0",
"0x0.000000288079811161p0", "0x0.0000002AC883E9DBB6p0", "0x0.0000002D208EE6A8B8p0", "0x0.0000002F889A7B788Cp0",
"0x0.0000003200A6AC4B58p0", "0x0.0000003488B37D2145p0", "0x0.0000003720C0F1FA7Ap0", "0x0.00000039C8CF0ED721p0",
"0x0.0000003C80DDD7B765p0", "0x0.0000003F48ED509B71p0", "0x0.0000004220FD7D8371p0", "0x0.00000045090E626F94p0",
"0x0.000000480120036008p0", "0x0.0000004B09326454FBp0", "0x0.0000004E2145894E9Fp0", "0x0.000000514959764D26p0",
"0x0.00000054816E2F50C1p0", "0x0.00000057C983B859A4p0", "0x0.0000005B219A156804p0", "0x0.0000005E89B14A7C16p0",
"0x0.0000006201C95B9611p0", "0x0.0000006589E24CB62Cp0", "0x0.0000006921FC21DCA0p0", "0x0.0000006CCA16DF09A6p0",
"0x0.000000708232883D78p0", "0x0.000000744A4F217853p0", "0x0.00000078226CAEBA73p0", "0x0.0000007C0A8B340414p0",
"0x0.0000008002AAB55577p0", "0x0.000000840ACB36AEDAp0", "0x0.0000008822ECBC107Dp0", "0x0.0000008C4B0F497AA3p0",
"0x0.000000908332E2ED8Ep0", "0x0.00000094CB578C6981p0", "0x0.00000099237D49EEC0p0", "0x0.0000009D8BA41F7D92p0",
"0x0.000000A203CC11163Dp0", "0x0.000000A68BF522B908p0", "0x0.000000AB241F58663Cp0", "0x0.000000AFCC4AB61E22p0",
"0x0.000000B484773FE105p0", "0x0.000000B94CA4F9AF31p0", "0x0.000000BE24D3E788F1p0", "0x0.000000C30D040D6E94p0",
"0x0.000000C805356F6068p0", "0x0.000000CD0D68115EBCp0", "0x0.000000D2259BF769E1p0", "0x0.000000D74DD1258228p0",
"0x0.000000DC86079FA7E4p0", "0x0.000000E1CE3F69DB69p0", "0x0.000000E72678881D0Bp0", "0x0.000000EC8EB2FE6D1Fp0",
"0x0.000000F206EED0CBFDp0", "0x0.000000F78F2C0339FAp0", "0x0.000000FD276A99B771p0", "0x0.00000102CFAA9844BBp0",
"0x0.0000010887EC02E231p0", "0x0.0000010E502EDD9030p0", "0x0.0000011428732C4F14p0", "0x0.0000011A10B8F31F3Bp0",
"0x0.000001200900360103p0", "0x0.000001261148F8F4CBp0", "0x0.0000012C29933FFAF5p0", "0x0.0000013251DF0F13E1p0",
"0x0.000001388A2C6A3FF3p0", "0x0.0000013ED27B557F8Dp0", "0x0.000001452ACBD4D315p0", "0x0.0000014B931DEC3AEFp0",
"0x0.000001520B719FB782p0", "0x0.0000015893C6F34937p0", "0x0.0000015F2C1DEAF074p0", "0x0.00000165D4768AADA5p0",
"0x0.0000016C8CD0D68133p0", "0x0.00000173552CD26B89p0", "0x0.0000017A2D8A826D16p0", "0x0.0000018115E9EA8645p0",
"0x0.000001880E4B0EB785p0", "0x0.0000018F16ADF30147p0", "0x0.000001962F129B63FAp0", "0x0.0000019D57790BE010p0",
"0x0.000001A48FE14875FBp0", "0x0.000001ABD84B552630p0", "0x0.000001B330B735F122p0", "0x0.000001BA9924EED748p0",
"0x0.000001C2119483D917p0", "0x0.000001C99A05F8F707p0", "0x0.000001D13279523191p0", "0x0.000001D8DAEE93892Ep0",
"0x0.000001E09365C0FE59p0", "0x0.000001E85BDEDE918Dp0", "0x0.000001F03459F04347p0", "0x0.000001F81CD6FA1405p0",
"0x0.000002001556000444p0", "0x0.000002081DD7061485p0", "0x0.00000210365A104547p0", "0x0.000002185EDF22970Dp0",
"0x0.000002209766410A5Ap0", "0x0.00000228DFEF6F9FAFp0", "0x0.00000231387AB25793p0", "0x0.00000239A1080D328Ap0",
"0x0.00000242199784311Cp0", "0x0.0000024AA2291B53CFp0", "0x0.000002533ABCD69B2Dp0", "0x0.0000025BE352BA07BEp0",
"0x0.000002649BEAC99A0Dp0", "0x0.0000026D64850952A7p0", "0x0.000002763D217D3216p0", "0x0.0000027F25C02938EAp0",
"0x0.000002881E611167B0p0", "0x0.00000291270439BEF8p0", "0x0.0000029A3FA9A63F53p0", "0x0.000002A368515AE951p0",
"0x0.000002ACA0FB5BBD86p0", "0x0.000002B5E9A7ACBC86p0", "0x0.000002BF425651E6E4p0", "0x0.000002C8AB074F3D36p0",
"0x0.000002D223BAA8C013p0", "0x0.000002DBAC70627012p0", "0x0.000002E54528804DCDp0", "0x0.000002EEEDE30659DBp0",
"0x0.000002F8A69FF894D9p0", "0x0.000003026F5F5AFF61p0", "0x0.0000030C4821319A10p0", "0x0.0000031630E5806584p0",
"0x0.0000032029AC4B625Bp0", "0x0.0000032A3275969134p0", "0x0.000003344B4165F2B1p0", "0x0.0000033E740FBD8772p0",
"0x0.00000348ACE0A1501Bp0", "0x0.00000352F5B4154D4Fp0", "0x0.0000035D4E8A1D7FB2p0", "0x0.00000367B762BDE7EAp0",
"0x0.00000372303DFA869Ep0", "0x0.0000037CB91BD75C75p0", "0x0.0000038751FC586A18p0", "0x0.00000391FADF81B02Fp0",
"0x0.0000039CB3C5572F67p0", "0x0.000003A77CADDCE86Ap0", "0x0.000003B2559916DBE4p0", "0x0.000003BD3E87090A84p0",
"0x0.000003C83777B774F8p0", "0x0.000003D3406B261BF0p0", "0x0.000003DE596159001Cp0", "0x0.000003E9825A54222Dp0",
"0x0.000003F4BB561B82D7p0", "0x0.000004000454B322CCp0", "0x0.0000040B5D561F02C2p0", "0x0.00000416C65A63236Ep0",
"0x0.000004223F61838586p0", "0x0.0000042DC86B8429C2p0", "0x0.0000043961786910DBp0", "0x0.000004450A88363B8Ap0",
"0x0.00000450C39AEFAA8Ap0", "0x0.0000045C8CB0995E96p0", "0x0.0000046865C937586Bp0", "0x0.000004744EE4CD98C6p0",
"0x0.000004804803602067p0", "0x0.0000048C5124F2F00Cp0", "0x0.000004986A498A0876p0", "0x0.000004A49371296A67p0",
"0x0.000004B0CC9BD516A1p0", "0x0.000004BD15C9910DE8p0", "0x0.000004C96EFA615101p0", "0x0.000004D5D82E49E0B0p0",
"0x0.000004E251654EBDBDp0", "0x0.000004EEDA9F73E8F0p0", "0x0.000004FB73DCBD6310p0", "0x0.000005081D1D2F2CE7p0",
"0x0.00000514D660CD4740p0", "0x0.000005219FA79BB2E7p0", "0x0.0000052E78F19E70A8p0", "0x0.0000053B623ED98150p0",
"0x0.000005485B8F50E5AFp0", "0x0.0000055564E3089E93p0", "0x0.000005627E3A04ACCEp0", "0x0.0000056FA794491131p0",
"0x0.0000057CE0F1D9CC8Ep0", "0x0.0000058A2A52BADFBAp0", "0x0.0000059783B6F04B88p0", "0x0.000005A4ED1E7E10CFp0",
"0x0.000005B26689683064p0", "0x0.000005BFEFF7B2AB20p0", "0x0.000005CD89696181DBp0", "0x0.000005DB32DE78B56Fp0",
"0x0.000005E8EC56FC46B6p0", "0x0.000005F6B5D2F0368Cp0", "0x0.000006048F525885CDp0", "0x0.0000061278D5393558p0",
"0x0.00000620725B96460Ap0", "0x0.0000062E7BE573B8C3p0", "0x0.0000063C9572D58E64p0", "0x0.0000064ABF03BFC7CEp0",
"0x0.00000658F8983665E5p0", "0x0.0000066742303D698Bp0", "0x0.000006759BCBD8D3A5p0", "0x0.00000684056B0CA519p0",
"0x0.000006927F0DDCDECEp0", "0x0.000006A108B44D81AAp0", "0x0.000006AFA25E628E98p0", "0x0.000006BE4C0C20067Fp0",
"0x0.000006CD05BD89EA4Bp0", "0x0.000006DBCF72A43AE8p0", "0x0.000006EAA92B72F942p0", "0x0.000006F992E7FA2646p0",
"0x0.000007088CA83DC2E4p0", "0x0.00000717966C41D00Ap0", "0x0.00000726B0340A4EAAp0", "0x0.00000735D9FF9B3FB6p0",
"0x0.0000074513CEF8A41Ep0", "0x0.000007545DA2267CD9p0", "0x0.00000763B77928CAD9p0", "0x0.000007732154038F14p0",
"0x0.000007829B32BACA82p0", "0x0.000007922515527E1Ap0", "0x0.000007A1BEFBCEAAD4p0", "0x0.000007B168E63351AAp0",
"0x0.000007C122D4847397p0", "0x0.000007D0ECC6C61195p0", "0x0.000007E0C6BCFC2CA3p0", "0x0.000007F0B0B72AC5BEp0",
            };
            ap_ufixed<51,-21> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<62,-10> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(61,54) = x_msb_3(7,0);
            exp_x_msb_3_m_1(50, 0) = f_x_msb_3(50,0);

            ap_ufixed<50,-10> exp_x_msb_3_m_1_s = exp_x_msb_3_m_1;
            ap_ufixed<100,-28> f_x_msb_3_4_lsb = exp_x_msb_3_m_1_s * exp_x_msb_4_lsb_m_1;
            ap_ufixed<44,-28> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<63, -9> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_lsb_m_1;


            const static ap_ufixed<64,-4> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.00000800AAB555DDEp0", "0x0.00002005560011127p0", "0x0.00004812036081A9Cp0",
"0x0.0000802AB55777D28p0", "0x0.0000C8536F6684062p0", "0x0.0001209036103740Dp0", "0x0.000188E50ED8634A0p0",
"0x0.0002015600445B0C3p0", "0x0.000289E711DB32FD7p0", "0x0.0003229C4C260197Ep0", "0x0.0003CB79B8B01FE26p0",
"0x0.0004848362076A08Dp0", "0x0.00054DBD53BC80058p0", "0x0.0006272B9A630659Dp0", "0x0.000710D24391E6D7Ap0",
"0x0.00080AB55DE3917ABp0", "0x0.000914D8F8F63D524p0", "0x0.000A2F41256C297AFp0", "0x0.000B59F1F4EBDE291p0",
"0x0.000C94EF7A206DC2Dp0", "0x0.000DE03DC8B9B60B1p0", "0x0.000F3BE0F56CA15C4p0", "0x0.0010A7DD15F367F40p0",
"0x0.00122436410DD14E5p0", "0x0.0013B0F08E817591Ep0", "0x0.00154E101719FF0C5p0", "0x0.0016FB98F4A96BBEFp0",
"0x0.0018B98F42084EFBDp0", "0x0.001A87F71B1613137p0", "0x0.001C66D49CB93B127p0", "0x0.001E562BE4DFA4904p0",
"0x0.00205601127EC98E0p0", "0x0.00226658459402659p0", "0x0.002487359F24C7C99p0", "0x0.0026B89D413EF4D5Ep0",
"0x0.0028FA934EF909304p0", "0x0.002B4D1BEC726B39Cp0", "0x0.002DB03B3ED3AA50Ep0", "0x0.003023F56C4EC123Fp0",
"0x0.0032A84E9C1F58145p0", "0x0.00353D4AF68B07AA1p0", "0x0.0037E2EEA4E19B185p0", "0x0.003A993DD17D52D25p0",
"0x0.003D603CA7C32730Fp0", "0x0.004037EF54230B293p0", "0x0.0043205A04182F12Fp0", "0x0.00461980E62943810p0",
"0x0.0049236829E8BC292p0", "0x0.004C3E13FFF512DD8p0", "0x0.004F698899F90A966p0", "0x0.0052A5CA2AABF28D0p0",
"0x0.0055F2DCE5D1E966Ep0", "0x0.005950C5003C20723p0", "0x0.005CBF86AFC91EF2Bp0", "0x0.00603F262B65057FCp0",
"0x0.0063CFA7AB09D1732p0", "0x0.0067710F67BFA0687p0", "0x0.006B23619B9CF3CDEp0", "0x0.006EE6A281C6F4857p0",
"0x0.0072BAD65671B6977p0", "0x0.0076A00156E07CF57p0", "0x0.007A9627C165FD4EDp0", "0x0.007E9D4DD564A3F5Ep0",
"0x0.0082B577D34ED7D5Bp0", "0x0.0086DEA9FCA73E799p0", "0x0.008B18E8940100253p0", "0x0.008F6437DD000BFDAp0",
"0x0.0093C09C1C595C43Ep0", "0x0.00982E1997D33A9FCp0", "0x0.009CACB49645847CCp0", "0x0.00A13C715F99EF773p0",
"0x0.00A5DD543CCC4DDAFp0", "0x0.00AA8F6177EAD3336p0", "0x0.00AF529D5C1658EBCp0", "0x0.00B4270C3582A301Dp0",
"0x0.00B90CB25176A4C8Bp0", "0x0.00BE0393FE4CC5BD7p0", "0x0.00C30BB58B73266CAp0", "0x0.00C8251B496BE5696p0",
"0x0.00CD4FC989CD64555p0", "0x0.00D28BC49F428CFA3p0", "0x0.00D7D910DD8B16743p0", "0x0.00DD37B2997BCA6E6p0",
"0x0.00E2A7AE28FECA6FBp0", "0x0.00E82907E313D5399p0", "0x0.00EDBBC41FD08C383p0", "0x0.00F35FE73860B9038p0",
"0x0.00F91575870692F24p0", "0x0.00FEDC73671B04BDFp0", "0x0.0104B4E5350DF2386p0", "0x0.010A9ECF4E667E12Dp0",
"0x0.01109A3611C34FB64p0", "0x0.0116A71DDEDAD92D8p0", "0x0.011CC58B167B9D206p0", "0x0.0122F5821A8C74E0Dp0",
"0x0.012937074E0CD6893p0", "0x0.012F8A1F15151B2C6p0", "0x0.0135EECDD4D6C5172p0", "0x0.013C6517F39CC6233p0",
"0x0.0142ED01D8CBC61C4p0", "0x0.0149868FECE26935Dp0", "0x0.015031C6997996937p0", "0x0.0156EEAA4944BEE23p0",
"0x0.015DBD3F68122303Ep0", "0x0.01649D8A62CB1ACBEp0", "0x0.016B8F8FA7745BCDBp0", "0x0.01729353A52E403D8p0",
"0x0.0179A8DACC350DE1Dp0", "0x0.0180D0298DE13D179p0", "0x0.018809445CA7BFE78p0", "0x0.018F542FAC1A492D6p0",
"0x0.0196B0EFF0E793D15p0", "0x0.019E1F89A0DBAA128p0", "0x0.01A5A00132E02CE42p0", "0x0.01AD325B1EFC9B5BCp0",
"0x0.01B4D69BDE569A322p0", "0x0.01BC8CC7EB323B553p0", "0x0.01C454E3C0F2458C8p0", "0x0.01CC2EF3DC187C2F6p0",
"0x0.01D41AFCBA45E6ED2p0", "0x0.01DC1902DA3B19A6Dp0", "0x0.01E4290ABBD87C5BCp0", "0x0.01EC4B18E01E9326Fp0",
"0x0.01F47F31C92E464FCp0", "0x0.01FCC559FA492A6B6p0", "0x0.02051D95F7D1C8917p0", "0x0.020D87EA474BE6A1Cp0",
"0x0.0216045B6F5CCF9CEp0", "0x0.021E92EDF7CB9C0E4p0", "0x0.022733A669817A88Ap0", "0x0.022FE6894E89F834Cp0",
"0x0.0238AB9B321349722p0", "0x0.024182E0A06E9289Bp0", "0x0.024A6C5E271030733p0", "0x0.02536818549001AC1p0",
"0x0.025C7613B8A9AF215p0", "0x0.02659654E43CF52B1p0", "0x0.026EC8E0694DEC9A9p0", "0x0.02780DBADB0553DA6p0",
"0x0.028164E8CDB0D8211p0", "0x0.028ACE6ED6C35EB5Fp0", "0x0.02944A518CD54E484p0", "0x0.029DD89587A4D858Dp0",
"0x0.02A7793F601642B5Dp0", "0x0.02B12C53B03431090p0", "0x0.02BAF1D7132FEE788p0", "0x0.02C4C9CE2561B759Fp0",
"0x0.02CEB43D844902F7Ap0", "0x0.02D8B129CE8CCD68Fp0", "0x0.02E2C097A3FBE17C9p0", "0x0.02ECE28BA58D22B56p0",
"0x0.02F7170A755FD759Ep0", "0x0.03015E18B6BBF2966p0", "0x0.030BB7BB0E125EB13p0", "0x0.031623F620FD4751Ep0",
"0x0.0320A2CE964063DACp0", "0x0.032B344915C941D54p0", "0x0.0335D86A48AF8F70Cp0", "0x0.03408F36D93566140p0",
"0x0.034B58B372C795013p0", "0x0.035634E4C1FDEC0D0p0", "0x0.036123CF749B8667Cp0", "0x0.036C2578398F157A0p0",
"0x0.037739E3C0F32BD30p0", "0x0.03826116BC0E882ACp0", "0x0.038D9B15DD5460763p0", "0x0.0398E7E5D864AD0E9p0",
"0x0.03A4478B620C73EB5p0", "0x0.03AFBA0B304613EEDp0", "0x0.03BB3F69FA3990464p0", "0x0.03C6D7AC783CDBDBFp0",
"0x0.03D282D763D424DCDp0", "0x0.03DE40EF77B220509p0", "0x0.03EA11F96FB855C4Fp0", "0x0.03F5F5FA08F76B0BBp0",
"0x0.0401ECF601AF700BDp0", "0x0.040DF6F219502AA55p0", "0x0.041A13F3107962A88p0", "0x0.042643FDA8FB2DDFBp0",
"0x0.04328716A5D63C2C4p0", "0x0.043EDD42CB3C23B6Dp0", "0x0.044B4686DE8FAD325p0", "0x0.0457C2E7A66520322p0",
"0x0.04645269EA828F932p0", "0x0.0470F51273E025F89p0", "0x0.047DAAE60CA8725B3p0", "0x0.048A73E98038B4ABFp0",
"0x0.049750219B212A8A0p0", "0x0.04A43F932B255C0B7p0", "0x0.04B14242FF3C689A0p0", "0x0.04BE5835E79153E1Dp0",
"0x0.04CB8170B58352D4Ep0", "0x0.04D8BDF83BA618C04p0", "0x0.04E60DD14DC22475Ep0", "0x0.04F37100C0D50D88Ep0",
"0x0.0500E78B6B11D19D6p0", "0x0.050E717623E121CBAp0", "0x0.051C0EC5C3E1B016Cp0", "0x0.0529BF7F24E87CF6Ap0",
"0x0.053783A7220124F51p0", "0x0.05455B42976E2E5EAp0", "0x0.0553465662A95706Bp0", "0x0.056144E76263E21F4p0",
"0x0.056F56FA7686E623Ep0", "0x0.057D7C9480339AD83p0", "0x0.058BB5BA61C3A75A3p0", "0x0.059A0270FEC97047Ap0",
"0x0.05A862BD3C1065F74p0", "0x0.05B6D6A3FF9D52C58p0", "0x0.05C55E2A30AEA974Ep0", "0x0.05D3F954B7BCD3A1Bp0",
"0x0.05E2A8287E7A8049Ep0", "0x0.05F16AAA6FD4F267Bp0", "0x0.060040DF77F44FA13p0", "0x0.060F2ACC843BEF0A0p0",
"0x0.061E2876834AA7FA4p0", "0x0.062D39E264FB20F7Ep0", "0x0.063C5F151A641EB4Cp0", "0x0.064B981395D8D31FEp0",
"0x0.065AE4E2CAE92C8AAp0", "0x0.066A4587AE6224E1Cp0", "0x0.0679BA07364E10FA3p0", "0x0.0689426659F4EFF1Bp0",
"0x0.0698DEAA11DCBAA37p0", "0x0.06A88ED757C9B3304p0", "0x0.06B852F326BEB49B0p0", "0x0.06C82B027AFD8278Ap0",
"0x0.06D8170A520718B46p0", "0x0.06E8170FAA9BFB67Ep0", "0x0.06F82B1784BC86C72p0", "0x0.07085326E1A93F207p0",
"0x0.07188F42C3E320F0Bp0", "0x0.0728DF702F2BF10B2p0", "0x0.073943B428868CD5Ap0", "0x0.0749BC13B6373A98Fp0",
"0x0.075A4893DFC3F9E4Cp0", "0x0.076AE939ADF4D4083p0", "0x0.077B9E0A2AD42C9E8p0", "0x0.078C670A61AF122F4p0",
"0x0.079D443F5F158EE3Ap0", "0x0.07AE35AE30DAF94F1p0", "0x0.07BF3B5BE616454CBp0", "0x0.07D0554D8F2254F0Cp0",
"0x0.07E183883D9E498E2p0", "0x0.07F2C611046DD4D06p0", "0x0.08041CECF7B989EA2p0", "0x0.081588212CEF2ED73p0",
"0x0.082707B2BAC20DB40p0", "0x0.08389BA6B92B46284p0", "0x0.084A4402416A1EE6Fp0", "0x0.085C00CA6E045741Fp0",
"0x0.086DD2045AC678D2Bp0", "0x0.087FB7B524C42936Cp0", "0x0.0891B1E1EA587BE12p0", "0x0.08A3C08FCB2643FFEp0",
            };
            ap_ufixed<64,-4> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 6,-4> f_x_msb_2_h;
            f_x_msb_2_h(5,0) = f_x_msb_2(63,58);
            ap_ufixed< 9,-1> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<67,-1> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(66,58) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(57, 0) = f_x_msb_2(57,0);

            ap_ufixed<130,-10> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<62,-10> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<72,0> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<68,32> exp_x_msb_1_table[256] = {
"0x1.000000000p0", "0x1.48B5E3C3Ep0", "0x1.A61298E1Ep0", "0x2.1DF3B68CFp0",
"0x2.B7E151628p0", "0x3.7D871DB61p0", "0x4.7B4FF993Fp0", "0x5.C12DA416Ep0",
"0x7.63992E353p0", "0x9.7CDC417A3p0", "0xC.2EB7EC98Fp0", "0xF.A48385EDFp0",
"0x14.15E5BF6FBp0", "0x19.CA53B7811p0", "0x21.1D8E4272Dp0", "0x2A.8565A144Cp0",
"0x36.99205C4E7p0", "0x46.1AFC4DB59p0", "0x5A.0462B7877p0", "0x73.9593ABB7Dp0",
"0x94.69C4CB819p0", "0xBE.90F6F83E9p0", "0xF4.B122790DDp0", "0x13A.30CF1CCBBp0",
"0x193.6DC5690C0p0", "0x206.03487A3B1p0", "0x299.2442102D9p0", "0x356.0F0B0F980p0",
"0x448.A216ABB76p0", "0x580.1AD754FA3p0", "0x710.0ADBAC7DAp0", "0x911.9289C3923p0",
"0xBA4.F53EA3863p0", "0xEF3.A035D5798p0", "0x1332.C4D2B7C4Ap0", "0x18A6.B027DA0A7p0",
"0x1FA7.157C470F8p0", "0x28A4.90D2CCEF1p0", "0x342F.BA11823B8p0", "0x4302.3A933EE5Cp0",
"0x560A.773E54157p0", "0x6E7A.8ABB4A83Cp0", "0x8DDB.80AF4269Dp0", "0xB626.0748BAEC7p0",
"0xE9E2.2447727BFp0", "0x12C4F.EB75B2AB0p0", "0x1819B.C560F6113p0", "0x1EF21.8F1B001A4p0",
"0x27BC2.CA9A6F934p0", "0x33055.49F35D91Fp0", "0x41831.49596E996p0", "0x541E7.E56949D58p0",
"0x6C02D.645AB2554p0", "0x8AB06.0A3EE9FB1p0", "0xB2148.5EAE56C5Bp0", "0xE4A8D.2881EDBE8p0",
"0x1259AC.48BF05D6Ep0", "0x178FEE.7792E44B3p0", "0x1E4127.437732B71p0", "0x26D8F9.4A204BEA5p0",
"0x31E199.5F5A550DDp0", "0x400C7D.64D3386CBp0", "0x523D82.79EDAEF9Cp0", "0x69993D.D4F2D9524p0",
"0x87975E.854001024p0", "0xAE1A47.C38A42CD0p0", "0xDF8D5F.6DCFE5CEAp0", "0x11F0BF8.1E99FDEB6p0",
"0x1709348.C0EA4F8CEp0", "0x1D94295.464477ACCp0", "0x25FAD90.65C78E342p0", "0x30C4623.616ED2BE2p0",
"0x3E9E441.232817A61p0", "0x506744D.3B342FC94p0", "0x673D70B.C00F1F76Dp0", "0x849012B.C127FC962p0",
"0xAA36C7C.F69370B94p0", "0xDA8F202.DD9ACE661p0", "0x118A2AAE.0AA05236Bp0", "0x16857CFA.1AA8A5555p0",
"0x1CEB088B.68E804021p0", "0x2521AEDA.32CD52BE5p0", "0x2FAD89E1.79BAB8EADp0", "0x3D3838C6.BE0F13F06p0",
"0x4E9B87F6.7BB3F5597p0", "0x64EF201B.01109A4A5p0", "0x819A1801.9394C0D96p0", "0xA6698403.CF5D9E663p0",
"0xD5AD6DCE.21AFFC0DDp0", "0x1125E066B.0B19418CCp0", "0x1604B68CF.05F65FAA9p0", "0x1C45AED0A.D0C934CDCp0",
"0x244D5E676.3FB814AF0p0", "0x2E9CEBF49.9C21839C7p0", "0x3BDA2CBD0.9F5AC2146p0", "0x4CDA0FD41.989F004E7p0",
"0x62ADFED51.D7EDCCDE6p0", "0x7EB50B520.76F91D6E8p0", "0xA2B1FD3D9.A57B6C33Cp0", "0xD0E7A50F4.EF0D7447Fp0",
"0x10C3D39209.62C88AAFBp0", "0x1586D0722B.3EEB27301p0", "0x1BA4068AAC.2B6E3EE34p0", "0x237DCBF1E5.709A9F9C1p0",
"0x2D9264D2D4.D6B94153Bp0", "0x3A83F23B18.FE5BD524Ap0", "0x4B22A1B5C3.27A2FD85Ap0", "0x6079C1866C.71A93951Dp0",
"0x7BE08BDFD9.CC72249ABp0", "0x9F0FB7309C.B446D3919p0", "0xCC3D265776.C3D25779Ep0", "0x1063F7612B0.C0831CA6Cp0",
"0x150BBA37963.79A4FB6ADp0", "0x1B05FA9B62E.737D935B8p0", "0x22B2DC5C41D.AD89559EBp0", "0x2C8DD1AB28B.404414BE7p0",
"0x39355C8C638.0AC5631B1p0", "0x49750434675.301B8D0E7p0", "0x5E521E7A16E.51F9CD3C2p0", "0x791C3B06F8B.EA2DEC48Cp0",
"0x9B823857614.764F43E20p0", "0xC7AD559D438.E7C270C30p0", "0x10063F4E687B.A1A43A35Bp0", "0x149363C905BA.3641D0164p0",
"0x1A6B765D8CDF.6CDBF1C63p0", "0x21EC75240E66.E2891CE63p0", "0x2B8F1073A6AF.BA219DB61p0", "0x37EE3FFC0063.E360F931Fp0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000001p0", "0x0.000000001p0", "0x0.000000002p0",
"0x0.000000002p0", "0x0.000000003p0", "0x0.000000004p0", "0x0.000000005p0",
"0x0.000000007p0", "0x0.000000009p0", "0x0.00000000Bp0", "0x0.00000000Ep0",
"0x0.000000013p0", "0x0.000000018p0", "0x0.00000001Fp0", "0x0.000000028p0",
"0x0.000000034p0", "0x0.000000042p0", "0x0.000000055p0", "0x0.00000006Ep0",
"0x0.00000008Dp0", "0x0.0000000B5p0", "0x0.0000000E9p0", "0x0.00000012Bp0",
"0x0.000000181p0", "0x0.0000001EEp0", "0x0.00000027Ap0", "0x0.00000032Fp0",
"0x0.000000416p0", "0x0.00000053Fp0", "0x0.0000006BDp0", "0x0.0000008A7p0",
"0x0.000000B1Cp0", "0x0.000000E44p0", "0x0.000001252p0", "0x0.000001786p0",
"0x0.000001E35p0", "0x0.0000026C9p0", "0x0.0000031CEp0", "0x0.000003FF3p0",
"0x0.00000521Dp0", "0x0.000006970p0", "0x0.000008762p0", "0x0.00000ADD6p0",
"0x0.00000DF36p0", "0x0.000011E9Cp0", "0x0.000017003p0", "0x0.00001D88Ap0",
"0x0.000025EC0p0", "0x0.000030B15p0", "0x0.00003E85Dp0", "0x0.00005047Ep0",
"0x0.000067153p0", "0x0.0000845C6p0", "0x0.0000A9F46p0", "0x0.0000DA39Ep0",
"0x0.000118354p0", "0x0.000167CB5p0", "0x0.0001CDFC2p0", "0x0.000251334p0",
"0x0.0002F9AF3p0", "0x0.0003D205Ap0", "0x0.0004E7CE2p0", "0x0.00064C7C6p0",
"0x0.000816791p0", "0x0.000A628A3p0", "0x0.000D55A1Fp0", "0x0.00111F30Fp0",
"0x0.0015FC210p0", "0x0.001C3AA91p0", "0x0.00243F374p0", "0x0.002E8ABFCp0",
"0x0.003BC2D73p0", "0x0.004CBC19Ap0", "0x0.006287862p0", "0x0.007E83A56p0",
"0x0.00A2728F8p0", "0x0.00D096336p0", "0x0.010BD4A5Ap0", "0x0.0157E6BFEp0",
"0x0.01B993FE0p0", "0x0.0236FF5BFp0", "0x0.02D80A08Dp0", "0x0.03A6D2222p0",
"0x0.04B0556E0p0", "0x0.0605424D5p0", "0x0.07BB04063p0", "0x0.09ED1B429p0",
"0x0.0CBED8666p0", "0x0.105D93892p0", "0x0.150385C09p0", "0x0.1AFB718E8p0",
"0x0.22A555477p0", "0x0.2C7C72FC0p0", "0x0.391F0EE49p0", "0x0.495860DCAp0",
"0x0.5E2D58D8Bp0", "0x0.78ED03AFBp0", "0x0.9B4597E37p0", "0x0.C75F7CF56p0",
            };
            ap_ufixed<68,32> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<140,32> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<33) {
            bool overf = 0;
            VITIS_LOOP_934_21: for (int j = 63; j >= I_+31; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_940_22: for (int j = 63; j >= I_+31; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_944_23: for (int j = I_+30; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    }
    return r;
}


template<int WO_, int I_, int WI_>
ap_fixed<WO_,I_> exp_core(ap_fixed<WI_,I_> x)
{
#pragma HLS pipeline

 const static int FO_ = WO_ - I_;
    const static int FI_ = WI_ - I_;


    if (I_>33) return 0;
    else if (FO_>32) return 0;
    else if (FI_>100) return 0;




    int I_s_;
    int M_ = (I_-1>FO_) ? (I_-1) : FO_;
    if (M_==1) I_s_ = 1;
    else if (M_==2) I_s_ = 2;
    else if (M_<6) I_s_ = 3;
    else if (M_<12) I_s_ = 4;
    else if (M_<24) I_s_ = 5;
    else I_s_ = 6;

    ap_fixed<WO_,I_> r = 0;

    ap_ufixed<1,-FO_> delta = 0;
    delta[0] = 1;

    if (I_s_==1) {






        const static int w = 7;
        const static int we = 2;
        const static int wf = 5;

        ap_fixed<w,we> x_l = x;
        ap_ufixed<3,2> y = 0;
        ap_ufixed<5,0> x_l_fract=0;
        x_l_fract(4,0) = x_l(4,0);


        if (x_l[6]!=x_l[5]) {
            if (!x_l[6]) y = "0x1.8p0";
        } else {
            if (!x_l[6]) y[1] = 1;

            if (!x_l[6]&(x_l[4]|(x_l[2]&x_l[3]))) y[0]=1;
            if (!x_l[6]&x_l[2]&x_l[3]) y[0]=1;
            if (x_l[6]&((x_l[4]&x_l[3])|x_l[5])) y[0] = 1;
            if (x_l[6]&x_l[5]&!x_l[4]&x_l[3]&!x_l[2]&x_l[1]) y[0] = 1;
        }
        y += delta;

            if (y[1]|y[2]) {
                y[2] = 0;
                y[1] = 0;
                y[0] = 1;
            }

        r = y;

    } else if (I_s_==2) {
        const static int w = 10;
        const static int we = 3;
        const static int wf = 7;


        ap_fixed<w,we> x_l = x;
        ap_ufixed<5,3> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(wf+1,wf);
        ap_ufixed<7,0> x_l_fract;
        x_l_fract(6,0) = x_l(6,0);

        ap_uint<5> x_msb_ind;
        x_msb_ind[3] = x_l[w-1];
        x_msb_ind(2,0) = x_l(wf,wf-3);
        ap_ufixed<4,-3> x_lsb = x_l;


        if ((x_l[w-1]!=x_l[w-2])||((x_l_int==1)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.54p0")))) {
            if (!x_l[w-1]) y = "0x3.cp0";
        } else {
            ap_ufixed<5,2> exp_x_msb_table[32] = {
               "0x1.00p0", "0x1.48p0", "0x1.A6p0", "0x2.1Dp0", "0x2.B7p0", "0x3.7Dp0", "0x4.7Bp0", "0x5.C1p0",
               "0x0.22p0", "0x0.2Cp0", "0x0.39p0", "0x0.49p0", "0x0.5Ep0", "0x0.78p0", "0x0.9Bp0", "0x0.C7p0",
            };
            ap_ufixed<5,2> exp_x_msb = exp_x_msb_table[x_msb_ind];


            ap_ufixed<5,0> y_lo = x_lsb * exp_x_msb;

            ap_ufixed<5,2> y_l = y_lo + exp_x_msb;

            y = y_l;
        }
        y += delta;
            bool overf = 0;
            VITIS_LOOP_1060_1: for (int j = 4; j >= I_+1; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1066_2: for (int j = 4; j >= I_+1; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1070_3: for (int j = I_; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        r = y;
    } else if (I_s_==3) {

        const static int w = 19;
        const static int we = 6;
        const static int wf = 13;

        ap_fixed<w,we> x_l = x;
        ap_ufixed<11,6> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(wf+2,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);




        if ((x_l[w-1]!=x_l[w-2])||(x_l[w-1]!=x_l[w-3])||(x_l[w-1]!=x_l[w-4])||((x_l_int==3)&&(x_l_fract>ap_ufixed<wf,0>("0x0.76FAp0")))) {
            if (!x_l[18]) y = "0x1f.f8p0";
        } else {
            const static int g = 2;
            const static int Maxprecision = FO_+we+g;
            ap_uint<4> x_msb_ind_1;
            x_msb_ind_1[3] = x_l[w-1];

            x_msb_ind_1(2,0) = x_l(wf+1,wf-1);

            ap_uint<6> x_msb_ind_2;
            x_msb_ind_2(5,0) = x_l(wf-2,wf-7);
            ap_ufixed<6,-1> x_msb_2 = x_l;

            ap_ufixed<wf-7,-7> x_lsb = x_l;

            const static ap_ufixed<Maxprecision,0> exp_x_msb_2_m_1_table[64] = {
                "0x0.0p0", "0x0.0202p0", "0x0.0408p0", "0x0.0612p0",
                "0x0.0820p0", "0x0.0A32p0", "0x0.0C49p0", "0x0.0E63p0",
                "0x0.1082p0", "0x0.12A5p0", "0x0.14CDp0", "0x0.16F9p0",
                "0x0.1929p0", "0x0.1B5Dp0", "0x0.1D96p0", "0x0.1FD4p0",
                "0x0.2216p0", "0x0.245Cp0", "0x0.26A7p0", "0x0.28F7p0",
                "0x0.2B4Bp0", "0x0.2DA4p0", "0x0.3001p0", "0x0.3264p0",
                "0x0.34CBp0", "0x0.3737p0", "0x0.39A8p0", "0x0.3C1Ep0",
                "0x0.3E98p0", "0x0.4118p0", "0x0.439Dp0", "0x0.4627p0",
                "0x0.48B5p0", "0x0.4B49p0", "0x0.4DE3p0", "0x0.5081p0",
                "0x0.5325p0", "0x0.55CEp0", "0x0.587Cp0", "0x0.5B2Fp0",
                "0x0.5DE9p0", "0x0.60A7p0", "0x0.636Bp0", "0x0.6635p0",
                "0x0.6904p0", "0x0.6BD9p0", "0x0.6EB3p0", "0x0.7194p0",
                "0x0.747Ap0", "0x0.7766p0", "0x0.7A57p0", "0x0.7D4Fp0",
                "0x0.804Dp0", "0x0.8350p0", "0x0.865Ap0", "0x0.896Ap0",
                "0x0.8C80p0", "0x0.8F9Cp0", "0x0.92BEp0", "0x0.95E7p0",
                "0x0.9916p0", "0x0.9C4Bp0", "0x0.9F87p0", "0x0.A2C9p0",
            };

            ap_ufixed<5,-8> f_x_msb_2_lsb = x_msb_2 * x_lsb;


            ap_ufixed<7,-6> f_x_msb_2_lsb_m_1_m=0;
            f_x_msb_2_lsb_m_1_m(5,0) = x_lsb(5,0);
            f_x_msb_2_lsb_m_1_m = f_x_msb_2_lsb_m_1_m + f_x_msb_2_lsb;


            ap_ufixed<Maxprecision+1,1> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<Maxprecision,1> exp_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_m_1_m + exp_x_msb_2_m_1;


            const static ap_ufixed<Maxprecision,5> exp_x_msb_1_table[16] = {
                "0x1.0000p0", "0x1.A612p0", "0x2.B7E1p0", "0x4.7B4Fp0",
                "0x7.6399p0", "0xC.2EB7p0", "0x14.15E5p0", "0x21.1D8Ep0",
                "0x0.04B0p0", "0x0.07BBp0", "0x0.0CBEp0", "0x0.1503p0",
                "0x0.22A5p0", "0x0.391Fp0", "0x0.5E2Dp0", "0x0.9B45p0",

            };
            ap_ufixed<Maxprecision,5> exp_x_msb = exp_x_msb_1_table[x_msb_ind_1];

            ap_ufixed<2*Maxprecision+1,6> y_lo = exp_x_msb * exp_x_msb_2_lsb_m_1;
            ap_ufixed<Maxprecision,5> y_lo_s = y_lo;
            ap_ufixed<Maxprecision,5> y_l = y_lo_s + exp_x_msb;
            y = y_l;

        }
        y += delta;

            bool overf = 0;
            VITIS_LOOP_1157_4: for (int j = 10; j >= I_+4; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1163_5: for (int j = 10; j >= I_+4; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1167_6: for (int j = I_+3; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    } else if (I_s_==4) {

        const static int wf = 25;
        const static int we = 12;
        const static int w = 37;
        ap_fixed<w,we> x_l = x;
        ap_ufixed<23,12> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(wf+3,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);
        bool overf = 0;
        VITIS_LOOP_1186_7: for (int j = wf+3; j < w-1; j++) {
#pragma HLS unroll
 if (x_l[w-1]!=x_l[j])
                overf = 1;
        }
        if (overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<wf,0>("0x0.9fe7038p0")))) {
            if (!x_l[w-1]) {
                VITIS_LOOP_1193_8: for (int j = 0; j < 22; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            const static int g = 2;
            const static int Maxprecision = 25;
            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1[4] = x_l[w-1];
            x_msb_ind_1(3,0) = x_l(wf+2,wf-1);

            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(wf-2,wf-6);
            ap_ufixed<5,-1> x_msb_2 = x_l;

            ap_uint<7> x_msb_ind_3;
            x_msb_ind_3(6,0) = x_l(wf-7,wf-13);
            ap_ufixed<7,-6> x_msb_3 = x_l;

            ap_ufixed<7,-13> x_lsb = x_l;

            const static ap_ufixed<12,-13> f_x_msb_3_m_1_table[128] = {
"0x0.0p0", "0x0.0000002p0", "0x0.0000008p0", "0x0.0000012p0",
"0x0.0000020p0", "0x0.0000032p0", "0x0.0000048p0", "0x0.0000062p0",
"0x0.0000080p0", "0x0.00000A2p0", "0x0.00000C8p0", "0x0.00000F2p0",
"0x0.0000120p0", "0x0.0000152p0", "0x0.0000188p0", "0x0.00001C2p0",
"0x0.0000200p0", "0x0.0000242p0", "0x0.0000288p0", "0x0.00002D2p0",
"0x0.0000320p0", "0x0.0000372p0", "0x0.00003C8p0", "0x0.0000422p0",
"0x0.0000481p0", "0x0.00004E3p0", "0x0.0000549p0", "0x0.00005B3p0",
"0x0.0000621p0", "0x0.0000693p0", "0x0.000070Ap0", "0x0.0000784p0",
"0x0.0000802p0", "0x0.0000884p0", "0x0.000090Bp0", "0x0.0000995p0",
"0x0.0000A23p0", "0x0.0000AB6p0", "0x0.0000B4Cp0", "0x0.0000BE6p0",
"0x0.0000C85p0", "0x0.0000D27p0", "0x0.0000DCEp0", "0x0.0000E78p0",
"0x0.0000F26p0", "0x0.0000FD9p0", "0x0.000108Fp0", "0x0.000114Ap0",
"0x0.0001209p0", "0x0.00012CBp0", "0x0.0001392p0", "0x0.000145Cp0",
"0x0.000152Bp0", "0x0.00015FEp0", "0x0.00016D4p0", "0x0.00017AFp0",
"0x0.000188Ep0", "0x0.0001971p0", "0x0.0001A57p0", "0x0.0001B42p0",
"0x0.0001C31p0", "0x0.0001D24p0", "0x0.0001E1Bp0", "0x0.0001F16p0",
"0x0.0002015p0", "0x0.0002118p0", "0x0.000221Fp0", "0x0.000232Ap0",
"0x0.0002439p0", "0x0.000254Cp0", "0x0.0002663p0", "0x0.000277Fp0",
"0x0.000289Ep0", "0x0.00029C1p0", "0x0.0002AE9p0", "0x0.0002C14p0",
"0x0.0002D43p0", "0x0.0002E77p0", "0x0.0002FAEp0", "0x0.00030EAp0",
"0x0.0003229p0", "0x0.000336Dp0", "0x0.00034B4p0", "0x0.0003600p0",
"0x0.0003750p0", "0x0.00038A4p0", "0x0.00039FBp0", "0x0.0003B57p0",
"0x0.0003CB7p0", "0x0.0003E1Bp0", "0x0.0003F83p0", "0x0.00040EFp0",
"0x0.000425Fp0", "0x0.00043D3p0", "0x0.000454Bp0", "0x0.00046C7p0",
"0x0.0004848p0", "0x0.00049CCp0", "0x0.0004B54p0", "0x0.0004CE1p0",
"0x0.0004E71p0", "0x0.0005006p0", "0x0.000519Ep0", "0x0.000533Bp0",
"0x0.00054DBp0", "0x0.0005680p0", "0x0.0005829p0", "0x0.00059D6p0",
"0x0.0005B86p0", "0x0.0005D3Bp0", "0x0.0005EF4p0", "0x0.00060B1p0",
"0x0.0006272p0", "0x0.0006437p0", "0x0.0006600p0", "0x0.00067CEp0",
"0x0.000699Fp0", "0x0.0006B74p0", "0x0.0006D4Ep0", "0x0.0006F2Bp0",
"0x0.000710Dp0", "0x0.00072F2p0", "0x0.00074DCp0", "0x0.00076CAp0",
"0x0.00078BBp0", "0x0.0007AB1p0", "0x0.0007CABp0", "0x0.0007EA9p0",
            };

            ap_ufixed<6,-19> f_x_msb_3_lsb = x_msb_3 * x_lsb;


            ap_ufixed<12,-13> f_x_msb_3 = f_x_msb_3_m_1_table[x_msb_ind_3];

            ap_ufixed<13,-12> exp_x_msb_3_lsb_m_1_m = 0;
            exp_x_msb_3_lsb_m_1_m(11,0) = f_x_msb_3(11,0);
            exp_x_msb_3_lsb_m_1_m = exp_x_msb_3_lsb_m_1_m + f_x_msb_3_lsb;


            ap_ufixed<19,-6> x_msb_3_lsb = x_l;

            ap_ufixed<20,-5> exp_x_msb_3_lsb_m_1 = 0;
            exp_x_msb_3_lsb_m_1(18,0) = x_msb_3_lsb(18,0);
            exp_x_msb_3_lsb_m_1 = exp_x_msb_3_lsb_m_1+ exp_x_msb_3_lsb_m_1_m;


            const static ap_ufixed<25,0> exp_x_msb_2_m_1_table[32] = {
                "0x0.0000000p0", "0x0.04080a8p0", "0x0.0820560p0", "0x0.0c49238p0",
                "0x0.1082b58p0", "0x0.14cd500p0", "0x0.1929370p0", "0x0.1d96b10p0",
                "0x0.2216048p0", "0x0.26a7790p0", "0x0.2b4b588p0", "0x0.3001ed0p0",
                "0x0.34cb818p0", "0x0.39a8628p0", "0x0.3e98de8p0", "0x0.439d440p0",
                "0x0.48b5e40p0", "0x0.4de30f0p0", "0x0.5325180p0", "0x0.587c540p0",
                "0x0.5de9178p0", "0x0.636bb98p0", "0x0.6904930p0", "0x0.6eb3fc8p0",
                "0x0.747a510p0", "0x0.7a57ee0p0", "0x0.804d300p0", "0x0.865a778p0",
                "0x0.8c80248p0", "0x0.92be998p0", "0x0.99163b0p0", "0x0.9f876e8p0",
            };
            ap_ufixed<25, 0> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];

            ap_ufixed<50,-5> f_x_msb_2_3_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_lsb_m_1;
            ap_ufixed<20,-5> f_x_msb_2_3_lsb_s = f_x_msb_2_3_lsb;
            ap_ufixed<25, 0> exp_x_msb_2_3_lsb_m_1 = f_x_msb_2_3_lsb_s + exp_x_msb_3_lsb_m_1 + exp_x_msb_2_m_1;


            const static ap_ufixed<25,11> exp_x_msb_1_table[32] = {
                "0x1.0000p0", "0x1.a614p0", "0x2.b7e0p0", "0x4.7b50p0",
                "0x7.6398p0", "0xc.2eb8p0", "0x14.15e4p0", "0x21.1d90p0",
                "0x36.9920p0", "0x5a.0464p0", "0x94.69c4p0", "0xf4.b124p0",
                "0x193.6dc4p0", "0x299.2444p0", "0x448.a218p0", "0x710.0adcp0",
                "0x0.0014p0", "0x0.0024p0", "0x0.003cp0", "0x0.0064p0",
                "0x0.00a4p0", "0x0.010cp0", "0x0.01b8p0", "0x0.02d8p0",
                "0x0.04b0p0", "0x0.07bcp0", "0x0.0cc0p0", "0x0.1504p0",
                "0x0.22a4p0", "0x0.3920p0", "0x0.5e2cp0", "0x0.9b44p0",
            };
            ap_ufixed<25,11> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];


            ap_ufixed<50,11> y_lo = exp_x_msb_1 * exp_x_msb_2_3_lsb_m_1;

            ap_ufixed<25,11> y_lo_s = y_lo;

            ap_ufixed<25,11> y_l = y_lo_s + exp_x_msb_1;

            y = y_l;

        }
        y += delta;

            overf = 0;
            VITIS_LOOP_1309_9: for (int j = 22; j >= I_+10; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1315_10: for (int j = 22; j >= I_+10; j--){
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1319_11: for (int j = I_+9; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    } else if (I_s_==5) {

        if(WI_>73) return 0;
        const static int we = 24;
        const static int wf = 49;
        const static int w = 73;
        ap_fixed<w,we> x_l = x;
        ap_ufixed<47,24> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(wf+4,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);
        bool overf = 0;
        VITIS_LOOP_1339_12: for (int j = wf+4; j < w-1; j++){
#pragma HLS unroll
 if (x_l[w-1]!=x_l[j])
                overf = 1;
        }
        if (overf||((x_l_int==15)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.F1402743D99F8p0")))) {
            if (!x_l[w-1]) {
                VITIS_LOOP_1346_13: for (int j = 0; j < 46; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            const static int g=4;
            const static int Maxprecision = 51;
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[w-1];
            x_msb_ind_1(6,0) = x_l(wf+3,wf-3);

            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(wf-4,wf-11);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(wf-12,wf-16);
            ap_uint<3> x_msb_ind_4;
            x_msb_ind_4(2,0) = x_l(wf-17,wf-19);

            ap_uint<6> x_msb_ind_5;
            x_msb_ind_5(5,0) = x_l(wf-20,wf-25);

            ap_ufixed<8, -3> x_msb_2 = x_l;
            ap_ufixed<5,-11> x_msb_3 = x_l;
            ap_ufixed<3,-16> x_msb_4 = x_l;
            ap_ufixed<6,-19> x_msb_5 = x_l;

            ap_ufixed<7,-25> x_lsb = x_l;

            const static ap_ufixed<12,-39> f_x_msb_5_table[64] = {
"0x0.0000000000000p0", "0x0.0000000000002p0", "0x0.0000000000008p0", "0x0.0000000000012p0",
"0x0.0000000000020p0", "0x0.0000000000032p0", "0x0.0000000000048p0", "0x0.0000000000062p0",
"0x0.0000000000080p0", "0x0.00000000000A2p0", "0x0.00000000000C8p0", "0x0.00000000000F2p0",
"0x0.0000000000120p0", "0x0.0000000000152p0", "0x0.0000000000188p0", "0x0.00000000001C2p0",
"0x0.0000000000200p0", "0x0.0000000000242p0", "0x0.0000000000288p0", "0x0.00000000002D2p0",
"0x0.0000000000320p0", "0x0.0000000000372p0", "0x0.00000000003C8p0", "0x0.0000000000422p0",
"0x0.0000000000480p0", "0x0.00000000004E2p0", "0x0.0000000000548p0", "0x0.00000000005B2p0",
"0x0.0000000000620p0", "0x0.0000000000692p0", "0x0.0000000000708p0", "0x0.0000000000782p0",
"0x0.0000000000800p0", "0x0.0000000000882p0", "0x0.0000000000908p0", "0x0.0000000000992p0",
"0x0.0000000000A20p0", "0x0.0000000000AB2p0", "0x0.0000000000B48p0", "0x0.0000000000BE2p0",
"0x0.0000000000C80p0", "0x0.0000000000D22p0", "0x0.0000000000DC8p0", "0x0.0000000000E72p0",
"0x0.0000000000F20p0", "0x0.0000000000FD2p0", "0x0.0000000001088p0", "0x0.0000000001142p0",
"0x0.0000000001200p0", "0x0.00000000012C2p0", "0x0.0000000001388p0", "0x0.0000000001452p0",
"0x0.0000000001520p0", "0x0.00000000015F2p0", "0x0.00000000016C8p0", "0x0.00000000017A2p0",
"0x0.0000000001880p0", "0x0.0000000001962p0", "0x0.0000000001A48p0", "0x0.0000000001B32p0",
"0x0.0000000001C20p0", "0x0.0000000001D12p0", "0x0.0000000001E08p0", "0x0.0000000001F02p0",

            };
            ap_ufixed<12,-39> f_x_msb_5 = f_x_msb_5_table[x_msb_ind_5];

            const static ap_ufixed<7,-33> f_x_msb_4_table[8] = {
"0x0.0000000000p0", "0x0.0000000002p0", "0x0.0000000008p0", "0x0.0000000012p0",
"0x0.0000000020p0", "0x0.0000000032p0", "0x0.0000000048p0", "0x0.0000000062p0",
            };
            ap_ufixed<7,-33> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            ap_ufixed<7,-44> f_x_msb_5_lsb = x_msb_5 * x_lsb;

            ap_ufixed<16,-19> x_msb_5_lsb = x_l;

            ap_ufixed<19,-35> f_x_msb_4_5_lsb = x_msb_5_lsb * x_msb_4;
            ap_ufixed<16,-35> f_x_msb_4_5_lsb_s = f_x_msb_4_5_lsb;

            ap_ufixed<13,-38> exp_x_msb_4_5_lsb_m_1_m3 = 0;
            exp_x_msb_4_5_lsb_m_1_m3(11,0)=f_x_msb_5(11,0);
            exp_x_msb_4_5_lsb_m_1_m3 = exp_x_msb_4_5_lsb_m_1_m3+f_x_msb_5_lsb;

            ap_ufixed<17,-34> exp_x_msb_4_5_lsb_m_1_m4 = 0;
            exp_x_msb_4_5_lsb_m_1_m4(15,0)=f_x_msb_4_5_lsb_s(15,0);
            exp_x_msb_4_5_lsb_m_1_m4 = exp_x_msb_4_5_lsb_m_1_m4 + f_x_msb_4_5_lsb_s;

            ap_ufixed<8,-32> exp_x_msb_4_5_lsb_m_1_m5_s = 0;
            exp_x_msb_4_5_lsb_m_1_m5_s(5,0)=exp_x_msb_4_5_lsb_m_1_m4(16,11);
            exp_x_msb_4_5_lsb_m_1_m5_s = f_x_msb_4+exp_x_msb_4_5_lsb_m_1_m5_s;

            ap_ufixed<19,-32> exp_x_msb_4_5_lsb_m_1_m5 = exp_x_msb_4_5_lsb_m_1_m5_s;
            exp_x_msb_4_5_lsb_m_1_m5(10,0)=exp_x_msb_4_5_lsb_m_1_m4(10,0);

            ap_ufixed<32,-15> exp_x_msb_4_5_lsb_m_1_m6 = 0;
            ap_ufixed<wf-16,-16> x_msb_4_5_lsb = x_l;
            exp_x_msb_4_5_lsb_m_1_m6(14,0) = exp_x_msb_4_5_lsb_m_1_m5(18,4);
            exp_x_msb_4_5_lsb_m_1_m6 = exp_x_msb_4_5_lsb_m_1_m6 + x_msb_4_5_lsb;
            ap_ufixed<36,-15> exp_x_msb_4_5_lsb_m_1 = exp_x_msb_4_5_lsb_m_1_m6;
            exp_x_msb_4_5_lsb_m_1(3,0) = exp_x_msb_4_5_lsb_m_1_m5(3,0);


            const static ap_ufixed<32,-23> f_x_msb_3_table[32] = {
"0x0.00000000000000p0", "0x0.0000000080002ap0", "0x0.00000002000156p0", "0x0.00000004800480p0",
"0x0.00000008000aaap0", "0x0.0000000c8014d6p0", "0x0.00000012002400p0", "0x0.0000001880392cp0",
"0x0.00000020005556p0", "0x0.00000028807982p0", "0x0.0000003200a6acp0", "0x0.0000003c80ddd8p0",
"0x0.00000048012004p0", "0x0.00000054816e30p0", "0x0.0000006201c95cp0", "0x0.00000070823288p0",
"0x0.0000008002aab6p0", "0x0.000000908332e2p0", "0x0.000000a203cc12p0", "0x0.000000b4847740p0",
"0x0.000000c8053570p0", "0x0.000000dc8607a0p0", "0x0.000000f206eed0p0", "0x0.0000010887ec02p0",
"0x0.00000120090036p0", "0x0.000001388a2c6ap0", "0x0.000001520b71a0p0", "0x0.0000016c8cd0d6p0",
"0x0.000001880e4b0ep0", "0x0.000001a48fe148p0", "0x0.000001c2119484p0", "0x0.000001e09365c0p0",
            };

            ap_ufixed<32,-23> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<44,-11> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(43,39) = x_msb_3(4,0);
            exp_x_msb_3_m_1(31, 0) = f_x_msb_3(31,0);


            ap_ufixed<80,-26> f_x_msb_3_4_lsb = exp_x_msb_3_m_1 * exp_x_msb_4_5_lsb_m_1;
            ap_ufixed<31,-26> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<48,-10> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_5_lsb_m_1;


            const static ap_ufixed<46,-6> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.0000020015560p0", "0x0.00000800AAB55p0", "0x0.0000120240360p0",
"0x0.0000200556001p0", "0x0.0000320A6C4B8p0", "0x0.0000481203608p0", "0x0.0000621C9B971p0",
"0x0.0000802AB5577p0", "0x0.0000A23CD119Dp0", "0x0.0000C8536F668p0", "0x0.0000F26F10D5Dp0",
"0x0.0001209036103p0", "0x0.000152B75FCE3p0", "0x0.000188E50ED86p0", "0x0.0001C319C4077p0",
"0x0.0002015600445p0", "0x0.0002439A4487Ep0", "0x0.000289E711DB3p0", "0x0.0002D43CE9577p0",
"0x0.0003229C4C260p0", "0x0.00037505BB805p0", "0x0.0003CB79B8B01p0", "0x0.000425F8C50F2p0",
"0x0.0004848362076p0", "0x0.0004E71A11131p0", "0x0.00054DBD53BC8p0", "0x0.0005B86DAB9E3p0",
"0x0.0006272B9A630p0", "0x0.000699F7A1C5Dp0", "0x0.000710D24391Ep0", "0x0.00078BBC01A29p0",
"0x0.00080AB55DE39p0", "0x0.00088DBEDA50Bp0", "0x0.000914D8F8F63p0", "0x0.0009A0043BF07p0",
"0x0.000A2F41256C2p0", "0x0.000AC29037A63p0", "0x0.000B59F1F4EBDp0", "0x0.000BF566DF9AAp0",
"0x0.000C94EF7A206p0", "0x0.000D388C46FB4p0", "0x0.000DE03DC8B9Bp0", "0x0.000E8C0481FA7p0",
"0x0.000F3BE0F56CAp0", "0x0.000FEFD3A5CFAp0", "0x0.0010A7DD15F36p0", "0x0.001163FDC8B7Fp0",
"0x0.00122436410DDp0", "0x0.0012E88701F5Ep0", "0x0.0013B0F08E817p0", "0x0.00147D7369D22p0",
"0x0.00154E101719Fp0", "0x0.001622C7199B7p0", "0x0.0016FB98F4A96p0", "0x0.0017D8862BA72p0",
"0x0.0018B98F42084p0", "0x0.00199EB4BB511p0", "0x0.001A87F71B161p0", "0x0.001B7556E4FC4p0",
"0x0.001C66D49CB93p0", "0x0.001D5C70C612Dp0", "0x0.001E562BE4DFAp0", "0x0.001F54067D067p0",
"0x0.00205601127ECp0", "0x0.00215C1C29507p0", "0x0.0022665845940p0", "0x0.002374B5EB724p0",
"0x0.002487359F24Cp0", "0x0.00259DD7E4F57p0", "0x0.0026B89D413EFp0", "0x0.0027D786386C4p0",
"0x0.0028FA934EF90p0", "0x0.002A21C509717p0", "0x0.002B4D1BEC726p0", "0x0.002C7C987CA92p0",
"0x0.002DB03B3ED3Ap0", "0x0.002EE804B7C07p0", "0x0.003023F56C4ECp0", "0x0.0031640DE16E3p0",
"0x0.0032A84E9C1F5p0", "0x0.0033F0B821730p0", "0x0.00353D4AF68B0p0", "0x0.00368E07A0999p0",
"0x0.0037E2EEA4E19p0", "0x0.00393C0088B6Cp0", "0x0.003A993DD17D5p0", "0x0.003BFAA704AA3p0",
"0x0.003D603CA7C32p0", "0x0.003EC9FF405E6p0", "0x0.004037EF54230p0", "0x0.0041AA0D68C8Cp0",
"0x0.0043205A04182p0", "0x0.00449AD5ABEA5p0", "0x0.00461980E6294p0", "0x0.00479C5C38CF9p0",
"0x0.0049236829E8Bp0", "0x0.004AAEA53F90Ep0", "0x0.004C3E13FFF51p0", "0x0.004DD1B4F152Fp0",
"0x0.004F698899F90p0", "0x0.0051058F8046Ap0", "0x0.0052A5CA2AABFp0", "0x0.00544A391FA9Cp0",
"0x0.0055F2DCE5D1Ep0", "0x0.00579FB603C6Ep0", "0x0.005950C5003C2p0", "0x0.005B060A61F5Dp0",
"0x0.005CBF86AFC91p0", "0x0.005E7D3A709BEp0", "0x0.00603F262B650p0", "0x0.0062054A672C2p0",
"0x0.0063CFA7AB09Dp0", "0x0.00659E3E7E278p0", "0x0.0067710F67BFAp0", "0x0.0069481AEF1D5p0",
"0x0.006B23619B9CFp0", "0x0.006D02E3F4AB7p0", "0x0.006EE6A281C6Fp0", "0x0.0070CE9DCA7E6p0",
"0x0.0072BAD65671Bp0", "0x0.0074AB4CAD51Cp0", "0x0.0076A00156E07p0", "0x0.007898F4DAF09p0",
"0x0.007A9627C165Fp0", "0x0.007C979A92356p0", "0x0.007E9D4DD564Ap0", "0x0.0080A742130A8p0",
"0x0.0082B577D34EDp0", "0x0.0084C7EF9E6A7p0", "0x0.0086DEA9FCA73p0", "0x0.0088F9A776601p0",
"0x0.008B18E894010p0", "0x0.008D3C6DDE06Fp0", "0x0.008F6437DD000p0", "0x0.00919047198B6p0",
"0x0.0093C09C1C595p0", "0x0.0095F5376E2B2p0", "0x0.00982E1997D33p0", "0x0.009A6B4322352p0",
"0x0.009CACB496458p0", "0x0.009EF26E7D0A2p0", "0x0.00A13C715F99Ep0", "0x0.00A38ABDC71CEp0",
"0x0.00A5DD543CCC4p0", "0x0.00A8343549F26p0", "0x0.00AA8F6177EADp0", "0x0.00ACEED950222p0",
"0x0.00AF529D5C165p0", "0x0.00B1BAAE25566p0", "0x0.00B4270C3582Ap0", "0x0.00B697B8164C7p0",
"0x0.00B90CB25176Ap0", "0x0.00BB85FB70D50p0", "0x0.00BE0393FE4CCp0", "0x0.00C0857C83D44p0",
"0x0.00C30BB58B732p0", "0x0.00C5963F9F424p0", "0x0.00C8251B496BEp0", "0x0.00CAB849142B5p0",
"0x0.00CD4FC989CD6p0", "0x0.00CFEB9D34B00p0", "0x0.00D28BC49F428p0", "0x0.00D5304054059p0",
"0x0.00D7D910DD8B1p0", "0x0.00DA8636C6764p0", "0x0.00DD37B2997BCp0", "0x0.00DFED84E1618p0",
"0x0.00E2A7AE28FECp0", "0x0.00E5662EFB3C3p0", "0x0.00E82907E313Dp0", "0x0.00EAF0396B910p0",
"0x0.00EDBBC41FD08p0", "0x0.00F08BA88B009p0", "0x0.00F35FE73860Bp0", "0x0.00F63880B341Ep0",
"0x0.00F9157587069p0", "0x0.00FBF6C63F228p0", "0x0.00FEDC73671B0p0", "0x0.0101C67D8A86Cp0",
"0x0.0104B4E5350DFp0", "0x0.0107A7AAF26A2p0", "0x0.010A9ECF4E667p0", "0x0.010D9A52D4DF8p0",
"0x0.01109A3611C34p0", "0x0.01139E7991116p0", "0x0.0116A71DDEDADp0", "0x0.0119B42387423p0",
"0x0.011CC58B167B9p0", "0x0.011FDB5518CCAp0", "0x0.0122F5821A8C7p0", "0x0.01261412A823Cp0",
"0x0.012937074E0CDp0", "0x0.012C5E6098D37p0", "0x0.012F8A1F15151p0", "0x0.0132BA434F80Ap0",
"0x0.0135EECDD4D6Cp0", "0x0.013927BF31E98p0", "0x0.013C6517F39CCp0", "0x0.013FA6D8A6E5Dp0",
"0x0.0142ED01D8CBCp0", "0x0.0146379416673p0", "0x0.0149868FECE26p0", "0x0.014CD9F5E9795p0",
"0x0.015031C699799p0", "0x0.01538E028A426p0", "0x0.0156EEAA4944Bp0", "0x0.015A53BE64033p0",
"0x0.015DBD3F68122p0", "0x0.01612B2DE3178p0", "0x0.01649D8A62CB1p0", "0x0.0168145574F65p0",
"0x0.016B8F8FA7745p0", "0x0.016F0F3988321p0", "0x0.01729353A52E4p0", "0x0.01761BDE8C792p0",
"0x0.0179A8DACC350p0", "0x0.017D3A48F295Dp0", "0x0.0180D0298DE13p0", "0x0.01846A7D2C6ECp0",
"0x0.018809445CA7Bp0", "0x0.018BAC7FAD074p0", "0x0.018F542FAC1A4p0", "0x0.01930054E87F8p0",
"0x0.0196B0EFF0E79p0", "0x0.019A66015414Dp0", "0x0.019E1F89A0DBAp0", "0x0.01A1DD8966221p0",
"0x0.01A5A00132E02p0", "0x0.01A966F1961FCp0", "0x0.01AD325B1EFC9p0", "0x0.01B1023E5CA45p0",
"0x0.01B4D69BDE569p0", "0x0.01B8AF743364Cp0", "0x0.01BC8CC7EB323p0", "0x0.01C06E9795345p0",
"0x0.01C454E3C0F24p0", "0x0.01C83FACFE054p0", "0x0.01CC2EF3DC187p0", "0x0.01D022B8EAE8Fp0",
"0x0.01D41AFCBA45Ep0", "0x0.01D817BFDA104p0", "0x0.01DC1902DA3B1p0", "0x0.01E01EC64ACB7p0",
"0x0.01E4290ABBD87p0", "0x0.01E837D0BD8B2p0", "0x0.01EC4B18E01E9p0", "0x0.01F062E3B3DFEp0",
"0x0.01F47F31C92E4p0", "0x0.01F8A003B07AFp0", "0x0.01FCC559FA492p0", "0x0.0200EF35372E4p0",
"0x0.02051D95F7D1Cp0", "0x0.0209507CCCED1p0", "0x0.020D87EA474BEp0", "0x0.0211C3DEF7CBDp0",
            };
            ap_ufixed<46,-6> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 5,-6> f_x_msb_2_h;
            f_x_msb_2_h(4,0) = f_x_msb_2(45,41);
            ap_ufixed< 9,-2> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<50,-2> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(49,41) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(40, 0) = f_x_msb_2(40,0);

            ap_ufixed<98,-12> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<46,-12> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<50,-2> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<50,23> exp_x_msb_1_table[256] = {
"0x1.0000000p0", "0x1.2216045p0", "0x1.48B5E3Cp0", "0x1.747A513p0",
"0x1.A61298Ep0", "0x1.DE455DFp0", "0x2.1DF3B68p0", "0x2.661CB0Fp0",
"0x2.B7E1516p0", "0x3.1489176p0", "0x3.7D871DBp0", "0x3.F47FE87p0",
"0x4.7B4FF99p0", "0x5.1413452p0", "0x5.C12DA41p0", "0x6.855466Ep0",
"0x7.63992E3p0", "0x8.5F7635Bp0", "0x9.7CDC417p0", "0xA.C042667p0",
"0xC.2EB7EC9p0", "0xD.CDF892Ep0", "0xF.A48385Ep0", "0x11.B9B5652p0",
"0x14.15E5BF6p0", "0x16.C2887C1p0", "0x19.CA53B78p0", "0x1D.396AA97p0",
"0x21.1D8E427p0", "0x25.865441Cp0", "0x2A.8565A14p0", "0x30.2EC550Bp0",
"0x36.99205C4p0", "0x3D.DE28BF3p0", "0x46.1AFC4DBp0", "0x4F.7099532p0",
"0x5A.0462B78p0", "0x66.00B5BC9p0", "0x73.9593ABBp0", "0x82.F9621ADp0",
"0x94.69C4CB8p0", "0xA8.2C948C1p0", "0xBE.90F6F83p0", "0xD7.F09B78Cp0",
"0xF4.B122790p0", "0x115.45B4704p0", "0x13A.30CF1CCp0", "0x164.0650296p0",
"0x193.6DC5690p0", "0x1C9.250BEDCp0", "0x206.03487A3p0", "0x24A.FC4533Cp0",
"0x299.2442102p0", "0x2F1.B447462p0", "0x356.0F0B0F9p0", "0x3C7.C67E5BEp0",
"0x448.A216ABBp0", "0x4DA.A5EE46Ap0", "0x580.1AD754Fp0", "0x63B.9782341p0",
"0x710.0ADBAC7p0", "0x800.C7CC8E3p0", "0x911.9289C39p0", "0xA46.AFAA2ADp0",
"0xBA4.F53EA38p0", "0xD31.DE30C52p0", "0xEF3.A035D57p0", "0x10F1.44ADE60p0",
"0x1332.C4D2B7Cp0", "0x15C1.29A744Cp0", "0x18A6.B027DA0p0", "0x1BEE.F24BB12p0",
"0x1FA7.157C470p0", "0x23DD.FF3C8BAp0", "0x28A4.90D2CCEp0", "0x2E0D.EAE454Bp0",
"0x342F.BA11823p0", "0x3B22.8DC5359p0", "0x4302.3A933EEp0", "0x4BEE.49AFCDCp0",
"0x560A.773E541p0", "0x617F.4171BF9p0", "0x6E7A.8ABB4A8p0", "0x7D30.5191764p0",
"0x8DDB.80AF426p0", "0xA0BE.DB0DB10p0", "0xB626.0748BAEp0", "0xCE66.BE9EAADp0",
"0xE9E2.2447727p0", "0x10906.4A831F8p0", "0x12C4F.EB75B2Ap0", "0x1544C.5CB6133p0",
"0x1819B.C560F61p0", "0x1B4F3.9F8AF64p0", "0x1EF21.8F1B001p0", "0x2310E.996C40Fp0",
"0x27BC2.CA9A6F9p0", "0x2D069.571279Ap0", "0x33055.49F35D9p0", "0x39D06.D2FEF17p0",
"0x41831.49596E9p0", "0x4A3C1.FB2AC39p0", "0x541E7.E56949Dp0", "0x5F51C.72B7532p0",
"0x6C02D.645AB25p0", "0x7A648.0CFF534p0", "0x8AB06.0A3EE9Fp0", "0x9D27B.AFE4CF1p0",
"0xB2148.5EAE56Cp0", "0xC9CA9.07F86EFp0", "0xE4A8D.2881EDBp0", "0x1031AE.8E4996Cp0",
"0x1259AC.48BF05Dp0", "0x14CB29.2F2B31Fp0", "0x178FEE.7792E44p0", "0x1AB312.E89CD0Dp0",
"0x1E4127.437732Bp0", "0x224868.979FC2Ep0", "0x26D8F9.4A204BEp0", "0x2C0521.B4A8E0Bp0",
"0x31E199.5F5A550p0", "0x3885D9.FA89D00p0", "0x400C7D.64D3386p0", "0x4893A8.361032Dp0",
"0x523D82.79EDAEFp0", "0x5D30C0.7DAB686p0", "0x69993D.D4F2D95p0", "0x77A8AD.02A7C71p0",
"0x0.000001Ep0", "0x0.0000022p0", "0x0.0000026p0", "0x0.000002Bp0",
"0x0.0000031p0", "0x0.0000038p0", "0x0.000003Fp0", "0x0.0000048p0",
"0x0.0000052p0", "0x0.000005Dp0", "0x0.0000069p0", "0x0.0000077p0",
"0x0.0000087p0", "0x0.0000099p0", "0x0.00000ADp0", "0x0.00000C4p0",
"0x0.00000DFp0", "0x0.00000FCp0", "0x0.000011Ep0", "0x0.0000144p0",
"0x0.0000170p0", "0x0.00001A1p0", "0x0.00001D8p0", "0x0.0000217p0",
"0x0.000025Ep0", "0x0.00002AFp0", "0x0.000030Bp0", "0x0.0000372p0",
"0x0.00003E8p0", "0x0.000046Dp0", "0x0.0000504p0", "0x0.00005AFp0",
"0x0.0000671p0", "0x0.000074Cp0", "0x0.0000845p0", "0x0.000095Fp0",
"0x0.0000A9Fp0", "0x0.0000C09p0", "0x0.0000DA3p0", "0x0.0000F74p0",
"0x0.0001183p0", "0x0.00013D8p0", "0x0.000167Cp0", "0x0.000197Bp0",
"0x0.0001CDFp0", "0x0.00020B7p0", "0x0.0002513p0", "0x0.0002A02p0",
"0x0.0002F9Ap0", "0x0.00035F1p0", "0x0.0003D20p0", "0x0.0004543p0",
"0x0.0004E7Cp0", "0x0.00058F0p0", "0x0.00064C7p0", "0x0.0007232p0",
"0x0.0008167p0", "0x0.00092A2p0", "0x0.000A628p0", "0x0.000BC48p0",
"0x0.000D55Ap0", "0x0.000F1C2p0", "0x0.00111F3p0", "0x0.001366Cp0",
"0x0.0015FC2p0", "0x0.0018E98p0", "0x0.001C3AAp0", "0x0.001FFCEp0",
"0x0.00243F3p0", "0x0.002912Bp0", "0x0.002E8ABp0", "0x0.0034BD2p0",
"0x0.003BC2Dp0", "0x0.0043B7Dp0", "0x0.004CBC1p0", "0x0.0056F3Ap0",
"0x0.0062878p0", "0x0.006FA5Fp0", "0x0.007E83Ap0", "0x0.008F5C0p0",
"0x0.00A2728p0", "0x0.00B813Bp0", "0x0.00D0963p0", "0x0.00EC5C1p0",
"0x0.010BD4Ap0", "0x0.012F7DEp0", "0x0.0157E6Bp0", "0x0.0185B0Fp0",
"0x0.01B993Fp0", "0x0.01F45F9p0", "0x0.0236FF5p0", "0x0.02827E0p0",
"0x0.02D80A0p0", "0x0.0338F9Fp0", "0x0.03A6D22p0", "0x0.04234A7p0",
"0x0.04B0556p0", "0x0.0550280p0", "0x0.0605424p0", "0x0.06D279Ap0",
"0x0.07BB040p0", "0x0.08C284Cp0", "0x0.09ED1B4p0", "0x0.0B3F736p0",
"0x0.0CBED86p0", "0x0.0E7149Cp0", "0x0.105D938p0", "0x0.128B697p0",
"0x0.150385Cp0", "0x0.17CFCC2p0", "0x0.1AFB718p0", "0x0.1E9328Bp0",
"0x0.22A5554p0", "0x0.2742456p0", "0x0.2C7C72Fp0", "0x0.3268CDBp0",
"0x0.391F0EEp0", "0x0.40BA188p0", "0x0.495860Dp0", "0x0.531C6C9p0",
"0x0.5E2D58Dp0", "0x0.6AB7782p0", "0x0.78ED03Ap0", "0x0.8906E49p0",
"0x0.9B4597Ep0", "0x0.AFF230Ap0", "0x0.C75F7CFp0", "0x0.E1EB512p0",
            };
            ap_ufixed<50,23> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];

            ap_ufixed<100,21> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<48,21> y_lo_s = y_lo;
            ap_ufixed<50,23> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        y += delta;

            overf = 0;
            VITIS_LOOP_1608_14: for (int j = 46; j >= I_+22; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_1614_15: for (int j = 46; j >= I_+22; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_1618_16: for (int j = I_+21; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    } else {
        const static int wf = 67;
        const static int we = 33;
        const static int w = 100;
        ap_fixed<w,we> x_l = x;


        ap_ufixed<65,33> y = 0;

        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(wf+5,wf);


        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);

        bool overf = 0;
        VITIS_LOOP_1642_17: for (int j = wf+5; j < w-1; j++){
#pragma HLS unroll
 if (x_l[w-1]!=x_l[j])
                overf = 1;
        }
        if (overf||(x_l_int>22)||((x_l_int==22)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.2E42FEFA39EF35783p0")))) {
            if (!x_l[w-1]) {
                VITIS_LOOP_1649_18: for (int j = 0; j < 64; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            const static int g=4;
            const static int Maxprecision=69;
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[w-1];

            x_msb_ind_1(6,0) = x_l(wf+4,wf-2);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(wf-3,wf-10);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(wf-11,wf-18);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(wf-19,wf-26);

            ap_uint<8> x_msb_ind_5;
            x_msb_ind_5(7,0) = x_l(wf-27,wf-34);

            ap_ufixed<8, -2> x_msb_2 = x_l;
            ap_ufixed<8,-10> x_msb_3 = x_l;
            ap_ufixed<8,-18> x_msb_4 = x_l;
            ap_ufixed<8,-26> x_msb_5 = x_l;
            ap_ufixed<9,-34> x_lsb = x_l;

            const static ap_ufixed<32,-37> f_x_msb_4_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000080000p0", "0x0.000000000000200000p0", "0x0.000000000000480000p0",
"0x0.000000000000800000p0", "0x0.000000000000C80000p0", "0x0.000000000001200000p0", "0x0.000000000001880000p0",
"0x0.000000000002000001p0", "0x0.000000000002880001p0", "0x0.000000000003200002p0", "0x0.000000000003C80003p0",
"0x0.000000000004800004p0", "0x0.000000000005480005p0", "0x0.000000000006200007p0", "0x0.000000000007080008p0",
"0x0.00000000000800000Ap0", "0x0.00000000000908000Cp0", "0x0.00000000000A20000Fp0", "0x0.00000000000B480011p0",
"0x0.00000000000C800014p0", "0x0.00000000000DC80018p0", "0x0.00000000000F20001Bp0", "0x0.00000000001088001Fp0",
"0x0.000000000012000024p0", "0x0.000000000013880028p0", "0x0.00000000001520002Dp0", "0x0.000000000016C80033p0",
"0x0.000000000018800039p0", "0x0.00000000001A48003Fp0", "0x0.00000000001C200046p0", "0x0.00000000001E08004Dp0",
"0x0.000000000020000055p0", "0x0.00000000002208005Dp0", "0x0.000000000024200066p0", "0x0.00000000002648006Fp0",
"0x0.000000000028800079p0", "0x0.00000000002AC80083p0", "0x0.00000000002D20008Ep0", "0x0.00000000002F88009Ap0",
"0x0.0000000000320000A6p0", "0x0.0000000000348800B3p0", "0x0.0000000000372000C0p0", "0x0.000000000039C800CFp0",
"0x0.00000000003C8000DDp0", "0x0.00000000003F4800EDp0", "0x0.0000000000422000FDp0", "0x0.00000000004508010Ep0",
"0x0.000000000048000120p0", "0x0.00000000004B080132p0", "0x0.00000000004E200145p0", "0x0.000000000051480159p0",
"0x0.00000000005480016Ep0", "0x0.000000000057C80183p0", "0x0.00000000005B20019Ap0", "0x0.00000000005E8801B1p0",
"0x0.0000000000620001C9p0", "0x0.0000000000658801E2p0", "0x0.0000000000692001FCp0", "0x0.00000000006CC80216p0",
"0x0.000000000070800232p0", "0x0.00000000007448024Fp0", "0x0.00000000007820026Cp0", "0x0.00000000007C08028Bp0",
"0x0.0000000000800002AAp0", "0x0.0000000000840802CBp0", "0x0.0000000000882002ECp0", "0x0.00000000008C48030Fp0",
"0x0.000000000090800332p0", "0x0.000000000094C80357p0", "0x0.00000000009920037Dp0", "0x0.00000000009D8803A4p0",
"0x0.0000000000A20003CCp0", "0x0.0000000000A68803F5p0", "0x0.0000000000AB20041Fp0", "0x0.0000000000AFC8044Ap0",
"0x0.0000000000B4800477p0", "0x0.0000000000B94804A4p0", "0x0.0000000000BE2004D3p0", "0x0.0000000000C3080503p0",
"0x0.0000000000C8000535p0", "0x0.0000000000CD080567p0", "0x0.0000000000D220059Bp0", "0x0.0000000000D74805D1p0",
"0x0.0000000000DC800607p0", "0x0.0000000000E1C8063Fp0", "0x0.0000000000E7200678p0", "0x0.0000000000EC8806B2p0",
"0x0.0000000000F20006EEp0", "0x0.0000000000F788072Bp0", "0x0.0000000000FD20076Ap0", "0x0.000000000102C807AAp0",
"0x0.0000000001088007EBp0", "0x0.00000000010E48082Ep0", "0x0.000000000114200872p0", "0x0.00000000011A0808B8p0",
"0x0.000000000120000900p0", "0x0.000000000126080948p0", "0x0.00000000012C200993p0", "0x0.0000000001324809DEp0",
"0x0.000000000138800A2Cp0", "0x0.00000000013EC80A7Bp0", "0x0.000000000145200ACBp0", "0x0.00000000014B880B1Dp0",
"0x0.000000000152000B71p0", "0x0.000000000158880BC6p0", "0x0.00000000015F200C1Dp0", "0x0.000000000165C80C76p0",
"0x0.00000000016C800CD0p0", "0x0.000000000173480D2Cp0", "0x0.00000000017A200D8Ap0", "0x0.000000000181080DE9p0",
"0x0.000000000188000E4Ap0", "0x0.00000000018F080EADp0", "0x0.000000000196200F12p0", "0x0.00000000019D480F78p0",
"0x0.0000000001A4800FE0p0", "0x0.0000000001ABC8104Ap0", "0x0.0000000001B32010B6p0", "0x0.0000000001BA881124p0",
"0x0.0000000001C2001194p0", "0x0.0000000001C9881205p0", "0x0.0000000001D1201278p0", "0x0.0000000001D8C812EEp0",
"0x0.0000000001E0801365p0", "0x0.0000000001E84813DEp0", "0x0.0000000001F0201459p0", "0x0.0000000001F80814D6p0",
"0x0.000000000200001555p0", "0x0.0000000002080815D6p0", "0x0.000000000210201659p0", "0x0.0000000002184816DEp0",
"0x0.000000000220801765p0", "0x0.000000000228C817EEp0", "0x0.000000000231201879p0", "0x0.000000000239881907p0",
"0x0.000000000242001996p0", "0x0.00000000024A881A28p0", "0x0.000000000253201ABBp0", "0x0.00000000025BC81B51p0",
"0x0.000000000264801BE9p0", "0x0.00000000026D481C84p0", "0x0.000000000276201D20p0", "0x0.00000000027F081DBFp0",
"0x0.000000000288001E60p0", "0x0.000000000291081F03p0", "0x0.00000000029A201FA8p0", "0x0.0000000002A3482050p0",
"0x0.0000000002AC8020FAp0", "0x0.0000000002B5C821A6p0", "0x0.0000000002BF202255p0", "0x0.0000000002C8882306p0",
"0x0.0000000002D20023B9p0", "0x0.0000000002DB88246Fp0", "0x0.0000000002E5202527p0", "0x0.0000000002EEC825E1p0",
"0x0.0000000002F880269Ep0", "0x0.00000000030248275Dp0", "0x0.00000000030C20281Fp0", "0x0.0000000003160828E3p0",
"0x0.0000000003200029AAp0", "0x0.00000000032A082A73p0", "0x0.000000000334202B3Fp0", "0x0.00000000033E482C0Dp0",
"0x0.000000000348802CDEp0", "0x0.000000000352C82DB2p0", "0x0.00000000035D202E88p0", "0x0.000000000367882F60p0",
"0x0.00000000037200303Cp0", "0x0.00000000037C883119p0", "0x0.0000000003872031FAp0", "0x0.000000000391C832DDp0",
"0x0.00000000039C8033C3p0", "0x0.0000000003A74834ABp0", "0x0.0000000003B2203596p0", "0x0.0000000003BD083684p0",
"0x0.0000000003C8003775p0", "0x0.0000000003D3083868p0", "0x0.0000000003DE20395Ep0", "0x0.0000000003E9483A57p0",
"0x0.0000000003F4803B53p0", "0x0.0000000003FFC83C52p0", "0x0.00000000040B203D53p0", "0x0.000000000416883E57p0",
"0x0.000000000422003F5Ep0", "0x0.00000000042D884068p0", "0x0.000000000439204175p0", "0x0.000000000444C84285p0",
"0x0.000000000450804397p0", "0x0.00000000045C4844ADp0", "0x0.0000000004682045C5p0", "0x0.0000000004740846E1p0",
"0x0.000000000480004800p0", "0x0.00000000048C084921p0", "0x0.000000000498204A46p0", "0x0.0000000004A4484B6Dp0",
"0x0.0000000004B0804C98p0", "0x0.0000000004BCC84DC5p0", "0x0.0000000004C9204EF6p0", "0x0.0000000004D588502Ap0",
"0x0.0000000004E2005161p0", "0x0.0000000004EE88529Bp0", "0x0.0000000004FB2053D8p0", "0x0.000000000507C85518p0",
"0x0.00000000051480565Cp0", "0x0.0000000005214857A3p0", "0x0.00000000052E2058EDp0", "0x0.00000000053B085A3Ap0",
"0x0.000000000548005B8Ap0", "0x0.000000000555085CDEp0", "0x0.000000000562205E35p0", "0x0.00000000056F485F8Fp0",
"0x0.00000000057C8060ECp0", "0x0.000000000589C8624Dp0", "0x0.0000000005972063B1p0", "0x0.0000000005A4886519p0",
"0x0.0000000005B2006684p0", "0x0.0000000005BF8867F2p0", "0x0.0000000005CD206963p0", "0x0.0000000005DAC86AD8p0",
"0x0.0000000005E8806C51p0", "0x0.0000000005F6486DCDp0", "0x0.000000000604206F4Cp0", "0x0.0000000006120870CFp0",
"0x0.000000000620007255p0", "0x0.00000000062E0873DFp0", "0x0.00000000063C20756Cp0", "0x0.00000000064A4876FDp0",
"0x0.000000000658807891p0", "0x0.000000000666C87A29p0", "0x0.000000000675207BC4p0", "0x0.000000000683887D64p0",
"0x0.000000000692007F06p0", "0x0.0000000006A08880ADp0", "0x0.0000000006AF208256p0", "0x0.0000000006BDC88404p0",
"0x0.0000000006CC8085B5p0", "0x0.0000000006DB48876Ap0", "0x0.0000000006EA208923p0", "0x0.0000000006F9088ADFp0",
"0x0.000000000708008CA0p0", "0x0.000000000717088E63p0", "0x0.00000000072620902Bp0", "0x0.0000000007354891F6p0",
"0x0.0000000007448093C6p0", "0x0.000000000753C89599p0", "0x0.000000000763209770p0", "0x0.00000000077288994Ap0",
"0x0.000000000782009B29p0", "0x0.000000000791889D0Bp0", "0x0.0000000007A1209EF2p0", "0x0.0000000007B0C8A0DCp0",
"0x0.0000000007C080A2CAp0", "0x0.0000000007D048A4BCp0", "0x0.0000000007E020A6B2p0", "0x0.0000000007F008A8ACp0",
            };
            ap_ufixed<32,-37> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            const static ap_ufixed<16,-53> f_x_msb_5_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000000008p0", "0x0.000000000000000020p0", "0x0.000000000000000048p0",
"0x0.000000000000000080p0", "0x0.0000000000000000C8p0", "0x0.000000000000000120p0", "0x0.000000000000000188p0",
"0x0.000000000000000200p0", "0x0.000000000000000288p0", "0x0.000000000000000320p0", "0x0.0000000000000003C8p0",
"0x0.000000000000000480p0", "0x0.000000000000000548p0", "0x0.000000000000000620p0", "0x0.000000000000000708p0",
"0x0.000000000000000800p0", "0x0.000000000000000908p0", "0x0.000000000000000A20p0", "0x0.000000000000000B48p0",
"0x0.000000000000000C80p0", "0x0.000000000000000DC8p0", "0x0.000000000000000F20p0", "0x0.000000000000001088p0",
"0x0.000000000000001200p0", "0x0.000000000000001388p0", "0x0.000000000000001520p0", "0x0.0000000000000016C8p0",
"0x0.000000000000001880p0", "0x0.000000000000001A48p0", "0x0.000000000000001C20p0", "0x0.000000000000001E08p0",
"0x0.000000000000002000p0", "0x0.000000000000002208p0", "0x0.000000000000002420p0", "0x0.000000000000002648p0",
"0x0.000000000000002880p0", "0x0.000000000000002AC8p0", "0x0.000000000000002D20p0", "0x0.000000000000002F88p0",
"0x0.000000000000003200p0", "0x0.000000000000003488p0", "0x0.000000000000003720p0", "0x0.0000000000000039C8p0",
"0x0.000000000000003C80p0", "0x0.000000000000003F48p0", "0x0.000000000000004220p0", "0x0.000000000000004508p0",
"0x0.000000000000004800p0", "0x0.000000000000004B08p0", "0x0.000000000000004E20p0", "0x0.000000000000005148p0",
"0x0.000000000000005480p0", "0x0.0000000000000057C8p0", "0x0.000000000000005B20p0", "0x0.000000000000005E88p0",
"0x0.000000000000006200p0", "0x0.000000000000006588p0", "0x0.000000000000006920p0", "0x0.000000000000006CC8p0",
"0x0.000000000000007080p0", "0x0.000000000000007448p0", "0x0.000000000000007820p0", "0x0.000000000000007C08p0",
"0x0.000000000000008000p0", "0x0.000000000000008408p0", "0x0.000000000000008820p0", "0x0.000000000000008C48p0",
"0x0.000000000000009080p0", "0x0.0000000000000094C8p0", "0x0.000000000000009920p0", "0x0.000000000000009D88p0",
"0x0.00000000000000A200p0", "0x0.00000000000000A688p0", "0x0.00000000000000AB20p0", "0x0.00000000000000AFC8p0",
"0x0.00000000000000B480p0", "0x0.00000000000000B948p0", "0x0.00000000000000BE20p0", "0x0.00000000000000C308p0",
"0x0.00000000000000C800p0", "0x0.00000000000000CD08p0", "0x0.00000000000000D220p0", "0x0.00000000000000D748p0",
"0x0.00000000000000DC80p0", "0x0.00000000000000E1C8p0", "0x0.00000000000000E720p0", "0x0.00000000000000EC88p0",
"0x0.00000000000000F200p0", "0x0.00000000000000F788p0", "0x0.00000000000000FD20p0", "0x0.0000000000000102C8p0",
"0x0.000000000000010880p0", "0x0.000000000000010E48p0", "0x0.000000000000011420p0", "0x0.000000000000011A08p0",
"0x0.000000000000012000p0", "0x0.000000000000012608p0", "0x0.000000000000012C20p0", "0x0.000000000000013248p0",
"0x0.000000000000013880p0", "0x0.000000000000013EC8p0", "0x0.000000000000014520p0", "0x0.000000000000014B88p0",
"0x0.000000000000015200p0", "0x0.000000000000015888p0", "0x0.000000000000015F20p0", "0x0.0000000000000165C8p0",
"0x0.000000000000016C80p0", "0x0.000000000000017348p0", "0x0.000000000000017A20p0", "0x0.000000000000018108p0",
"0x0.000000000000018800p0", "0x0.000000000000018F08p0", "0x0.000000000000019620p0", "0x0.000000000000019D48p0",
"0x0.00000000000001A480p0", "0x0.00000000000001ABC8p0", "0x0.00000000000001B320p0", "0x0.00000000000001BA88p0",
"0x0.00000000000001C200p0", "0x0.00000000000001C988p0", "0x0.00000000000001D120p0", "0x0.00000000000001D8C8p0",
"0x0.00000000000001E080p0", "0x0.00000000000001E848p0", "0x0.00000000000001F020p0", "0x0.00000000000001F808p0",
"0x0.000000000000020000p0", "0x0.000000000000020808p0", "0x0.000000000000021020p0", "0x0.000000000000021848p0",
"0x0.000000000000022080p0", "0x0.0000000000000228C8p0", "0x0.000000000000023120p0", "0x0.000000000000023988p0",
"0x0.000000000000024200p0", "0x0.000000000000024A88p0", "0x0.000000000000025320p0", "0x0.000000000000025BC8p0",
"0x0.000000000000026480p0", "0x0.000000000000026D48p0", "0x0.000000000000027620p0", "0x0.000000000000027F08p0",
"0x0.000000000000028800p0", "0x0.000000000000029108p0", "0x0.000000000000029A20p0", "0x0.00000000000002A348p0",
"0x0.00000000000002AC80p0", "0x0.00000000000002B5C8p0", "0x0.00000000000002BF20p0", "0x0.00000000000002C888p0",
"0x0.00000000000002D200p0", "0x0.00000000000002DB88p0", "0x0.00000000000002E520p0", "0x0.00000000000002EEC8p0",
"0x0.00000000000002F880p0", "0x0.000000000000030248p0", "0x0.000000000000030C20p0", "0x0.000000000000031608p0",
"0x0.000000000000032000p0", "0x0.000000000000032A08p0", "0x0.000000000000033420p0", "0x0.000000000000033E48p0",
"0x0.000000000000034880p0", "0x0.0000000000000352C8p0", "0x0.000000000000035D20p0", "0x0.000000000000036788p0",
"0x0.000000000000037200p0", "0x0.000000000000037C88p0", "0x0.000000000000038720p0", "0x0.0000000000000391C8p0",
"0x0.000000000000039C80p0", "0x0.00000000000003A748p0", "0x0.00000000000003B220p0", "0x0.00000000000003BD08p0",
"0x0.00000000000003C800p0", "0x0.00000000000003D308p0", "0x0.00000000000003DE20p0", "0x0.00000000000003E948p0",
"0x0.00000000000003F480p0", "0x0.00000000000003FFC8p0", "0x0.000000000000040B20p0", "0x0.000000000000041688p0",
"0x0.000000000000042200p0", "0x0.000000000000042D88p0", "0x0.000000000000043920p0", "0x0.0000000000000444C8p0",
"0x0.000000000000045080p0", "0x0.000000000000045C48p0", "0x0.000000000000046820p0", "0x0.000000000000047408p0",
"0x0.000000000000048000p0", "0x0.000000000000048C08p0", "0x0.000000000000049820p0", "0x0.00000000000004A448p0",
"0x0.00000000000004B080p0", "0x0.00000000000004BCC8p0", "0x0.00000000000004C920p0", "0x0.00000000000004D588p0",
"0x0.00000000000004E200p0", "0x0.00000000000004EE88p0", "0x0.00000000000004FB20p0", "0x0.0000000000000507C8p0",
"0x0.000000000000051480p0", "0x0.000000000000052148p0", "0x0.000000000000052E20p0", "0x0.000000000000053B08p0",
"0x0.000000000000054800p0", "0x0.000000000000055508p0", "0x0.000000000000056220p0", "0x0.000000000000056F48p0",
"0x0.000000000000057C80p0", "0x0.0000000000000589C8p0", "0x0.000000000000059720p0", "0x0.00000000000005A488p0",
"0x0.00000000000005B200p0", "0x0.00000000000005BF88p0", "0x0.00000000000005CD20p0", "0x0.00000000000005DAC8p0",
"0x0.00000000000005E880p0", "0x0.00000000000005F648p0", "0x0.000000000000060420p0", "0x0.000000000000061208p0",
"0x0.000000000000062000p0", "0x0.000000000000062E08p0", "0x0.000000000000063C20p0", "0x0.000000000000064A48p0",
"0x0.000000000000065880p0", "0x0.0000000000000666C8p0", "0x0.000000000000067520p0", "0x0.000000000000068388p0",
"0x0.000000000000069200p0", "0x0.00000000000006A088p0", "0x0.00000000000006AF20p0", "0x0.00000000000006BDC8p0",
"0x0.00000000000006CC80p0", "0x0.00000000000006DB48p0", "0x0.00000000000006EA20p0", "0x0.00000000000006F908p0",
"0x0.000000000000070800p0", "0x0.000000000000071708p0", "0x0.000000000000072620p0", "0x0.000000000000073548p0",
"0x0.000000000000074480p0", "0x0.0000000000000753C8p0", "0x0.000000000000076320p0", "0x0.000000000000077288p0",
"0x0.000000000000078200p0", "0x0.000000000000079188p0", "0x0.00000000000007A120p0", "0x0.00000000000007B0C8p0",
"0x0.00000000000007C080p0", "0x0.00000000000007D048p0", "0x0.00000000000007E020p0", "0x0.00000000000007F008p0",
            };

            ap_ufixed<16,-53> f_x_msb_5 = f_x_msb_5_table[x_msb_ind_5];

            ap_ufixed<9,-60> f_x_msb_5_lsb = x_msb_5 * x_lsb;

            ap_ufixed<25,-26> x_msb_5_lsb = x_l;

            ap_ufixed<25,-44> f_x_msb_4_5_lsb = x_msb_5_lsb * x_msb_4;

            ap_ufixed<6,-37> f_x_msb_4_s = f_x_msb_4;
            ap_ufixed<6,-63> exp_x_msb_4_5_lsb_m_1_m1 = x_msb_5 * f_x_msb_4;

            ap_ufixed<10,-59> exp_x_msb_4_5_lsb_m_1_m2 = 0;
            exp_x_msb_4_5_lsb_m_1_m2(8,0) = f_x_msb_5_lsb(8,0);
            exp_x_msb_4_5_lsb_m_1_m2 = exp_x_msb_4_5_lsb_m_1_m1 + exp_x_msb_4_5_lsb_m_1_m2;

            ap_ufixed<17,-52> exp_x_msb_4_5_lsb_m_1_m3 = 0;
            exp_x_msb_4_5_lsb_m_1_m3(15,0) = f_x_msb_5(15,0);
            exp_x_msb_4_5_lsb_m_1_m3 = exp_x_msb_4_5_lsb_m_1_m2+exp_x_msb_4_5_lsb_m_1_m3;

            ap_ufixed<26,-43> exp_x_msb_4_5_lsb_m_1_m4 =0;
            exp_x_msb_4_5_lsb_m_1_m4(24,0) = f_x_msb_4_5_lsb(24,0);
            exp_x_msb_4_5_lsb_m_1_m4 = exp_x_msb_4_5_lsb_m_1_m4 + exp_x_msb_4_5_lsb_m_1_m3;

            ap_ufixed<33,-36> exp_x_msb_4_5_lsb_m_1_m5 = 0;
            exp_x_msb_4_5_lsb_m_1_m5(31,0) = f_x_msb_4(31,0);
            exp_x_msb_4_5_lsb_m_1_m5 = exp_x_msb_4_5_lsb_m_1_m5 + exp_x_msb_4_5_lsb_m_1_m4;

            ap_ufixed<wf-18,-18> x_msb_4_5_lsb = x_l;
            ap_ufixed<wf-17,-17> exp_x_msb_4_5_lsb_m_1_s = 0;
            exp_x_msb_4_5_lsb_m_1_s(30,0) = exp_x_msb_4_5_lsb_m_1_m5(32,2);
            exp_x_msb_4_5_lsb_m_1_s = exp_x_msb_4_5_lsb_m_1_s + x_msb_4_5_lsb;

            ap_ufixed<52,-17> exp_x_msb_4_5_lsb_m_1 = exp_x_msb_4_5_lsb_m_1_s;
            exp_x_msb_4_5_lsb_m_1(1,0) = exp_x_msb_4_5_lsb_m_1_m5(1,0);


            const static ap_ufixed<51,-21> f_x_msb_3_table[256] = {
"0x0", "0x0.00000000080000AAAAp0", "0x0.000000002000055556p0", "0x0.000000004800120003p0",
"0x0.0000000080002AAAB5p0", "0x0.00000000C80053556Fp0", "0x0.000000012000900036p0", "0x0.000000018800E4AB0Ep0",
"0x0.000000020001555600p0", "0x0.000000028801E60111p0", "0x0.0000000320029AAC4Bp0", "0x0.00000003C8037757B7p0",
"0x0.000000048004800360p0", "0x0.000000054805B8AF50p0", "0x0.000000062007255B96p0", "0x0.000000070808CA083Dp0",
"0x0.00000008000AAAB555p0", "0x0.00000009080CCB62EDp0", "0x0.0000000A200F301116p0", "0x0.0000000B4811DCBFE0p0",
"0x0.0000000C8014D56F60p0", "0x0.0000000DC8181E1FA7p0", "0x0.0000000F201BBAD0CBp0", "0x0.00000010881FAF82E1p0",
"0x0.000000120024003600p0", "0x0.000000138828B0EA3Fp0", "0x0.00000015202DC59FB6p0", "0x0.00000016C83342567Fp0",
"0x0.0000001880392B0EB5p0", "0x0.0000001A483F83C874p0", "0x0.0000001C20465083D6p0", "0x0.0000001E084D9540FBp0",
"0x0.000000200055560001p0", "0x0.00000022085D96C106p0", "0x0.0000002420665B842Cp0", "0x0.00000026486FA84995p0",
"0x0.000000288079811161p0", "0x0.0000002AC883E9DBB6p0", "0x0.0000002D208EE6A8B8p0", "0x0.0000002F889A7B788Cp0",
"0x0.0000003200A6AC4B58p0", "0x0.0000003488B37D2145p0", "0x0.0000003720C0F1FA7Ap0", "0x0.00000039C8CF0ED721p0",
"0x0.0000003C80DDD7B765p0", "0x0.0000003F48ED509B71p0", "0x0.0000004220FD7D8371p0", "0x0.00000045090E626F94p0",
"0x0.000000480120036008p0", "0x0.0000004B09326454FBp0", "0x0.0000004E2145894E9Fp0", "0x0.000000514959764D26p0",
"0x0.00000054816E2F50C1p0", "0x0.00000057C983B859A4p0", "0x0.0000005B219A156804p0", "0x0.0000005E89B14A7C16p0",
"0x0.0000006201C95B9611p0", "0x0.0000006589E24CB62Cp0", "0x0.0000006921FC21DCA0p0", "0x0.0000006CCA16DF09A6p0",
"0x0.000000708232883D78p0", "0x0.000000744A4F217853p0", "0x0.00000078226CAEBA73p0", "0x0.0000007C0A8B340414p0",
"0x0.0000008002AAB55577p0", "0x0.000000840ACB36AEDAp0", "0x0.0000008822ECBC107Dp0", "0x0.0000008C4B0F497AA3p0",
"0x0.000000908332E2ED8Ep0", "0x0.00000094CB578C6981p0", "0x0.00000099237D49EEC0p0", "0x0.0000009D8BA41F7D92p0",
"0x0.000000A203CC11163Dp0", "0x0.000000A68BF522B908p0", "0x0.000000AB241F58663Cp0", "0x0.000000AFCC4AB61E22p0",
"0x0.000000B484773FE105p0", "0x0.000000B94CA4F9AF31p0", "0x0.000000BE24D3E788F1p0", "0x0.000000C30D040D6E94p0",
"0x0.000000C805356F6068p0", "0x0.000000CD0D68115EBCp0", "0x0.000000D2259BF769E1p0", "0x0.000000D74DD1258228p0",
"0x0.000000DC86079FA7E4p0", "0x0.000000E1CE3F69DB69p0", "0x0.000000E72678881D0Bp0", "0x0.000000EC8EB2FE6D1Fp0",
"0x0.000000F206EED0CBFDp0", "0x0.000000F78F2C0339FAp0", "0x0.000000FD276A99B771p0", "0x0.00000102CFAA9844BBp0",
"0x0.0000010887EC02E231p0", "0x0.0000010E502EDD9030p0", "0x0.0000011428732C4F14p0", "0x0.0000011A10B8F31F3Bp0",
"0x0.000001200900360103p0", "0x0.000001261148F8F4CBp0", "0x0.0000012C29933FFAF5p0", "0x0.0000013251DF0F13E1p0",
"0x0.000001388A2C6A3FF3p0", "0x0.0000013ED27B557F8Dp0", "0x0.000001452ACBD4D315p0", "0x0.0000014B931DEC3AEFp0",
"0x0.000001520B719FB782p0", "0x0.0000015893C6F34937p0", "0x0.0000015F2C1DEAF074p0", "0x0.00000165D4768AADA5p0",
"0x0.0000016C8CD0D68133p0", "0x0.00000173552CD26B89p0", "0x0.0000017A2D8A826D16p0", "0x0.0000018115E9EA8645p0",
"0x0.000001880E4B0EB785p0", "0x0.0000018F16ADF30147p0", "0x0.000001962F129B63FAp0", "0x0.0000019D57790BE010p0",
"0x0.000001A48FE14875FBp0", "0x0.000001ABD84B552630p0", "0x0.000001B330B735F122p0", "0x0.000001BA9924EED748p0",
"0x0.000001C2119483D917p0", "0x0.000001C99A05F8F707p0", "0x0.000001D13279523191p0", "0x0.000001D8DAEE93892Ep0",
"0x0.000001E09365C0FE59p0", "0x0.000001E85BDEDE918Dp0", "0x0.000001F03459F04347p0", "0x0.000001F81CD6FA1405p0",
"0x0.000002001556000444p0", "0x0.000002081DD7061485p0", "0x0.00000210365A104547p0", "0x0.000002185EDF22970Dp0",
"0x0.000002209766410A5Ap0", "0x0.00000228DFEF6F9FAFp0", "0x0.00000231387AB25793p0", "0x0.00000239A1080D328Ap0",
"0x0.00000242199784311Cp0", "0x0.0000024AA2291B53CFp0", "0x0.000002533ABCD69B2Dp0", "0x0.0000025BE352BA07BEp0",
"0x0.000002649BEAC99A0Dp0", "0x0.0000026D64850952A7p0", "0x0.000002763D217D3216p0", "0x0.0000027F25C02938EAp0",
"0x0.000002881E611167B0p0", "0x0.00000291270439BEF8p0", "0x0.0000029A3FA9A63F53p0", "0x0.000002A368515AE951p0",
"0x0.000002ACA0FB5BBD86p0", "0x0.000002B5E9A7ACBC86p0", "0x0.000002BF425651E6E4p0", "0x0.000002C8AB074F3D36p0",
"0x0.000002D223BAA8C013p0", "0x0.000002DBAC70627012p0", "0x0.000002E54528804DCDp0", "0x0.000002EEEDE30659DBp0",
"0x0.000002F8A69FF894D9p0", "0x0.000003026F5F5AFF61p0", "0x0.0000030C4821319A10p0", "0x0.0000031630E5806584p0",
"0x0.0000032029AC4B625Bp0", "0x0.0000032A3275969134p0", "0x0.000003344B4165F2B1p0", "0x0.0000033E740FBD8772p0",
"0x0.00000348ACE0A1501Bp0", "0x0.00000352F5B4154D4Fp0", "0x0.0000035D4E8A1D7FB2p0", "0x0.00000367B762BDE7EAp0",
"0x0.00000372303DFA869Ep0", "0x0.0000037CB91BD75C75p0", "0x0.0000038751FC586A18p0", "0x0.00000391FADF81B02Fp0",
"0x0.0000039CB3C5572F67p0", "0x0.000003A77CADDCE86Ap0", "0x0.000003B2559916DBE4p0", "0x0.000003BD3E87090A84p0",
"0x0.000003C83777B774F8p0", "0x0.000003D3406B261BF0p0", "0x0.000003DE596159001Cp0", "0x0.000003E9825A54222Dp0",
"0x0.000003F4BB561B82D7p0", "0x0.000004000454B322CCp0", "0x0.0000040B5D561F02C2p0", "0x0.00000416C65A63236Ep0",
"0x0.000004223F61838586p0", "0x0.0000042DC86B8429C2p0", "0x0.0000043961786910DBp0", "0x0.000004450A88363B8Ap0",
"0x0.00000450C39AEFAA8Ap0", "0x0.0000045C8CB0995E96p0", "0x0.0000046865C937586Bp0", "0x0.000004744EE4CD98C6p0",
"0x0.000004804803602067p0", "0x0.0000048C5124F2F00Cp0", "0x0.000004986A498A0876p0", "0x0.000004A49371296A67p0",
"0x0.000004B0CC9BD516A1p0", "0x0.000004BD15C9910DE8p0", "0x0.000004C96EFA615101p0", "0x0.000004D5D82E49E0B0p0",
"0x0.000004E251654EBDBDp0", "0x0.000004EEDA9F73E8F0p0", "0x0.000004FB73DCBD6310p0", "0x0.000005081D1D2F2CE7p0",
"0x0.00000514D660CD4740p0", "0x0.000005219FA79BB2E7p0", "0x0.0000052E78F19E70A8p0", "0x0.0000053B623ED98150p0",
"0x0.000005485B8F50E5AFp0", "0x0.0000055564E3089E93p0", "0x0.000005627E3A04ACCEp0", "0x0.0000056FA794491131p0",
"0x0.0000057CE0F1D9CC8Ep0", "0x0.0000058A2A52BADFBAp0", "0x0.0000059783B6F04B88p0", "0x0.000005A4ED1E7E10CFp0",
"0x0.000005B26689683064p0", "0x0.000005BFEFF7B2AB20p0", "0x0.000005CD89696181DBp0", "0x0.000005DB32DE78B56Fp0",
"0x0.000005E8EC56FC46B6p0", "0x0.000005F6B5D2F0368Cp0", "0x0.000006048F525885CDp0", "0x0.0000061278D5393558p0",
"0x0.00000620725B96460Ap0", "0x0.0000062E7BE573B8C3p0", "0x0.0000063C9572D58E64p0", "0x0.0000064ABF03BFC7CEp0",
"0x0.00000658F8983665E5p0", "0x0.0000066742303D698Bp0", "0x0.000006759BCBD8D3A5p0", "0x0.00000684056B0CA519p0",
"0x0.000006927F0DDCDECEp0", "0x0.000006A108B44D81AAp0", "0x0.000006AFA25E628E98p0", "0x0.000006BE4C0C20067Fp0",
"0x0.000006CD05BD89EA4Bp0", "0x0.000006DBCF72A43AE8p0", "0x0.000006EAA92B72F942p0", "0x0.000006F992E7FA2646p0",
"0x0.000007088CA83DC2E4p0", "0x0.00000717966C41D00Ap0", "0x0.00000726B0340A4EAAp0", "0x0.00000735D9FF9B3FB6p0",
"0x0.0000074513CEF8A41Ep0", "0x0.000007545DA2267CD9p0", "0x0.00000763B77928CAD9p0", "0x0.000007732154038F14p0",
"0x0.000007829B32BACA82p0", "0x0.000007922515527E1Ap0", "0x0.000007A1BEFBCEAAD4p0", "0x0.000007B168E63351AAp0",
"0x0.000007C122D4847397p0", "0x0.000007D0ECC6C61195p0", "0x0.000007E0C6BCFC2CA3p0", "0x0.000007F0B0B72AC5BEp0",
            };
            ap_ufixed<51,-21> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<62,-10> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(61,54) = x_msb_3(7,0);
            exp_x_msb_3_m_1(50, 0) = f_x_msb_3(50,0);

            ap_ufixed<50,-10> exp_x_msb_3_m_1_s = exp_x_msb_3_m_1;

            ap_ufixed<101,-27> f_x_msb_3_4_5_lsb = exp_x_msb_3_m_1_s * exp_x_msb_4_5_lsb_m_1;
            ap_ufixed<45,-27> f_x_msb_3_4_5_lsb_s = f_x_msb_3_4_5_lsb;
            ap_ufixed<63, -9> exp_x_msb_3_4_5_lsb_m_1 = f_x_msb_3_4_5_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_5_lsb_m_1;


            const static ap_ufixed<64,-4> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.00000800AAB555DDEp0", "0x0.00002005560011127p0", "0x0.00004812036081A9Cp0",
"0x0.0000802AB55777D28p0", "0x0.0000C8536F6684062p0", "0x0.0001209036103740Dp0", "0x0.000188E50ED8634A0p0",
"0x0.0002015600445B0C3p0", "0x0.000289E711DB32FD7p0", "0x0.0003229C4C260197Ep0", "0x0.0003CB79B8B01FE26p0",
"0x0.0004848362076A08Dp0", "0x0.00054DBD53BC80058p0", "0x0.0006272B9A630659Dp0", "0x0.000710D24391E6D7Ap0",
"0x0.00080AB55DE3917ABp0", "0x0.000914D8F8F63D524p0", "0x0.000A2F41256C297AFp0", "0x0.000B59F1F4EBDE291p0",
"0x0.000C94EF7A206DC2Dp0", "0x0.000DE03DC8B9B60B1p0", "0x0.000F3BE0F56CA15C4p0", "0x0.0010A7DD15F367F40p0",
"0x0.00122436410DD14E5p0", "0x0.0013B0F08E817591Ep0", "0x0.00154E101719FF0C5p0", "0x0.0016FB98F4A96BBEFp0",
"0x0.0018B98F42084EFBDp0", "0x0.001A87F71B1613137p0", "0x0.001C66D49CB93B127p0", "0x0.001E562BE4DFA4904p0",
"0x0.00205601127EC98E0p0", "0x0.00226658459402659p0", "0x0.002487359F24C7C99p0", "0x0.0026B89D413EF4D5Ep0",
"0x0.0028FA934EF909304p0", "0x0.002B4D1BEC726B39Cp0", "0x0.002DB03B3ED3AA50Ep0", "0x0.003023F56C4EC123Fp0",
"0x0.0032A84E9C1F58145p0", "0x0.00353D4AF68B07AA1p0", "0x0.0037E2EEA4E19B185p0", "0x0.003A993DD17D52D25p0",
"0x0.003D603CA7C32730Fp0", "0x0.004037EF54230B293p0", "0x0.0043205A04182F12Fp0", "0x0.00461980E62943810p0",
"0x0.0049236829E8BC292p0", "0x0.004C3E13FFF512DD8p0", "0x0.004F698899F90A966p0", "0x0.0052A5CA2AABF28D0p0",
"0x0.0055F2DCE5D1E966Ep0", "0x0.005950C5003C20723p0", "0x0.005CBF86AFC91EF2Bp0", "0x0.00603F262B65057FCp0",
"0x0.0063CFA7AB09D1732p0", "0x0.0067710F67BFA0687p0", "0x0.006B23619B9CF3CDEp0", "0x0.006EE6A281C6F4857p0",
"0x0.0072BAD65671B6977p0", "0x0.0076A00156E07CF57p0", "0x0.007A9627C165FD4EDp0", "0x0.007E9D4DD564A3F5Ep0",
"0x0.0082B577D34ED7D5Bp0", "0x0.0086DEA9FCA73E799p0", "0x0.008B18E8940100253p0", "0x0.008F6437DD000BFDAp0",
"0x0.0093C09C1C595C43Ep0", "0x0.00982E1997D33A9FCp0", "0x0.009CACB49645847CCp0", "0x0.00A13C715F99EF773p0",
"0x0.00A5DD543CCC4DDAFp0", "0x0.00AA8F6177EAD3336p0", "0x0.00AF529D5C1658EBCp0", "0x0.00B4270C3582A301Dp0",
"0x0.00B90CB25176A4C8Bp0", "0x0.00BE0393FE4CC5BD7p0", "0x0.00C30BB58B73266CAp0", "0x0.00C8251B496BE5696p0",
"0x0.00CD4FC989CD64555p0", "0x0.00D28BC49F428CFA3p0", "0x0.00D7D910DD8B16743p0", "0x0.00DD37B2997BCA6E6p0",
"0x0.00E2A7AE28FECA6FBp0", "0x0.00E82907E313D5399p0", "0x0.00EDBBC41FD08C383p0", "0x0.00F35FE73860B9038p0",
"0x0.00F91575870692F24p0", "0x0.00FEDC73671B04BDFp0", "0x0.0104B4E5350DF2386p0", "0x0.010A9ECF4E667E12Dp0",
"0x0.01109A3611C34FB64p0", "0x0.0116A71DDEDAD92D8p0", "0x0.011CC58B167B9D206p0", "0x0.0122F5821A8C74E0Dp0",
"0x0.012937074E0CD6893p0", "0x0.012F8A1F15151B2C6p0", "0x0.0135EECDD4D6C5172p0", "0x0.013C6517F39CC6233p0",
"0x0.0142ED01D8CBC61C4p0", "0x0.0149868FECE26935Dp0", "0x0.015031C6997996937p0", "0x0.0156EEAA4944BEE23p0",
"0x0.015DBD3F68122303Ep0", "0x0.01649D8A62CB1ACBEp0", "0x0.016B8F8FA7745BCDBp0", "0x0.01729353A52E403D8p0",
"0x0.0179A8DACC350DE1Dp0", "0x0.0180D0298DE13D179p0", "0x0.018809445CA7BFE78p0", "0x0.018F542FAC1A492D6p0",
"0x0.0196B0EFF0E793D15p0", "0x0.019E1F89A0DBAA128p0", "0x0.01A5A00132E02CE42p0", "0x0.01AD325B1EFC9B5BCp0",
"0x0.01B4D69BDE569A322p0", "0x0.01BC8CC7EB323B553p0", "0x0.01C454E3C0F2458C8p0", "0x0.01CC2EF3DC187C2F6p0",
"0x0.01D41AFCBA45E6ED2p0", "0x0.01DC1902DA3B19A6Dp0", "0x0.01E4290ABBD87C5BCp0", "0x0.01EC4B18E01E9326Fp0",
"0x0.01F47F31C92E464FCp0", "0x0.01FCC559FA492A6B6p0", "0x0.02051D95F7D1C8917p0", "0x0.020D87EA474BE6A1Cp0",
"0x0.0216045B6F5CCF9CEp0", "0x0.021E92EDF7CB9C0E4p0", "0x0.022733A669817A88Ap0", "0x0.022FE6894E89F834Cp0",
"0x0.0238AB9B321349722p0", "0x0.024182E0A06E9289Bp0", "0x0.024A6C5E271030733p0", "0x0.02536818549001AC1p0",
"0x0.025C7613B8A9AF215p0", "0x0.02659654E43CF52B1p0", "0x0.026EC8E0694DEC9A9p0", "0x0.02780DBADB0553DA6p0",
"0x0.028164E8CDB0D8211p0", "0x0.028ACE6ED6C35EB5Fp0", "0x0.02944A518CD54E484p0", "0x0.029DD89587A4D858Dp0",
"0x0.02A7793F601642B5Dp0", "0x0.02B12C53B03431090p0", "0x0.02BAF1D7132FEE788p0", "0x0.02C4C9CE2561B759Fp0",
"0x0.02CEB43D844902F7Ap0", "0x0.02D8B129CE8CCD68Fp0", "0x0.02E2C097A3FBE17C9p0", "0x0.02ECE28BA58D22B56p0",
"0x0.02F7170A755FD759Ep0", "0x0.03015E18B6BBF2966p0", "0x0.030BB7BB0E125EB13p0", "0x0.031623F620FD4751Ep0",
"0x0.0320A2CE964063DACp0", "0x0.032B344915C941D54p0", "0x0.0335D86A48AF8F70Cp0", "0x0.03408F36D93566140p0",
"0x0.034B58B372C795013p0", "0x0.035634E4C1FDEC0D0p0", "0x0.036123CF749B8667Cp0", "0x0.036C2578398F157A0p0",
"0x0.037739E3C0F32BD30p0", "0x0.03826116BC0E882ACp0", "0x0.038D9B15DD5460763p0", "0x0.0398E7E5D864AD0E9p0",
"0x0.03A4478B620C73EB5p0", "0x0.03AFBA0B304613EEDp0", "0x0.03BB3F69FA3990464p0", "0x0.03C6D7AC783CDBDBFp0",
"0x0.03D282D763D424DCDp0", "0x0.03DE40EF77B220509p0", "0x0.03EA11F96FB855C4Fp0", "0x0.03F5F5FA08F76B0BBp0",
"0x0.0401ECF601AF700BDp0", "0x0.040DF6F219502AA55p0", "0x0.041A13F3107962A88p0", "0x0.042643FDA8FB2DDFBp0",
"0x0.04328716A5D63C2C4p0", "0x0.043EDD42CB3C23B6Dp0", "0x0.044B4686DE8FAD325p0", "0x0.0457C2E7A66520322p0",
"0x0.04645269EA828F932p0", "0x0.0470F51273E025F89p0", "0x0.047DAAE60CA8725B3p0", "0x0.048A73E98038B4ABFp0",
"0x0.049750219B212A8A0p0", "0x0.04A43F932B255C0B7p0", "0x0.04B14242FF3C689A0p0", "0x0.04BE5835E79153E1Dp0",
"0x0.04CB8170B58352D4Ep0", "0x0.04D8BDF83BA618C04p0", "0x0.04E60DD14DC22475Ep0", "0x0.04F37100C0D50D88Ep0",
"0x0.0500E78B6B11D19D6p0", "0x0.050E717623E121CBAp0", "0x0.051C0EC5C3E1B016Cp0", "0x0.0529BF7F24E87CF6Ap0",
"0x0.053783A7220124F51p0", "0x0.05455B42976E2E5EAp0", "0x0.0553465662A95706Bp0", "0x0.056144E76263E21F4p0",
"0x0.056F56FA7686E623Ep0", "0x0.057D7C9480339AD83p0", "0x0.058BB5BA61C3A75A3p0", "0x0.059A0270FEC97047Ap0",
"0x0.05A862BD3C1065F74p0", "0x0.05B6D6A3FF9D52C58p0", "0x0.05C55E2A30AEA974Ep0", "0x0.05D3F954B7BCD3A1Bp0",
"0x0.05E2A8287E7A8049Ep0", "0x0.05F16AAA6FD4F267Bp0", "0x0.060040DF77F44FA13p0", "0x0.060F2ACC843BEF0A0p0",
"0x0.061E2876834AA7FA4p0", "0x0.062D39E264FB20F7Ep0", "0x0.063C5F151A641EB4Cp0", "0x0.064B981395D8D31FEp0",
"0x0.065AE4E2CAE92C8AAp0", "0x0.066A4587AE6224E1Cp0", "0x0.0679BA07364E10FA3p0", "0x0.0689426659F4EFF1Bp0",
"0x0.0698DEAA11DCBAA37p0", "0x0.06A88ED757C9B3304p0", "0x0.06B852F326BEB49B0p0", "0x0.06C82B027AFD8278Ap0",
"0x0.06D8170A520718B46p0", "0x0.06E8170FAA9BFB67Ep0", "0x0.06F82B1784BC86C72p0", "0x0.07085326E1A93F207p0",
"0x0.07188F42C3E320F0Bp0", "0x0.0728DF702F2BF10B2p0", "0x0.073943B428868CD5Ap0", "0x0.0749BC13B6373A98Fp0",
"0x0.075A4893DFC3F9E4Cp0", "0x0.076AE939ADF4D4083p0", "0x0.077B9E0A2AD42C9E8p0", "0x0.078C670A61AF122F4p0",
"0x0.079D443F5F158EE3Ap0", "0x0.07AE35AE30DAF94F1p0", "0x0.07BF3B5BE616454CBp0", "0x0.07D0554D8F2254F0Cp0",
"0x0.07E183883D9E498E2p0", "0x0.07F2C611046DD4D06p0", "0x0.08041CECF7B989EA2p0", "0x0.081588212CEF2ED73p0",
"0x0.082707B2BAC20DB40p0", "0x0.08389BA6B92B46284p0", "0x0.084A4402416A1EE6Fp0", "0x0.085C00CA6E045741Fp0",
"0x0.086DD2045AC678D2Bp0", "0x0.087FB7B524C42936Cp0", "0x0.0891B1E1EA587BE12p0", "0x0.08A3C08FCB2643FFEp0",
            };
            ap_ufixed<64,-4> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 6,-4> f_x_msb_2_h;
            f_x_msb_2_h(5,0) = f_x_msb_2(63,58);
            ap_ufixed< 9,-1> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<67,-1> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(66,58) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(57, 0) = f_x_msb_2(57,0);

            ap_ufixed<130,-10> f_x_msb_2_3_4_5_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_5_lsb_m_1;
            ap_ufixed<62,-10> f_x_msb_2_3_4_5_lsb_s = f_x_msb_2_3_4_5_lsb;
            ap_ufixed<72,0> exp_x_msb_2_3_4_5_lsb_m_1 = f_x_msb_2_3_4_5_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_5_lsb_m_1;

            const static ap_ufixed<68,32> exp_x_msb_1_table[256] = {
"0x1.000000000p0", "0x1.48B5E3C3Ep0", "0x1.A61298E1Ep0", "0x2.1DF3B68CFp0",
"0x2.B7E151628p0", "0x3.7D871DB61p0", "0x4.7B4FF993Fp0", "0x5.C12DA416Ep0",
"0x7.63992E353p0", "0x9.7CDC417A3p0", "0xC.2EB7EC98Fp0", "0xF.A48385EDFp0",
"0x14.15E5BF6FBp0", "0x19.CA53B7811p0", "0x21.1D8E4272Dp0", "0x2A.8565A144Cp0",
"0x36.99205C4E7p0", "0x46.1AFC4DB59p0", "0x5A.0462B7877p0", "0x73.9593ABB7Dp0",
"0x94.69C4CB819p0", "0xBE.90F6F83E9p0", "0xF4.B122790DDp0", "0x13A.30CF1CCBBp0",
"0x193.6DC5690C0p0", "0x206.03487A3B1p0", "0x299.2442102D9p0", "0x356.0F0B0F980p0",
"0x448.A216ABB76p0", "0x580.1AD754FA3p0", "0x710.0ADBAC7DAp0", "0x911.9289C3923p0",
"0xBA4.F53EA3863p0", "0xEF3.A035D5798p0", "0x1332.C4D2B7C4Ap0", "0x18A6.B027DA0A7p0",
"0x1FA7.157C470F8p0", "0x28A4.90D2CCEF1p0", "0x342F.BA11823B8p0", "0x4302.3A933EE5Cp0",
"0x560A.773E54157p0", "0x6E7A.8ABB4A83Cp0", "0x8DDB.80AF4269Dp0", "0xB626.0748BAEC7p0",
"0xE9E2.2447727BFp0", "0x12C4F.EB75B2AB0p0", "0x1819B.C560F6113p0", "0x1EF21.8F1B001A4p0",
"0x27BC2.CA9A6F934p0", "0x33055.49F35D91Fp0", "0x41831.49596E996p0", "0x541E7.E56949D58p0",
"0x6C02D.645AB2554p0", "0x8AB06.0A3EE9FB1p0", "0xB2148.5EAE56C5Bp0", "0xE4A8D.2881EDBE8p0",
"0x1259AC.48BF05D6Ep0", "0x178FEE.7792E44B3p0", "0x1E4127.437732B71p0", "0x26D8F9.4A204BEA5p0",
"0x31E199.5F5A550DDp0", "0x400C7D.64D3386CBp0", "0x523D82.79EDAEF9Cp0", "0x69993D.D4F2D9524p0",
"0x87975E.854001024p0", "0xAE1A47.C38A42CD0p0", "0xDF8D5F.6DCFE5CEAp0", "0x11F0BF8.1E99FDEB6p0",
"0x1709348.C0EA4F8CEp0", "0x1D94295.464477ACCp0", "0x25FAD90.65C78E342p0", "0x30C4623.616ED2BE2p0",
"0x3E9E441.232817A61p0", "0x506744D.3B342FC94p0", "0x673D70B.C00F1F76Dp0", "0x849012B.C127FC962p0",
"0xAA36C7C.F69370B94p0", "0xDA8F202.DD9ACE661p0", "0x118A2AAE.0AA05236Bp0", "0x16857CFA.1AA8A5555p0",
"0x1CEB088B.68E804021p0", "0x2521AEDA.32CD52BE5p0", "0x2FAD89E1.79BAB8EADp0", "0x3D3838C6.BE0F13F06p0",
"0x4E9B87F6.7BB3F5597p0", "0x64EF201B.01109A4A5p0", "0x819A1801.9394C0D96p0", "0xA6698403.CF5D9E663p0",
"0xD5AD6DCE.21AFFC0DDp0", "0x1125E066B.0B19418CCp0", "0x1604B68CF.05F65FAA9p0", "0x1C45AED0A.D0C934CDCp0",
"0x244D5E676.3FB814AF0p0", "0x2E9CEBF49.9C21839C7p0", "0x3BDA2CBD0.9F5AC2146p0", "0x4CDA0FD41.989F004E7p0",
"0x62ADFED51.D7EDCCDE6p0", "0x7EB50B520.76F91D6E8p0", "0xA2B1FD3D9.A57B6C33Cp0", "0xD0E7A50F4.EF0D7447Fp0",
"0x10C3D39209.62C88AAFBp0", "0x1586D0722B.3EEB27301p0", "0x1BA4068AAC.2B6E3EE34p0", "0x237DCBF1E5.709A9F9C1p0",
"0x2D9264D2D4.D6B94153Bp0", "0x3A83F23B18.FE5BD524Ap0", "0x4B22A1B5C3.27A2FD85Ap0", "0x6079C1866C.71A93951Dp0",
"0x7BE08BDFD9.CC72249ABp0", "0x9F0FB7309C.B446D3919p0", "0xCC3D265776.C3D25779Ep0", "0x1063F7612B0.C0831CA6Cp0",
"0x150BBA37963.79A4FB6ADp0", "0x1B05FA9B62E.737D935B8p0", "0x22B2DC5C41D.AD89559EBp0", "0x2C8DD1AB28B.404414BE7p0",
"0x39355C8C638.0AC5631B1p0", "0x49750434675.301B8D0E7p0", "0x5E521E7A16E.51F9CD3C2p0", "0x791C3B06F8B.EA2DEC48Cp0",
"0x9B823857614.764F43E20p0", "0xC7AD559D438.E7C270C30p0", "0x10063F4E687B.A1A43A35Bp0", "0x149363C905BA.3641D0164p0",
"0x1A6B765D8CDF.6CDBF1C63p0", "0x21EC75240E66.E2891CE63p0", "0x2B8F1073A6AF.BA219DB61p0", "0x37EE3FFC0063.E360F931Fp0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000001p0", "0x0.000000001p0", "0x0.000000002p0",
"0x0.000000002p0", "0x0.000000003p0", "0x0.000000004p0", "0x0.000000005p0",
"0x0.000000007p0", "0x0.000000009p0", "0x0.00000000Bp0", "0x0.00000000Ep0",
"0x0.000000013p0", "0x0.000000018p0", "0x0.00000001Fp0", "0x0.000000028p0",
"0x0.000000034p0", "0x0.000000042p0", "0x0.000000055p0", "0x0.00000006Ep0",
"0x0.00000008Dp0", "0x0.0000000B5p0", "0x0.0000000E9p0", "0x0.00000012Bp0",
"0x0.000000181p0", "0x0.0000001EEp0", "0x0.00000027Ap0", "0x0.00000032Fp0",
"0x0.000000416p0", "0x0.00000053Fp0", "0x0.0000006BDp0", "0x0.0000008A7p0",
"0x0.000000B1Cp0", "0x0.000000E44p0", "0x0.000001252p0", "0x0.000001786p0",
"0x0.000001E35p0", "0x0.0000026C9p0", "0x0.0000031CEp0", "0x0.000003FF3p0",
"0x0.00000521Dp0", "0x0.000006970p0", "0x0.000008762p0", "0x0.00000ADD6p0",
"0x0.00000DF36p0", "0x0.000011E9Cp0", "0x0.000017003p0", "0x0.00001D88Ap0",
"0x0.000025EC0p0", "0x0.000030B15p0", "0x0.00003E85Dp0", "0x0.00005047Ep0",
"0x0.000067153p0", "0x0.0000845C6p0", "0x0.0000A9F46p0", "0x0.0000DA39Ep0",
"0x0.000118354p0", "0x0.000167CB5p0", "0x0.0001CDFC2p0", "0x0.000251334p0",
"0x0.0002F9AF3p0", "0x0.0003D205Ap0", "0x0.0004E7CE2p0", "0x0.00064C7C6p0",
"0x0.000816791p0", "0x0.000A628A3p0", "0x0.000D55A1Fp0", "0x0.00111F30Fp0",
"0x0.0015FC210p0", "0x0.001C3AA91p0", "0x0.00243F374p0", "0x0.002E8ABFCp0",
"0x0.003BC2D73p0", "0x0.004CBC19Ap0", "0x0.006287862p0", "0x0.007E83A56p0",
"0x0.00A2728F8p0", "0x0.00D096336p0", "0x0.010BD4A5Ap0", "0x0.0157E6BFEp0",
"0x0.01B993FE0p0", "0x0.0236FF5BFp0", "0x0.02D80A08Dp0", "0x0.03A6D2222p0",
"0x0.04B0556E0p0", "0x0.0605424D5p0", "0x0.07BB04063p0", "0x0.09ED1B429p0",
"0x0.0CBED8666p0", "0x0.105D93892p0", "0x0.150385C09p0", "0x0.1AFB718E8p0",
"0x0.22A555477p0", "0x0.2C7C72FC0p0", "0x0.391F0EE49p0", "0x0.495860DCAp0",
"0x0.5E2D58D8Bp0", "0x0.78ED03AFBp0", "0x0.9B4597E37p0", "0x0.C75F7CF56p0",
            };
            ap_ufixed<68,32> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<140,32> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_5_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        y += delta;

            overf = 0;
            VITIS_LOOP_2079_19: for (int j = 64; j >= I_+31; j--) {
#pragma HLS unroll
 if (y[j])
                    overf = 1;
            }
            if (overf) {
                VITIS_LOOP_2085_20: for (int j = 64; j >= I_+31; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2089_21: for (int j = I_+30; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }

        r = y;
    }
    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> exp(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return exp(xf);
}

template<int I_>
ap_int<I_> exp(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return exp(xf);
}

template<int I_>
ap_uint<I_> exp(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return exp(xf);
}

template<int W, int I>
ap_fixed<W,I> expm1(ap_fixed<W,I> x) {
    ap_fixed<W,I> result, tmp;
    ap_ufixed<1,1> one = 1;
    if(I < 1) {
        result = 0;
    } else {
        ap_fixed<W,I> tmp = exp(x);
        ap_ufixed<1,1> one = 1;
        result = tmp - one;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> expm1(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return expm1(xf);
}

template<int I>
ap_int<I> expm1(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return expm1(xf);
}

template<int I>
ap_uint<I> expm1(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return expm1(xf);
}

template<int W, int I>
ap_fixed<W,I> exp2(ap_fixed<W,I> x) {

    int F = W - I;
    if(I > 33 || F > 32) {
        return 0;
    }

    int I_s;
    int M = ((I - 1) > F) ? (I - 1) : F;

    if(M == 1) {
        I_s = 1;
    } else if(M == 2) {
        I_s = 2;
    } else if(M <= 4) {
        I_s = 3;
    } else if(M <= 8) {
        I_s = 4;
    } else if(M <= 16) {
        I_s = 5;
    } else {
        I_s = 6;
    }

    ap_fixed<W,I> r;

    if(I_s == 1) {

        ap_fixed<3,2> x_l = x;
        ap_ufixed<2,1> y = 0;

        if(!x_l[2]) {
            y[1] = 1;
        }
        if(x_l[1]) {
            y[0] = 1;
        }

        if(I<2) {
            if(y[1]) {
                y[1]=0;
                y[0]=1;
            }
        }
        r = y;

    } else if(I_s == 2) {

        ap_fixed<5,3> x_l = x;
        ap_ufixed<4,2> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(3,2);
        ap_ufixed<2,0> x_l_fract;
        x_l_fract(1,0) = x_l(1,0);

        if( (x_l[4]&&(!x_l[3])) || ((!x_l[4])&&x_l[3]) ) {
            if(!x_l[4]) {
                y = "0x3.cp0";
            }
        } else {
            if((!x_l[3])&(x_l[2])) y[3] = 1;
            if(((!x_l[3])&(!x_l[2])) | ((!x_l[3])&x_l[2]&x_l[1]&x_l[0])) y[2] = 1;
            if( (x_l[3]&x_l[2]) | ((!x_l[3])&( (x_l[2]&(x_l[1]^x_l[0])) | ((!x_l[2])&x_l[1]&x_l[0] )))) y[1] = 1;
            if((x_l[3]&(!x_l[2])) | (x_l[1]&((x_l[0]&x_l[2]) | ((!x_l[0])&(!x_l[3]))))) y[0] =1;
        }

        if(I<3) {
            bool overf = 0;
            VITIS_LOOP_2219_1: for(int j=3; j>=I+1; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf = 1;
                }
            }
            if (overf) {
                VITIS_LOOP_2226_2: for(int j=3; j>=I+1; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2230_3: for(int j=I; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 3) {

        ap_fixed<9,5> x_l = x;
        ap_ufixed<8,4> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(6,4);
        ap_ufixed<4,0> x_l_fract;
        x_l_fract(3,0) = x_l(3,0);

        if((x_l[8]!=x_l[7])||(x_l[8]!=x_l[6])) {
            if(!x_l[8]) {
                y = "0xf.fp0";
            }
        } else {
            ap_uint<4> x_msb_ind;
            ap_uint<3> x_lsb_ind;
            x_msb_ind[3] = x_l[8];
            x_msb_ind(2,0) = x_l(5,3);
            x_lsb_ind(2,0) = x_l(2,0);
            const static ap_ufixed<10,4> exp2_x_msb_table[16] = {
                "0x1.00p0", "0x1.6Cp0", "0x2.00p0", "0x2.D4p0",
                "0x4.00p0", "0x5.A8p0", "0x8.00p0", "0xB.50p0",
                "0x0.10p0", "0x0.18p0", "0x0.20p0", "0x0.2Cp0",
                "0x0.40p0", "0x0.5Cp0", "0x0.80p0", "0x0.B4p0"
            };
            const static ap_ufixed<10,0> exp2_x_lsb_m_1_table[8] = {
                "0x0.0p0", "0x0.0B4p0", "0x0.174p0", "0x0.238p0",
                "0x0.308p0", "0x0.3E0p0", "0x0.4C0p0", "0x0.5ACp0"
            };
            ap_ufixed<11,0> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];
            ap_ufixed<10,4> exp2_x_msb = exp2_x_msb_table[x_msb_ind];
            ap_ufixed<21,4> y_lo = exp2_x_msb * exp2_x_lsb_m_1;
            ap_ufixed<10,4> y_lo_s = y_lo;
            ap_ufixed<10,4> y_l = y_lo_s + exp2_x_msb;
            y = y_l;
        }

        if(I < 5) {
            bool overf = 0;
            VITIS_LOOP_2277_4: for(int j=7; j>=3+I; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf = 1;
                }
            }
            if(overf) {
                VITIS_LOOP_2284_5: for(int j=7; j>=3+I; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2288_6: for(int j=I+2; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 4) {

        ap_fixed<17,9> x_l=x;
        ap_ufixed<16,8> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(11,8);
        ap_ufixed<8,0> x_l_fract;
        x_l_fract(7,0) = x_l(7,0);

        bool overf_1 = 0;
        VITIS_LOOP_2306_7: for(int j=11; j<16; j++) {
#pragma HLS unroll
 if(x_l[16]!=x_l[j]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[16]) {
                y = "0xff.ffp0";
            }
        } else {

            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1(4,0) = x_l(11,7);
            ap_uint<4> x_msb_ind_2;
            x_msb_ind_2(3,0) = x_l(6,3);
            ap_uint<3> x_lsb_ind;
            x_lsb_ind = x_l(2,0);

            const static ap_ufixed<14,-5> exp2_x_lsb_m_1_table[8] = {
                "0x0.0p0", "0x0.00B1Ap0", "0x0.0163Ep0", "0x0.02168p0",
                "0x0.02C9Ap0", "0x0.037D4p0", "0x0.04316p0", "0x0.04E60p0"
            };
            ap_ufixed<14,-5> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<19,0> exp2_x_msb_2_m_1_table[16] = {
                "0x0.0p0,0", "0x0.059B0p0", "0x0.0B558p0", "0x0.11302p0",
                "0x0.172B8p0", "0x0.1D488p0", "0x0.2387Ap0", "0x0.29E9Ep0",
                "0x0.306FEp0", "0x0.371A8p0", "0x0.3DEA6p0", "0x0.44E08p0",
                "0x0.4BFDAp0", "0x0.5342Cp0", "0x0.5AB08p0", "0x0.6247Ep0"
            };
            ap_ufixed<19,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<33,-5> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_lsb_m_1;
            ap_ufixed<19,0> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<19,0> exp2_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<19,8> exp2_x_msb_1_table[32] = {
                "0x1.000p0", "0x1.6A0p0", "0x2.000p0", "0x2.D42p0",
                "0x4.000p0", "0x5.A82p0", "0x8.000p0", "0xB.504p0",
                "0x10.000p0", "0x16.A0Ap0", "0x20.000p0", "0x2D.414p0",
                "0x40.000p0", "0x5A.828p0", "0x80.000p0", "0xB5.050p0",
                "0x0.010p0", "0x0.016p0", "0x0.020p0", "0x0.02Ep0",
                "0x0.040p0", "0x0.05Ap0", "0x0.080p0", "0x0.0B6p0",
                "0x0.100p0", "0x0.16Ap0", "0x0.200p0", "0x0.2D4p0",
                "0x0.400p0", "0x0.5A8p0", "0x0.800p0", "0x0.B50p0"
            };
            ap_ufixed<19,8> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<38,8> y_lo = exp2_x_msb_1 * exp2_x_msb_2_lsb_m_1;
            ap_ufixed<19,8> y_lo_s = y_lo;
            ap_ufixed<19,8> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I < 9) {
            bool overf_2 = 0;
            VITIS_LOOP_2361_8: for(int j=15; j>=7+I; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
                VITIS_LOOP_2368_9: for(int j=15; j>=7+I; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2372_10: for(int j=6+I; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 5) {

        ap_fixed<33,17> x_l = x;
        ap_ufixed<32,16> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(20,16);
        ap_ufixed<16,0> x_l_fract;
        x_l_fract(15,0) = x_l(15,0);

        bool overf_1 = 0;
        VITIS_LOOP_2390_11: for(int j=20; j<32; j++) {
#pragma HLS unroll
 if(x_l[32]!=x_l[j]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[32]) {
                y = "0xffff.ffffp0";
            }
        } else {
            ap_uint<6> x_msb_ind_1;
            x_msb_ind_1(5,0) = x_l(20,15);
            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(14,10);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(9,5);
            ap_uint<5> x_lsb_ind;
            x_lsb_ind = x_l(4,0);

            const static ap_ufixed<25,-11> exp2_x_lsb_m_1_table[32] = {
                "0x0.0p0", "0x0.0000B1725p0", "0x0.000162E52p0", "0x0.000214587p0",
                "0x0.0002C5CC3p0", "0x0.000377408p0", "0x0.000428B53p0", "0x0.0004DA2A7p0",
                "0x0.00058BA02p0", "0x0.00063D165p0", "0x0.0006EE8CFp0", "0x0.0007A0042p0",
                "0x0.0008517BBp0", "0x0.000902F3Dp0", "0x0.0009B46C6p0", "0x0.000A65E57p0",
                "0x0.000B175F0p0", "0x0.000BC8D90p0", "0x0.000C7A538p0", "0x0.000D2BCE8p0",
                "0x0.000DDD4A0p0", "0x0.000E8EC5Fp0", "0x0.000F40425p0", "0x0.000FF1BF4p0",
                "0x0.0010A33CAp0", "0x0.001154BA8p0", "0x0.00120638Dp0", "0x0.0012B7B7Bp0",
                "0x0.001369370p0", "0x0.00141AB6Cp0", "0x0.0014CC371p0", "0x0.00157DB7Dp0"
            };
            ap_ufixed<25,-11> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<30,-6> exp2_x_msb_3_m_1_table[32] = {
                "0x0.0p0", "0x0.00162F390p0", "0x0.002C605E3p0", "0x0.0042936FBp0",
                "0x0.0058C86DAp0", "0x0.006EFF584p0", "0x0.0085382FBp0", "0x0.009B72F42p0",
                "0x0.00B1AFA5Bp0", "0x0.00C7EE449p0", "0x0.00DE2ED0Fp0", "0x0.00F4714AFp0",
                "0x0.010AB5B2Dp0", "0x0.0120FC08Ap0", "0x0.0137444CAp0", "0x0.014D8E7EFp0",
                "0x0.0163DA9FBp0", "0x0.017A28AF2p0", "0x0.019078AD7p0", "0x0.01A6CA9ABp0",
                "0x0.01BD1E771p0", "0x0.01D37442Dp0", "0x0.01E9CBFE1p0", "0x0.020025A8Fp0",
                "0x0.02168143Bp0", "0x0.022CDECE7p0", "0x0.02433E495p0", "0x0.02599FB48p0",
                "0x0.027003104p0", "0x0.0286685CAp0", "0x0.029CCF99Dp0", "0x0.02B338C81p0"
            };
            ap_ufixed<30,-6> exp2_x_msb_3_m_1 = exp2_x_msb_3_m_1_table[x_msb_ind_3];
            ap_ufixed<55,-17> f_x_msb_3_lsb = exp2_x_msb_3_m_1 * exp2_x_lsb_m_1;
            ap_ufixed<19,-17> f_x_msb_3_lsb_s = f_x_msb_3_lsb;
            ap_ufixed<30,-6> exp2_x_msb_3_lsb_m_1 = f_x_msb_3_lsb_s + exp2_x_msb_3_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<36,0> exp2_x_msb_2_m_1_table[32] = {
                "0x0.0p0", "0x0.02C9A3E78p0", "0x0.059B0D316p0", "0x0.087451876p0",
                "0x0.0B5586CFAp0", "0x0.0E3EC32D4p0", "0x0.11301D012p0", "0x0.1429AAEA9p0",
                "0x0.172B83C7Dp0", "0x0.1A35BEB70p0", "0x0.1D4873169p0", "0x0.2063B8863p0",
                "0x0.2387A6E75p0", "0x0.26B4565E2p0", "0x0.29E9DF520p0", "0x0.2D285A6E4p0",
                "0x0.306FE0A32p0", "0x0.33C08B264p0", "0x0.371A7373Bp0", "0x0.3A7DB34E6p0",
                "0x0.3DEA64C12p0", "0x0.4160A21F7p0", "0x0.44E086062p0", "0x0.486A2B5C1p0",
                "0x0.4BFDAD536p0", "0x0.4F9B2769Dp0", "0x0.5342B569Dp0", "0x0.56F4736B5p0",
                "0x0.5AB07DD48p0", "0x0.5E76F15ADp0", "0x0.6247EB03Ap0", "0x0.662388255p0"
            };
            ap_ufixed<36,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<66,-6> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_msb_3_lsb_m_1;
            ap_ufixed<30,-6> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<36,0> exp2_x_msb_2_3_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_msb_3_lsb_m_1;

            const static ap_ufixed<36,16> exp2_x_msb_1_table[64] = {
                "0x1.00000p0", "0x1.6A09Ep0", "0x2.00000p0", "0x2.D413Dp0",
                "0x4.00000p0", "0x5.A827Ap0", "0x8.00000p0", "0xB.504F3p0",
                "0x10.00000p0", "0x16.A09E6p0", "0x20.00000p0", "0x2D.413CDp0",
                "0x40.00000p0", "0x5A.8279Ap0", "0x80.00000p0", "0xB5.04F33p0",
                "0x100.00000p0", "0x16A.09E66p0", "0x200.00000p0", "0x2D4.13CCDp0",
                "0x400.00000p0", "0x5A8.2799Ap0", "0x800.00000p0", "0xB50.4F334p0",
                "0x1000.00000p0", "0x16A0.9E668p0", "0x2000.00000p0", "0x2D41.3CCD0p0",
                "0x4000.00000p0", "0x5A82.799A0p0", "0x8000.00000p0", "0xB504.F3340p0",
                "0x0.00010p0", "0x0.00017p0", "0x0.00020p0", "0x0.0002Dp0",
                "0x0.00040p0", "0x0.0005Bp0", "0x0.00080p0", "0x0.000B5p0",
                "0x0.00100p0", "0x0.0016Ap0", "0x0.00200p0", "0x0.002D4p0",
                "0x0.00400p0", "0x0.005A8p0", "0x0.00800p0", "0x0.00B50p0",
                "0x0.01000p0", "0x0.016A1p0", "0x0.02000p0", "0x0.02D41p0",
                "0x0.04000p0", "0x0.05A82p0", "0x0.08000p0", "0x0.0B505p0",
                "0x0.10000p0", "0x0.16A0Ap0", "0x0.20000p0", "0x0.2D414p0",
                "0x0.40000p0", "0x0.5A828p0", "0x0.80000p0", "0x0.B504Fp0"
            };
            ap_ufixed<36,16> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<72,16> y_lo = exp2_x_msb_1 * exp2_x_msb_2_3_lsb_m_1;
            ap_ufixed<36,16> y_lo_s = y_lo;
            ap_ufixed<36,16> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I<17) {
            bool overf_2 = 0;
            VITIS_LOOP_2479_12: for(int j=31; j>=I+15; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
                VITIS_LOOP_2486_13: for(int j=31; j>=I+15; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2490_14: for(int j=I+14; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;

    } else {
        ap_fixed<65,33> x_l = 0;
        VITIS_LOOP_2500_15: for(int j=32-F; j<32+I; j++) {
#pragma HLS unroll
 x_l[j] = x[j-(32-F)];
        }
        VITIS_LOOP_2504_16: for(int j=32+I; j<=64; j++) {
#pragma HLS unroll
 x_l[j] = x[W-1];
        }
        ap_ufixed<64,32> y = 0;
        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(37,32);
        ap_ufixed<32,0> x_l_fract;
        x_l_fract(31,0) = x_l(31,0);

        bool overf_1 = 0;
        VITIS_LOOP_2515_17: for(int j=37; j<64; j++) {
#pragma HLS unroll
 if(x_l[j]!=x_l[64]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[64]) {
                VITIS_LOOP_2523_18: for(int j=0; j<64; j++) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1(7,0) = x_l(37,30);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(29,22);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(21,14);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(13,6);
            ap_uint<6> x_lsb_ind;
            x_lsb_ind(5,0) = x_l(5,0);

            const static ap_ufixed<42,-26> exp2_x_lsb_m_1_table[64] = {
                "0x0.0p0", "0x0.00000000B17217F81p0", "0x0.0000000162E42FF0Ap0", "0x0.00000002145647E9Ap0",
                "0x0.00000002C5C85FE32p0", "0x0.00000003773A77DD2p0", "0x0.0000000428AC8FD79p0", "0x0.00000004DA1EA7D28p0",
                "0x0.000000058B90BFCDFp0", "0x0.000000063D02D7C9Dp0", "0x0.00000006EE74EFC63p0", "0x0.000000079FE707C31p0",
                "0x0.0000000851591FC07p0", "0x0.0000000902CB37BE4p0", "0x0.00000009B43D4FBC9p0", "0x0.0000000A65AF67BB6p0",
                "0x0.0000000B17217FBAAp0", "0x0.0000000BC89397BA6p0", "0x0.0000000C7A05AFBA9p0", "0x0.0000000D2B77C7BB5p0",
                "0x0.0000000DDCE9DFBC8p0", "0x0.0000000E8E5BF7BE2p0", "0x0.0000000F3FCE0FC05p0", "0x0.0000000FF14027C2Fp0",
                "0x0.00000010A2B23FC61p0", "0x0.00000011542457C9Ap0", "0x0.0000001205966FCDBp0", "0x0.00000012B70887D24p0",
                "0x0.00000013687A9FD75p0", "0x0.0000001419ECB7DCDp0", "0x0.00000014CB5ECFE2Dp0", "0x0.000000157CD0E7E94p0",
                "0x0.000000162E42FFF03p0", "0x0.00000016DFB517F7Ap0", "0x0.0000001791272FFF9p0", "0x0.0000001842994807Fp0",
                "0x0.00000018F40B6010Dp0", "0x0.00000019A57D781A3p0", "0x0.0000001A56EF90240p0", "0x0.0000001B0861A82E6p0",
                "0x0.0000001BB9D3C0392p0", "0x0.0000001C6B45D8447p0", "0x0.0000001D1CB7F0503p0", "0x0.0000001DCE2A085C7p0",
                "0x0.0000001E7F9C20692p0", "0x0.0000001F310E38765p0", "0x0.0000001FE28050840p0", "0x0.0000002093F268923p0",
                "0x0.00000021456480A0Dp0", "0x0.00000021F6D698AFFp0", "0x0.00000022A848B0BF9p0", "0x0.0000002359BAC8CFAp0",
                "0x0.000000240B2CE0E03p0", "0x0.00000024BC9EF8F14p0", "0x0.000000256E111102Cp0", "0x0.000000261F832914Cp0",
                "0x0.00000026D0F541274p0", "0x0.000000278267593A3p0", "0x0.0000002833D9714DBp0", "0x0.00000028E54B89619p0",
                "0x0.0000002996BDA1760p0", "0x0.0000002A482FB98AEp0", "0x0.0000002AF9A1D1A04p0", "0x0.0000002BAB13E9B61p0"
            };
            ap_ufixed<42,-26> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<50,-18> exp2_x_msb_4_m_1_table[256] = {
                "0x0.0p0", "0x0.0000002C5C8601CC7p0", "0x0.00000058B90C0B48Cp0", "0x0.0000008515921C751p0",
                "0x0.000000B1721835515p0", "0x0.000000DDCE9E55DD7p0", "0x0.0000010A2B247E199p0", "0x0.0000013687AAAE059p0",
                "0x0.00000162E430E5A19p0", "0x0.0000018F40B724ED7p0", "0x0.000001BB9D3D6BE95p0", "0x0.000001E7F9C3BA951p0",
                "0x0.00000214564A10F0Dp0", "0x0.00000240B2D06EFC7p0", "0x0.0000026D0F56D4B80p0", "0x0.000002996BDD42239p0",
                "0x0.000002C5C863B73F0p0", "0x0.000002F224EA340A6p0", "0x0.0000031E8170B885Cp0", "0x0.0000034ADDF744B10p0",
                "0x0.000003773A7DD88C3p0", "0x0.000003A3970474175p0", "0x0.000003CFF38B17526p0", "0x0.000003FC5011C23D6p0",
                "0x0.00000428AC9874D86p0", "0x0.00000455091F2F234p0", "0x0.0000048165A5F11E1p0", "0x0.000004ADC22CBAC8Dp0",
                "0x0.000004DA1EB38C238p0", "0x0.000005067B3A652E2p0", "0x0.00000532D7C145E8Bp0", "0x0.0000055F34482E533p0",
                "0x0.0000058B90CF1E6D9p0", "0x0.000005B7ED561637Fp0", "0x0.000005E449DD15B24p0", "0x0.00000610A6641CDC8p0",
                "0x0.0000063D02EB2BB6Bp0", "0x0.000006695F724240Dp0", "0x0.00000695BBF9607AEp0", "0x0.000006C218808664Dp0",
                "0x0.000006EE7507B3FECp0", "0x0.0000071AD18EE948Ap0", "0x0.000007472E1626427p0", "0x0.000007738A9D6AEC2p0",
                "0x0.0000079FE724B745Dp0", "0x0.000007CC43AC0B4F7p0", "0x0.000007F8A0336708Fp0", "0x0.00000824FCBACA727p0",
                "0x0.000008515942358BEp0", "0x0.0000087DB5C9A8553p0", "0x0.000008AA125122CE8p0", "0x0.000008D66ED8A4F7Bp0",
                "0x0.00000902CB602ED0Ep0", "0x0.0000092F27E7C059Fp0", "0x0.0000095B846F59930p0", "0x0.00000987E0F6FA7C0p0",
                "0x0.000009B43D7EA314Ep0", "0x0.000009E09A06535DCp0", "0x0.00000A0CF68E0B568p0", "0x0.00000A395315CAFF3p0",
                "0x0.00000A65AF9D9257Ep0", "0x0.00000A920C2561607p0", "0x0.00000ABE68AD38190p0", "0x0.00000AEAC53516817p0",
                "0x0.00000B1721BCFC99Ep0", "0x0.00000B437E44EA623p0", "0x0.00000B6FDACCDFDA7p0", "0x0.00000B9C3754DD02Bp0",
                "0x0.00000BC893DCE1DADp0", "0x0.00000BF4F064EE62Fp0", "0x0.00000C214CED029AFp0", "0x0.00000C4DA9751E82Ep0",
                "0x0.00000C7A05FD421ADp0", "0x0.00000CA662856D62Ap0", "0x0.00000CD2BF0DA05A6p0", "0x0.00000CFF1B95DB022p0",
                "0x0.00000D2B781E1D59Cp0", "0x0.00000D57D4A667615p0", "0x0.00000D84312EB918Dp0", "0x0.00000DB08DB712805p0",
                "0x0.00000DDCEA3F7397Bp0", "0x0.00000E0946C7DC5F0p0", "0x0.00000E35A3504CD65p0", "0x0.00000E61FFD8C4FD8p0",
                "0x0.00000E8E5C6144D4Ap0", "0x0.00000EBAB8E9CC5BBp0", "0x0.00000EE715725B92Cp0", "0x0.00000F1371FAF279Bp0",
                "0x0.00000F3FCE8391109p0", "0x0.00000F6C2B0C37576p0", "0x0.00000F988794E54E3p0", "0x0.00000FC4E41D9AF4Ep0",
                "0x0.00000FF140A6584B8p0", "0x0.0000101D9D2F1D521p0", "0x0.00001049F9B7EA08Ap0", "0x0.000010765640BE6F1p0",
                "0x0.000010A2B2C99A857p0", "0x0.000010CF0F527E4BCp0", "0x0.000010FB6BDB69C21p0", "0x0.00001127C8645CE84p0",
                "0x0.0000115424ED57BE6p0", "0x0.0000118081765A447p0", "0x0.000011ACDDFF647A7p0", "0x0.000011D93A8876607p0",
                "0x0.0000120597118FF65p0", "0x0.00001231F39AB13C2p0", "0x0.0000125E5023DA31Ep0", "0x0.0000128AACAD0AD7Ap0",
                "0x0.000012B70936432D4p0", "0x0.000012E365BF8332Dp0", "0x0.0000130FC248CAE85p0", "0x0.0000133C1ED21A4DDp0",
                "0x0.000013687B5B71633p0", "0x0.00001394D7E4D0288p0", "0x0.000013C1346E369DDp0", "0x0.000013ED90F7A4C30p0",
                "0x0.00001419ED811A982p0", "0x0.000014464A0A981D4p0", "0x0.00001472A6941D524p0", "0x0.0000149F031DAA373p0",
                "0x0.000014CB5FA73ECC1p0", "0x0.000014F7BC30DB10Fp0", "0x0.0000152418BA7F05Bp0", "0x0.0000155075442AAA6p0",
                "0x0.0000157CD1CDDDFF1p0", "0x0.000015A92E579903Ap0", "0x0.000015D58AE15BB83p0", "0x0.00001601E76B261CAp0",
                "0x0.0000162E43F4F8310p0", "0x0.0000165AA07ED1F56p0", "0x0.00001686FD08B369Ap0", "0x0.000016B359929C8DEp0",
                "0x0.000016DFB61C8D620p0", "0x0.0000170C12A685E62p0", "0x0.000017386F30861A2p0", "0x0.00001764CBBA8DFE1p0",
                "0x0.0000179128449D920p0", "0x0.000017BD84CEB4D5Dp0", "0x0.000017E9E158D3C9Ap0", "0x0.000018163DE2FA6D6p0",
                "0x0.000018429A6D28C10p0", "0x0.0000186EF6F75EC4Ap0", "0x0.0000189B53819C782p0", "0x0.000018C7B00BE1DBAp0",
                "0x0.000018F40C962EEF0p0", "0x0.00001920692083B26p0", "0x0.0000194CC5AAE025Bp0", "0x0.0000197922354448Ep0",
                "0x0.000019A57EBFB01C1p0", "0x0.000019D1DB4A239F3p0", "0x0.000019FE37D49ED23p0", "0x0.00001A2A945F21B53p0",
                "0x0.00001A56F0E9AC482p0", "0x0.00001A834D743E8B0p0", "0x0.00001AAFA9FED87DCp0", "0x0.00001ADC06897A208p0",
                "0x0.00001B08631423733p0", "0x0.00001B34BF9ED475Dp0", "0x0.00001B611C298D286p0", "0x0.00001B8D78B44D8ADp0",
                "0x0.00001BB9D53F159D4p0", "0x0.00001BE631C9E55FAp0", "0x0.00001C128E54BCD1Fp0", "0x0.00001C3EEADF9BF43p0",
                "0x0.00001C6B476A82C66p0", "0x0.00001C97A3F571488p0", "0x0.00001CC40080677A9p0", "0x0.00001CF05D0B655C9p0",
                "0x0.00001D1CB9966AEE8p0", "0x0.00001D49162178306p0", "0x0.00001D7572AC8D223p0", "0x0.00001DA1CF37A9C40p0",
                "0x0.00001DCE2BC2CE15Bp0", "0x0.00001DFA884DFA175p0", "0x0.00001E26E4D92DC8Ep0", "0x0.00001E534164692A6p0",
                "0x0.00001E7F9DEFAC3BEp0", "0x0.00001EABFA7AF6FD4p0", "0x0.00001ED85706496E9p0", "0x0.00001F04B391A38FEp0",
                "0x0.00001F31101D05611p0", "0x0.00001F5D6CA86EE23p0", "0x0.00001F89C933E0135p0", "0x0.00001FB625BF58F45p0",
                "0x0.00001FE2824AD9855p0", "0x0.0000200EDED661C63p0", "0x0.0000203B3B61F1B71p0", "0x0.0000206797ED8957Dp0",
                "0x0.00002093F47928A89p0", "0x0.000020C05104CFA93p0", "0x0.000020ECAD907E59Dp0", "0x0.000021190A1C34BA6p0",
                "0x0.0000214566A7F2CAEp0", "0x0.00002171C333B88B4p0", "0x0.0000219E1FBF85FBAp0", "0x0.000021CA7C4B5B1BFp0",
                "0x0.000021F6D8D737EC3p0", "0x0.0000222335631C6C6p0", "0x0.0000224F91EF089C7p0", "0x0.0000227BEE7AFC7C8p0",
                "0x0.000022A84B06F80C8p0", "0x0.000022D4A792FB4C7p0", "0x0.00002301041F063C5p0", "0x0.0000232D60AB18DC3p0",
                "0x0.00002359BD37332BFp0", "0x0.0000238619C3552BAp0", "0x0.000023B2764F7EDB4p0", "0x0.000023DED2DBB03ADp0",
                "0x0.0000240B2F67E94A5p0", "0x0.000024378BF42A09Dp0", "0x0.00002463E88072793p0", "0x0.00002490450CC2988p0",
                "0x0.000024BCA1991A67Dp0", "0x0.000024E8FE2579E70p0", "0x0.000025155AB1E1163p0", "0x0.00002541B73E4FF54p0",
                "0x0.0000256E13CAC6845p0", "0x0.0000259A705744C34p0", "0x0.000025C6CCE3CAB23p0", "0x0.000025F3297058511p0",
                "0x0.0000261F85FCED9FDp0", "0x0.0000264BE2898A9E9p0", "0x0.000026783F162F4D4p0", "0x0.000026A49BA2DBABEp0",
                "0x0.000026D0F82F8FBA7p0", "0x0.000026FD54BC4B78Fp0", "0x0.00002729B1490EE75p0", "0x0.000027560DD5DA05Bp0",
                "0x0.000027826A62ACD41p0", "0x0.000027AEC6EF87525p0", "0x0.000027DB237C69808p0", "0x0.000028078009535EAp0",
                "0x0.00002833DC9644ECBp0", "0x0.0000286039233E2ABp0", "0x0.0000288C95B03F18Bp0", "0x0.000028B8F23D47B69p0",
                "0x0.000028E54ECA58046p0", "0x0.00002911AB5770023p0", "0x0.0000293E07E48FAFEp0", "0x0.0000296A6471B70D9p0",
                "0x0.00002996C0FEE61B2p0", "0x0.000029C31D8C1CD8Bp0", "0x0.000029EF7A195B463p0", "0x0.00002A1BD6A6A1639p0",
                "0x0.00002A483333EF30Fp0", "0x0.00002A748FC144AE4p0", "0x0.00002AA0EC4EA1DB8p0", "0x0.00002ACD48DC06B8Bp0",
                "0x0.00002AF9A5697345Dp0", "0x0.00002B2601F6E782Ep0", "0x0.00002B525E84636FEp0", "0x0.00002B7EBB11E70CDp0",
                "0x0.00002BAB179F7259Bp0", "0x0.00002BD7742D05568p0", "0x0.00002C03D0BAA0035p0", "0x0.00002C302D4842600p0"
            };
            ap_ufixed<50,-18> exp2_x_msb_4_m_1 = exp2_x_msb_4_m_1_table[x_msb_ind_4];
            ap_ufixed<92,-44> f_x_msb_4_lsb = exp2_x_lsb_m_1 * exp2_x_msb_4_m_1;
            ap_ufixed<24,-44> f_x_msb_4_lsb_s = f_x_msb_4_lsb;
            ap_ufixed<50,-18> exp2_x_msb_4_lsb_m_1 = f_x_msb_4_lsb_s + exp2_x_msb_4_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<58,-10> exp2_x_msb_3_m_1_table[256] = {
                "0x0.0p0", "0x0.00002C5C89D5EC6CAp0", "0x0.000058B91B5BC9AE3p0", "0x0.00008515B4919919Ap0",
                "0x0.0000B17255775C040p0", "0x0.0000DDCEFE0D13C26p0", "0x0.00010A2BAE52C1A9Bp0", "0x0.000136886648670F0p0",
                "0x0.000162E525EE05475p0", "0x0.00018F41ED439DA7Bp0", "0x0.0001BB9EBC4931853p0", "0x0.0001E7FB92FEC234Bp0",
                "0x0.000214587164510B6p0", "0x0.000240B55779DF5E3p0", "0x0.00026D12453F6E823p0", "0x0.0002996F3AB4FFCC6p0",
                "0x0.0002C5CC37DA9491Dp0", "0x0.0002F2293CB02E278p0", "0x0.00031E864935CDE29p0", "0x0.00034AE35D6B7517Ep0",
                "0x0.000377407951251C9p0", "0x0.0003A39D9CE6DF45Bp0", "0x0.0003CFFAC82CA4E84p0", "0x0.0003FC57FB2277595p0",
                "0x0.000428B535C857EDDp0", "0x0.00045512781E47FAFp0", "0x0.0004816FC22448D5Ap0", "0x0.0004ADCD13DA5BD2Fp0",
                "0x0.0004DA2A6D408247Ep0", "0x0.00050687CE56BD89Ap0", "0x0.000532E5371D0EED1p0", "0x0.00055F42A79377C75p0",
                "0x0.00058BA01FB9F96D7p0", "0x0.0005B7FD9F9095347p0", "0x0.0005E45B27174C716p0", "0x0.000610B8B64E20794p0",
                "0x0.00063D164D3512A14p0", "0x0.00066973EBCC243E4p0", "0x0.000695D1921356A57p0", "0x0.0006C22F400AAB2BCp0",
                "0x0.0006EE8CF5B223266p0", "0x0.00071AEAB309BFEA4p0", "0x0.00074748781182CC7p0", "0x0.000773A644C96D221p0",
                "0x0.0007A004193180402p0", "0x0.0007CC61F549BD7BCp0", "0x0.0007F8BFD9122629Ep0", "0x0.0008251DC48ABB9FAp0",
                "0x0.0008517BB7B37F322p0", "0x0.00087DD9B28C72365p0", "0x0.0008AA37B51596015p0", "0x0.0008D695BF4EEBE83p0",
                "0x0.000902F3D13875400p0", "0x0.00092F51EAD2335DCp0", "0x0.00095BB00C1C2796Ap0", "0x0.0009880E3516533FAp0",
                "0x0.0009B46C65C0B7ADCp0", "0x0.0009E0CA9E1B56363p0", "0x0.000A0D28DE26302DFp0", "0x0.000A398725E146EA2p0",
                "0x0.000A65E5754C9BBFBp0", "0x0.000A9243CC683003Ep0", "0x0.000ABEA22B34050BAp0", "0x0.000AEB0091B01C2C1p0",
                "0x0.000B175EFFDC76BA4p0", "0x0.000B43BD75B9160B4p0", "0x0.000B701BF345FB742p0", "0x0.000B9C7A7883284A1p0",
                "0x0.000BC8D905709DE20p0", "0x0.000BF5379A0E5D912p0", "0x0.000C2196365C68AC6p0", "0x0.000C4DF4DA5AC0890p0",
                "0x0.000C7A538609667C0p0", "0x0.000CA6B239685BDA6p0", "0x0.000CD310F477A1F96p0", "0x0.000CFF6FB7373A2DFp0",
                "0x0.000D2BCE81A725CD4p0", "0x0.000D582D53C7662C6p0", "0x0.000D848C2D97FCA05p0", "0x0.000DB0EB0F18EA7E4p0",
                "0x0.000DDD49F84A311B4p0", "0x0.000E09A8E92BD1CC6p0", "0x0.000E3607E1BDCDE6Cp0", "0x0.000E6266E20026BF7p0",
                "0x0.000E8EC5E9F2DDAB9p0", "0x0.000EBB24F995F4003p0", "0x0.000EE78410E96B126p0", "0x0.000F13E32FED44375p0",
                "0x0.000F404256A180C40p0", "0x0.000F6CA18506220D9p0", "0x0.000F9900BB1B29692p0", "0x0.000FC55FF8E0982BDp0",
                "0x0.000FF1BF3E566FAAAp0", "0x0.00101E1E8B7CB13ACp0", "0x0.00104A7DE0535E314p0", "0x0.001076DD3CDA77E34p0",
                "0x0.0010A33CA111FFA5Dp0", "0x0.0010CF9C0CF9F6CE1p0", "0x0.0010FBFB80925EB11p0", "0x0.0011285AFBDB38A40p0",
                "0x0.001154BA7ED485FC0p0", "0x0.0011811A097E480E0p0", "0x0.0011AD799BD8802F5p0", "0x0.0011D9D935E32FB4Fp0",
                "0x0.00120638D79E57F3Fp0", "0x0.001232988109FA419p0", "0x0.00125EF8322617F2Dp0", "0x0.00128B57EAF2B25CDp0",
                "0x0.0012B7B7AB6FCAD4Bp0", "0x0.0012E417739D62AFAp0", "0x0.00131077437B7B42Ap0", "0x0.00133CD71B0A15E2Ep0",
                "0x0.00136936FA4933E58p0", "0x0.00139596E138D69F9p0", "0x0.0013C1F6CFD8FF663p0", "0x0.0013EE56C629AF8E9p0",
                "0x0.00141AB6C42AE86DBp0", "0x0.00144716C9DCAB58Dp0", "0x0.00147376D73EF9A50p0", "0x0.00149FD6EC51D4A76p0",
                "0x0.0014CC3709153DB51p0", "0x0.0014F8972D8936234p0", "0x0.001524F759ADBF46Fp0", "0x0.001551578D82DA755p0",
                "0x0.00157DB7C90889038p0", "0x0.0015AA180C3ECC46Bp0", "0x0.0015D6785725A593Fp0", "0x0.001602D8A9BD16406p0",
                "0x0.00162F3904051FA13p0", "0x0.00165B9965FDC30B7p0", "0x0.001687F9CFA701D45p0", "0x0.0016B45A4100DD50Ep0",
                "0x0.0016E0BABA0B56D66p0", "0x0.00170D1B3AC66FB9Ep0", "0x0.0017397BC33229508p0", "0x0.001765DC534E84EF7p0",
                "0x0.0017923CEB1B83EBCp0", "0x0.0017BE9D8A99279ABp0", "0x0.0017EAFE31C771515p0", "0x0.0018175EE0A66264Cp0",
                "0x0.001843BF9735FC2A3p0", "0x0.0018702055763FF6Cp0", "0x0.00189C811B672F1FAp0", "0x0.0018C8E1E908CAF9Ep0",
                "0x0.0018F542BE5B14DABp0", "0x0.001921A39B5E0E174p0", "0x0.00194E048011B804Ap0", "0x0.00197A656C7613F81p0",
                "0x0.0019A6C6608B2346Ap0", "0x0.0019D3275C50E7458p0", "0x0.0019FF885FC76149Dp0", "0x0.001A2BE96AEE92A8Cp0",
                "0x0.001A584A7DC67CB77p0", "0x0.001A84AB984F20CB1p0", "0x0.001AB10CBA888038Cp0", "0x0.001ADD6DE4729C55Ap0",
                "0x0.001B09CF160D7676Fp0", "0x0.001B36304F590FF1Dp0", "0x0.001B629190556A1B5p0", "0x0.001B8EF2D9028648Cp0",
                "0x0.001BBB54296065CF2p0", "0x0.001BE7B5816F0A03Cp0", "0x0.001C1416E12E743BBp0", "0x0.001C4078489EA5CC2p0",
                "0x0.001C6CD9B7BFA00A4p0", "0x0.001C993B2E91644B3p0", "0x0.001CC59CAD13F3E42p0", "0x0.001CF1FE3347502A4p0",
                "0x0.001D1E5FC12B7A72Bp0", "0x0.001D4AC156C07412Ap0", "0x0.001D7722F4063E5F4p0", "0x0.001DA38498FCDAADBp0",
                "0x0.001DCFE645A44A533p0", "0x0.001DFC47F9FC8EA4Dp0", "0x0.001E28A9B605A8F7Dp0", "0x0.001E550B79BF9AA16p0",
                "0x0.001E816D452A64F6Ap0", "0x0.001EADCF1846094CCp0", "0x0.001EDA30F31288F8Ep0", "0x0.001F0692D58FE5505p0",
                "0x0.001F32F4BFBE1FA82p0", "0x0.001F5F56B19D39559p0", "0x0.001F8BB8AB2D33ADCp0", "0x0.001FB81AAC6E1005Ep0",
                "0x0.001FE47CB55FCFB33p0", "0x0.002010DEC602740ACp0", "0x0.00203D40DE55FE61Ep0", "0x0.002069A2FE5A700DAp0",
                "0x0.00209605260FCA635p0", "0x0.0020C26755760EB80p0", "0x0.0020EEC98C8D3E60Fp0", "0x0.00211B2BCB555AB35p0",
                "0x0.0021478E11CE65045p0", "0x0.002173F05FF85EA93p0", "0x0.0021A052B5D348F70p0", "0x0.0021CCB5135F25430p0",
                "0x0.0021F917789BF4E26p0", "0x0.00222579E589B92A6p0", "0x0.002251DC5A2873702p0", "0x0.00227E3ED6782508Ep0",
                "0x0.0022AAA15A78CF49Cp0", "0x0.0022D703E62A73880p0", "0x0.00230366798D1318Dp0", "0x0.00232FC914A0AF516p0",
                "0x0.00235C2BB7654986Fp0", "0x0.0023888E61DAE30EAp0", "0x0.0023B4F114017D3DBp0", "0x0.0023E153CDD919695p0",
                "0x0.00240DB68F61B8E6Cp0", "0x0.00243A19589B5D0B2p0", "0x0.0024667C2986072BAp0", "0x0.002492DF0221B89D9p0",
                "0x0.0024BF41E26E72B62p0", "0x0.0024EBA4CA6C36CA7p0", "0x0.00251807BA1B062FDp0", "0x0.0025446AB17AE23B5p0",
                "0x0.002570CDB08BCC425p0", "0x0.00259D30B74DC599Fp0", "0x0.0025C993C5C0CF977p0", "0x0.0025F5F6DBE4EB900p0",
                "0x0.00262259F9BA1AD8Dp0", "0x0.00264EBD1F405EC72p0", "0x0.00267B204C77B8B03p0", "0x0.0026A783816029E92p0",
                "0x0.0026D3E6BDF9B3C74p0", "0x0.0027004A0244579FCp0", "0x0.00272CAD4E4016C7Dp0", "0x0.00275910A1ECF294Bp0",
                "0x0.00278573FD4AEC5BAp0", "0x0.0027B1D7605A0571Cp0", "0x0.0027DE3ACB1A3F2C6p0", "0x0.00280A9E3D8B9AE0Cp0",
                "0x0.00283701B7AE19E40p0", "0x0.002863653981BD8B6p0", "0x0.00288FC8C306872C3p0", "0x0.0028BC2C543C781B9p0",
                "0x0.0028E88FED2391AECp0", "0x0.002914F38DBBD53B1p0", "0x0.0029415736054415Ap0", "0x0.00296DBAE5FFDF93Cp0",
                "0x0.00299A1E9DABA90A9p0", "0x0.0029C6825D08A1CF7p0", "0x0.0029F2E62416CB378p0", "0x0.002A1F49F2D626981p0",
                "0x0.002A4BADC946B5464p0", "0x0.002A7811A76878977p0", "0x0.002AA4758D3B71E0Cp0", "0x0.002AD0D97ABFA2778p0",
                "0x0.002AFD3D6FF50BB0Ep0", "0x0.002B29A16CDBAEE23p0", "0x0.002B560571738D609p0", "0x0.002B82697DBCA8816p0",
                "0x0.002BAECD91B70199Cp0", "0x0.002BDB31AD6299FF0p0", "0x0.002C0795D0BF73066p0", "0x0.002C33F9FBCD8E052p0"
            };
            ap_ufixed<58,-10> exp2_x_msb_3_m_1 = exp2_x_msb_3_m_1_table[x_msb_ind_3];
            ap_ufixed<108,-28> f_x_msb_3_lsb = exp2_x_msb_3_m_1 * exp2_x_msb_4_lsb_m_1;
            ap_ufixed<40, -28> f_x_msb_3_lsb_s = f_x_msb_3_lsb;
            ap_ufixed<58, -10> exp2_x_msb_3_4_lsb_m_1 = f_x_msb_3_lsb_s + exp2_x_msb_3_m_1 + exp2_x_msb_4_lsb_m_1;

            const static ap_ufixed<68,0> exp2_x_msb_2_m_1_table[256] = {
                "0x0.0p0", "0x0.002C605E2E8CEC507p0", "0x0.0058C86DA1C09EA20p0", "0x0.0085382FAEF831DA9p0",
                "0x0.00B1AFA5ABCBED613p0", "0x0.00DE2ED0EE0F4F5FDp0", "0x0.010AB5B2CBD117074p0", "0x0.0137444C9B5B4ED49p0",
                "0x0.0163DA9FB33356D85p0", "0x0.019078AD6A19EEFF7p0", "0x0.01BD1E77170B415E7p0", "0x0.01E9CBFE113EEC7DCp0",
                "0x0.02168143B0280DA82p0", "0x0.02433E494B754B3ADp0", "0x0.027003103B10DEF7Dp0", "0x0.029CCF99D720A0593p0",
                "0x0.02C9A3E778060EE6Fp0", "0x0.02F67FFA765E5C8E5p0", "0x0.032363D42B0277FAAp0", "0x0.03504F75EF0716F0Cp0",
                "0x0.037D42E11BBCC0AB4p0", "0x0.03AA3E170AAFD8396p0", "0x0.03D7411915A8A6DF0p0", "0x0.04044BE896AB66771p0",
                "0x0.04315E86E7F84BD74p0", "0x0.045E78F5640B9135Cp0", "0x0.048B9B35659D8090Ep0", "0x0.04B8C54847A27E186p0",
                "0x0.04E5F72F654B12987p0", "0x0.051330EC1A03F5E6Ap0", "0x0.0540727FC1761950Dp0", "0x0.056DBBEBB786B20D9p0",
                "0x0.059B0D31585743AE8p0", "0x0.05C866520045AA948p0", "0x0.05F5C74F0BEC2665Bp0", "0x0.06233029D82164855p0",
                "0x0.0650A0E3C1F88A8D2p0", "0x0.067E197E26C140C90p0", "0x0.06AB99FA6407BCB43p0", "0x0.06D92259D794CB783p0",
                "0x0.0706B29DDF6DDC6DCp0", "0x0.07344AC7D9D50B9FCp0", "0x0.0761EAD925492C4F5p0", "0x0.078F92D32085D37A9p0",
                "0x0.07BD42B72A8362646p0", "0x0.07EAFA86A277111EFp0", "0x0.0818BA42E7D2F916Ep0", "0x0.084681ED5A461FA1Ap0",
                "0x0.0874518759BC808C3p0", "0x0.08A22912465F18AD3p0", "0x0.08D0088F8093F0774p0", "0x0.08FDF00068FE268ECp0",
                "0x0.092BDF66607DFA5FEp0", "0x0.0959D6C2C830D6B7Fp0", "0x0.0987D61701715C5F5p0", "0x0.09B5DD646DD76CB61p0",
                "0x0.09E3ECAC6F3834522p0", "0x0.0A1203F067A6359F1p0", "0x0.0A402331B97153804p0", "0x0.0A6E4A71C726DBF42p0",
                "0x0.0A9C79B1F39192BA3p0", "0x0.0ACAB0F3A1B9BBF9Fp0", "0x0.0AF8F03834E526EC8p0", "0x0.0B273781109738876p0",
                "0x0.0B5586CF9890F6299p0", "0x0.0B83DE2530D1104A2p0", "0x0.0BB23D833D93ED290p0", "0x0.0BE0A4EB2353B3818p0",
                "0x0.0C0F145E46C8553E6p0", "0x0.0C3D8BDE0CE79A306p0", "0x0.0C6C0B6BDAE52AC5Dp0", "0x0.0C9A930916329AC51p0",
                "0x0.0CC922B7247F7407Bp0", "0x0.0CF7BA776BB94138Ap0", "0x0.0D265A4B520B98932p0", "0x0.0D5502343DE026A4Bp0",
                "0x0.0D83B23395DEB90FBp0", "0x0.0DB26A4AC0ED4950Dp0", "0x0.0DE12A7B263007860p0", "0x0.0E0FF2C62D0965371p0",
                "0x0.0E3EC32D3D1A20207p0", "0x0.0E6D9BB1BE414CFFDp0", "0x0.0E9C7C55189C62628p0", "0x0.0ECB6518B4874375Bp0",
                "0x0.0EFA55FDFA9C4AD89p0", "0x0.0F294F0653B45570Ap0", "0x0.0F58503328E6CD3F5p0", "0x0.0F875985E389B439Ep0",
                "0x0.0FB66AFFED31AF232p0", "0x0.0FE584A2AFB210670p0", "0x0.1014A66F951CE2F7Ep0", "0x0.1043D06807C2F52E1p0",
                "0x0.1073028D7233E3A8Ep0", "0x0.10A23CE13F3E2431Dp0", "0x0.10D17F64D9EF10A19p0", "0x0.1100CA19AD92F1C6Bp0",
                "0x0.11301D0125B50A4ECp0", "0x0.115F781CAE1FA1B08p0", "0x0.118EDB6DB2DC0F18Dp0", "0x0.11BE46F5A032C458Fp0",
                "0x0.11EDBAB5E2AB58D6Fp0", "0x0.121D36AFE70C947FBp0", "0x0.124CBAE51A5C7ABB5p0", "0x0.127C4756E9E055631p0",
                "0x0.12ABDC06C31CBFB93p0", "0x0.12DB78F613D5B162Dp0", "0x0.130B1E264A0E8963Cp0", "0x0.133ACB98D40A191C1p0",
                "0x0.136A814F204AAF478p0", "0x0.139A3F4A9D9222FF2p0", "0x0.13CA058CBAE1DEBC9p0", "0x0.13F9D416E77AEB5F6p0",
                "0x0.1429AAEA92DDFB341p0", "0x0.14598A092CCB74FD3p0", "0x0.1489717425437EFE9p0", "0x0.14B9612CEC860A09Ep0",
                "0x0.14E95934F312DC8DCp0", "0x0.1519598DA9A99DA67p0", "0x0.154962388149E0304p0", "0x0.15797336EB332DDCAp0",
                "0x0.15A98C8A58E512481p0", "0x0.15D9AE343C1F26130p0", "0x0.1609D83606E119FBFp0", "0x0.163A0A912B6AC1FBBp0",
                "0x0.166A45471C3C2063Dp0", "0x0.169A88594C1570FE6p0", "0x0.16CAD3C92DF734306p0", "0x0.16FB279835223A1D7p0",
                "0x0.172B83C7D517ADCDFp0", "0x0.175BE85981992056Cp0", "0x0.178C554EAEA894030p0", "0x0.17BCCAA8D088877FCp0",
                "0x0.17ED48695BBC0109Ep0", "0x0.181DCE91C506999D8p0", "0x0.184E5D23816C88275p0", "0x0.187EF4200632ACB89p0",
                "0x0.18AF9388C8DE9BBBFp0", "0x0.18E03B5F3F36A92D4p0", "0x0.1910EBA4DF41F3D2Ap0", "0x0.1941A45B1F487077Ap0",
                "0x0.1972658375D2F52ABp0", "0x0.19A32F1F59AB447C4p0", "0x0.19D4013041DC18BF8p0", "0x0.1A04DBB7A5B12F4DCp0",
                "0x0.1A35BEB6FCB753CB7p0", "0x0.1A66AA2FBEBC6B6ECp0", "0x0.1A979E2363CF8048Fp0", "0x0.1AC89A936440CC90Dp0",
                "0x0.1AF99F8138A1C5EFEp0", "0x0.1B2AACEE59C528D0Dp0", "0x0.1B5BC2DC40BF03B07p0", "0x0.1B8CE14C66E4C2704p0",
                "0x0.1BBE084045CD39AB2p0", "0x0.1BEF37B95750B20C0p0", "0x0.1C206FB91588F3A67p0", "0x0.1C51B040FAD151512p0",
                "0x0.1C82F95281C6B4026p0", "0x0.1CB44AEF2547A62ECp0", "0x0.1CE5A51860745F298p0", "0x0.1D1707CFAEAECE86Cp0",
                "0x0.1D4873168B9AA7806p0", "0x0.1D79E6EE731D6C5BDp0", "0x0.1DAB6358E15E79D2Fp0", "0x0.1DDCE85752C7127E2p0",
                "0x0.1E0E75EB44026A409p0", "0x0.1E400C1631FDB1B6Ap0", "0x0.1E71AAD999E821A64p0", "0x0.1EA35236F9330670Ep0",
                "0x0.1ED5022FCD91CB882p0", "0x0.1F06BAC594FA06E38p0", "0x0.1F387BF9CDA384793p0", "0x0.1F6A45CDF60851B7Cp0",
                "0x0.1F9C18438CE4C902Bp0", "0x0.1FCDF35C11379D307p0", "0x0.1FFFD7190241E50A9p0", "0x0.2031C37BDF8726CFFp0",
                "0x0.2063B88628CD63B8Fp0", "0x0.2095B6395E1D237DAp0", "0x0.20C7BC96FFC17FDDEp0", "0x0.20F9CBA08E48302B7p0",
                "0x0.212BE3578A8194D65p0", "0x0.215E03BD7580C2FABp0", "0x0.21902CD3D09B8FF15p0", "0x0.21C25E9C1D6A9CE17p0",
                "0x0.21F49917DDC962553p0", "0x0.2226DC4893D63BCFAp0", "0x0.2259282FC1F273650p0", "0x0.228B7CCEEAC24D54Fp0",
                "0x0.22BDDA27912D13A6Ap0", "0x0.22F0403B385D21C70p0", "0x0.2322AF0B63BFF0291p0", "0x0.2355269997061FE83p0",
                "0x0.2387A6E75623866C2p0", "0x0.23BA2FF6254F390FBp0", "0x0.23ECC1C7890398C8Ap0", "0x0.241F5C5D05FE5DD26p0",
                "0x0.2451FFB82140A35A0p0", "0x0.2484ABDA600EF32CEp0", "0x0.24B760C547F15168Fp0", "0x0.24EA1E7A5EB3482F4p0",
                "0x0.251CE4FB2A63F3583p0", "0x0.254FB44931560C2A2p0", "0x0.25828C65FA1FF511Fp0", "0x0.25B56D530B9BC55D9p0",
                "0x0.25E85711ECE754F87p0", "0x0.261B49A42564482A2p0", "0x0.264E450B3CB81B573p0", "0x0.26814948BACC2EC3Ap0",
                "0x0.26B4565E27CDD257Ap0", "0x0.26E76C4D0C2E51669p0", "0x0.271A8B16F0A2FE778p0", "0x0.274DB2BD5E253F101p0",
                "0x0.2780E341DDF29781Ap0", "0x0.27B41CA5F98CB6B7Ep0", "0x0.27E75EEB3AB9820A2p0", "0x0.281AAA132B83210E1p0",
                "0x0.284DFE1F5638096CFp0", "0x0.28815B11456B0ABADp0", "0x0.28B4C0EA83F35A4FAp0", "0x0.28E82FAC9CEC9F225p0",
                "0x0.291BA7591BB6FDA67p0", "0x0.294F27F18BF723AB3p0", "0x0.2982B1777996543D0p0", "0x0.29B643EC70C273890p0",
                "0x0.29E9DF51FDEE12C26p0", "0x0.2A1D83A9ADD07C0A3p0", "0x0.2A5130F50D65BE58Dp0", "0x0.2A84E735A9EEB96A0p0",
                "0x0.2AB8A66D10F129AA3p0", "0x0.2AEC6E9CD037B426Bp0", "0x0.2B203FC675D1F27F9p0", "0x0.2B5419EB90147EDB7p0",
                "0x0.2B87FD0DAD98FFDDFp0", "0x0.2BBBE92E5D3E349F5p0", "0x0.2BEFDE4F2E2800A73p0", "0x0.2C23DC71AFBF77E86p0",
                "0x0.2C57E39771B2EABFBp0", "0x0.2C8BF3C203F5F1F3Fp0", "0x0.2CC00CF2F6C17AB8Dp0", "0x0.2CF42F2BDA93D2B35p0",
                "0x0.2D285A6E4030B4009p0", "0x0.2D5C8EBBB8A1513E7p0", "0x0.2D90CC15D53461967p0", "0x0.2DC5127E277E2CCAFp0",
                "0x0.2DF961F641589745Bp0", "0x0.2E2DBA7FB4E32E298p0", "0x0.2E621C1C148333651p0", "0x0.2E9686CCF2E3A9C88p0",
                "0x0.2ECAFA93E2F5611CAp0", "0x0.2EFF777277EF023C8p0", "0x0.2F33FD6A454D1B313p0", "0x0.2F688C7CDED22B4F1p0",
                "0x0.2F9D24ABD886AF562p0", "0x0.2FD1C5F8C6B92D937p0", "0x0.300670653DFE42058p0", "0x0.303B23F2D330AA821p0"
            };
            ap_ufixed<68,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<126,-10> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_msb_3_4_lsb_m_1;
            ap_ufixed<58, -10> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<68,0> exp2_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<68,32> exp2_x_msb_1_table[256] = {
                "0x1.000000000p0", "0x1.306FE0A32p0", "0x1.6A09E667Fp0", "0x1.AE89F995Bp0",
                "0x2.000000000p0", "0x2.60DFC1463p0", "0x2.D413CCCFEp0", "0x3.5D13F32B6p0",
                "0x4.000000000p0", "0x4.C1BF828C7p0", "0x5.A827999FDp0", "0x6.BA27E656Bp0",
                "0x8.000000000p0", "0x9.837F0518Ep0", "0xB.504F333FAp0", "0xD.744FCCAD7p0",
                "0x10.000000000p0", "0x13.06FE0A31Bp0", "0x16.A09E667F4p0", "0x1A.E89F995ADp0",
                "0x20.000000000p0", "0x26.0DFC14637p0", "0x2D.413CCCFE7p0", "0x35.D13F32B5Ap0",
                "0x40.000000000p0", "0x4C.1BF828C6Ep0", "0x5A.827999FCFp0", "0x6B.A27E656B5p0",
                "0x80.000000000p0", "0x98.37F0518DCp0", "0xB5.04F333F9Ep0", "0xD7.44FCCAD6Ap0",
                "0x100.000000000p0", "0x130.6FE0A31B7p0", "0x16A.09E667F3Cp0", "0x1AE.89F995AD4p0",
                "0x200.000000000p0", "0x260.DFC14636Ep0", "0x2D4.13CCCFE78p0", "0x35D.13F32B5A7p0",
                "0x400.000000000p0", "0x4C1.BF828C6DCp0", "0x5A8.27999FCEFp0", "0x6BA.27E656B4Fp0",
                "0x800.000000000p0", "0x983.7F0518DB9p0", "0xB50.4F333F9DEp0", "0xD74.4FCCAD69Dp0",
                "0x1000.000000000p0", "0x1306.FE0A31B71p0", "0x16A0.9E667F3BDp0", "0x1AE8.9F995AD3Bp0",
                "0x2000.000000000p0", "0x260D.FC14636E3p0", "0x2D41.3CCCFE77Ap0", "0x35D1.3F32B5A76p0",
                "0x4000.000000000p0", "0x4C1B.F828C6DC5p0", "0x5A82.7999FCEF3p0", "0x6BA2.7E656B4EBp0",
                "0x8000.000000000p0", "0x9837.F0518DB8Bp0", "0xB504.F333F9DE6p0", "0xD744.FCCAD69D7p0",
                "0x10000.000000000p0", "0x1306F.E0A31B715p0", "0x16A09.E667F3BCDp0", "0x1AE89.F995AD3ADp0",
                "0x20000.000000000p0", "0x260DF.C14636E2Ap0", "0x2D413.CCCFE7799p0", "0x35D13.F32B5A75Bp0",
                "0x40000.000000000p0", "0x4C1BF.828C6DC55p0", "0x5A827.999FCEF32p0", "0x6BA27.E656B4EB5p0",
                "0x80000.000000000p0", "0x9837F.0518DB8A9p0", "0xB504F.333F9DE65p0", "0xD744F.CCAD69D6Bp0",
                "0x100000.000000000p0", "0x1306FE.0A31B7153p0", "0x16A09E.667F3BCC9p0", "0x1AE89F.995AD3AD6p0",
                "0x200000.000000000p0", "0x260DFC.14636E2A6p0", "0x2D413C.CCFE77992p0", "0x35D13F.32B5A75ACp0",
                "0x400000.000000000p0", "0x4C1BF8.28C6DC54Bp0", "0x5A8279.99FCEF324p0", "0x6BA27E.656B4EB58p0",
                "0x800000.000000000p0", "0x9837F0.518DB8A97p0", "0xB504F3.33F9DE648p0", "0xD744FC.CAD69D6AFp0",
                "0x1000000.000000000p0", "0x1306FE0.A31B7152Ep0", "0x16A09E6.67F3BCC91p0", "0x1AE89F9.95AD3AD5Fp0",
                "0x2000000.000000000p0", "0x260DFC1.4636E2A5Cp0", "0x2D413CC.CFE779921p0", "0x35D13F3.2B5A75ABDp0",
                "0x4000000.000000000p0", "0x4C1BF82.8C6DC54B8p0", "0x5A82799.9FCEF3242p0", "0x6BA27E6.56B4EB57Ap0",
                "0x8000000.000000000p0", "0x9837F05.18DB8A96Fp0", "0xB504F33.3F9DE6484p0", "0xD744FCC.AD69D6AF4p0",
                "0x10000000.000000000p0", "0x1306FE0A.31B7152DFp0", "0x16A09E66.7F3BCC909p0", "0x1AE89F99.5AD3AD5E8p0",
                "0x20000000.000000000p0", "0x260DFC14.636E2A5BDp0", "0x2D413CCC.FE7799211p0", "0x35D13F32.B5A75ABD1p0",
                "0x40000000.000000000p0", "0x4C1BF828.C6DC54B7Ap0", "0x5A827999.FCEF32423p0", "0x6BA27E65.6B4EB57A2p0",
                "0x80000000.000000000p0", "0x9837F051.8DB8A96F4p0", "0xB504F333.F9DE64846p0", "0xD744FCCA.D69D6AF44p0",
                "0x0.000000010p0", "0x0.000000013p0", "0x0.000000017p0", "0x0.00000001Bp0",
                "0x0.000000020p0", "0x0.000000026p0", "0x0.00000002Dp0", "0x0.000000036p0",
                "0x0.000000040p0", "0x0.00000004Cp0", "0x0.00000005Bp0", "0x0.00000006Cp0",
                "0x0.000000080p0", "0x0.000000098p0", "0x0.0000000B5p0", "0x0.0000000D7p0",
                "0x0.000000100p0", "0x0.000000130p0", "0x0.00000016Ap0", "0x0.0000001AFp0",
                "0x0.000000200p0", "0x0.000000261p0", "0x0.0000002D4p0", "0x0.00000035Dp0",
                "0x0.000000400p0", "0x0.0000004C2p0", "0x0.0000005A8p0", "0x0.0000006BAp0",
                "0x0.000000800p0", "0x0.000000983p0", "0x0.000000B50p0", "0x0.000000D74p0",
                "0x0.000001000p0", "0x0.000001307p0", "0x0.0000016A1p0", "0x0.000001AE9p0",
                "0x0.000002000p0", "0x0.00000260Ep0", "0x0.000002D41p0", "0x0.0000035D1p0",
                "0x0.000004000p0", "0x0.000004C1Cp0", "0x0.000005A82p0", "0x0.000006BA2p0",
                "0x0.000008000p0", "0x0.000009838p0", "0x0.00000B505p0", "0x0.00000D745p0",
                "0x0.000010000p0", "0x0.000013070p0", "0x0.000016A0Ap0", "0x0.00001AE8Ap0",
                "0x0.000020000p0", "0x0.0000260E0p0", "0x0.00002D414p0", "0x0.000035D14p0",
                "0x0.000040000p0", "0x0.00004C1C0p0", "0x0.00005A828p0", "0x0.00006BA28p0",
                "0x0.000080000p0", "0x0.00009837Fp0", "0x0.0000B504Fp0", "0x0.0000D7450p0",
                "0x0.000100000p0", "0x0.0001306FEp0", "0x0.00016A09Ep0", "0x0.0001AE8A0p0",
                "0x0.000200000p0", "0x0.000260DFCp0", "0x0.0002D413Dp0", "0x0.00035D13Fp0",
                "0x0.000400000p0", "0x0.0004C1BF8p0", "0x0.0005A827Ap0", "0x0.0006BA27Ep0",
                "0x0.000800000p0", "0x0.0009837F0p0", "0x0.000B504F3p0", "0x0.000D744FDp0",
                "0x0.001000000p0", "0x0.001306FE1p0", "0x0.0016A09E6p0", "0x0.001AE89FAp0",
                "0x0.002000000p0", "0x0.00260DFC1p0", "0x0.002D413CDp0", "0x0.0035D13F3p0",
                "0x0.004000000p0", "0x0.004C1BF83p0", "0x0.005A8279Ap0", "0x0.006BA27E6p0",
                "0x0.008000000p0", "0x0.009837F05p0", "0x0.00B504F33p0", "0x0.00D744FCDp0",
                "0x0.010000000p0", "0x0.01306FE0Ap0", "0x0.016A09E66p0", "0x0.01AE89F99p0",
                "0x0.020000000p0", "0x0.0260DFC14p0", "0x0.02D413CCDp0", "0x0.035D13F33p0",
                "0x0.040000000p0", "0x0.04C1BF829p0", "0x0.05A82799Ap0", "0x0.06BA27E65p0",
                "0x0.080000000p0", "0x0.09837F052p0", "0x0.0B504F334p0", "0x0.0D744FCCBp0",
                "0x0.100000000p0", "0x0.1306FE0A3p0", "0x0.16A09E668p0", "0x0.1AE89F996p0",
                "0x0.200000000p0", "0x0.260DFC146p0", "0x0.2D413CCD0p0", "0x0.35D13F32Bp0",
                "0x0.400000000p0", "0x0.4C1BF828Cp0", "0x0.5A82799A0p0", "0x0.6BA27E657p0",
                "0x0.800000000p0", "0x0.9837F0519p0", "0x0.B504F3340p0", "0x0.D744FCCADp0"
            };
            ap_ufixed<68,32> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<136,32> y_lo = exp2_x_msb_1 * exp2_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I<33) {
            bool overf_2 = 0;
            VITIS_LOOP_2848_19: for(int j=63; j>=I+31; j--) {
#pragma HLS unroll
 if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
                VITIS_LOOP_2855_20: for(int j=63; j>=I+31; j--) {
#pragma HLS unroll
 y[j] = 0;
                }
                VITIS_LOOP_2859_21: for(int j=I+30; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
                }
            }
        }
        r = y;
    }
    return r;
}

template<int W, int I>
ap_ufixed<W,I> exp2(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return exp2(xf);
}

template<int I>
ap_int<I> exp2(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return exp2(xf);
}

template<int I>
ap_uint<I> exp2(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return exp2(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> exp10(ap_fixed<W_,I_> x) {

 int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;

 int I_s_;
    int M_ = (I_-1>F_) ? (I_-1) : F_;
 if (M_==1) I_s_ = 0;
    else if (M_<4) I_s_ = 1;
    else if (M_<7) I_s_ = 2;
    else if (M_<14) I_s_ = 3;
    else if (M_<27) I_s_ = 4;
    else I_s_ = 5;

 ap_fixed<W_,I_> r;
 if(I_s_==0) {
  ap_fixed<3,2> x_l = x;
  ap_ufixed<2,1> y = 0;
  if(x_l[2]) {
   if(x_l[1]&x_l[0]) {
    y = ap_ufixed<2,1>("0x0.8p0");
   }
  } else {
   if(x_l[1]|x_l[0]) {
    y = ap_ufixed<2,1>("0x1.8p0");
   } else {
    y = ap_ufixed<2,1>("0x1.0p0");
   }
  }
  if(I_<2) {
   bool overf = 0;
   if(y[1]) {
    y[1] = 0;
    y[0] = 1;
   }
  }
  r = y;
 } else if (I_s_==1) {
  ap_fixed<7,4> x_l = x;
  ap_ufixed<6,3> y = 0;
  if((x_l[6]!=x_l[5])||(x_l[5]!=x_l[4])||(x_l[4]!=x_l[3])) {
   if(!x_l[6]) {
    y = ap_ufixed<6,3>("0x7.Ep0");
   }
  } else {
   ap_uint<4> x_ind;
   x_ind[3] = x_l[6];
   x_ind(2,0) = x_l(2,0);
   const static ap_ufixed<6,3> exp_x_ind_table[16] = {
    "0x1.000p0", "0x1.600p0", "0x1.C00p0", "0x2.600p0", "0x3.200p0", "0x4.400p0", "0x5.A00p0", "0x7.800p0",
    "0x0.200p0", "0x0.200p0", "0x0.200p0", "0x0.400p0", "0x0.600p0", "0x0.600p0", "0x0.800p0", "0x0.C00p0"
   };
   y = exp_x_ind_table[x_ind];
  }
  if(I_<4){
   bool overf = 0;
   VITIS_LOOP_2947_1: for(int j = 5; j>=I_+2; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_2954_2: for(int j = 5; j>=I_+2; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_2958_3: for(int j = I_+1; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==2) {
  ap_fixed<13,7> x_l = x;
  ap_ufixed<12,6> y = 0;
  ap_fixed<2,2> x_l_int;
  x_l_int(1,0) = x_l(7,6);
  ap_ufixed<6,0> x_l_fract;
  x_l_fract(5,0) = x_l(5,0);
  bool overf = 0;
  VITIS_LOOP_2973_4: for(int j = 11; j >=7; j--) {
#pragma HLS unroll
 if(x_l[12]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==1)&&(x_l_fract>ap_ufixed<5,0>("0x.D0p0")))) {
   if(!x_l[12]) {
    y = ap_ufixed<12,6>("0x3F.FCp0");
   }
  } else {
   ap_uint<4> x_msb_ind;
   x_msb_ind(3,0) = x_l(7,4);
   ap_uint<4> x_lsb_ind;
   x_lsb_ind(3,0) = x_l(3,0);
   const static ap_ufixed<14,6> exp_x_msb_table[16] = {
    "0x1.00p0", "0x1.C7p0", "0x3.2Ap0", "0x5.A0p0", "0xA.00p0", "0x11.C8p0", "0x1F.9Fp0", "0x38.3Cp0",
    "0x0.03p0", "0x0.05p0", "0x0.08p0", "0x0.0Ep0", "0x0.1Ap0", "0x0.2Ep0", "0x0.51p0", "0x0.90p0"
   };
   const static ap_ufixed<14,0> exp_x_lsb_m_1_table[16] = {
    "0x0.0p0", "0x0.0960p0", "0x0.1318p0", "0x0.1D2Cp0", "0x0.27A0p0", "0x0.3274p0", "0x0.3DB0p0", "0x0.4950p0",
    "0x0.5560p0", "0x0.61E4p0", "0x0.6ED8p0", "0x0.7C4Cp0", "0x0.8A38p0", "0x0.98A8p0", "0x0.A7A4p0", "0x0.B728p0"
   };
   ap_ufixed<14,6> exp_x_msb = exp_x_msb_table[x_msb_ind];
   ap_ufixed<14,0> exp_x_lsb_m_1 = exp_x_lsb_m_1_table[x_lsb_ind];
   ap_ufixed<28,6> y_lo = exp_x_msb * exp_x_lsb_m_1;
   ap_ufixed<14,6> y_lo_s = y_lo;
   ap_ufixed<14,6> y_l = y_lo_s + exp_x_msb;
   y = y_l;
  }
  if(I_<7) {
   bool overf = 0;
   VITIS_LOOP_3005_5: for(int j = 11; j >= I_+5; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3012_6: for(int j = 11; j>= I_+5; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3016_7: for(int j = I_+4; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==3) {
  ap_fixed<27,14> x_l = x;
  ap_ufixed<26,13> y = 0;
  ap_fixed<3,3> x_l_int;
  x_l_int(2,0) = x_l(15,13);
  ap_ufixed<13,0> x_l_fract;
  x_l_fract(12,0) = x_l(12,0);
  bool overf = 0;
  VITIS_LOOP_3031_8: for(int j = 25; j>=15; j--) {
#pragma HLS unroll
 if(x_l[26]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==3)&&(x_l_fract>ap_ufixed<12,0>("0x3.E9D0p0")))) {
   if(!x_l[26]) {
    y = ap_ufixed<26,13>("0x1FFF.FFF8p0");
   }
  } else {
   ap_uint<6> x_msb_ind_1;
   x_msb_ind_1[5] = x_l[26];
   x_msb_ind_1(4,0) = x_l(14,10);
   ap_uint<5> x_msb_ind_2;
   x_msb_ind_2(4,0) = x_l(9,5);
   ap_uint<5> x_lsb_ind;
   x_lsb_ind(4,0) = x_l(4,0);
   const static ap_ufixed<24,-6> exp_lsb_ind_m_1_table[32] = {
    "0x0p0", "0x0.00126C5Cp0", "0x0.0024DA0Cp0", "0x0.0037490Cp0", "0x0.0049B964p0", "0x0.005C2B0Cp0", "0x0.006E9E08p0", "0x0.0081125Cp0",
    "0x0.00938800p0", "0x0.00A5FEF8p0", "0x0.00B87748p0", "0x0.00CAF0E8p0", "0x0.00DD6BE0p0", "0x0.00EFE82Cp0", "0x0.010265C8p0", "0x0.0114E4BCp0",
    "0x0.01276508p0", "0x0.0139E6A4p0", "0x0.014C6998p0", "0x0.015EEDDCp0", "0x0.0171737Cp0", "0x0.0183FA6Cp0", "0x0.019682B4p0", "0x0.01A90C50p0",
    "0x0.01BB9744p0", "0x0.01CE238Cp0", "0x0.01E0B128p0", "0x0.01F3401Cp0", "0x0.0205D064p0", "0x0.02186204p0", "0x0.022AF4F8p0", "0x0.023D8944p0"
   };
   ap_ufixed<24,-6> exp_lsb_ind_m_1 = exp_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<29,-1> exp_msb_ind_2_m_1_table[32] = {
    "0x0p0", "0x0.02501EE8p0", "0x0.04A5975Cp0", "0x0.070075C0p0", "0x0.0960C68Cp0", "0x0.0BC69660p0", "0x0.0E31F1F0p0", "0x0.10A2E60Cp0",
    "0x0.13197FA8p0", "0x0.1595CBD4p0", "0x0.1817D7BCp0", "0x0.1A9FB0ACp0", "0x0.1D2D6410p0", "0x0.1FC0FF74p0", "0x0.225A9080p0", "0x0.24FA24F8p0",
    "0x0.279FCACCp0", "0x0.2A4B8FFCp0", "0x0.2CFD82BCp0", "0x0.2FB5B150p0", "0x0.32742A20p0", "0x0.3538FBC0p0", "0x0.380434D8p0", "0x0.3AD5E43Cp0",
    "0x0.3DAE18DCp0", "0x0.408CE1CCp0", "0x0.43724E48p0", "0x0.465E6DA8p0", "0x0.49514F68p0", "0x0.4C4B0330p0", "0x0.4F4B98C4p0", "0x0.5253200Cp0"
   };
   ap_ufixed<29,-1> exp_msb_ind_2_m1 = exp_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<53,-7> f_x_msb_2_lsb = exp_lsb_ind_m_1 * exp_msb_ind_2_m1;
   ap_ufixed<27,-1> exp_msb_2_lsb_m_1 = f_x_msb_2_lsb + exp_msb_ind_2_m1 + exp_lsb_ind_m_1;
   const static ap_ufixed<28,13> exp_msb_ind_1_table[64] = {
    "0x1.0000p0", "0x1.5562p0", "0x1.C73Ep0", "0x2.5F12p0", "0x3.298Cp0", "0x4.378Cp0", "0x5.9F98p0", "0x7.7FBAp0",
    "0xA.0000p0", "0xD.55D0p0", "0x11.C866p0", "0x17.B6B8p0", "0x1F.9F6Ep0", "0x2A.2B6Ep0", "0x38.3BF0p0", "0x4A.FD4Ap0",
    "0x64.0000p0", "0x85.5A26p0", "0xB1.D3F4p0", "0xED.232Ap0", "0x13C.3A4Ep0", "0x1A5.B24Ep0", "0x232.5762p0", "0x2ED.E4EAp0",
    "0x3E8.0000p0", "0x535.857Cp0", "0x6F2.4788p0", "0x943.5FACp0", "0xC5A.4714p0", "0x1078.F70Cp0", "0x15F7.69CAp0", "0x1D4A.F12Ep0",
    "0x0.0006p0", "0x0.0008p0", "0x0.000Cp0", "0x0.0010p0", "0x0.0014p0", "0x0.001Cp0", "0x0.0024p0", "0x0.0032p0",
    "0x0.0042p0", "0x0.0058p0", "0x0.0074p0", "0x0.009Cp0", "0x0.00D0p0", "0x0.0114p0", "0x0.0170p0", "0x0.01ECp0",
    "0x0.0290p0", "0x0.036Ap0", "0x0.048Ep0", "0x0.0612p0", "0x0.0818p0", "0x0.0ACCp0", "0x0.0E66p0", "0x0.1332p0",
    "0x0.199Ap0", "0x0.2224p0", "0x0.2D86p0", "0x0.3CB6p0", "0x0.50F4p0", "0x0.6BF4p0", "0x0.8FF6p0", "0x0.BFFAp0"
   };
   ap_ufixed<28,13> exp_msb_ind_1 = exp_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<28,13> f_x_msb_1_msb_2_lsb_l = exp_msb_ind_1 * exp_msb_2_lsb_m_1;
   y = f_x_msb_1_msb_2_lsb_l + exp_msb_ind_1;
  }
  if(I_<14) {
   bool overf = 0;
   VITIS_LOOP_3081_9: for(int j = 25; j>= I_+12; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3088_10: for(int j = 25; j>=I_+12; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3092_11: for(int j = I_+11; j>=0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else if (I_s_==4) {
  ap_fixed<53,27> x_l = x;
  ap_ufixed<52,26> y = 0;
  ap_fixed<4,4> x_l_int;
  x_l_int(3,0) = x_l(29,26);
  ap_ufixed<26,0> x_l_fract;
  x_l_fract(25,0) = x_l(25,0);
  bool overf = 0;
  VITIS_LOOP_3107_12: for(int j = 51; j >= 29; j--) {
#pragma HLS unroll
 if(x_l[52]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<26,0>("0x0.D3A7D8C")))) {
   if(!x_l[52]) {
    y = ap_ufixed<52,26>("0x3FFFFFF.FFFFFFCp0");
   }
  } else {
   ap_uint<8> x_msb_ind_1;
   x_msb_ind_1[7] = x_l[52];
   x_msb_ind_1(6,0) = x_l(28,22);
   ap_uint<8> x_msb_ind_2;
   x_msb_ind_2(7,0) = x_l(21,14);
   ap_uint<7> x_msb_ind_3;
   x_msb_ind_3(6,0) = x_l(13,7);
   ap_uint<7> x_lsb_ind;
   x_lsb_ind(6,0) = x_l(6,0);
   const static ap_ufixed<41,-17> exp_lsb_ind_m_1_table[128] = {
    "0x0.0p0", "0x0.000000935D8E080p0", "0x0.00000126BB1C650p0", "0x0.000001BA18AB16Cp0", "0x0.0000024D763A1D4p0", "0x0.000002E0D3C978Cp0", "0x0.000003743159290p0", "0x0.000004078EE92E0p0",
    "0x0.0000049AEC79880p0", "0x0.0000052E4A0A368p0", "0x0.000005C1A79B3A4p0", "0x0.00000655052C928p0", "0x0.000006E862BE3FCp0", "0x0.0000077BC05041Cp0", "0x0.0000080F1DE298Cp0", "0x0.000008A27B75448p0",
    "0x0.00000935D908450p0", "0x0.000009C9369B9A4p0", "0x0.00000A5C942F448p0", "0x0.00000AEFF1C3438p0", "0x0.00000B834F57978p0", "0x0.00000C16ACEC400p0", "0x0.00000CAA0A813D8p0", "0x0.00000D3D6816900p0",
    "0x0.00000DD0C5AC370p0", "0x0.00000E642342334p0", "0x0.00000EF780D8840p0", "0x0.00000F8ADE6F29Cp0", "0x0.0000101E3C06244p0", "0x0.000010B1999D738p0", "0x0.00001144F73517Cp0", "0x0.000011D854CD10Cp0",
    "0x0.0000126BB2655E8p0", "0x0.000012FF0FFE010p0", "0x0.000013926D96F88p0", "0x0.00001425CB30450p0", "0x0.000014B928C9E60p0", "0x0.0000154C8663DC0p0", "0x0.000015DFE3FE26Cp0", "0x0.000016734198C68p0",
    "0x0.000017069F33BB0p0", "0x0.00001799FCCF044p0", "0x0.0000182D5A6AA24p0", "0x0.000018C0B806954p0", "0x0.0000195415A2DD0p0", "0x0.000019E7733F79Cp0", "0x0.00001A7AD0DC6B4p0", "0x0.00001B0E2E79B18p0",
    "0x0.00001BA18C174C8p0", "0x0.00001C34E9B53C8p0", "0x0.00001CC84753814p0", "0x0.00001D5BA4F21B0p0", "0x0.00001DEF0291094p0", "0x0.00001E8260304C8p0", "0x0.00001F15BDCFE4Cp0", "0x0.00001FA91B6FD18p0",
    "0x0.0000203C7910134p0", "0x0.000020CFD6B0AA0p0", "0x0.000021633451954p0", "0x0.000021F691F2D58p0", "0x0.00002289EF946ACp0", "0x0.0000231D4D36548p0", "0x0.000023B0AAD8934p0", "0x0.00002444087B270p0",
    "0x0.000024D7661E0F4p0", "0x0.0000256AC3C14C8p0", "0x0.000025FE2164DE8p0", "0x0.000026917F08C58p0", "0x0.00002724DCAD014p0", "0x0.000027B83A5191Cp0", "0x0.0000284B97F6774p0", "0x0.000028DEF59BB14p0",
    "0x0.000029725341408p0", "0x0.00002A05B0E7244p0", "0x0.00002A990E8D5D0p0", "0x0.00002B2C6C33EA8p0", "0x0.00002BBFC9DACD0p0", "0x0.00002C532782040p0", "0x0.00002CE68529900p0", "0x0.00002D79E2D1710p0",
    "0x0.00002E0D4079A6Cp0", "0x0.00002EA09E22314p0", "0x0.00002F33FBCB108p0", "0x0.00002FC7597444Cp0", "0x0.0000305AB71DCDCp0", "0x0.000030EE14C7AB8p0", "0x0.000031817271DE4p0", "0x0.00003214D01C65Cp0",
    "0x0.000032A82DC7420p0", "0x0.0000333B8B72734p0", "0x0.000033CEE91DF94p0", "0x0.0000346246C9D40p0", "0x0.000034F5A47603Cp0", "0x0.000035890222884p0", "0x0.0000361C5FCF618p0", "0x0.000036AFBD7C8FCp0",
    "0x0.000037431B2A12Cp0", "0x0.000037D678D7EA8p0", "0x0.00003869D686170p0", "0x0.000038FD3434988p0", "0x0.0000399091E36ECp0", "0x0.00003A23EF929A0p0", "0x0.00003AB74D421A0p0", "0x0.00003B4AAAF1EECp0",
    "0x0.00003BDE08A2188p0", "0x0.00003C71665296Cp0", "0x0.00003D04C4036A0p0", "0x0.00003D9821B4924p0", "0x0.00003E2B7F660F4p0", "0x0.00003EBEDD17E10p0", "0x0.00003F523ACA078p0", "0x0.00003FE5987C830p0",
    "0x0.00004078F62F534p0", "0x0.0000410C53E2788p0", "0x0.0000419FB195F24p0", "0x0.000042330F49C10p0", "0x0.000042C66CFDE4Cp0", "0x0.00004359CAB25D0p0", "0x0.000043ED28672A4p0", "0x0.00004480861C4C8p0",
    "0x0.00004513E3D1C34p0", "0x0.000045A741878F0p0", "0x0.0000463A9F3DAFCp0", "0x0.000046CDFCF4250p0", "0x0.000047615AAAEF4p0", "0x0.000047F4B8620E8p0", "0x0.000048881619824p0", "0x0.0000491B73D14B0p0"
   };
   ap_ufixed<41,-17> exp_lsb_ind_m_1 = exp_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<48,-10> exp_msb_ind_3_m_1_table[128] = {
    "0x0.0p0", "0x0.000049AED18968Cp0", "0x0.0000935DB847FC4p0", "0x0.0000DD0CB43BC10p0", "0x0.000126BBC564BCCp0", "0x0.0001706AEBC2F58p0", "0x0.0001BA1A275671Cp0", "0x0.000203C9781F374p0",
    "0x0.00024D78DE1D4C8p0", "0x0.000297285950B74p0", "0x0.0002E0D7E9B97D8p0", "0x0.00032A878F57A5Cp0", "0x0.000374374A2B360p0", "0x0.0003BDE71A34344p0", "0x0.00040796FF72A68p0", "0x0.00045146F9E6930p0",
    "0x0.00049AF70990000p0", "0x0.0004E4A72E6EF34p0", "0x0.00052E576883734p0", "0x0.00057807B7CD85Cp0", "0x0.0005C1B81C4D314p0", "0x0.00060B6896027B4p0", "0x0.0006551924ED6A8p0", "0x0.00069EC9C90E04Cp0",
    "0x0.0006E87A8264500p0", "0x0.0007322B50F052Cp0", "0x0.00077BDC34B2130p0", "0x0.0007C58D2DA9968p0", "0x0.00080F3E3BD6E3Cp0", "0x0.000858EF5F3A008p0", "0x0.0008A2A097D2F34p0", "0x0.0008EC51E5A1C1Cp0",
    "0x0.0009360348A6724p0", "0x0.00097FB4C0E10B0p0", "0x0.0009C9664E51920p0", "0x0.000A1317F0F80D4p0", "0x0.000A5CC9A8D4830p0", "0x0.000AA67B75E6F94p0", "0x0.000AF02D582F764p0", "0x0.000B39DF4FADFFCp0",
    "0x0.000B83915C629C4p0", "0x0.000BCD437E4D51Cp0", "0x0.000C16F5B56E268p0", "0x0.000C60A801C5200p0", "0x0.000CAA5A6352450p0", "0x0.000CF40CDA159B8p0", "0x0.000D3DBF660F294p0", "0x0.000D8772073EF4Cp0",
    "0x0.000DD124BDA5040p0", "0x0.000E1AD789415CCp0", "0x0.000E648A6A1405Cp0", "0x0.000EAE3D601D048p0", "0x0.000EF7F06B5C5F8p0", "0x0.000F41A38BD21CCp0", "0x0.000F8B56C17E424p0", "0x0.000FD50A0C60D64p0",
    "0x0.00101EBD6C79DECp0", "0x0.00106870E1C9620p0", "0x0.0010B2246C4F660p0", "0x0.0010FBD80C0BF0Cp0", "0x0.0011458BC0FF088p0", "0x0.00118F3F8B28B34p0", "0x0.0011D8F36A88F74p0", "0x0.001222A75F1FDA8p0",
    "0x0.00126C5B68ED630p0", "0x0.0012B60F87F1974p0", "0x0.0012FFC3BC2C7D0p0", "0x0.00134978059E1A8p0", "0x0.0013932C644675Cp0", "0x0.0013DCE0D82594Cp0", "0x0.00142695613B7E0p0", "0x0.00147049FF88374p0",
    "0x0.0014B9FEB30BC70p0", "0x0.001503B37BC632Cp0", "0x0.00154D6859B7810p0", "0x0.0015971D4CDFB80p0", "0x0.0015E0D2553EDD8p0", "0x0.00162A8772D4F7Cp0", "0x0.0016743CA5A20D0p0", "0x0.0016BDF1EDA6230p0",
    "0x0.001707A74AE1404p0", "0x0.0017515CBD536ACp0", "0x0.00179B1244FCA88p0", "0x0.0017E4C7E1DCFF8p0", "0x0.00182E7D93F4760p0", "0x0.001878335B43124p0", "0x0.0018C1E937C8DA4p0", "0x0.00190B9F2985D40p0",
    "0x0.00195555307A05Cp0", "0x0.00199F0B4CA5758p0", "0x0.0019E8C17E08294p0", "0x0.001A3277C4A2278p0", "0x0.001A7C2E2073760p0", "0x0.001AC5E4917C1ACp0", "0x0.001B0F9B17BC1C4p0", "0x0.001B5951B333808p0",
    "0x0.001BA30863E24D8p0", "0x0.001BECBF29C8894p0", "0x0.001C367604E63A4p0", "0x0.001C802CF53B664p0", "0x0.001CC9E3FAC8134p0", "0x0.001D139B158C47Cp0", "0x0.001D5D52458809Cp0", "0x0.001DA7098ABB5F4p0",
    "0x0.001DF0C0E5264E4p0", "0x0.001E3A7854C8DD0p0", "0x0.001E842FD9A311Cp0", "0x0.001ECDE773B4F24p0", "0x0.001F179F22FE850p0", "0x0.001F6156E77FCFCp0", "0x0.001FAB0EC138D90p0", "0x0.001FF4C6B029A68p0",
    "0x0.00203E7EB4523E8p0", "0x0.00208836CDB2A70p0", "0x0.0020D1EEFC4AE68p0", "0x0.00211BA7401B028p0", "0x0.0021655F9923018p0", "0x0.0021AF180762E98p0", "0x0.0021F8D08ADAC0Cp0", "0x0.00224289238A8D4p0",
    "0x0.00228C41D172550p0", "0x0.0022D5FA94921E4p0", "0x0.00231FB36CE9EF0p0", "0x0.0023696C5A79CD8p0", "0x0.0023B3255D41BFCp0", "0x0.0023FCDE7541CC0p0", "0x0.00244697A279F80p0", "0x0.00249050E4EA4A4p0"
   };
   ap_ufixed<48,-10> exp_msb_ind_3_m_1 = exp_msb_ind_3_m_1_table[x_msb_ind_3];
   ap_ufixed<89,-27> f_x_msb_ind_3_lsb = exp_lsb_ind_m_1 * exp_msb_ind_3_m_1;
   ap_ufixed<46,-10> exp_msb_ind_3_lsb_ind_m_1 = f_x_msb_ind_3_lsb + exp_lsb_ind_m_1 + exp_msb_ind_3_m_1;
   const static ap_ufixed<54,-2> exp_msb_ind_2_m_1_table[256] = {
    "0x0.0p0", "0x0.0024DA0A3C92C9p0", "0x0.0049B96285BC0Ap0", "0x0.006E9E099EFA37p0", "0x0.009388004BE7E5p0", "0x0.00B87747503BD4p0", "0x0.00DD6BDF6FC8EEp0", "0x0.010265C96E7E4Fp0",
    "0x0.01276506106748p0", "0x0.014C699619AB60p0", "0x0.0171737A4E8E5Ep0", "0x0.019682B3737048p0", "0x0.01BB97424CCD67p0", "0x0.01E0B1279F3E51p0", "0x0.0205D0642F77E5p0", "0x0.022AF4F8C24B54p0",
    "0x0.02501EE61CA626p0", "0x0.02754E2D03923Bp0", "0x0.029A82CE3C35CEp0", "0x0.02BFBCCA8BD37Fp0", "0x0.02E4FC22B7CA50p0", "0x0.030A40D78595AFp0", "0x0.032F8AE9BACD76p0", "0x0.0354DA5A1D25F2p0",
    "0x0.037A2F29726FE5p0", "0x0.039F895880988Ap0", "0x0.03C4E8E80DA99Bp0", "0x0.03EA4DD8DFC955p0", "0x0.040FB82BBD3A78p0", "0x0.043527E16C5C51p0", "0x0.045A9CFAB3AABBp0", "0x0.0480177859BE22p0",
    "0x0.04A5975B254B8Bp0", "0x0.04CB1CA3DD2493p0", "0x0.04F0A753483778p0", "0x0.0516376A2D8F1Ap0", "0x0.053BCCE95452FFp0", "0x0.056167D183C75Bp0", "0x0.05870823834D0Ep0", "0x0.05ACADE01A61AEp0",
    "0x0.05D25908109F88p0", "0x0.05F8099C2DBDA3p0", "0x0.061DBF9D398FC8p0", "0x0.06437B0BFC0683p0", "0x0.06693BE93D2F28p0", "0x0.068F0235C533D7p0", "0x0.06B4CDF25C5B83p0", "0x0.06DA9F1FCB09EFp0",
    "0x0.070075BED9BFBBp0", "0x0.072651D0511A61p0", "0x0.074C3354F9D43Dp0", "0x0.07721A4D9CC491p0", "0x0.079806BB02DF87p0", "0x0.07BDF89DF53637p0", "0x0.07E3EFF73CF6ACp0", "0x0.0809ECC7A36BE3p0",
    "0x0.082FEF0FF1FDD7p0", "0x0.0855F6D0F23180p0", "0x0.087C040B6DA8D8p0", "0x0.08A216C02E22DFp0", "0x0.08C82EEFFD7BA0p0", "0x0.08EE4C9BA5AC35p0", "0x0.09146FC3F0CACCp0", "0x0.093A9869A90AA9p0",
    "0x0.0960C68D98BC2Cp0", "0x0.0986FA308A4CD4p0", "0x0.09AD3353484744p0", "0x0.09D371F69D5348p0", "0x0.09F9B61B5435D7p0", "0x0.0A1FFFC237D119p0", "0x0.0A464EEC13246Bp0", "0x0.0A6CA399B14C61p0",
    "0x0.0A92FDCBDD82CEp0", "0x0.0AB95D83631EC5p0", "0x0.0ADFC2C10D94A0p0", "0x0.0B062D85A87601p0", "0x0.0B2C9DD1FF71D8p0", "0x0.0B5313A6DE5467p0", "0x0.0B798F05110749p0", "0x0.0BA00FED63916Fp0",
    "0x0.0BC69660A2172Dp0", "0x0.0BED225F98DA36p0", "0x0.0C13B3EB1439A8p0", "0x0.0C3A4B03E0B20Ap0", "0x0.0C60E7AACADD54p0", "0x0.0C8789E09F72F1p0", "0x0.0CAE31A62B47C4p0", "0x0.0CD4DEFC3B4E2Dp0",
    "0x0.0CFB91E39C960Dp0", "0x0.0D224A5D1C4CC9p0", "0x0.0D49086987BD4Fp0", "0x0.0D6FCC09AC501Cp0", "0x0.0D96953E578B3Ep0", "0x0.0DBD6408571257p0", "0x0.0DE4386878A6A5p0", "0x0.0E0B125F8A2704p0",
    "0x0.0E31F1EE598FF3p0", "0x0.0E58D715B4FB98p0", "0x0.0E7FC1D66AA1C4p0", "0x0.0EA6B23148D7F6p0", "0x0.0ECDA8271E1164p0", "0x0.0EF4A3B8B8DEF8p0", "0x0.0F1BA4E6E7EF5Dp0", "0x0.0F42ABB27A0EFAp0",
    "0x0.0F69B81C3E27FEp0", "0x0.0F90CA25034260p0", "0x0.0FB7E1CD9883E5p0", "0x0.0FDEFF16CD3022p0", "0x0.1006220170A885p0", "0x0.102D4A8E526C53p0", "0x0.105478BE4218B3p0", "0x0.107BAC920F68ACp0",
    "0x0.10A2E60A8A352Ep0", "0x0.10CA2528827515p0", "0x0.10F169ECC83D2Ap0", "0x0.1118B4582BC02Dp0", "0x0.1140046B7D4ED5p0", "0x0.11675A278D57D7p0", "0x0.118EB58D2C67E8p0", "0x0.11B6169D2B29C2p0",
    "0x0.11DD7D585A662Bp0", "0x0.1204E9BF8B03F4p0", "0x0.122C5BD38E0803p0", "0x0.1253D395349553p0", "0x0.127B51054FECFBp0", "0x0.12A2D424B16E31p0", "0x0.12CA5CF42A964Fp0", "0x0.12F1EB748D00D7p0",
    "0x0.13197FA6AA6777p0", "0x0.1341198B54A20Dp0", "0x0.1368B9235DA6AEp0", "0x0.13905E6F9789A8p0", "0x0.13B80970D47D86p0", "0x0.13DFBA27E6D314p0", "0x0.14077095A0F967p0", "0x0.142F2CBAD57DDEp0",
    "0x0.1456EE98570C27p0", "0x0.147EB62EF86E43p0", "0x0.14A6837F8C8C8Cp0", "0x0.14CE568AE66DB7p0", "0x0.14F62F51D936DBp0", "0x0.151E0DD5382B74p0", "0x0.1545F215D6AD66p0", "0x0.156DDC14883D04p0",
    "0x0.1595CBD2207913p0", "0x0.15BDC14F731ECFp0", "0x0.15E5BC8D5409EEp0", "0x0.160DBD8C9734A6p0", "0x0.1635C44E10B7B0p0", "0x0.165DD0D294CA4Ep0", "0x0.1685E31AF7C24Ep0", "0x0.16ADFB280E140Fp0",
    "0x0.16D618FAAC5286p0", "0x0.16FE3C93A72F41p0", "0x0.172665F3D37A6Cp0", "0x0.174E951C0622D6p0", "0x0.1776CA0D1435F4p0", "0x0.179F04C7D2DFE7p0", "0x0.17C7454D176B81p0", "0x0.17EF8B9DB74247p0",
    "0x0.1817D7BA87EC75p0", "0x0.184029A45F1107p0", "0x0.1868815C1275B9p0", "0x0.1890DEE277FF0Dp0", "0x0.18B9423865B04Fp0", "0x0.18E1AB5EB1AB9Ap0", "0x0.190A1A563231DCp0", "0x0.19328F1FBDA2DCp0",
    "0x0.195B09BC2A7D3Ap0", "0x0.19838A2C4F5E7Ap0", "0x0.19AC1071030303p0", "0x0.19D49C8B1C4625p0", "0x0.19FD2E7B722220p0", "0x0.1A25C642DBB023p0", "0x0.1A4E63E2302857p0", "0x0.1A77075A46E1DEp0",
    "0x0.1A9FB0ABF752DBp0", "0x0.1AC85FD8191074p0", "0x0.1AF114DF83CED8p0", "0x0.1B19CFC30F6145p0", "0x0.1B42908393BA07p0", "0x0.1B6B5721E8EA82p0", "0x0.1B94239EE72334p0", "0x0.1BBCF5FB66B3BCp0",
    "0x0.1BE5CE38400AD8p0", "0x0.1C0EAC564BB672p0", "0x0.1C37905662639Fp0", "0x0.1C607A395CDEA5p0", "0x0.1C896A001412FEp0", "0x0.1CB25FAB610B61p0", "0x0.1CDB5B3C1CF1BFp0", "0x0.1D045CB3210F50p0",
    "0x0.1D2D641146CC91p0", "0x0.1D56715767B14Cp0", "0x0.1D7F84865D649Ap0", "0x0.1DA89D9F01ACEBp0", "0x0.1DD1BCA22E7006p0", "0x0.1DFAE190BDB311p0", "0x0.1E240C6B899A96p0", "0x0.1E4D3D336C6A83p0",
    "0x0.1E7673E9408633p0", "0x0.1E9FB08DE07072p0", "0x0.1EC8F32226CB7Ep0", "0x0.1EF23BA6EE590Fp0", "0x0.1F1B8A1D11FA5Cp0", "0x0.1F44DE856CB01Dp0", "0x0.1F6E38E0D99A90p0", "0x0.1F97993033F980p0",
    "0x0.1FC0FF74572C45p0", "0x0.1FEA6BAE1EB1CEp0", "0x0.2013DDDE6628A0p0", "0x0.203D5606094EE1p0", "0x0.2066D425E40256p0", "0x0.2090583ED2406Ap0", "0x0.20B9E251B02636p0", "0x0.20E3725F59F080p0",
    "0x0.210D0868ABFBC3p0", "0x0.2136A46E82C433p0", "0x0.21604671BAE5C1p0", "0x0.2189EE73311C20p0", "0x0.21B39C73C242C8p0", "0x0.21DD50744B54FDp0", "0x0.22070A75A96DD4p0", "0x0.2230CA78B9C835p0",
    "0x0.225A907E59BEDFp0", "0x0.22845C8766CC70p0", "0x0.22AE2E94BE8B69p0", "0x0.22D806A73EB62Fp0", "0x0.2301E4BFC52713p0", "0x0.232BC8DF2FD857p0", "0x0.2355B3065CE42Fp0", "0x0.237FA3362A84CAp0",
    "0x0.23A9996F771453p0", "0x0.23D395B3210CF7p0", "0x0.23FD98020708EAp0", "0x0.2427A05D07C26Dp0", "0x0.2451AEC50213CEp0", "0x0.247BC33AD4F771p0", "0x0.24A5DDBF5F87D3p0", "0x0.24CFFE5380FF8Fp0",
    "0x0.24FA24F818B962p0", "0x0.252451AE063030p0", "0x0.254E847628FF09p0", "0x0.2578BD5160E12Cp0", "0x0.25A2FC408DB20Fp0", "0x0.25CD41448F6D5Fp0", "0x0.25F78C5E462F0Ap0", "0x0.2621DD8E92333Fp0",
    "0x0.264C34D653D674p0", "0x0.267692366B956Dp0", "0x0.26A0F5AFBA0D3Cp0", "0x0.26CB5F431FFB4Cp0", "0x0.26F5CEF17E3D5Fp0", "0x0.272044BBB5D196p0", "0x0.274AC0A2A7D678p0", "0x0.277542A7358AF1p0"
   };
   ap_ufixed<54,-2> exp_msb_ind_2_m_1 = exp_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<100,-12> f_x_msb_ind_2_msb_ind3_lsb = exp_msb_ind_3_lsb_ind_m_1 * exp_msb_ind_2_m_1;
   ap_ufixed<52,-2> exp_msb_ind2_msb_ind3_lsb_ind_m_1 = f_x_msb_ind_2_msb_ind3_lsb + exp_msb_ind_3_lsb_ind_m_1 + exp_msb_ind_2_m_1;
   const static ap_ufixed<54,26> exp_msb_ind_1_table[256] = {
    "0x1.0000000p0", "0x1.279FCADp0", "0x1.5561A92p0", "0x1.8A389FFp0", "0x1.C73D51Cp0", "0x2.0DB3D0Fp0", "0x2.5F1258Ep0", "0x2.BD0911Bp0",
    "0x3.298B076p0", "0x3.A6D8842p0", "0x4.378B054p0", "0x4.DEA3099p0", "0x5.9F9802Dp0", "0x6.7E6ABF0p0", "0x7.7FBAAB4p0", "0x8.A8DE610p0",
    "0xA.0000000p0", "0xB.8C3DEBEp0", "0xD.55D09B1p0", "0xF.66363F8p0", "0x11.C86531Bp0", "0x14.8906295p0", "0x17.B6B778Cp0", "0x1B.625AB10p0",
    "0x1F.9F6E499p0", "0x24.8475291p0", "0x2A.2B6E347p0", "0x30.B25E5F8p0", "0x38.3BF01BEp0", "0x40.F02B75Fp0", "0x4A.FD4AB0Bp0", "0x56.98AFCA2p0",
    "0x64.0000000p0", "0x73.7A6B370p0", "0x85.5A260EDp0", "0x99.FE1E7B3p0", "0xB1.D3F3F11p0", "0xCD.5A3D9D0p0", "0xED.232AB7Bp0", "0x111.D78AEA4p0",
    "0x13C.3A4EDFBp0", "0x16D.2C939A9p0", "0x1A5.B24E0C7p0", "0x1E6.F7AFBABp0", "0x232.5761167p0", "0x289.61B29B6p0", "0x2ED.E4EAE72p0", "0x361.F6DDE55p0",
    "0x3E8.0000000p0", "0x482.C830261p0", "0x535.857C941p0", "0x603.ED30CFDp0", "0x6F2.47876A9p0", "0x805.8668224p0", "0x943.5FAB2CAp0", "0xAB2.6B6D26Bp0",
    "0xC5A.4714BCAp0", "0xE43.BDC409Bp0", "0x1078.F70C7CBp0", "0x1305.ACDD4AFp0", "0x15F7.69CAE07p0", "0x195D.D0FA11Ep0", "0x1D4A.F12D073p0", "0x21D3.A4AAF51p0",
    "0x2710.0000000p0", "0x2D1B.D1E17C7p0", "0x3417.36DDC85p0", "0x3C27.43E81E5p0", "0x4576.CB4A29Cp0", "0x5037.401156Cp0", "0x5CA1.BCAFBE1p0", "0x6AF8.324382Fp0",
    "0x7B86.C6CF5E3p0", "0x8EA5.69A8609p0", "0xA4B9.A67CDEAp0", "0xBE38.C0A4ED5p0", "0xDBAA.21ECC48p0", "0xFDAA.29C4B2Ap0", "0x124ED.6BC2480p0", "0x15244.6EAD929p0",
    "0x186A0.0000000p0", "0x1C316.32CEDC6p0", "0x208E8.24A9D35p0", "0x25988.A7112F0p0", "0x2B6A3.F0E5A19p0", "0x32228.80AD63Cp0", "0x39E51.5EDD6CAp0", "0x42DB1.F6A31D7p0",
    "0x4D343.C419ADFp0", "0x59276.2093C5Ep0", "0x66F40.80E0B21p0", "0x76E37.8671452p0", "0x894A5.533FACCp0", "0x9E8A5.A1AEFA8p0", "0xB7146.3596CFDp0", "0xD36AC.52C7B9Bp0",
    "0xF4240.0000000p0", "0x119EDD.FC149BCp0", "0x145911.6EA2417p0", "0x177F56.86ABD5Cp0", "0x1B2267.68F84F9p0", "0x1F5595.06C5E54p0", "0x242F2D.B4A63E0p0", "0x29C8F3.A25F263p0",
    "0x3040A5.A900CB8p0", "0x37B89D.45C5BB0p0", "0x405885.08C6F4Ap0", "0x4A4E2B.406CB33p0", "0x55CE75.407CBF4p0", "0x631678.50D5C93p0", "0x726CBE.17E41E4p0", "0x8422BB.3BCD40Ap0",
    "0x989680.0000000p0", "0xB034AB.D8CE155p0", "0xCB7AAE.52568E6p0", "0xEAF961.42B6594p0", "0x10F580A.19B31BCp0", "0x13957D2.43BAF49p0", "0x169D7C9.0E7E6C2p0", "0x1A1D984.57B77DEp0",
    "0x1E28678.9A07F2Fp0", "0x22D3624.B9B94DFp0", "0x2837532.57C58E8p0", "0x2E70DB0.843F002p0", "0x35A1094.84DF78Cp0", "0x3DEE0B3.2859DBCp0", "0x4783F6C.EEE92ECp0", "0x5295B50.5604864p0",
    "0x0.0000003p0", "0x0.0000003p0", "0x0.0000004p0", "0x0.0000004p0", "0x0.0000005p0", "0x0.0000006p0", "0x0.0000006p0", "0x0.0000007p0",
    "0x0.0000008p0", "0x0.000000Ap0", "0x0.000000Bp0", "0x0.000000Dp0", "0x0.000000Fp0", "0x0.0000011p0", "0x0.0000014p0", "0x0.0000017p0",
    "0x0.000001Bp0", "0x0.000001Fp0", "0x0.0000024p0", "0x0.0000029p0", "0x0.0000030p0", "0x0.0000037p0", "0x0.0000040p0", "0x0.000004Ap0",
    "0x0.0000055p0", "0x0.0000062p0", "0x0.0000071p0", "0x0.0000083p0", "0x0.0000097p0", "0x0.00000AEp0", "0x0.00000C9p0", "0x0.00000E8p0",
    "0x0.000010Cp0", "0x0.0000136p0", "0x0.0000166p0", "0x0.000019Dp0", "0x0.00001DDp0", "0x0.0000227p0", "0x0.000027Dp0", "0x0.00002DFp0",
    "0x0.0000351p0", "0x0.00003D4p0", "0x0.000046Cp0", "0x0.000051Bp0", "0x0.00005E6p0", "0x0.00006CFp0", "0x0.00007DDp0", "0x0.0000915p0",
    "0x0.0000A7Cp0", "0x0.0000C1Cp0", "0x0.0000DFCp0", "0x0.0001026p0", "0x0.00012A6p0", "0x0.0001588p0", "0x0.00018DEp0", "0x0.0001CB7p0",
    "0x0.0002129p0", "0x0.000264Bp0", "0x0.0002C38p0", "0x0.0003310p0", "0x0.0003AF7p0", "0x0.0004418p0", "0x0.0004EA2p0", "0x0.0005ACEp0",
    "0x0.00068DCp0", "0x0.0007916p0", "0x0.0008BD4p0", "0x0.000A179p0", "0x0.000BA77p0", "0x0.000D754p0", "0x0.000F8A8p0", "0x0.0011F25p0",
    "0x0.0014B97p0", "0x0.0017EEAp0", "0x0.001BA2Ep0", "0x0.001FE9Fp0", "0x0.0024DA8p0", "0x0.002A8EDp0", "0x0.0031252p0", "0x0.0038C08p0",
    "0x0.0041893p0", "0x0.004BAE0p0", "0x0.005764Cp0", "0x0.0064EBBp0", "0x0.00748A9p0", "0x0.0086947p0", "0x0.009B691p0", "0x0.00B3771p0",
    "0x0.00CF3E3p0", "0x0.00EF521p0", "0x0.01145CFp0", "0x0.013F239p0", "0x0.0170894p0", "0x0.01A9943p0", "0x0.01EB736p0", "0x0.023784Bp0",
    "0x0.028F5C3p0", "0x0.02F4CC4p0", "0x0.0369EFCp0", "0x0.03F134Dp0", "0x0.048D69Cp0", "0x0.0541CC5p0", "0x0.06121A8p0", "0x0.0702A69p0",
    "0x0.08186E2p0", "0x0.0959348p0", "0x0.0ACBA15p0", "0x0.0C7763Fp0", "0x0.0E655C3p0", "0x0.109FC99p0", "0x0.133281Bp0", "0x0.162B2F1p0",
    "0x0.199999Ap0", "0x0.1D8FFABp0", "0x0.22235DBp0", "0x0.276C100p0", "0x0.2D8621Cp0", "0x0.3491FB5p0", "0x0.3CB508Ep0", "0x0.461A81Cp0",
    "0x0.50F44D9p0", "0x0.5D7C0D3p0", "0x0.6BF44D5p0", "0x0.7CA9E76p0", "0x0.8FF599Ep0", "0x0.A63DDFEp0", "0x0.BFF9112p0", "0x0.DDAFD68p0"
   };
   ap_ufixed<54,26> exp_msb_ind_1 = exp_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<106,24> f_x_msb_ind_1_ind_2_ind_1_lsb = exp_msb_ind_1 * exp_msb_ind2_msb_ind3_lsb_ind_m_1;
   y = f_x_msb_ind_1_ind_2_ind_1_lsb + exp_msb_ind_1;
  }
  if(I_<27) {
   bool overf = 0;
   VITIS_LOOP_3244_13: for(int j = 51; j >= 25 + I_; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3251_14: for(int j = 51; j>=25 + I_; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3255_15: for(int j = 24 + I_; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 } else {
  ap_fixed<65,33> x_l = x;
  ap_ufixed<64,32> y = 0;
  ap_fixed<5,5> x_l_int;
  x_l_int(4,0) = x_l(36,32);
  ap_ufixed<32,0> x_l_fract;
  x_l_fract(31,0) = x_l(31,0);
  bool overf = 0;
  VITIS_LOOP_3270_16: for(int j = 63; j >= 36; j--) {
#pragma HLS unroll
 if(x_l[64]!=x_l[j]) {
    overf = 1;
   }
  }
  if(overf||(x_l_int >= 10)||((x_l_int==9)&&(x_l_fract>ap_fixed<32,0>("0x0.A209A84F")))) {
   if(!x_l[64]) {
    y = ap_ufixed<64,32>("0xFFFFFFFF.FFFFFFFFp0");
   }
  } else {
   ap_uint<8> x_msb_ind_1;
   x_msb_ind_1[7] = x_l[64];
   x_msb_ind_1(6,0) = x_l(35,29);
   ap_uint<8> x_msb_ind_2;
   x_msb_ind_2(7,0) = x_l(28,21);
   ap_uint<7> x_msb_ind_3;
   x_msb_ind_3(6,0) = x_l(20,14);
   ap_uint<7> x_msb_ind_4;
   x_msb_ind_4(6,0) = x_l(13,7);
   ap_uint<7> x_lsb_ind;
   x_lsb_ind(6,0) = x_l(6,0);
   const static ap_ufixed<49,-23> exp_x_lsb_ind_m_1_table[128] = {
    "0x0.0p0", "0x0.000000024D76377927p0", "0x0.000000049AEC6EF79Cp0", "0x0.00000006E862A67B5Dp0", "0x0.0000000935D8DE046Dp0", "0x0.0000000B834F1592C9p0", "0x0.0000000DD0C54D2672p0", "0x0.000000101E3B84BF69p0",
    "0x0.000000126BB1BC5DAEp0", "0x0.00000014B927F4013Fp0", "0x0.00000017069E2BAA1Ep0", "0x0.00000019541463584Ap0", "0x0.0000001BA18A9B0BC3p0", "0x0.0000001DEF00D2C48Ap0", "0x0.000000203C770A829Ep0", "0x0.0000002289ED4245FFp0",
    "0x0.00000024D7637A0EAEp0", "0x0.0000002724D9B1DCA9p0", "0x0.00000029724FE9AFF2p0", "0x0.0000002BBFC6218889p0", "0x0.0000002E0D3C59666Cp0", "0x0.000000305AB291499Dp0", "0x0.00000032A828C9321Bp0", "0x0.00000034F59F011FE7p0",
    "0x0.000000374315391300p0", "0x0.00000039908B710B66p0", "0x0.0000003BDE01A90919p0", "0x0.0000003E2B77E10C1Ap0", "0x0.0000004078EE191468p0", "0x0.00000042C664512203p0", "0x0.0000004513DA8934EBp0", "0x0.000000476150C14D21p0",
    "0x0.00000049AEC6F96AA4p0", "0x0.0000004BFC3D318D75p0", "0x0.0000004E49B369B592p0", "0x0.000000509729A1E2FDp0", "0x0.00000052E49FDA15B5p0", "0x0.000000553216124DBBp0", "0x0.000000577F8C4A8B0Ep0", "0x0.00000059CD0282CDAEp0",
    "0x0.0000005C1A78BB159Bp0", "0x0.0000005E67EEF362D6p0", "0x0.00000060B5652BB55Ep0", "0x0.0000006302DB640D33p0", "0x0.0000006550519C6A55p0", "0x0.000000679DC7D4CCC5p0", "0x0.00000069EB3E0D3482p0", "0x0.0000006C38B445A18Dp0",
    "0x0.0000006E862A7E13E4p0", "0x0.00000070D3A0B68B89p0", "0x0.000000732116EF087Bp0", "0x0.000000756E8D278ABBp0", "0x0.00000077BC03601248p0", "0x0.0000007A0979989F22p0", "0x0.0000007C56EFD13149p0", "0x0.0000007EA46609C8BEp0",
    "0x0.00000080F1DC426580p0", "0x0.000000833F527B078Fp0", "0x0.000000858CC8B3AEEBp0", "0x0.00000087DA3EEC5B95p0", "0x0.0000008A27B5250D8Cp0", "0x0.0000008C752B5DC4D1p0", "0x0.0000008EC2A1968162p0", "0x0.000000911017CF4341p0",
    "0x0.000000935D8E080A6Dp0", "0x0.00000095AB0440D6E7p0", "0x0.00000097F87A79A8AEp0", "0x0.0000009A45F0B27FC2p0", "0x0.0000009C9366EB5C23p0", "0x0.0000009EE0DD243DD2p0", "0x0.000000A12E535D24CEp0", "0x0.000000A37BC9961117p0",
    "0x0.000000A5C93FCF02ADp0", "0x0.000000A816B607F991p0", "0x0.000000AA642C40F5C2p0", "0x0.000000ACB1A279F741p0", "0x0.000000AEFF18B2FE0Cp0", "0x0.000000B14C8EEC0A25p0", "0x0.000000B39A05251B8Bp0", "0x0.000000B5E77B5E323Fp0",
    "0x0.000000B834F1974E40p0", "0x0.000000BA8267D06F8Ep0", "0x0.000000BCCFDE099629p0", "0x0.000000BF1D5442C212p0", "0x0.000000C16ACA7BF348p0", "0x0.000000C3B840B529CBp0", "0x0.000000C605B6EE659Bp0", "0x0.000000C8532D27A6B9p0",
    "0x0.000000CAA0A360ED24p0", "0x0.000000CCEE199A38DDp0", "0x0.000000CF3B8FD389E2p0", "0x0.000000D189060CE035p0", "0x0.000000D3D67C463BD5p0", "0x0.000000D623F27F9CC3p0", "0x0.000000D87168B902FEp0", "0x0.000000DABEDEF26E86p0",
    "0x0.000000DD0C552BDF5Bp0", "0x0.000000DF59CB65557Ep0", "0x0.000000E1A7419ED0EEp0", "0x0.000000E3F4B7D851ABp0", "0x0.000000E6422E11D7B6p0", "0x0.000000E88FA44B630Dp0", "0x0.000000EADD1A84F3B2p0", "0x0.000000ED2A90BE89A5p0",
    "0x0.000000EF7806F824E4p0", "0x0.000000F1C57D31C571p0", "0x0.000000F412F36B6B4Cp0", "0x0.000000F66069A51673p0", "0x0.000000F8ADDFDEC6E8p0", "0x0.000000FAFB56187CAAp0", "0x0.000000FD48CC5237B9p0", "0x0.000000FF96428BF816p0",
    "0x0.00000101E3B8C5BDC0p0", "0x0.00000104312EFF88B7p0", "0x0.000001067EA53958FCp0", "0x0.00000108CC1B732E8Ep0", "0x0.0000010B1991AD096Dp0", "0x0.0000010D6707E6E999p0", "0x0.0000010FB47E20CF13p0", "0x0.0000011201F45AB9DAp0",
    "0x0.000001144F6A94A9EEp0", "0x0.000001169CE0CE9F4Fp0", "0x0.00000118EA570899FEp0", "0x0.0000011B37CD4299FAp0", "0x0.0000011D85437C9F44p0", "0x0.0000011FD2B9B6A9DAp0", "0x0.00000122202FF0B9BEp0", "0x0.000001246DA62ACEEFp0"
   };
   ap_ufixed<49,-23> exp_x_lsb_ind_m_1 = exp_x_lsb_ind_m_1_table[x_lsb_ind];
   const static ap_ufixed<56,-16> exp_x_msb_ind_4_m_1_table[128] = {
    "0x0.0p0", "0x0.00000126BB1C64FE3Ep0", "0x0.0000024D763A1D4ECAp0", "0x0.00000374315928F1A6p0", "0x0.0000049AEC7987E6D2p0", "0x0.000005C1A79B3A2E51p0", "0x0.000006E862BE3FC825p0", "0x0.0000080F1DE298B44Dp0",
    "0x0.00000935D90844F2CDp0", "0x0.00000A5C942F4483A6p0", "0x0.00000B834F579766D9p0", "0x0.00000CAA0A813D9C67p0", "0x0.00000DD0C5AC372453p0", "0x0.00000EF780D883FE9Ep0", "0x0.0000101E3C06242B48p0", "0x0.00001144F73517AA55p0",
    "0x0.0000126BB2655E7BC5p0", "0x0.000013926D96F89F9Ap0", "0x0.000014B928C9E615D5p0", "0x0.000015DFE3FE26DE78p0", "0x0.000017069F33BAF985p0", "0x0.0000182D5A6AA266FCp0", "0x0.0000195415A2DD26E0p0", "0x0.00001A7AD0DC6B3932p0",
    "0x0.00001BA18C174C9DF4p0", "0x0.00001CC84753815527p0", "0x0.00001DEF0291095ECCp0", "0x0.00001F15BDCFE4BAE6p0", "0x0.0000203C7910136975p0", "0x0.000021633451956A7Bp0", "0x0.00002289EF946ABDFAp0", "0x0.000023B0AAD89363F3p0",
    "0x0.000024D7661E0F5C68p0", "0x0.000025FE2164DEA75Ap0", "0x0.00002724DCAD0144CCp0", "0x0.0000284B97F67734BDp0", "0x0.000029725341407730p0", "0x0.00002A990E8D5D0C27p0", "0x0.00002BBFC9DACCF3A2p0", "0x0.00002CE68529902DA4p0",
    "0x0.00002E0D4079A6BA2Ep0", "0x0.00002F33FBCB109942p0", "0x0.0000305AB71DCDCAE0p0", "0x0.000031817271DE4F0Bp0", "0x0.000032A82DC74225C5p0", "0x0.000033CEE91DF94F0Dp0", "0x0.000034F5A47603CAE7p0", "0x0.0000361C5FCF619954p0",
    "0x0.000037431B2A12BA54p0", "0x0.00003869D686172DEBp0", "0x0.0000399091E36EF418p0", "0x0.00003AB74D421A0CDFp0", "0x0.00003BDE08A218783Fp0", "0x0.00003D04C4036A363Cp0", "0x0.00003E2B7F660F46D5p0", "0x0.00003F523ACA07AA0Ep0",
    "0x0.00004078F62F535FE7p0", "0x0.0000419FB195F26862p0", "0x0.000042C66CFDE4C380p0", "0x0.000043ED28672A7144p0", "0x0.00004513E3D1C371ADp0", "0x0.0000463A9F3DAFC4BFp0", "0x0.000047615AAAEF6A7Ap0", "0x0.0000488816198262E1p0",
    "0x0.000049AED18968ADF4p0", "0x0.00004AD58CFAA24BB5p0", "0x0.00004BFC486D2F3C26p0", "0x0.00004D2303E10F7F48p0", "0x0.00004E49BF5643151Cp0", "0x0.00004F707ACCC9FDA5p0", "0x0.000050973644A438E4p0", "0x0.000051BDF1BDD1C6DAp0",
    "0x0.000052E4AD3852A788p0", "0x0.0000540B68B426DAF1p0", "0x0.0000553224314E6116p0", "0x0.00005658DFAFC939F8p0", "0x0.0000577F9B2F976599p0", "0x0.000058A656B0B8E3FBp0", "0x0.000059CD12332DB51Ep0", "0x0.00005AF3CDB6F5D905p0",
    "0x0.00005C1A893C114FB1p0", "0x0.00005D4144C2801924p0", "0x0.00005E68004A42355Fp0", "0x0.00005F8EBBD357A463p0", "0x0.000060B5775DC06632p0", "0x0.000061DC32E97C7ACEp0", "0x0.00006302EE768BE238p0", "0x0.00006429AA04EE9C72p0",
    "0x0.000065506594A4A97Dp0", "0x0.000066772125AE095Ap0", "0x0.0000679DDCB80ABC0Cp0", "0x0.000068C4984BBAC194p0", "0x0.000069EB53E0BE19F3p0", "0x0.00006B120F7714C52Bp0", "0x0.00006C38CB0EBEC33Ep0", "0x0.00006D5F86A7BC142Cp0",
    "0x0.00006E8642420CB7F8p0", "0x0.00006FACFDDDB0AEA2p0", "0x0.000070D3B97AA7F82Dp0", "0x0.000071FA7518F2949Ap0", "0x0.0000732130B89083EBp0", "0x0.00007447EC5981C621p0", "0x0.0000756EA7FBC65B3Dp0", "0x0.00007695639F5E4341p0",
    "0x0.000077BC1F44497E2Fp0", "0x0.000078E2DAEA880C08p0", "0x0.00007A09969219ECCEp0", "0x0.00007B30523AFF2082p0", "0x0.00007C570DE537A726p0", "0x0.00007D7DC990C380BBp0", "0x0.00007EA4853DA2AD43p0", "0x0.00007FCB40EBD52CBFp0",
    "0x0.000080F1FC9B5AFF31p0", "0x0.00008218B84C34249Ap0", "0x0.0000833F73FE609CFCp0", "0x0.000084662FB1E06859p0", "0x0.0000858CEB66B386B2p0", "0x0.000086B3A71CD9F808p0", "0x0.000087DA62D453BC5Dp0", "0x0.000089011E8D20D3B2p0",
    "0x0.00008A27DA47413E0Ap0", "0x0.00008B4E9602B4FB65p0", "0x0.00008C7551BF7C0BC5p0", "0x0.00008D9C0D7D966F2Cp0", "0x0.00008EC2C93D04259Bp0", "0x0.00008FE984FDC52F14p0", "0x0.0000911040BFD98B98p0", "0x0.00009236FC83413B29p0"
   };
   ap_ufixed<56,-16> exp_x_msb_ind_4_m_1 = exp_x_msb_ind_4_m_1_table[x_msb_ind_4];
   ap_ufixed<105,-39> f_x_msb_ind_4_lsb_ind = exp_x_msb_ind_4_m_1 * exp_x_lsb_ind_m_1;
   ap_ufixed<54,-16> exp_x_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_4_lsb_ind + exp_x_msb_ind_4_m_1 + exp_x_lsb_ind_m_1;
   const static ap_ufixed<61,-9> exp_x_msb_ind_3_m_1_table[128] = {
    "0x0.0p0", "0x0.0000935DB847FC5AA8p0", "0x0.000126BBC564BCA768p0", "0x0.0001BA1A275671BB78p0", "0x0.00024D78DE1D4C6C2Cp0", "0x0.0002E0D7E9B97D8EFCp0", "0x0.000374374A2B35F970p0", "0x0.00040796FF72A6813Cp0",
    "0x0.00049AF7098FFFFC24p0", "0x0.00052E57688373400Cp0", "0x0.0005C1B81C4D3122F0p0", "0x0.0006551924ED6A7AF0p0", "0x0.0006E87A8264501E44p0", "0x0.00077BDC34B212E340p0", "0x0.00080F3E3BD6E3A04Cp0", "0x0.0008A2A097D2F32C00p0",
    "0x0.0009360348A6725D00p0", "0x0.0009C9664E51920A0Cp0", "0x0.000A5CC9A8D4830A0Cp0", "0x0.000AF02D582F7633F4p0", "0x0.000B83915C629C5EE4p0", "0x0.000C16F5B56E266210p0", "0x0.000CAA5A63524514C8p0", "0x0.000D3DBF660F294E74p0",
    "0x0.000DD124BDA503E6A8p0", "0x0.000E648A6A1405B500p0", "0x0.000EF7F06B5C5F9140p0", "0x0.000F8B56C17E425348p0", "0x0.00101EBD6C79DED310p0", "0x0.0010B2246C4F65E8ACp0", "0x0.0011458BC0FF086C50p0", "0x0.0011D8F36A88F7364Cp0",
    "0x0.00126C5B68ED631F08p0", "0x0.0012FFC3BC2C7CFF0Cp0", "0x0.0013932C644675AEF4p0", "0x0.00142695613B7E0788p0", "0x0.0014B9FEB30BC6E19Cp0", "0x0.00154D6859B7811628p0", "0x0.0015E0D2553EDD7E44p0", "0x0.0016743CA5A20CF314p0",
    "0x0.001707A74AE1404DF0p0", "0x0.00179B1244FCA86834p0", "0x0.00182E7D93F4761B6Cp0", "0x0.0018C1E937C8DA4134p0", "0x0.00195555307A05B348p0", "0x0.0019E8C17E08294B7Cp0", "0x0.001A7C2E207375E3C8p0", "0x0.001B0F9B17BC1C563Cp0",
    "0x0.001BA30863E24D7D04p0", "0x0.001C367604E63A3268p0", "0x0.001CC9E3FAC81350CCp0", "0x0.001D5D52458809B2ACp0", "0x0.001DF0C0E5264E32ACp0", "0x0.001E842FD9A311AB84p0", "0x0.001F179F22FE84F804p0", "0x0.001FAB0EC138D8F320p0",
    "0x0.00203E7EB4523E77E4p0", "0x0.0020D1EEFC4AE66178p0", "0x0.0021655F9923018B24p0", "0x0.0021F8D08ADAC0D048p0", "0x0.00228C41D172550C64p0", "0x0.00231FB36CE9EF1B0Cp0", "0x0.0023B3255D41BFD7FCp0", "0x0.00244697A279F81F04p0",
    "0x0.0024DA0A3C92C8CC10p0", "0x0.00256D7D2B8C62BB2Cp0", "0x0.002600F06F66F6C880p0", "0x0.002694640822B5D04Cp0", "0x0.002727D7F5BFD0AEECp0", "0x0.0027BB4C383E7840E0p0", "0x0.00284EC0CF9EDD62C0p0", "0x0.0028E235BBE130F138p0",
    "0x0.002975AAFD05A3C918p0", "0x0.002A0920930C66C754p0", "0x0.002A9C967DF5AAC8E8p0", "0x0.002B300CBDC1A0AB00p0", "0x0.002BC3835270794AD4p0", "0x0.002C56FA3C026585C8p0", "0x0.002CEA717A77963950p0", "0x0.002D7DE90DD03C4300p0",
    "0x0.002E1160F60C888084p0", "0x0.002EA4D9332CABCFB0p0", "0x0.002F3851C530D70E68p0", "0x0.002FCBCAAC193B1AB0p0", "0x0.00305F43E7E608D2ACp0", "0x0.0030F2BD7897711494p0", "0x0.003186375E2DA4BEC4p0", "0x0.003219B198A8D4AFB0p0",
    "0x0.0032AD2C280931C5ECp0", "0x0.003340A70C4EECE020p0", "0x0.0033D422457A36DD1Cp0", "0x0.0034679DD38B409BBCp0", "0x0.0034FB19B6823AFB0Cp0", "0x0.00358E95EE5F56DA24p0", "0x0.003622127B22C51840p0", "0x0.0036B58F5CCCB694B4p0",
    "0x0.0037490C935D5C2EF8p0", "0x0.0037DC8A1ED4E6C690p0", "0x0.00387007FF33873B30p0", "0x0.0039038634796E6C9Cp0", "0x0.00399704BEA6CD3AB4p0", "0x0.003A2A839DBBD48578p0", "0x0.003ABE02D1B8B52D04p0", "0x0.003B51825A9DA01190p0",
    "0x0.003BE502386AC6136Cp0", "0x0.003C78826B2058130Cp0", "0x0.003D0C02F2BE86F0F8p0", "0x0.003D9F83CF45838DD8p0", "0x0.003E330500B57ECA74p0", "0x0.003EC686870EA987A4p0", "0x0.003F5A08625134A66Cp0", "0x0.003FED8A927D5107E4p0",
    "0x0.0040810D17932F8D38p0", "0x0.0041148FF1930117C0p0", "0x0.0041A813207CF688E8p0", "0x0.00423B96A45140C234p0", "0x0.0042CF1A7D1010A550p0", "0x0.0043629EAAB99713F8p0", "0x0.0043F6232D4E04F00Cp0", "0x0.004489A804CD8B1B80p0",
    "0x0.00451D2D31385A7870p0", "0x0.0045B0B2B28EA3E90Cp0", "0x0.0046443888D0984FA0p0", "0x0.0046D7BEB3FE688E98p0", "0x0.00476B453418458878p0", "0x0.0047FECC091E601FE4p0", "0x0.004892533310E93798p0", "0x0.004925DAB1F011B270p0"
   };
   ap_ufixed<61,-9> exp_x_msb_ind_3_m_1 = exp_x_msb_ind_3_m_1_table[x_msb_ind_3];
   ap_ufixed<115,-25> f_x_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_3_m_1 * exp_x_msb_ind_4_lsb_ind_m_1;
   ap_ufixed<59,-9> exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_3_m_1 + exp_x_msb_ind_4_lsb_ind_m_1;
   const static ap_ufixed<67,-1> exp_x_msb_ind_2_m_1_table[256] = {
    "0x0.0p0", "0x0.0049B96285BC0A736p0", "0x0.009388004BE7E5593p0", "0x0.00DD6BDF6FC8EDEABp0", "0x0.01276506106747AA4p0", "0x0.0171737A4E8E5E346p0", "0x0.01BB97424CCD67360p0", "0x0.0205D0642F77E4885p0",
    "0x.02501EE61CA62671Ep0", "0x0.029A82CE3C35CE0DBp0", "0x0.02E4FC22B7CA4FD73p0", "0x0.032F8AE9BACD765C6p0", "0x0.037A2F29726FE5154p0", "0x0.03C4E8E80DA99B612p0", "0x0.040FB82BBD3A77A9Ap0", "0x0.045A9CFAB3AABAAB4p0",
    "0x.04A5975B254B8AE40p0", "0x0.04F0A75348377827Fp0", "0x0.053BCCE95452FF5B2p0", "0x0.05870823834D0E520p0", "0x0.05D25908109F87D7Ap0", "0x0.061DBF9D398FC7D9Dp0", "0x0.06693BE93D2F27BB7p0", "0x0.06B4CDF25C5B82CCDp0",
    "0x.070075BED9BFBAEA4p0", "0x0.074C3354F9D43D40Ap0", "0x0.079806BB02DF8738Ap0", "0x0.07E3EFF73CF6AB87Ap0", "0x0.082FEF0FF1FDD767Bp0", "0x0.087C040B6DA8D7F50p0", "0x0.08C82EEFFD7B9FB28p0", "0x0.09146FC3F0CACC34Cp0",
    "0x.0960C68D98BC2BF2Ep0", "0x0.09AD33534847443EAp0", "0x0.09F9B61B5435D762Cp0", "0x0.0A464EEC13246AE7Ep0", "0x0.0A92FDCBDD82CE006p0", "0x0.0ADFC2C10D94A01AAp0", "0x0.0B2C9DD1FF71D79A4p0", "0x0.0B798F05110748B7Fp0",
    "0x.0BC69660A2172C887p0", "0x0.0C13B3EB1439A82A1p0", "0x0.0C60E7AACADD54194p0", "0x0.0CAE31A62B47C3AC7p0", "0x0.0CFB91E39C960CB66p0", "0x0.0D49086987BD4F4FEp0", "0x0.0D96953E578B3DC88p0", "0x0.0DE4386878A6A4BEAp0",
    "0x.0E31F1EE598FF35E7p0", "0x0.0E7FC1D66AA1C3C87p0", "0x0.0ECDA8271E11639EAp0", "0x0.0F1BA4E6E7EF5CBA0p0", "0x0.0F69B81C3E27FE069p0", "0x0.0FB7E1CD9883E4871p0", "0x0.1006220170A884803p0", "0x0.105478BE4218B2CB7p0",
    "0x.10A2E60A8A352E513p0", "0x0.10F169ECC83D29AA6p0", "0x0.1140046B7D4ED4EA6p0", "0x0.118EB58D2C67E78FCp0", "0x0.11DD7D585A662A9D7p0", "0x0.122C5BD38E0802DB1p0", "0x0.127B51054FECFB3DBp0", "0x0.12CA5CF42A964F780p0",
    "0x.13197FA6AA6776B28p0", "0x0.1368B9235DA6AE6BAp0", "0x0.13B80970D47D85804p0", "0x0.14077095A0F9675B6p0", "0x0.1456EE98570C274EEp0", "0x0.14A6837F8C8C8C138p0", "0x0.14F62F51D936DB71Dp0", "0x0.1545F215D6AD6612Fp0",
    "0x.1595CBD2207913796p0", "0x0.15E5BC8D5409EE22Bp0", "0x0.1635C44E10B7AFD11p0", "0x0.1685E31AF7C24DFD9p0", "0x0.16D618FAAC528672Ap0", "0x0.172665F3D37A6C0F3p0", "0x0.1776CA0D1435F3B24p0", "0x0.17C7454D176B814F4p0",
    "0x.1817D7BA87EC752AAp0", "0x0.1868815C1275B93F8p0", "0x0.18B9423865B04ECDCp0", "0x0.190A1A563231DC114p0", "0x0.195B09BC2A7D3A217p0", "0x0.19AC1071030302FA1p0", "0x0.19FD2E7B72221FACBp0", "0x0.1A4E63E2302856BB6p0",
    "0x.1A9FB0ABF752DA9BEp0", "0x0.1AF114DF83CED8647p0", "0x0.1B42908393BA06A18p0", "0x0.1B94239EE72334542p0", "0x0.1BE5CE38400AD81A5p0", "0x0.1C37905662639F7FEp0", "0x0.1C896A001412FE793p0", "0x0.1CDB5B3C1CF1BF06Bp0",
    "0x.1D2D641146CC91022p0", "0x0.1D7F84865D649A153p0", "0x0.1DD1BCA22E7005D96p0", "0x0.1E240C6B899A96219p0", "0x0.1E7673E94086336D2p0", "0x0.1EC8F32226CB7D849p0", "0x0.1F1B8A1D11FA5C3FAp0", "0x0.1F6E38E0D99A9075Cp0",
    "0x.1FC0FF74572C45177p0", "0x0.2013DDDE6628A071Cp0", "0x0.2066D425E402559C1p0", "0x0.20B9E251B026360EFp0", "0x0.210D0868ABFBC3658p0", "0x0.21604671BAE5C1485p0", "0x0.21B39C73C242C7830p0", "0x0.22070A75A96DD4433p0",
    "0x.225A907E59BEDE81Cp0", "0x0.22AE2E94BE8B6896Ap0", "0x0.2301E4BFC52712F67p0", "0x0.2355B3065CE42F1A7p0", "0x0.23A9996F77145292Cp0", "0x0.23FD98020708EA434p0", "0x0.2451AEC50213CDCA7p0", "0x0.24A5DDBF5F87D312Ep0",
    "0x.24FA24F818B9620F7p0", "0x0.254E847628FF08A1Bp0", "0x0.25A2FC408DB20EAB1p0", "0x0.25F78C5E462F0A48Bp0", "0x0.264C34D653D67439Bp0", "0x0.26A0F5AFBA0D3C70Bp0", "0x0.26F5CEF17E3D5ECF9p0", "0x0.274AC0A2A7D6780E4p0",
    "0x.279FCACA404E5ACCBp0", "0x0.27F4ED6F5321A4CF5p0", "0x0.284A2898EDD45466Ap0", "0x0.289F7C4E1FF25E01Ep0", "0x0.28F4E895FB1041ECEp0", "0x0.294A6D7792CBA238Bp0", "0x0.29A00AF9FCCBD8CFCp0", "0x0.29F5C12450C28DB50p0",
    "0x.2A4B8FFDA86C4D6E8p0", "0x0.2AA1778D1F911F9B4p0", "0x0.2AF777D9D4051DB44p0", "0x0.2B4D90EAE5A909F93p0", "0x0.2BA3C2C7766AE6888p0", "0x0.2BFA0D76AA468CA2Fp0", "0x0.2C5070FFA746441ACp0", "0x0.2CA6ED6995835AEE4p0",
    "0x.2CFD82BB9F26BD0EAp0", "0x0.2D5430FCF0698C518p0", "0x0.2DAAF834B795B88F5p0", "0x0.2E01D86A250697ECCp0", "0x0.2E58D1A46B297F504p0", "0x0.2EAFE3EABE7E5B03Bp0", "0x0.2F070F44559847819p0", "0x0.2F5E53B8691E2A6E5p0",
    "0x.2FB5B14E33CB4BBE3p0", "0x0.300D280CF26FEF065p0", "0x0.3064B7FBE3F1ECFAEp0", "0x0.30BC6122494D4D18Bp0", "0x0.311423876594DF7B7p0", "0x0.316BFF327DF2D6E06p0", "0x0.31C3F42AD9A962D4Ep0", "0x0.321C0277C2134A11Dp0",
    "0x.32742A2082A485035p0", "0x0.32CC6B2C68EAD87CAp0", "0x0.3324C5A2C48E70995p0", "0x0.337D398AE7527BCA2p0", "0x0.33D5C6EC2515C60F8p0", "0x0.342E6DCDD3D3545FDp0", "0x0.34872E374BA3003AFp0", "0x0.34E0082FE6BA136ADp0",
    "0x.3538FBBF016BE3F00p0", "0x0.359208EBFA2A701C4p0", "0x0.35EB2FBE3186FAD90p0", "0x0.3644703D0A32A81BDp0", "0x0.369DCA6FE8FF1986Fp0", "0x0.36F73E5E34DF0B37Bp0", "0x0.3750CC0F56E6F0C1Ep0", "0x0.37AA738ABA4D92580p0",
    "0x.380434D7CC6CAA213p0", "0x0.385E0FFDFCC181BC3p0", "0x0.38B80504BCED8FF00p0", "0x0.391213F380B716895p0", "0x0.396C3CD1BE09C0665p0", "0x0.39C67FA6ECF73FAF1p0", "0x0.3A20DC7A87B7EC3C5p0", "0x0.3A7B53540AAB622AFp0",
    "0x.3AD5E43AF459209E5p0", "0x0.3B308F36C57128AF1p0", "0x0.3B8B544F00CC9C88Ap0", "0x0.3BE6338B2B6E5EB41p0", "0x0.3C412CF2CC83B1910p0", "0x0.3C9C408D6D64D6FC5p0", "0x0.3CF76E629995B0251p0", "0x0.3D52B679DEC65D8F1p0",
    "0x.3DAE18DACCD3DF440p0", "0x0.3E09958CF5C8B5321p0", "0x0.3E652C97EDDD7FB9Bp0", "0x0.3EC0DE034B79A0686p0", "0x0.3F1CA9D6A733DAE2Ep0", "0x0.3F7890199BD2F5FCFp0", "0x0.3FD490D3C64E5D001p0", "0x0.4030AC0CC5CEC11FFp0",
    "0x.408CE1CC3BAEBB1E6p0", "0x0.40E93219CB7B6D1CCp0", "0x0.41459CFD1AF5249CFp0", "0x0.41A2227DD20FFCB02p0", "0x0.41FEC2A39AF480553p0", "0x0.425B7D7622004D04Dp0", "0x0.42B852FD15C6B56D6p0", "0x0.431543402711645D2p0",
    "0x.43724E4708E0FFDB7p0", "0x0.43CF7419706DCC711p0", "0x0.442CB4BF1528509F4p0", "0x0.448A103FB0B9F8866p0", "0x0.44E786A2FF05B9BB0p0", "0x0.454517F0BE28B74ACp0", "0x0.45A2C430AE7AE5F03p0", "0x0.46008B6A928FB075Ep0",
    "0x.465E6DA62F369C48Ep0", "0x0.46BC6AEB4B7BEE3AAp0", "0x0.471A8341B0A94F727p0", "0x0.4778B6B12A46728E1p0", "0x0.47D705418619B8F25p0", "0x0.48356EFA9428D84B1p0", "0x0.4893F3E426B9803ABp0", "0x0.48F2940612520039Ap0",
    "0x.49514F682DB9EDA59p0", "0x0.49B0261251FACA004p0", "0x0.4A0F180C5A60A95E7p0", "0x0.4A6E255E247AD906Ap0", "0x0.4ACD4E0F901C863FEp0", "0x0.4B2C92287F5D65507p0", "0x0.4B8BF1B0D69A58AD0p0", "0x0.4BEB6CB07C7618574p0",
    "0x.4C4B032F59D9D96D8p0", "0x0.4CAAB53559F5F5E9Fp0", "0x0.4D0A82CA6A429492Bp0", "0x0.4D6A6BF67A8051199p0", "0x0.4DCA70C17CB8E46D2p0", "0x0.4E2A9133653FCD395p0", "0x0.4E8ACD542AB2F8995p0", "0x0.4EEB252BC5FB6AF99p0",
    "0x.4F4B98C2324DE92ACp0", "0x0.4FAC281F6D2BA1A4Fp0", "0x0.500CD34B7662D5FC3p0", "0x0.506D9A4E500F84855p0", "0x0.50CE7D2FFE9C122BEp0", "0x0.512F7BF888C1F4791p0", "0x0.519096AFF78A5BCB5p0", "0x0.51F1CD5E564EDDBF2p0",
    "0x.5253200BB2BA1FC90p0", "0x0.52B48EC01CC882005p0", "0x0.53161983A6C8CA1BBp0", "0x0.5377C05E655CCE9E1p0", "0x0.53D983586F7A2235Ep0", "0x0.543B6279DE6ABF4CAp0", "0x0.549D5DCACDCDB3C8Dp0", "0x0.54FF75535B97CD007p0"
   };
   ap_ufixed<67,-1> exp_x_msb_ind_2_m_1 = exp_x_msb_ind_2_m_1_table[x_msb_ind_2];
   ap_ufixed<126,-10> f_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_2_m_1 * exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   ap_ufixed<65,-1> exp_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind_m_1 = f_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_2_m_1 + exp_x_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   const static ap_ufixed<66,32> exp_x_msb_ind_1_table[256] = {
    "0x1.000000000p0", "0x1.5561A91BCp0", "0x1.C73D51C54p0", "0x2.5F1258E08p0", "0x3.298B075B4p0", "0x4.378B053ECp0", "0x5.9F9802C8Cp0", "0x7.7FBAAB458p0",
    "0xA.000000000p0", "0xD.55D09B148p0", "0x11.C86531B4Cp0", "0x17.B6B778C40p0", "0x1F.9F6E49910p0", "0x2A.2B6E34724p0", "0x38.3BF01BD84p0", "0x4A.FD4AB0B64p0",
    "0x64.000000000p0", "0x85.5A260ECDCp0", "0xB1.D3F3F10ECp0", "0xED.232AB7A90p0", "0x13C.3A4EDFA98p0", "0x1A5.B24E0C774p0", "0x232.57611671Cp0", "0x2ED.E4EAE71ECp0",
    "0x3E8.000000000p0", "0x535.857C94088p0", "0x6F2.47876A934p0", "0x943.5FAB2C9B4p0", "0xC5A.4714BC9E8p0", "0x1078.F70C7CA94p0", "0x15F7.69CAE0728p0", "0x1D4A.F12D0732Cp0",
    "0x2710.000000000p0", "0x3417.36DDC8558p0", "0x4576.CB4A29C18p0", "0x5CA1.BCAFBE0F8p0", "0x7B86.C6CF5E320p0", "0xA4B9.A67CDE9B4p0", "0xDBAA.21ECC4790p0", "0x124ED.6BC247FB8p0",
    "0x186A0.000000000p0", "0x208E8.24A9D3580p0", "0x2B6A3.F0E5A18ECp0", "0x39E51.5EDD6C9A0p0", "0x4D343.C419ADF30p0", "0x66F40.80E0B210Cp0", "0x894A5.533FACBA4p0", "0xB7146.3596CFD3Cp0",
    "0xF4240.000000000p0", "0x145911.6EA2416F4p0", "0x1B2267.68F84F938p0", "0x242F2D.B4A63E038p0", "0x3040A5.A900CB7F0p0", "0x405885.08C6F4A64p0", "0x55CE75.407CBF46Cp0", "0x726CBE.17E41E45Cp0",
    "0x989680.000000000p0", "0xCB7AAE.52568E584p0", "0x10F580A.19B31BC34p0", "0x169D7C9.0E7E6C220p0", "0x1E28678.9A07F2F6Cp0", "0x2837532.57C58E7F0p0", "0x35A1094.84DF78C38p0", "0x4783F6C.EEE92EB90p0",
    "0x5F5E100.000000000p0", "0x7F2CACF.37618F720p0", "0xA997065.00FF159FCp0", "0xE226DDA.90F039530p0", "0x12D940B6.044F7DA48p0", "0x192293F7.6DB790F54p0", "0x2184A5CD.30BAB7A30p0", "0x2CB27A41.551BD339Cp0",
    "0x3B9ACA00.000000000p0", "0x4F7BEC18.29CF9A750p0", "0x69FE63F2.09F6D83E4p0", "0x8D584A89.A9623D3E0p0", "0xBC7C871C.2B1AE86C4p0", "0xFB59C7AA.492BA9948p0", "0x14F2E7A03.E74B2C5F4p0", "0x1BEF8C68D.531640404p0",
    "0x2540BE400.000000000p0", "0x31AD738F1.A21C08914p0", "0x423EFE774.63A4726F4p0", "0x58572E960.9DD6646C4p0", "0x75CDD4719.AF0D143A8p0", "0x9D181CCA6.DBB49FCD0p0", "0xD17D0C427.08EFBBB80p0", "0x1175B7C185.3EDE8282Cp0",
    "0x174876E800.000000000p0", "0x1F0C683970.551855AD0p0", "0x29675F0A8B.E46C78594p0", "0x37367D1DC6.2A5FEC3A0p0", "0x49A0A4C700.D682CA49Cp0", "0x622F11FE84.950E3E020p0", "0x82EE27A986.595D55300p0", "0xAE992D8F34.74B1191B8p0",
    "0xE8D4A51000.000000000p0", "0x1367C123E63.52F358C14p0", "0x19E09B66976.EC3CB37C0p0", "0x22820E329BD.A7BF3A448p0", "0x2E0466FC608.611BE6E18p0", "0x3D5D6B3F12D.D28E6C148p0", "0x51D4D8C9F3F.7DA553E00p0", "0x6D1FBC7980C.8EEAFB130p0",
    "0x9184E72A000.000000000p0", "0xC20D8B66FE1.3D81778C0p0", "0x102C61201EA5.3A5F02D70p0", "0x159148DFA168.8D7846AE0p0", "0x1CC2C05DBC53.CB1704CFCp0", "0x265A63076BCA.399038CD8p0", "0x3325077E387A.E87546BF0p0", "0x4433D5CBF07D.952DCEBE8p0",
    "0x5AF3107A4000.000000000p0", "0x794877205ECC.670EAB770p0", "0xA1BBCB413274.47B61C654p0", "0xD7ACD8BC4E15.86B2C2CC0p0", "0x11F9B83A95B45.EEE6301D8p0", "0x17F87DE4A35E6.3FA238074p0", "0x1FF724AEE34CD.1494C3758p0", "0x2AA0659F764E7.D3CA13714p0",
    "0x38D7EA4C68000.000000000p0", "0x4BCD4A743B3FC.0692B2A70p0", "0x65155F08BF88A.CD1D1BF4Cp0", "0x86CC0775B0CD7.42FB9BF90p0", "0xB3C13249D90BB.54FDE1260p0", "0xEFB4EAEE61AFE.7C563047Cp0", "0x13FA76ED4E1002.CDCFA296Cp0", "0x1AA43F83A9F10E.45E4C26DCp0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0",
    "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x0.0p0", "0x.000000004p0", "0x.000000004p0", "0x.000000004p0", "0x.000000004p0",
    "0x0.000000008p0", "0x.000000008p0", "0x.00000000Cp0", "0x.000000010p0", "0x.000000014p0", "0x.00000001Cp0", "0x.000000028p0", "0x.000000034p0",
    "0x0.000000044p0", "0x.00000005Cp0", "0x.00000007Cp0", "0x.0000000A4p0", "0x.0000000D8p0", "0x.000000120p0", "0x.000000184p0", "0x.000000204p0",
    "0x0.0000002B0p0", "0x.000000394p0", "0x.0000004C8p0", "0x.00000065Cp0", "0x.00000087Cp0", "0x.000000B50p0", "0x.000000F18p0", "0x.000001420p0",
    "0x0.000001AD8p0", "0x.0000023CCp0", "0x.000002FBCp0", "0x.000003FA8p0", "0x.0000054E4p0", "0x.000007134p0", "0x.0000096F4p0", "0x.00000C94Cp0",
    "0x0.000010C70p0", "0x.0000165F8p0", "0x.00001DD5Cp0", "0x.000027C90p0", "0x.0000350E0p0", "0x.000046BFCp0", "0x.00005E588p0", "0x.00007DCFCp0",
    "0x0.0000A7C5Cp0", "0x.0000DFBA4p0", "0x.00012A588p0", "0x.00018DD9Cp0", "0x.0002128ACp0", "0x.0002C37D4p0", "0x.0003AF73Cp0", "0x.0004EA1D0p0",
    "0x0.00068DB8Cp0", "0x.0008BD470p0", "0x.000BA7754p0", "0x.000F8A814p0", "0x.0014B96C0p0", "0x.001BA2E4Cp0", "0x.0024DA858p0", "0x.003125230p0",
    "0x0.004189374p0", "0x.005764C70p0", "0x.00748A940p0", "0x.009B690C8p0", "0x.00CF3E374p0", "0x.01145CEF0p0", "0x.017089380p0", "0x.01EB735F0p0",
    "0x0.028F5C290p0", "0x.0369EFC58p0", "0x.048D69C70p0", "0x.06121A7D0p0", "0x.08186E274p0", "0x.0ACBA1550p0", "0x.0E655C300p0", "0x.133281B68p0",
    "0x0.199999998p0", "0x.22235DB60p0", "0x.2D8621C70p0", "0x.3CB508E34p0", "0x.50F44D894p0", "0x.6BF44D530p0", "0x.8FF599E10p0", "0x.BFF911208p0"
   };
   ap_ufixed<66,32> exp_x_msb_ind_1 = exp_x_msb_ind_1_table[x_msb_ind_1];
   ap_ufixed<131,31> f_x_msb_ind_1_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind = exp_x_msb_ind_1 * exp_x_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind_m_1;
   y = f_x_msb_ind_1_msb_ind_2_msb_ind_3_msb_ind_4_lsb_ind + exp_x_msb_ind_1;
  }
  if(I_<33) {
   bool overf = 0;
   VITIS_LOOP_3430_17: for(int j = 63; j >= 31 + I_; j--) {
#pragma HLS unroll
 if(y[j]) {
     overf = 1;
    }
   }
   if(overf) {
    VITIS_LOOP_3437_18: for(int j = 63; j >= 31 + I_; j--) {
#pragma HLS unroll
 y[j] = 0;
    }
    VITIS_LOOP_3441_19: for(int j = 30 + I_; j >= 0; j--) {
#pragma HLS unroll
 y[j] = 1;
    }
   }
  }
  r = y;
 }
 return r;
}

template<int W, int I>
ap_ufixed<W,I> exp10(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return exp10(xf);
}

template<int I>
ap_int<I> exp10(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return exp10(xf);
}

template<int I>
ap_uint<I> exp10(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return exp10(xf);
}

}
# 1068 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_log_apfixed.h" 1
# 39 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_log_apfixed.h"
namespace log_apfixed_reduce {


template <typename T, int p, int alpha, int size> class log_lut_table { public:
log_lut_table<T,p,alpha,size>();
static const T array [size];};
template <> class log_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};

template <> class log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <typename T, int p, int alpha, int size> class log0_lut_table { public:
log0_lut_table<T,p,alpha,size>();
static const T array[size];};
template <> class log0_lut_table<ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();

static const ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

class log_inverse_lut_table { public:
log_inverse_lut_table();
static const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array[64];};


template <typename LOG_TYPE, int p, int alpha, int size, int sizeout>
void range_reduce(ap_ufixed<size, -p> zN, LOG_TYPE &log, ap_ufixed<sizeout, -(p+alpha-1)> &zN1)
{

    const int T1size = 1 << alpha;




    ap_ufixed<alpha, -p> a = zN;
    ap_ufixed<size-alpha, -p-alpha> b = zN;
    ap_ufixed<size+p+2*p+1, 1> zNext = 1+zN;
    int e_shift = (p!=4 || a[a.wl()-1]==1) ? 2*p : 2*p+1;
    ap_ufixed<size+p+1, 1-2*p> eZ = zNext >> e_shift;

    zN1 = ((b + eZ) - a*zN);
    ap_uint<alpha> index = a(alpha-1,0);
    log = log_lut_table<LOG_TYPE, p,alpha,T1size>::array[index];


}




const int p0 = 0;
const int alpha0 = 5;
const int p1 = (alpha0 == 5) ? 4 : (alpha0-2);
const int alpha1 = 4;
const int p2 = p1 + alpha1 - 1;
const int alpha2 = 6;
const int p3 = p2 + alpha2 - 1;
const int alpha3 = 6;
const int p4 = p3 + alpha3 - 1;
const int alpha4 = 6;
const int p5 = p4 + alpha4 - 1;
const int alpha5 = 6;
const int p6 = p5 + alpha5 - 1;
const int alpha6 = 6;
const int p7 = p6 + alpha6 - 1;
const int alpha7 = 6;
const int p8 = p7 + alpha7 - 1;

template <int W_s_> class log_traits{};

template <>
class log_traits<1>{
public:
    const static int we = 6;
    const static int wf = 11;
    const static int org_wf = wf;

    const static int gbits = 1;
    const static int p_generic = p1;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        (void)(log_sum);
        return z1;
    }
};

template <>
class log_traits<2>{
public:
    const static int we = 6;
    const static int wf = 19;
    const static int org_wf = wf;

    const static int gbits = 2;
    const static int p_generic = p2;
    const static int MaxPrecision =wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        return z2;
    }
};

template <>
class log_traits<3>{
public:
    const static int we = 6;
    const static int wf = 33;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p3;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        return z3;
    }
};

template <>
class log_traits<4>{
public:
    const static int we = 6;
    const static int wf = 48;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p4;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        return z4;
    }
};

template <>
class log_traits<5>{
public:
    const static int we = 6;
    const static int wf = 63;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p5;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        return z5;
    }
};

template <>
class log_traits<6>{
public:
    const static int we = 6;
    const static int wf = 76;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p6;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        return z6;
    }
};

template <>
class log_traits<7>{
public:
    const static int we = 6;
    const static int wf = 91;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p7;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        return z7;
    }
};

template <>
class log_traits<8>{
public:
    const static int we = 6;
    const static int wf = 106;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p8;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);
    const static int w8 = w7+2*p7+1-(alpha7-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        ap_ufixed<(w8 < MaxPrecision-p8) ? w8 : (MaxPrecision-p8), -p8> z8;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        range_reduce<LOG_TYPE, p7, alpha7> (z7, logn, z8);
        log_sum += logn;
        return z8;
    }
};
template<int W_, int I_>
ap_fixed<W_,I_> log(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
    if (I_>34) return 0;
    else if (F_>100) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=7) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else r = 4;
        } else if (I_<=10) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else r = 6;
        } else if (I_<=13) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else r = 8;
        } else if (I_<=17) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else r = 11;
        } else if (I_<=19) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else r = 12;
        } else if (I_<=26) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else r = 17;
        } else if (I_<=32) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x25fad90p0")) r = 17;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x673d70bp0")) r = 18;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x118a2aaep0")) r = 19;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2fad89e1p0")) r = 20;
            else r = 21;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x25fad90p0")) r = 17;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x673d70bp0")) r = 18;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x118a2aaep0")) r = 19;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2fad89e1p0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x819a1801p0")) r = 21;
            else r = 22;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x2.cp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x2.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x1.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x1.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x0.dp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x0.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.9p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.ap0")) r = "-0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "-0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.cp0")) r = "-0x0.5p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.dp0")) r = "-0x0.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.ep0")) r = "-0x0.2p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.fp0")) r = "-0x0.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1p0")) r = "0x0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.2p0")) r = "0x0.2p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.8p0")) r = "0x0.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.9p0")) r = "0x0.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.bp0")) r = "0x0.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.cp0")) r = "0x0.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ep0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = "0x0.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.7p0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.ap0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.cp0")) r = "0x1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.9p0")) r = "0x1.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.dp0")) r = "0x1.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.1p0")) r = "0x1.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.5p0")) r = "0x1.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.9p0")) r = "0x1.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ep0")) r = "0x1.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x1.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.9p0")) r = "0x1.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.ep0")) r = "0x1.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.5p0")) r = "0x1.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.bp0")) r = "0x1.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.2p0")) r = "0x1.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.9p0")) r = "0x2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.1p0")) r = "0x2.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.ap0")) r = "0x2.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.3p0")) r = "0x2.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.cp0")) r = "0x2.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.6p0")) r = "0x2.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.1p0")) r = "0x2.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.cp0")) r = "0x2.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.9p0")) r = "0x2.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.6p0")) r = "0x2.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.3p0")) r = "0x2.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.2p0")) r = "0x2.bp0";
            else r = "0x2.cp0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {


            const static int W_s_ = (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;
# 717 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_log_apfixed.h"
            const static int wf = log_traits<W_s_>::wf;
            const static int I_s= I_>0? I_:-I_;
            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;




            ap_int<7> b_exp;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
            VITIS_LOOP_729_1: for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
#pragma HLS unroll
 if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }



            const ap_ufixed<MaxPrecision,0> LOG2 = "0x0.B17217F7D1CF79ABC9E3B39803p0";
            ap_fixed<MaxPrecision,6> Elog2 = LOG2 * b_exp;



            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;


            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];


            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;





            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;


            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);


            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base;
            log_base = Elog2 + log_sum + sum;



            ap_fixed<2 + F_, 1> delta = 0;
            delta[delta.wl()-1] = log_base[log_base.wl()-1];
            delta[delta.wl()-delta.iwl()-1] = 1;
            log_base = log_base + ( delta >> F_ );

            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log(xf);
}

template<int I_>
ap_int<I_> log(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log(xf);
}

template<int I_>
ap_uint<I_> log(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> log10(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=9) {
            if (x<=0) {r[W_-1] = 1;}
            else {
                ap_ufixed<8,8> x_s_l = x_s;
                if (x_s_l(7,2)==0) r = 0;
                else if (x_s_l(7,5)==0) r = 1;
                else r = 2;
            }
        } else if (I_<=15) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else r = 4;
        } else if (I_<=19) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else r = 5;
        } else if (I_<=25) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else r = 7;
        } else if (I_<=32) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e28678p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x12d940b6p0")) r = 8;
            else r = 9;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e28678p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x12d940b6p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xbc7c871cp0")) r = 9;
            else r = 10;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x0.ep0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x0.cp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x0.ap0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x0.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x0.5p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "-0x0.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.cp0")) r = "-0x0.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.ep0")) r = "-0x0.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ap0")) r = "0x0.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ep0")) r = "0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.3p0")) r = "0x0.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x0.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x0.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x0.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ep0")) r = "0x0.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.8p0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x0.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.fp0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8p0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.4p0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.bp0")) r = "0x1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.6p0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.5p0")) r = "0x1.2p0";
            else r = "0x1.3p0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {
            const static int W_s_= (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;






            const static int wf = log_traits<W_s_>::wf;
            const static int I_s= I_>0? I_:-I_;
            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;





            ap_int<7> b_exp=0;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
            VITIS_LOOP_947_1: for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
#pragma HLS unroll
 if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }

            const ap_ufixed<25,0> LOG1_35_s = 0.3010300099849700927734375;
            const ap_ufixed<43,0> LOG1_35_l = 0.30102999566395283181918784976006;
            ap_fixed<30,5> Elog2_s = LOG1_35_s * b_exp;
            ap_fixed<48,5> Elog2_l = LOG1_35_l * b_exp;


            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;

            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];

            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;




            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;

            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);

            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base = log_sum + sum;

            const ap_ufixed<25,0> LOG1_54_s = 0.4342944920063018798828125;
            const ap_ufixed<43,0> LOG1_54_l = 0.43429448190329367207596078515053;

            if (F_<=16) log_base = Elog2_s + log_base * LOG1_54_s;
            else log_base = Elog2_l + log_base * LOG1_54_l;
# 1005 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_log_apfixed.h"
            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log10(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log10(xf);
}

template<int I_>
ap_int<I_> log10(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log10(xf);
}

template<int I_>
ap_uint<I_> log10(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log10(xf);
}

template<int W, int I>
ap_fixed<W,I> log1p(ap_fixed<W,I> x) {
    ap_ufixed<1,1> inc = 1;
    ap_fixed<W+1,I+1> xp1 = x + inc;
    return log(xp1);
}

template<int W, int I>
ap_ufixed<W,I> log1p(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return log1p(xf);
}

template<int I>
ap_int<I> log1p(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return log1p(xf);
}

template<int I>
ap_uint<I> log1p(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return log1p(xf);
}

template<int W,int I>
ap_fixed<W,I> ilogb(ap_fixed<W,I> x) {
    int F = W - I;
    if(F>32 || I>33) {
        return 0;
    }
    ap_fixed<W+1,I+1> xf;
    if(x>0) {
        xf = x;
    }
    else {
        xf = -x;
    }
    return I + 1 - xf.countLeadingZeros() - 1;
}

template<int W,int I>
ap_ufixed<W,I> ilogb(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return ilogb(xf);
}

template<int I>
ap_int<I> ilogb(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return ilogb(xf);
}

template<int I>
ap_uint<I> ilogb(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return ilogb(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> log2(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const static int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
            else r = 4;
  } else if (I_<=9) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
            else r = 8;
        } else if (I_<=13) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
            else r = 12;
  } else if (I_<=17) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
            else r = 16;
        } else if (I_<=21) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
            else r = 20;
        } else if (I_<=25) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
            else r = 24;
        } else if (I_<=29) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E6p0")) r = 24;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCp0")) r = 25;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82799p0")) r = 26;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F33p0")) r = 27;
            else r = 28;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = 1;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5p0")) r = 2;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xBp0")) r = 3;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2Dp0")) r = 5;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5Ap0")) r = 6;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB5p0")) r = 7;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16Ap0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D4p0")) r = 9;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8p0")) r = 10;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB50p0")) r = 11;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A0p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D41p0")) r = 13;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82p0")) r = 14;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504p0")) r = 15;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09p0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413p0")) r = 17;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827p0")) r = 18;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504Fp0")) r = 19;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09Ep0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413Cp0")) r = 21;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A8279p0")) r = 22;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F3p0")) r = 23;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E6p0")) r = 24;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCp0")) r = 25;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A82799p0")) r = 26;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F33p0")) r = 27;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x16A09E66p0")) r = 28;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2D413CCCp0")) r = 29;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5A827999p0")) r = 30;
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB504F333p0")) r = 31;
            else r = 32;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x4.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x3.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x2.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x2.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x1.Bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x1.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x1.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.Dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.Ap0")) r = "-0x0.Bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Bp0")) r = "-0x0.9p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Cp0")) r = "-0x0.7p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Dp0")) r = "-0x0.5p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Ep0")) r = "-0x0.3p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.Fp0")) r = "-0x0.1p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.0p0")) r = "0x0.0p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0.1p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.2p0")) r = "0x0.3p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.4p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.4p0")) r = "0x0.5p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x0.6p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.7p0";
   else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.7p0")) r = "0x0.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.8p0")) r = "0x0.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.9p0")) r = "0x0.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Ap0")) r = "0x0.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Bp0")) r = "0x0.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Cp0")) r = "0x0.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Dp0")) r = "0x0.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.Fp0")) r = "0x0.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.0p0")) r = "0x1.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x1.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.3p0")) r = "0x1.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x1.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.6p0")) r = "0x1.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x1.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Ap0")) r = "0x1.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Cp0")) r = "0x1.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.Ep0")) r = "0x1.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.0p0")) r = "0x1.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.4p0")) r = "0x1.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.9p0")) r = "0x1.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.Bp0")) r = "0x1.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.Ep0")) r = "0x1.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.1p0")) r = "0x2.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.4p0")) r = "0x2.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.7p0")) r = "0x2.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.Ap0")) r = "0x2.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.Dp0")) r = "0x2.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.1p0")) r = "0x2.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.4p0")) r = "0x2.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.8p0")) r = "0x2.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.Cp0")) r = "0x2.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.0p0")) r = "0x2.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.4p0")) r = "0x2.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.9p0")) r = "0x2.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.Dp0")) r = "0x2.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.2p0")) r = "0x2.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.7p0")) r = "0x2.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.Dp0")) r = "0x2.Fp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.2p0")) r = "0x3.0p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.8p0")) r = "0x3.1p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.Ep0")) r = "0x3.2p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.4p0")) r = "0x3.3p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.Bp0")) r = "0x3.4p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xA.2p0")) r = "0x3.5p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xA.9p0")) r = "0x3.6p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB.1p0")) r = "0x3.7p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xB.8p0")) r = "0x3.8p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xC.1p0")) r = "0x3.9p0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xC.9p0")) r = "0x3.Ap0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xD.2p0")) r = "0x3.Bp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xD.Bp0")) r = "0x3.Cp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xE.5p0")) r = "0x3.Dp0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xE.Fp0")) r = "0x3.Ep0";
   else if (x_s<=ap_ufixed<W_-1,I_-1>("0xF.Ap0")) r = "0x3.Fp0";
            else r = "0x4.0p0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {
            const static int W_s_= (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;

            const static int wf = log_traits<W_s_>::wf;
            const static int I_s= I_>0? I_:-I_;
            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;

            ap_int<7> b_exp=0;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
            VITIS_LOOP_1371_1: for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
#pragma HLS unroll
 if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }

            ap_fixed<30,5> Elog2_s = b_exp;
            ap_fixed<48,5> Elog2_l = b_exp;


            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;

            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];

            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;




            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;

            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);

            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base = log_sum + sum;

            const ap_ufixed<26,1> LOG1_54_s = "0x1.7154765p0";
            const ap_ufixed<44,1> LOG1_54_l = "0x1.71547652B82Fp0";

            if (F_<=16) log_base = Elog2_s + log_base * LOG1_54_s;
            else log_base = Elog2_l + log_base * LOG1_54_l;



            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log2(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log2(xf);
}

template<int I_>
ap_int<I_> log2(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log2(xf);
}

template<int I_>
ap_uint<I_> log2(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log2(xf);
}

template<int W_, int I_>
ap_fixed<W_,I_> logb(ap_fixed<W_,I_> x) {
 return log2(x);
}

template<int W_, int I_>
ap_ufixed<W_,I_> logb(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return logb(xf);
}

template<int I_>
ap_int<I_> logb(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return logb(xf);
}

template<int I_>
ap_uint<I_> logb(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return logb(xf);
}

}
# 1069 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_sqrt_apfixed.h" 1
# 34 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_sqrt_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 35 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_sqrt_apfixed.h" 2






template <int W_, int I_>
ap_fixed<W_,I_> sqrt_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


 const int F_ = W_ - I_;
    if (I_>34) return 0;
    else if (F_>32) return 0;


    ap_ufixed<F_+(I_+1)/2,(I_+1)/2> r;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if ((F_==0)&&(I_==2)) {
            r = x_s;
    } else if ((F_==0)&&(I_<=13)) {
        ap_ufixed<W_,I_> x_s_l = x_s + 1;
        ap_ufixed<W_-1,I_-1> x_s_1;
        x_s_1(W_-2,0) = x_s_l(W_-1,1);
        if (I_<=8) {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else r = 11;
        } else if (I_<=9) {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1==ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x42p0")) r = 11;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4ep0")) r = 12;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5bp0")) r = 13;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x69p0")) r = 14;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x78p0")) r = 15;
            else r = 16;
        } else {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1==ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x42p0")) r = 11;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4ep0")) r = 12;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5bp0")) r = 13;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x69p0")) r = 14;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x78p0")) r = 15;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x88p0")) r = 16;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x99p0")) r = 17;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xabp0")) r = 18;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xbep0")) r = 19;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xd2p0")) r = 20;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xe7p0")) r = 21;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfdp0")) r = 22;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x114p0")) r = 23;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x12cp0")) r = 24;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x145p0")) r = 25;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15fp0")) r = 26;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x17ap0")) r = 27;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x196p0")) r = 28;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1b3p0")) r = 29;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1d1p0")) r = 30;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1f0p0")) r = 31;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x210p0")) r = 32;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x231p0")) r = 33;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x253p0")) r = 34;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x276p0")) r = 35;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x29ap0")) r = 36;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2bfp0")) r = 37;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2e5p0")) r = 38;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x30cp0")) r = 39;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x334p0")) r = 40;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x35dp0")) r = 41;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x387p0")) r = 42;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3b2p0")) r = 43;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3dep0")) r = 44;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x40bp0")) r = 45;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x439p0")) r = 46;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x468p0")) r = 47;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x498p0")) r = 48;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4c9p0")) r = 49;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4fbp0")) r = 50;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x52ep0")) r = 51;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x562p0")) r = 52;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x597p0")) r = 53;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5cdp0")) r = 54;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x604p0")) r = 55;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x63cp0")) r = 56;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x675p0")) r = 57;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6afp0")) r = 58;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6eap0")) r = 59;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x726p0")) r = 60;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x763p0")) r = 61;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x7a1p0")) r = 62;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x7e0p0")) r = 63;
            else r = 64;
        }
    } else if (F_<=4 && I_<=5) {
            if (x_s==ap_ufixed<W_-1,I_-1>("0x0.0p0")) r = "0x0.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "0x0.4p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "0x0.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "0x0.9p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "0x0.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.dp0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.fp0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x1.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x1.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.7p0")) r = "0x1.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ap0")) r = "0x1.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.cp0")) r = "0x1.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.fp0")) r = "0x1.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x1.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x1.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x1.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.bp0")) r = "0x1.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x1.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ap0")) r = "0x1.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ep0")) r = "0x1.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.2p0")) r = "0x2.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.6p0")) r = "0x2.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ap0")) r = "0x2.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ep0")) r = "0x2.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x2.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.7p0")) r = "0x2.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.cp0")) r = "0x2.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.1p0")) r = "0x2.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.6p0")) r = "0x2.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.bp0")) r = "0x2.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.0p0")) r = "0x2.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.6p0")) r = "0x2.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.bp0")) r = "0x2.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.1p0")) r = "0x2.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.7p0")) r = "0x2.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.dp0")) r = "0x2.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.3p0")) r = "0x3.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.9p0")) r = "0x3.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.fp0")) r = "0x3.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.5p0")) r = "0x3.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.cp0")) r = "0x3.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.2p0")) r = "0x3.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.9p0")) r = "0x3.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.0p0")) r = "0x3.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.7p0")) r = "0x3.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.ep0")) r = "0x3.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.5p0")) r = "0x3.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.dp0")) r = "0x3.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.4p0")) r = "0x3.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.cp0")) r = "0x3.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.4p0")) r = "0x3.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.cp0")) r = "0x3.fp0";
            else r = "0x4.0p0";
    } else {

        if (x[W_-1]) return 0;
        if (I_<=0) {
            const static int lsbx = (-I_+2<=W_) ? (W_+I_-2) : 0;
            if ( x(W_-1,lsbx) != 0 ) return 0;
        }

        const static int prcs = (F_+1)*2;
        const static int msbr = (I_>0) ? (I_+1)/2 : 1;
        const static int msbx = (I_>0) ? I_+3 : 4;
        const static int msbm = (I_>0) ? I_+1 : 2;


        ap_ufixed<msbx , msbx> x_l_I = x;
        ap_ufixed< prcs/2, 0> x_l_FH = x;
        ap_ufixed< prcs/2, -prcs/2> x_l_FL = 0;
        ap_ufixed<msbr + prcs , msbr> res = 0;
        ap_ufixed<msbr , msbr> res_I = 0;
        ap_ufixed< prcs/2, 0> res_FH = 0;
# 265 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_sqrt_apfixed.h"
    if (I_>0)
        VITIS_LOOP_266_1: for ( int pos = msbr-1; pos >= 0; pos-- ) {
#pragma HLS unroll
 ap_ufixed<msbm , msbm> mul_I = 0;



            mul_I ( msbr+pos , pos*2+1 ) = res_I ( msbr-1 , pos );



            mul_I [ pos*2 ] = 1;




            if ( x_l_I ( msbr+pos+1 , pos*2 ) >= mul_I ( msbr+pos , pos*2 ) ) {



                ap_ufixed<msbx,msbx> x_l_I_ = x_l_I;
                x_l_I ( msbr+pos+1 , pos*2 ) = x_l_I ( msbr+pos+1 , pos*2 ) - mul_I ( msbr+pos , pos*2 );




                res_I [ pos ] = 1;
            }
        }
        VITIS_LOOP_294_2: for ( int pos = -1; pos >= -F_-1; pos-- ) {
#pragma HLS unroll
 ap_ufixed<msbm + prcs , msbm> mul = 0;




            mul ( msbr+pos + prcs , pos +1 + prcs ) = res_I ( msbr-1 , 0 );
            mul ( pos + prcs , pos*2+1 + prcs ) = res_FH ( -1+prcs/2 , pos+prcs/2 );



            mul [ pos*2 + prcs ] = 1;
            ap_ufixed<msbm , msbm> mul_I = mul;
            ap_ufixed< prcs/2, 0> mul_FH = mul;
            ap_ufixed< prcs/2, -prcs/2> mul_FL = mul;

            ap_ufixed<msbx + prcs , msbx> x_l;
            x_l ( -1+msbx + prcs , prcs ) = x_l_I ( -1+msbx , 0 );
            x_l ( -1 + prcs , prcs/2 ) = x_l_FH ( -1+prcs/2 , 0 );
            x_l ( -1 + prcs/2 , 0 ) = x_l_FL ( -1+prcs/2 , 0 );



            if ( (x_l_I>mul_I) || ((x_l_I==mul_I)&&(x_l_FH>mul_FH)) || ((x_l_I==mul_I)&&(x_l_FH==mul_FH)&&(x_l_FL>=mul_FL)) ) {




                ap_ufixed< prcs/2+1 , -prcs/2+1 > x_l_FL_l = x_l_FL;
                if ( x_l_FL < mul_FL ) x_l_FL_l[prcs/2] = 1;
                                                  x_l_FL_l -= mul_FL;




                ap_ufixed< prcs/2+1 , 1 > x_l_FH_l = x_l_FH;
                if ( (x_l_FH<mul_FH)||((x_l_FH==mul_FH)&&(x_l_FL<mul_FL)) ) x_l_FH_l[prcs/2] = 1;
                ap_ufixed< 1 , -prcs/2+1 > delta = 0;
                if ( x_l_FL < mul_FL ) delta[0] = 1;
                                                                             x_l_FH_l -= delta;
                                                                             x_l_FH_l -= mul_FH;



                if ( (x_l_FH<mul_FH)||((x_l_FH==mul_FH)&&(x_l_FL<mul_FL)) ) x_l_I --;
                                                                             x_l_I -= mul_I;

                                                                             x_l_FH = x_l_FH_l;
                                                                             x_l_FL = x_l_FL_l;

                ap_ufixed<msbx + prcs , msbx> x_l_ = x_l;
                x_l ( -1+msbx + prcs , prcs ) = x_l_I ( -1+msbx , 0 );
                x_l ( -1 + prcs , prcs/2 ) = x_l_FH ( -1+prcs/2 , 0 );
                x_l ( -1 + prcs/2 , 0 ) = x_l_FL ( -1+prcs/2 , 0 );



                res_FH [ pos+prcs/2 ] = 1;
            }
        }



        ap_ufixed< prcs/2+1 , 1 > res_FH_l = res_FH;
        ap_ufixed< prcs/2 , 0 > delta;
                                  delta[delta.wl()-1] = 1;
                                  res_FH_l += ( delta >> F_ );
                                  res_FH = res_FH_l;
        if (res_FH_l[prcs/2]) res_I ++;

        res ( msbr-1 + prcs , prcs ) = res_I ( msbr-1 , 0 );
        res ( -1 + prcs , prcs/2 ) = res_FH ( -1+prcs/2 , 0 );

        r = res;
    }

    return r;
}
template<int W_, int I_>
ap_ufixed<W_,I_> sqrt_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return sqrt_fixed(xf);
}
template<int I_>
ap_int<I_> sqrt_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return sqrt_fixed(xf);
}
template<int I_>
ap_uint<I_> sqrt_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return sqrt_fixed(xf);
}


template <int W_, int I_>
ap_fixed<W_,I_> rsqrt_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 ap_ufixed<W_-1,I_-1> xs = x;
    const int Ix = ( I_ > 1 )? I_-1 : 1;
    ap_ufixed<Ix,Ix> xs_I = xs;
    ap_ufixed<W_-1,I_-1> r;
    const int I = ( I_-1 > W_-I_+1 ) ? I_-1 : W_-I_+1;
    ap_ufixed<I+W_-I_,I> y1;
    ap_ufixed<I+W_-I_,I> y2;
    if ( xs == 0 ) {
        return 0;
    } else if ( xs_I != 0 ) {
        y1 = xs;
    } else {
        y1 = 1;
        y1 = y1/xs;
    }
    y2 = sqrt_fixed(y1);
    if ( y2 == 0 ) {
        return 0;
    } else if ( xs_I != 0 ) {
        r = 1;
        r = r/y2;
    } else {
        r = y2;
    }
    return r;
}
template<int W_, int I_>
ap_ufixed<W_,I_> rsqrt_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return rsqrt_fixed(xf);
}
template<int I_>
ap_int<I_> rsqrt_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return rsqrt_fixed(xf);
}
template<int I_>
ap_uint<I_> rsqrt_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return rsqrt_fixed(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> recip_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if ( x == 0 ) return 0;
    ap_fixed<W_,I_> r = 1;
    return r/x;
}
template<int W_, int I_>
ap_ufixed<W_,I_> recip_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return recip_fixed(xf);
}
template<int I_>
ap_int<I_> recip_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return recip_fixed(xf);
}
template<int I_>
ap_uint<I_> recip_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return recip_fixed(xf);
}
# 1070 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_round_copysign_apfixed.h" 1
# 35 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_round_copysign_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 36 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_round_copysign_apfixed.h" 2

template <int W_, int I_>
ap_fixed<W_,I_> ceil_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    } else {
        if(I_<0) return 0;
        else {
           if ( x(W_-I_-1,0) != 0 ) {
               x(W_-I_-1,0) = 0;
               x += 1;
           }
           return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> ceil_fixed(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_ < 0) return 0;
        else {
           if ( x(W_-I_-1,0) != 0 ) {
               x(W_-I_-1,0) = 0;
               x += 1;
           }
           return x;
        }
    }
}
template <int I_>
ap_int<I_> ceil_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> ceil_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> floor_fixed(ap_fixed<W_,I_> x)
{
    if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            if ( x(W_-I_-1,0) != 0 ) x(W_-I_-1,0) = 0;
            return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> floor_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return floor_fixed(xi);
}
template <int I_>
ap_int<I_> floor_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> floor_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> trunc_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            if ( x(W_-I_-1,0) != 0 ) {
                x(W_-I_-1,0) = 0;
                if ( x[W_-1] )
                    x += 1;
            }
            return x;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> trunc_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return trunc_fixed(xi);
}
template <int I_>
ap_int<I_> trunc_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> trunc_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> copysign_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y)
{
    x[W_-1] = y[W_-1];
    return x;
}
template <int W_, int I_>
ap_ufixed<W_,I_> copysign_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    (void)(y);
    return x;
}
template <int I_>
ap_int<I_> copysign_fixed(ap_int<I_> x, ap_int<I_> y)
{
    x[I_-1] = y[I_-1];
    return x;
}
template <int I_>
ap_uint<I_> copysign_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    (void)(y);
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> fabs_fixed(ap_fixed<W_,I_> x)
{
    ap_fixed<W_,I_> xs = -x;
                    xs[W_-1] = 0;
    return ( ( x[W_-1] ) ? xs : x );
}
template <int W_, int I_>
ap_ufixed<W_,I_> fabs_fixed(ap_ufixed<W_,I_> x)
{
    return x;
}
template <int I_>
ap_int<I_> fabs_fixed(ap_int<I_> x)
{
    ap_int<I_> xs = -x;
               xs[I_-1] = 0;
    return ( ( x[I_-1] ) ? xs : x );
}
template <int I_>
ap_uint<I_> fabs_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> round_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            ap_ufixed<1, 0> half_val = 0.5;
            ap_ufixed<W_,I_> x_pos = fabs_fixed(x);
            ap_ufixed<W_+1,I_+1> r = x_pos + half_val;
            r(W_-I_-1,0) = 0;
            if(x[W_-1]) return -r;
            else return r;
        }
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> round_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return round_fixed(xi);
}
template <int I_>
ap_int<I_> round_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> round_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> rint_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
 if(W_ == I_) {
        return x;
    }
    else {
        if(I_<0) return 0;
        else {
            ap_ufixed<W_, I_> x_p = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
            ap_ufixed<1,0> half_val = 0.5;
            ap_ufixed<W_+1,I_+1> xUp = x_p + half_val;

            if(xUp(W_-I_-1,0) == 0) {

               xUp[W_-I_] = 0;
            } else {
               xUp(W_-I_-1,0) = 0;
            }
            if(x[W_-1]) return -xUp;
            else return xUp;
        }
# 289 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_round_copysign_apfixed.h"
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> rint_fixed(ap_ufixed<W_,I_> x)
{
   ap_fixed<W_+1, I_+1> xi = x;
   return rint_fixed(xi);
}
template <int I_>
ap_int<I_> rint_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> rint_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> nearbyint_fixed(ap_fixed<W_,I_> x)
{

    return rint_fixed(x);
}
template <int W_, int I_>
ap_ufixed<W_,I_> nearbyint_fixed(ap_ufixed<W_,I_> x)
{
    ap_fixed<W_+1,I_+1> xi = x;
    return nearbyint_fixed(xi);
}
template <int I_>
ap_int<I_> nearbyint_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> nearbyint_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
bool signbit_fixed(ap_fixed<W_, I_> x){
    if(x[W_-1]) return true;
    else return false;
}
template <int W_, int I_>
bool signbit_fixed(ap_ufixed<W_, I_> x){
    (void)(x);
    return false;
}

template <int I_>
bool signbit_fixed(ap_int<I_> x){
    if(x[I_-1]) return true;
    else return false;
}

template <int I_>
bool signbit_fixed(ap_uint<I_> x){
    (void)(x);
    return false;
}
namespace fp_internal {
  template<int W, int I>
  ap_fixed<W, I> nextafter(ap_fixed<W, I> x, ap_fixed<W, I> y){
     const static int F = W - I;
     ap_ufixed<1, -F+1> ulp = 0;
     ulp[0] = 1;
     ap_fixed<W, I> r = 0;
     if(x == y) r = y;
     else if(x < y) r = x + ulp;
     else r = x - ulp;
     return r;
  }
  template<int W, int I>
  ap_ufixed<W, I> nextafter(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
     ap_fixed<W+1, I+1> xi = x;
     ap_fixed<W+1, I+1> yi = y;
     return nextafter(xi, yi);

  }
  template<int I>
  ap_int<I> nextafter(ap_int<I> x, ap_int<I> y) {
     ap_fixed<I, I> xi = x;
     ap_fixed<I, I> yi = y;
     return nextafter(xi, yi);
  }
  template<int I>
  ap_uint<I> nextafter(ap_uint<I> x, ap_uint<I> y) {
     ap_fixed<I+1, I+1> xi = x;
     ap_fixed<I+1, I+1> yi = y;
     return nextafter(xi, yi);
  }
  template<int W, int I>
  ap_fixed<W, I> nexttoward(ap_fixed<W, I> x, ap_fixed<W, I> y){
     return nextafter(x,y);
  }
  template<int W, int I>
  ap_ufixed<W, I> nexttoward(ap_ufixed<W, I> x, ap_ufixed<W, I> y){
     return nextafter(x,y);
  }
  template<int I>
  ap_int<I> nexttoward(ap_int<I> x, ap_int<I> y){
     return nextafter(x,y);
  }
  template<int I>
  ap_uint<I> nexttoward(ap_uint<I> x, ap_uint<I> y){
     return nextafter(x,y);
  }
}


template <int W, int I>
long long int llround_fixed(ap_fixed<W,I> x){
    return round_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
}


template <int W, int I>
long long int llround_fixed(ap_ufixed<W,I> x){
    return round_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
}


template <int I>
long long int llround_fixed(ap_int<I> x){
    return x;
}


template <int I>
long long int llround_fixed(ap_uint<I> x){
    return x;
}


template <int W, int I>
long int lround_fixed(ap_fixed<W,I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[W-1])? minval : maxval;
    }
    else {
        return round_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
    }
}


template <int W, int I>
long int lround_fixed(ap_ufixed<W,I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) ) {
        return maxval;
    }
    else {
        return round_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
    }
}


template <int I>
long int lround_fixed(ap_int<I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[I-1])? minval : maxval;
    }
    else {
        return x;
    }
}


template <int I>
long int lround_fixed(ap_uint<I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) ) {
        return maxval;
    }
    else {
        return x;
    }
}


template <int W, int I>
long long int llrint_fixed(ap_fixed<W,I> x){
    return rint_fixed<W+1,I+1>(ap_fixed<W+1,I+1> (x));
}


template <int W, int I>
long long int llrint_fixed(ap_ufixed<W,I> x){
    return rint_fixed<W+1,I+1>(ap_ufixed<W+1,I+1> (x));
}


template <int I>
long long int llrint_fixed(ap_int<I> x){
    return x;
}


template <int I>
long long int llrint_fixed(ap_uint<I> x){
    return x;
}


template <int W, int I>
long int lrint_fixed(ap_fixed<W,I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x<minval)) {
        return (x[W-1])? minval : maxval;
    }
    else {
        return rint_fixed<W+1, I+1>(ap_fixed<W+1,I+1> (x));
    }
}



template <int W, int I>
long int lrint_fixed(ap_ufixed<W,I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if(x>maxval){
        return maxval;
    }
    else {
        return rint_fixed<W+1, I+1>(ap_ufixed<W+1,I+1> (x));
    }
}


template <int I>
long int lrint_fixed(ap_int<I> x){
    ap_int<8*sizeof(long int)> minval = 0;
    minval[8*sizeof(long int)-1] = 1;
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if((x>maxval) || (x>minval)) {
        return (x[I-1])? minval : maxval;
    }
    else {
        return x;
    }
}


template <int I>
long int lrint_fixed(ap_uint<I> x){
    ap_int<8*sizeof(long int)> maxval = -1;
    maxval[8*sizeof(long int)-1] = 0;
    if(x>maxval) {
        return maxval;
    }
    else {
        return x;
    }
}
# 1071 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_pow_apfixed.h" 1
# 37 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_pow_apfixed.h"
namespace pow_apfixed_reduce{
# 52 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_,int I_>
ap_fixed<W_,I_> pow(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y) {
    const static int F_ = W_ - I_;

    if (I_>34) return 0;
    else if (F_>33) return 0;
    ap_fixed<W_,I_> r = 0;

    bool r_is_neg = 0;
    bool y_is_frac = 0;

    if (F_>0&&y(F_-1,0)>0)
        y_is_frac =1;
    if (x==0) {

        if (y==0&&I_>1) {
            return 1;

        } else if (y>0) {
            return 0;
        } else {

            VITIS_LOOP_74_1: for (int j = 0; j < W_-1; j++){
#pragma HLS unroll
 r[j] = 1;
            }
               r[W_-1] = 0;
            return r;
        }
    } else if (x<0) {

        if (y_is_frac) return 0;

        else {
            if (y==0||(I_>1&&y[F_]==0))
                r_is_neg = 0;
            else
                r_is_neg = 1;
        }
    }

    ap_fixed<W_+1,I_+1> x_e_1 = x;

    ap_fixed<W_+1,I_+1> x_p = 0;
    x_p = fabs_fixed(x_e_1);


    const static int E_l = I_+2;
    const static int F_l = W_+E_l;

    const static int I_l = I_+1>6?I_+1:6;
    const static int W_l = F_l + I_l;

    ap_fixed<W_l,I_l> x_l = x_p;


    ap_fixed<W_l,I_l> ln_x = log_apfixed_reduce::log(x_l);


    ap_fixed<F_l+6,6> ln_x_s = ln_x;


    const static int FI_m = W_+2;

    const static int I_m = I_>6 ? I_ : 6;
    const static int WI_m = FI_m + I_m;
    const static int WO_m = F_ + I_m;
    ap_fixed<F_l+W_+6,6+I_> mul_y_ln = ln_x_s * y;
# 129 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_pow_apfixed.h"
    ap_fixed<WO_m,I_m> exp_r = 0;
    ap_fixed<W_,I_> r_1 = 0;
    bool m_overf = 0;
    bool e_overf = 0;
    bool overf = 0;

    VITIS_LOOP_135_2: for (int j = F_l+F_+I_m-1; j < F_l+W_+5; j++){
#pragma HLS unroll
 if (mul_y_ln[F_l+W_+5]!=mul_y_ln[j])
            m_overf = 1;
    }

    if (!m_overf) {

        ap_fixed<WI_m,I_m> mul_y_ln_s = mul_y_ln;

        exp_r = exp_reduce::exp_core<WO_m,I_m,WI_m>(mul_y_ln_s);


        if (I_<I_m) {
            VITIS_LOOP_149_3: for (int j = WO_m-1; j >= W_-1; j--) {
#pragma HLS unroll
 if (exp_r[j])
                    e_overf=1;
            }
        }
        r_1 = exp_r;
    }

    if (e_overf||(m_overf&&!mul_y_ln[F_l+W_+5])) {
        overf = 1;
    }

    if (r_is_neg) {

        if (overf) {
            r=0;
            r[W_-1]=1;

        } else {
            if (r_1!=0) {
                r = -r_1;
                r[W_-1] = 1;
            }
        }

    } else {

        if(overf) {
            r[W_-1] = 0;
            VITIS_LOOP_179_4: for (int j = W_-2; j >= 0; j--){
#pragma HLS unroll
 r[j] = 1;
            }

        } else {
            r = r_1;
        }
    }

    return r;
}
# 210 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_, int I_>
ap_fixed<W_,I_> pown(ap_fixed<W_,I_> x, int n) {






    const static int F_ = W_ - I_;

    if (I_>34) return 0;
    else if (F_>33) return 0;

    ap_fixed<W_,I_> r = 0;
    ap_fixed<32,32> n_fix = n;

    bool x_sig = x[W_-1];
    bool n_sig = n_fix[31];
    bool n_is_odd = n_fix[0];
    bool x_gt_0 = 0;

    if (x == 0 && n_fix != 0) r = 0;
    else if(n_fix == 0) r = 1;
    else if(n_fix == 1) r = x;

    else if(x == 1) r = 1;
    else if(x == -1) {
        if(n_is_odd) r = -1;
        else r = 1;
    }else {
# 266 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_pow_apfixed.h"
       const static int we_n = F_ > 26? 32 : 6 + F_;

       const static int wf_log = I_ == F_>26 ? (31+F_+I_) : (we_n-1+F_+I_);
       const static int I_e = I_>6 ? I_ : 6;
       const static int WI_e = I_e + wf_log - we_n;
       const static int WO_e = F_ + I_e;
       ap_fixed<33,33> max_n = 0;
       max_n[we_n-1] = 1;
       ap_ufixed<32,32> n_pos = fabs_fixed(ap_fixed<33,33>(n));
       ap_ufixed<WO_e,I_e> exp_r=0;
       bool ovf = 0;
       ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
       if(x_pos>1) x_gt_0 = 1;
       ap_fixed<32,32> min_n = -max_n;
       if(n_fix != -1 && ((n >= max_n) || (n < min_n))){

           ovf = 1;
       }else {
           ap_fixed<we_n, we_n> n_s = n;





           const static int I_l = I_+1 < 6? 6 : I_+1;
           ap_fixed<wf_log+I_l,I_l> x_e = x_pos;
           const static int we_log = 6;
           ap_fixed<wf_log+we_log,we_log> x_log = log_apfixed_reduce::log(x_e);






           ap_fixed<wf_log+we_log, we_log+we_n> x_log_mul_n = n_s * x_log;






           VITIS_LOOP_307_1: for(int i = wf_log+we_log-2; i > WI_e - 2; --i) {
#pragma HLS unroll
 if(x_log_mul_n[i] != x_log_mul_n[wf_log+we_log-1]){

                    ovf = 1;
                }
           }
           ap_fixed<WI_e, I_e> x_log_mul_n_1 = x_log_mul_n ;





           exp_r = exp_reduce::exp_core<WO_e,I_e,WI_e>(x_log_mul_n_1);





           if (I_<I_e) {
               VITIS_LOOP_327_2: for (int j = WO_e-1; j >= W_-1; j--) {
#pragma HLS unroll

 if (exp_r[j])
                       ovf=1;
               }
           }
       }
       if(ovf) {
           if(x_gt_0 ^ n_sig) {

               if(x_sig && !n_is_odd) {
                   r[W_-1] = 1;
               } else {
                   VITIS_LOOP_341_3: for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[W_-1] = 1;
                   }
               }
           }
       } else {
           if(x_sig && n_is_odd) r = -exp_r;
           else r = exp_r;
       }
   }
   return r;
}
# 380 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_pow_apfixed.h"
template<int W_,int I_>
ap_fixed<W_,I_> rootn(ap_fixed<W_,I_> x, int n) {






    const static int F_ = W_ - I_;

    if (I_ > 34) return 0;
    else if (F_ > 33) return 0;

    ap_fixed<W_,I_> r = 0;
    ap_fixed<32,32> n_fix = n;
    bool n_is_odd = 0;
    if(n_fix[0]) n_is_odd = 1;

    if (x == 0) r = 0;
    else if(n_fix == 0) r = 0;
    else if(n_fix == 1) r = x;
    else if(n_fix == -1) r = ap_fixed<W_, I_>(1)/x;
    else if(x<0 && !n_is_odd) r = 0;
    else if(x==1) r = 1;
    else if(x==-1 && n_is_odd) r = -1;
    else {

        ap_ufixed<W_,I_> x_p = fabs_fixed((ap_fixed<W_+1,I_+1>)x);


        const static int m_we = (F_+1)/2 > (I_+1)/2? (F_+1)/2:(I_+1)/2;
        const static int we = I_ > m_we ? m_we : I_;
        const static int E_l = we - 1;
        const static int F_l = F_ + E_l;

        const static int I_l = I_ + 1 > 6 ? I_ + 1 : 6;
        const static int W_l = F_l + I_l;

        ap_fixed<W_l,I_l> x_l = x_p;


        ap_fixed<W_l,I_l> ln_x = log_apfixed_reduce::log(x_l);






        ap_fixed<F_l+6,6> ln_x_s = ln_x;


        const static int FI_d = F_l + 1;

        const static int I_d = we+1 > 5? we+1 : 5;
        const static int WI_d = FI_d + I_d;
        const static int WO_d = F_ + I_d;
        ap_fixed<F_l+6,5> divd_n_ln = ln_x_s / n_fix;







        ap_fixed<WI_d,I_d> divd_n_ln_s = divd_n_ln;





        ap_ufixed<WO_d, I_d> exp_r = exp_reduce::exp_core<WO_d,I_d,WI_d>(divd_n_ln_s);





        bool ovf = 0;

        if(I_ < I_d) {
           VITIS_LOOP_459_1: for (int j =WO_d-1; j >= W_-1; j--) {
#pragma HLS unroll

 if (exp_r[j])
                   ovf=1;
           }
        }
        if(!ovf) {
           if(x[W_-1]&&n_is_odd) r = -exp_r;
           else r = exp_r;
        }else {
           if(x[W_-1]&&n_is_odd) {
              r[W_-1] = 1;
           } else {
              VITIS_LOOP_473_2: for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[i] = 1;
              }
           }
        }
   }
   return r;
}


template<int W_, int I_>
ap_ufixed<W_,I_> pow(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y) {
    ap_fixed<W_+1,I_+1> xf = x;
    ap_fixed<W_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_int<I_> pow(ap_int<I_> x, ap_int<I_> y) {
    ap_fixed<I_,I_> xf = x;
    ap_fixed<I_,I_> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_uint<I_> pow(ap_uint<I_> x,ap_uint<I_> y) {
    ap_fixed<I_+1,I_+1> xf = x;
    ap_fixed<I_+1,I_+1> yf = y;
    return pow(xf,yf);
}


template<int W_, int I_>
ap_fixed<W_,I_> powr(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y) {
    return pow(x,y);
}

template<int W_, int I_>
ap_ufixed<W_,I_> powr(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y) {
    ap_fixed<W_+1,I_+1> xf = x;
    ap_fixed<W_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_int<I_> powr(ap_int<I_> x, ap_int<I_> y) {
    ap_fixed<I_,I_> xf = x;
    ap_fixed<I_,I_> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_uint<I_> powr(ap_uint<I_> x,ap_uint<I_> y) {
    ap_fixed<I_+1,I_+1> xf = x;
    ap_fixed<I_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int W_, int I_>
ap_ufixed<W_,I_> pown(ap_ufixed<W_, I_> x, int n) {
    ap_fixed<W_+1,I_+1> xi = x;
    return pown(xi, n);
}

template<int I_>
ap_int<I_> pown(ap_int<I_> x, int n) {
   ap_fixed<I_, I_> xi = x;
   return pown(xi, n);
}

template<int I_>
ap_uint<I_> pown(ap_uint<I_> x, int n) {
   ap_fixed<I_+1, I_+1> xi = x;
   return pown(xi, n);
}
template<int W_, int I_>
ap_ufixed<W_,I_> rootn(ap_ufixed<W_, I_> x, int n) {
    ap_fixed<W_+1,I_+1> xi = x;
    return rootn(xi, n);
}

template<int I_>
ap_int<I_> rootn(ap_int<I_> x, int n) {
   ap_fixed<I_, I_> xi = x;
   return rootn(xi, n);
}

template<int I_>
ap_uint<I_> rootn(ap_uint<I_> x, int n) {
   ap_fixed<I_+1, I_+1> xi = x;
   return rootn(xi, n);
}
}
# 1072 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_diff_apfixed.h" 1
# 35 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_diff_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 36 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_diff_apfixed.h" 2
# 46 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fdim_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> x_overf = 0;
    ap_fixed<W_ ,I_ > xs = 0;
        bool overf = 0;

    if(x > y)
    {
        x_overf = x - y;
        overf = x_overf[W_-1];
        if(overf) {
            VITIS_LOOP_59_1: for (int i = 0; i < W_-1; i++){
#pragma HLS UNROLL
 xs[i] = 1;
            }
            xs[W_-1] = 0;
        }
        else{
            x_overf[W_] = 0;
            xs = x_overf;
        }
    }
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fdim_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x > y){ xs = x - y; }
    return xs;
}
template <int I_>
ap_int<I_> fdim_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return fdim_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> fdim_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x > y) { xs = x - y; }
    return xs;
}
# 102 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fmax_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
    ap_fixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x ;
        else xs = y ;
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fmax_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> fmax_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_int<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_uint<I_> fmax_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
# 143 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fmin_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
    ap_fixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x ;
        else xs = y ;
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fmin_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> fmin_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_int<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_uint<I_> fmin_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
# 186 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> maxmag_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> xm = -x;
    ap_fixed<W_+1,I_+1> ym = -y;
    ap_fixed<W_+1,I_+1> x_fabs = ( x[W_-1] ) ? xm : ap_fixed<W_+1,I_+1>(x);
    ap_fixed<W_+1,I_+1> y_fabs = ( y[W_-1] ) ? ym : ap_fixed<W_+1,I_+1>(y);

    ap_fixed<W_+1,I_+1> xs_t = 0;
    ap_fixed<W_,I_> xs = 0;
    if(x_fabs >= y_fabs)
    {
     xs_t = x_fabs ;
     xs = x;
    }
    else{
     xs_t = y_fabs ;
     xs = y;
    }

    if(xs_t[W_-1])
    {
            VITIS_LOOP_209_1: for (int i = 0; i < W_-1; i++){
#pragma HLS UNROLL
 xs[i] = 1;
            }
            xs[W_-1] = 0;
    }

    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> maxmag_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> maxmag_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return maxmag_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> maxmag_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
# 252 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> minmag_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
 ap_fixed<W_+1,I_+1> xm = -x;
    ap_fixed<W_+1,I_+1> ym = -y;
    ap_fixed<W_+1,I_+1> x_fabs = ( x[W_-1] ) ? xm : ap_fixed<W_+1,I_+1>(x);
    ap_fixed<W_+1,I_+1> y_fabs = ( y[W_-1] ) ? ym : ap_fixed<W_+1,I_+1>(y);

    ap_fixed<W_+1,I_+1> xs_t = 0;
    ap_fixed<W_,I_> xs = 0;
    if(x_fabs <= y_fabs)
    {
     xs_t = x_fabs ;
     xs = x;
    }
    else{
     xs_t = y_fabs ;
     xs = y;
    }
    if(xs_t[W_-1])
    {
            VITIS_LOOP_274_1: for (int i = 0; i < W_-1; i++){
#pragma HLS UNROLL
 xs[i] = 1;
            }
            xs[W_-1] = 0;
    }

    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> minmag_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> minmag_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return minmag_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> minmag_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
# 1073 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_comparison_apfixed.h" 1
# 35 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_comparison_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 36 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_comparison_apfixed.h" 2



template<int W, int I>
bool isgreater_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isgreater_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreater_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreater_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool isgreaterequal_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isgreaterequal_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreaterequal_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreaterequal_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool isless_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isless_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isless_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isless_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool islessequal_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool islessequal_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessequal_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessequal_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool islessgreater_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool islessgreater_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessgreater_fixed(ap_int<I> x1, ap_int<I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessgreater_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
# 1074 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_frexp_apfixed.h" 1
# 41 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_frexp_apfixed.h"
namespace frexp_internal {

template<int W, int I>
ap_fixed<W,I> frexp(ap_fixed<W,I> x,
                    ap_fixed<W,I>* exp){
    if(I<0) {
           *exp = 0;
           return x;
    }
    static const int F = W - I;
    static const int we = W > 5 ? W/2 : 3;

    ap_int<we> e = 0;
    ap_ufixed<W, I> r_p = 0;

    ap_fixed<W+1, I+1> xi = x;
    ap_ufixed<W, I> x_p = fabs_fixed(xi);

    static const ap_uint<3> clz_table_6bit[64] = {7, 6, 5, 5, 4, 4, 4, 4,
                                                  3, 3, 3, 3, 3, 3, 3, 3,
                                                  2, 2, 2, 2, 2, 2, 2, 2,
                                                  2, 2, 2, 2, 2, 2, 2, 2,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1};
    int pos = 0;

    static const int loop_nm = W > 6 ? (W + 5)/6 : 1;
    CLZ_LOOP:
    for(int l = loop_nm; l > 0; --l){
#pragma HLS pipeline II=1
 ap_uint<6> t = 0;
       if(l*6 > W) t = x_p(W - 1, (l - 1) * 6);
       else t = x_p(l * 6 - 1, (l - 1) * 6);
       if((t & 0x3f) != 0) {
          pos = l * 6 - clz_table_6bit[t];
          break;
       }
    }
    if(pos >= 0) {
        e = pos + 1 - F;
        if(F > 0) {
           ap_uint<we> w_f = (pos + 1) < F ? (pos + 1) : F;
           r_p(F - 1,F - w_f) = x_p(pos, pos + 1 - w_f);
        }
    } else {
        e = 0;
        r_p = 0;
    }
    ap_fixed<W, I> r = 0;
    if(xi[W-1]) r = -r_p;
    else r = r_p;



    *exp = e;
    return r;
}
template<int W, int I>
ap_ufixed<W,I> frexp(ap_ufixed<W,I> x,
                     ap_ufixed<W,I>* exp){
    ap_fixed<W+1, I+1> xe = x;
    ap_fixed<W+1, I+1> ee = 0;
    ap_fixed<W+1, I+1> r = frexp(xe,&ee);
    *exp = ee;
    return r;
}
template<int I>
ap_uint<I> frexp(ap_uint<I> x,
                 ap_uint<I>* exp) {
   ap_fixed<I, I> xe = x;
   ap_fixed<I, I> ee = 0;
   ap_fixed<I, I> r = frexp(xe,&ee);
   *exp = ee;
   return r;
}
template<int I>
ap_int<I> frexp(ap_int<I> x,
                ap_int<I>* exp) {
   ap_fixed<I+1, I+1> xe = x;
   ap_fixed<I+1, I+1> ee = 0;
   ap_fixed<I+1, I+1> r = frexp(xe,&ee);
   *exp = ee;
   return r;
}
}
# 1075 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_modf_apfixed.h" 1
# 40 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_modf_apfixed.h"
namespace modf_internal {
template<int W, int I>
ap_fixed<W,I> modf(ap_fixed<W, I> x,
                   ap_fixed<W, I>* int_part){
    ap_fixed<W, I> frac_part = 0;
    if(W == I) {
        *int_part = x;
        frac_part = 0;
    } else if(I > 0) {
        ap_fixed<W+1, I+1> xi = x;
        ap_ufixed<W, I> x_p = fabs_fixed(xi);
        frac_part(W - I - 1,0) = x_p(W - I - 1,0);
        if(xi[W-1]) frac_part = - frac_part;
        *int_part = x_p(W-1, W-I);
        if(xi[W-1]) *int_part = -*int_part;
    } else {
       *int_part = 0;
       frac_part = x;
    }
    return frac_part;
}
template<int W, int I>
ap_ufixed<W,I> modf(ap_ufixed<W, I> x,
                    ap_ufixed<W, I>* int_part){
    ap_fixed<W+1, I+1> xi = x;
    ap_fixed<W+1, I+1> ii = 0;
    ap_fixed<W+1, I+1> r = modf(xi, &ii);
    *int_part = ii;
    return r;
}
template<int I>
ap_int<I> modf(ap_int<I> x,
               ap_int<I>* int_part){
    *int_part = x;
    return 0;
}
template<int I>
ap_uint<I> modf(ap_uint<I> x,
                ap_uint<I>* int_part){
    *int_part = x;
    return 0;
}
}
# 1076 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_isequal_isnotequal_apfixed.h" 1
# 40 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_isequal_isnotequal_apfixed.h"
template <int W_, int I_>
bool generic_isequal(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_ufixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_ufixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_fixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_fixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}



template <int I_>
bool generic_isequal(ap_int<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_int<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_uint<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_uint<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_int<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_int<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_uint<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_uint<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}
# 1077 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_all_any_apfixed.h" 1
# 35 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_all_any_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 36 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_all_any_apfixed.h" 2


template <int W_, int I_>
bool generic_all(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_42_1: for (int i=0; i<W_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int W_, int I_>
bool generic_all(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_53_1: for (int i=0; i<W_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int I_>
bool generic_all(ap_int<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_64_1: for (int i=0; i<I_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int I_>
bool generic_all(ap_uint<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_75_1: for (int i=0; i<I_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int W_, int I_>
bool generic_any(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_86_1: for (int i=0; i<W_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int W_, int I_>
bool generic_any(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_97_1: for (int i=0; i<W_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int I_>
bool generic_any(ap_int<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_108_1: for (int i=0; i<I_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int I_>
bool generic_any(ap_uint<I_> x)
{
#pragma HLS pipeline II=1
 VITIS_LOOP_119_1: for (int i=0; i<I_;i++)
     if (x[i]==1)
      return true;
    return false;
}
# 1078 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_select_bitselect_apfixed.h" 1
# 35 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_select_bitselect_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 36 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_select_bitselect_apfixed.h" 2
# 62 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_select_bitselect_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> generic_bitselect(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y, ap_fixed<W_,I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}


template <int W_, int I_>
ap_ufixed<W_,I_> generic_bitselect(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y, ap_ufixed<W_,I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}


template <int I_>
ap_int<I_> generic_bitselect(ap_int<I_> x,ap_int<I_> y, ap_int<I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}

template <int I_>
ap_uint<I_> generic_bitselect(ap_uint<I_> x,ap_uint<I_> y, ap_uint<I_> z)
{
#pragma HLS pipeline
 return (z & y)|(~z & x);
}
# 1079 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_erf_apfixed.h" 1
# 35 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_erf_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 36 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_erf_apfixed.h" 2



namespace erf_erfc_fixed {

    namespace {
 template <typename T> class coeff { };

 template <> class coeff<double> {

 public:
   static const double tiny;
   static const double one_over_two;
   static const double one;
   static const double two;
   static const double erx;
   static const double efx;
   static const double efx8;
   static const double pp[5];
   static const double qq[6];
   static const double pa[7];
   static const double qa[7];
   static const double ra[8];
   static const double sa[9];
   static const double rb[7];
   static const double sb[8];
 };
 const double coeff<double>::tiny = 1e-300;
 const double coeff<double>::one_over_two= 5.00000000000000000000e-01;
 const double coeff<double>::one = 1.00000000000000000000e+00;
 const double coeff<double>::two = 2.00000000000000000000e+00;

 const double coeff<double>::erx = 8.45062911510467529297e-01;



 const double coeff<double>::efx = 1.28379167095512586316e-01;
 const double coeff<double>::efx8= 1.02703333676410069053e+00;
 const double coeff<double>::pp[] =
   {1.28379167095512558561e-01,
    -3.25042107247001499370e-01,
    -2.84817495755985104766e-02,
    -5.77027029648944159157e-03,
    -2.37630166566501626084e-05};
 const double coeff<double>::qq[] =
   {0.0, 3.97917223959155352819e-01,
    6.50222499887672944485e-02,
    5.08130628187576562776e-03,
    1.32494738004321644526e-04,
    -3.96022827877536812320e-06};



 const double coeff<double>::pa[] =
   {-2.36211856075265944077e-03,
    4.14856118683748331666e-01,
    -3.72207876035701323847e-01,
    3.18346619901161753674e-01,
    -1.10894694282396677476e-01,
    3.54783043256182359371e-02,
    -2.16637559486879084300e-03};
 const double coeff<double>::qa[] =
   {0.0, 1.06420880400844228286e-01,
    5.40397917702171048937e-01,
    7.18286544141962662868e-02,
    1.26171219808761642112e-01,
    1.36370839120290507362e-02,
    1.19844998467991074170e-02};



 const double coeff<double>::ra[] =
   {-9.86494403484714822705e-03,
    -6.93858572707181764372e-01,
    -1.05586262253232909814e+01,
    -6.23753324503260060396e+01,
    -1.62396669462573470355e+02,
    -1.84605092906711035994e+02,
    -8.12874355063065934246e+01,
    -9.81432934416914548592e+00};
 const double coeff<double>::sa[] =
   {0.0,1.96512716674392571292e+01,
    1.37657754143519042600e+02,
    4.34565877475229228821e+02,
    6.45387271733267880336e+02,
    4.29008140027567833386e+02,
    1.08635005541779435134e+02,
    6.57024977031928170135e+00,
    -6.04244152148580987438e-02};



 const double coeff<double>::rb[] =
   {-9.86494292470009928597e-03,
    -7.99283237680523006574e-01,
    -1.77579549177547519889e+01,
    -1.60636384855821916062e+02,
    -6.37566443368389627722e+02,
    -1.02509513161107724954e+03,
    -4.83519191608651397019e+02};
 const double coeff<double>::sb[] =
   {0.0,3.03380607434824582924e+01,
    3.25792512996573918826e+02,
    1.53672958608443695994e+03,
    3.19985821950859553908e+03,
    2.55305040643316442583e+03,
    4.74528541206955367215e+02,
    -2.24409524465858183362e+01};
# 245 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_erf_apfixed.h"
 template<typename T> class erf_traits{ };
# 267 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_erf_apfixed.h"
 template<> class erf_traits<double> {
 public:
   static const uint64_t mask;
   static const uint32_t segment[10];
 };
 const uint64_t erf_traits<double>::mask = 0xffffffff00000000;
 const uint32_t erf_traits<double>::segment[10] =
   {
  0x7fffffff,
  0x7ff00000,
  0x3feb0000,
  0x3e300000,
  0x00800000,
  0x3ff40000,
  0x40180000,
  0x4006DB6E,
  63,
  32
   };

 template<typename T> class erfc_traits{};
# 308 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_erf_apfixed.h"
 template<> class erfc_traits<double>{
 public:
   static const uint32_t segment[11];
 };
 const uint32_t erfc_traits<double>::segment[11] =
   {
  0x7fffffff,
  0x7ff00000,
  0x3feb0000,
  0x3c700000,
  0x3fd00000,
  0x3ff40000,
  0x403c0000,
  0x4006DB6D,
  0x40180000,
  63,
  32
   };
  }
# 346 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_erf_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> erf(ap_fixed<W_,I_> x_fixed )
{
    int F_ = W_ - I_;

    if (I_>33) return 0;
    else if (F_>32) return 0;

    double x = x_fixed.to_double();
 int32_t hx;
    uint32_t ix;
 double R,S,P,Q,s,y,z,r;

    fp_struct<double> fp_abs(x);
      fp_abs.sign=0;
    fp_struct<double> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erf_traits<double>::segment[8],erf_traits<double>::segment[9]);
    hx = tmp.to_int();
 ix = hx & erf_traits<double>::segment[0];






    if(fp_x.exp == 0x0 && fp_x.sign!= 0x0){
   return 0;
 }

 if(ix>=erf_traits<double>::segment[1]) {

   if(hx>0)
  return ap_fixed<W_,I_>((double)1.0 +coeff<double>::one/x);
   else
  return ap_fixed<W_,I_>(coeff<double>::one/x-(double)1.0);
 }

 if(ix < erf_traits<double>::segment[2]) {
   double r1,r2,s1,s2,s3,z2,z4;
   if(ix < erf_traits<double>::segment[3]) {
  if (ix < erf_traits<double>::segment[2])
    return ap_fixed<W_,I_>(((double)0.125)*((double)8.0*x+coeff<double>::efx8*x));
  return ap_fixed<W_,I_>(x + coeff<double>::efx*x);
   }
   z = x*x;




   r1 = coeff<double>::pp[0]+z*coeff<double>::pp[1]; z2=z*z;
   r2 = coeff<double>::pp[2]+z*coeff<double>::pp[3]; z4=z2*z2;
   s1 = coeff<double>::one+z* coeff<double>::qq[1];
   s2 = coeff<double>::qq[2]+z*coeff<double>::qq[3];
   s3 = coeff<double>::qq[4]+z*coeff<double>::qq[5];
   r = r1 + z2*r2 + z4*coeff<double>::pp[4];
   s = s1 + z2*s2 + z4*s3;

   y = r/s;
   return ap_fixed<W_,I_>(x + x*y);
 }
 if(ix < erf_traits<double>::segment[5]) {
   double s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;

      s = fp_abs.to_ieee()-coeff<double>::one;




   P1 = coeff<double>::pa[0]+s*coeff<double>::pa[1]; s2=s*s;
   Q1 = coeff<double>::one+s*coeff<double>::qa[1]; s4=s2*s2;
   P2 = coeff<double>::pa[2]+s*coeff<double>::pa[3]; s6=s4*s2;
   Q2 = coeff<double>::qa[2]+s*coeff<double>::qa[3];
   P3 = coeff<double>::pa[4]+s*coeff<double>::pa[5];
   Q3 = coeff<double>::qa[4]+s*coeff<double>::qa[5];
   P4 = coeff<double>::pa[6];
   Q4 = coeff<double>::qa[6];
   P = P1 + s2*P2 + s4*P3 + s6*P4;
   Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

   if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::erx + P/Q);
      else return ap_fixed<W_,I_>(-coeff<double>::erx - P/Q);
 }
 if (ix >= erf_traits<double>::segment[6]) {
   if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::one-coeff<double>::tiny);
      else return ap_fixed<W_,I_>(coeff<double>::tiny-coeff<double>::one);
 }
 x = fp_abs.to_ieee();
  s = coeff<double>::one/(x*x);
 if(ix< erf_traits<double>::segment[7]) {






   double R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
   R1 = coeff<double>::ra[0]+s*coeff<double>::ra[1];s2 = s*s;
   S1 = coeff<double>::one+ s*coeff<double>::sa[1]; s4 = s2*s2;
   R2 = coeff<double>::ra[2]+s*coeff<double>::ra[3];s6 = s4*s2;
   S2 = coeff<double>::sa[2]+s*coeff<double>::sa[3];s8 = s4*s4;
   R3 = coeff<double>::ra[4]+s*coeff<double>::ra[5];
   S3 = coeff<double>::sa[4]+s*coeff<double>::sa[5];
   R4 = coeff<double>::ra[6]+s*coeff<double>::ra[7];
   S4 = coeff<double>::sa[6]+s*coeff<double>::sa[7];
   R = R1 + s2*R2 + s4*R3 + s6*R4;
   S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<double>::sa[8];

 } else {






   double R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
   R1 = coeff<double>::rb[0]+s*coeff<double>::rb[1];s2 = s*s;
   S1 = coeff<double>::one+ s*coeff<double>::sb[1]; s4 = s2*s2;
   R2 = coeff<double>::rb[2]+s*coeff<double>::rb[3];s6 = s4*s2;
   S2 = coeff<double>::sb[2]+s*coeff<double>::sb[3];
   R3 = coeff<double>::rb[4]+s*coeff<double>::rb[5];
   S3 = coeff<double>::sb[4]+s*coeff<double>::sb[5];
   S4 = coeff<double>::sb[6]+s*coeff<double>::sb[7];
   R = R1 + s2*R2 + s4*R3 + s6*coeff<double>::rb[6];
   S = S1 + s2*S2 + s4*S3 + s6*S4;

 }
 z = x;

    fp_struct<double> fp_z(z);
    ap_uint<Type_BitWidth<double>::Value> data = fp_z.data() & erf_traits<double>::mask;
    fp_struct<double> fp_z_new(data);
    z = fp_z_new.to_ieee();


    ap_fixed<W_, I_> r_fixed = exp_reduce::exp(ap_fixed<W_, I_>(-z*z-(double)0.5625))*exp_reduce::exp(ap_fixed<W_, I_>((z-x)*(z+x)+R/S));
 r = r_fixed.to_double();

 if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::one-r/x);
    else return ap_fixed<W_,I_>(r/x-coeff<double>::one);
  }


template <int W_, int I_>
ap_ufixed<W_,I_> erf(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xs = x;
    return erf(xs);
}

template <int I_>
ap_int<I_> erf(ap_int<I_> x) {
    ap_fixed<I_,I_> xs = x;
    return erf(xs);
}

template <int I_>
ap_uint<I_> erf(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xs = x;
    return erf(xs);
}
# 513 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_erf_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> erfc(ap_fixed<W_,I_> x_fixed)
{
#pragma HLS PIPELINE II=1
 int F_ = W_ - I_;

    if (I_>33) return 0;
    else if (F_>32) return 0;

    double x = x_fixed.to_double();
    int32_t hx;
    uint32_t ix;
 double R,S,P,Q,s,y,z,r;

    fp_struct<double> fp_abs(x);
    fp_abs.sign=0;
    fp_struct<double> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erfc_traits<double>::segment[9],erfc_traits<double>::segment[10]);
    hx = tmp.to_int();
 ix = hx & erfc_traits<double>::segment[0];
 if(ix>=erfc_traits<double>::segment[1]) {

   if(hx>0)
  return ap_fixed<W_,I_>(coeff<double>::one/x);
   else
  return ap_fixed<W_,I_>(coeff<double>::two + coeff<double>::one/x);

 }

 if(ix < erfc_traits<double>::segment[2]) {
   double r1,r2,s1,s2,s3,z2,z4;
   if(ix < erfc_traits<double>::segment[3])
  return ap_fixed<W_,I_>(coeff<double>::one-x);
   z = x*x;




   r1 = coeff<double>::pp[0]+z*coeff<double>::pp[1]; z2=z*z;
   r2 = coeff<double>::pp[2]+z*coeff<double>::pp[3]; z4=z2*z2;
   s1 = coeff<double>::one+z*coeff<double>::qq[1];
   s2 = coeff<double>::qq[2]+z*coeff<double>::qq[3];
   s3 = coeff<double>::qq[4]+z*coeff<double>::qq[5];
   r = r1 + z2*r2 + z4*coeff<double>::pp[4];
   s = s1 + z2*s2 + z4*s3;

   y = r/s;
   if(ix < erfc_traits<double>::segment[4]) {
  return ap_fixed<W_,I_>(coeff<double>::one-(x+x*y));
   } else {
  r = x*y;
  r += (x-coeff<double>::one_over_two);
  return ap_fixed<W_,I_>(coeff<double>::one_over_two - r) ;
   }
 }
 if(ix < erfc_traits<double>::segment[5]) {
   double s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;
   s =fp_abs.to_ieee()-coeff<double>::one;




   P1 = coeff<double>::pa[0]+s*coeff<double>::pa[1]; s2=s*s;
   Q1 = coeff<double>::one+s*coeff<double>::qa[1]; s4=s2*s2;
   P2 = coeff<double>::pa[2]+s*coeff<double>::pa[3]; s6=s4*s2;
   Q2 = coeff<double>::qa[2]+s*coeff<double>::qa[3];
   P3 = coeff<double>::pa[4]+s*coeff<double>::pa[5];
   Q3 = coeff<double>::qa[4]+s*coeff<double>::qa[5];
   P4 = coeff<double>::pa[6];
   Q4 = coeff<double>::qa[6];
   P = P1 + s2*P2 + s4*P3 + s6*P4;
   Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

   if(hx>=0) {
  z = coeff<double>::one-coeff<double>::erx;
        return ap_fixed<W_,I_>(z - P/Q);
   } else {
  z = coeff<double>::erx+P/Q; return ap_fixed<W_,I_>(coeff<double>::one+z);
   }
 }
 if (ix < erfc_traits<double>::segment[6]) {
   x = fp_abs.to_ieee();
   s = coeff<double>::one/(x*x);
   if(ix< erfc_traits<double>::segment[7]) {






  double R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
     R1 = coeff<double>::ra[0]+s*coeff<double>::ra[1];s2 = s*s;
     S1 = coeff<double>::one+s*coeff<double>::sa[1]; s4 = s2*s2;
     R2 = coeff<double>::ra[2]+s*coeff<double>::ra[3];s6 = s4*s2;
     S2 = coeff<double>::sa[2]+s*coeff<double>::sa[3];s8 = s4*s4;
     R3 = coeff<double>::ra[4]+s*coeff<double>::ra[5];
     S3 = coeff<double>::sa[4]+s*coeff<double>::sa[5];
     R4 = coeff<double>::ra[6]+s*coeff<double>::ra[7];
     S4 = coeff<double>::sa[6]+s*coeff<double>::sa[7];
     R = R1 + s2*R2 + s4*R3 + s6*R4;
     S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<double>::sa[8];

   } else {
  double R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
  if(hx<0&&ix>=erfc_traits<double>::segment[8]) return ap_fixed<W_,I_>(coeff<double>::two-coeff<double>::tiny);






  R1 = coeff<double>::rb[0]+s*coeff<double>::rb[1];s2 = s*s;
  S1 = coeff<double>::one+s*coeff<double>::sb[1]; s4 = s2*s2;
  R2 = coeff<double>::rb[2]+s*coeff<double>::rb[3];s6 = s4*s2;
  S2 = coeff<double>::sb[2]+s*coeff<double>::sb[3];
  R3 = coeff<double>::rb[4]+s*coeff<double>::rb[5];
  S3 = coeff<double>::sb[4]+s*coeff<double>::sb[5];
  S4 = coeff<double>::sb[6]+s*coeff<double>::sb[7];
  R = R1 + s2*R2 + s4*R3 + s6*coeff<double>::rb[6];
  S = S1 + s2*S2 + s4*S3 + s6*S4;

   }
   z = x;

   fp_struct<double> fp_z(z);
   ap_uint<Type_BitWidth<double>::Value> data = fp_z.data() & erf_traits<double>::mask;
   fp_struct<double> fp_z_new(data);
   z = fp_z_new.to_ieee();


   ap_fixed<W_, I_> r_fixed = exp_reduce::exp((ap_fixed<W_, I_>)(-z*z-(double)0.5625))*exp_reduce::exp((ap_fixed<W_, I_>)((z-x)*(z+x)+R/S));
   double r = r_fixed.to_double();
   double r_x = r/x;
   if(hx>0) {





        if(fp_x.exp == 0x0 && fp_x.sign!= 0x0){
   return 0;
        }
  return ap_fixed<W_,I_>(r_x);
   } else
  return ap_fixed<W_,I_>(coeff<double>::two-r_x);
 } else {
   if(hx>0) return ap_fixed<W_,I_>(coeff<double>::tiny*coeff<double>::tiny);
      else return ap_fixed<W_,I_>(coeff<double>::two-coeff<double>::tiny);
 }

}
template <int W_, int I_>
ap_ufixed<W_,I_> erfc(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xs = x;
    return erfc(xs);
}

template <int I_>
ap_int<I_> erfc(ap_int<I_> x) {
    ap_fixed<I_,I_> xs = x;
    return erfc(xs);
}

template <int I_>
ap_uint<I_> erfc(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xs = x;
    return erfc(xs);
}

}
# 1080 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h" 1
# 40 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 41 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_fmod_rem_quo_remainder_divide_apfixed.h" 2



namespace hls_internal{

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_divide(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        if(y==0){




                return 0;

        } else{
     return(x/y);
        }
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_divide(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
     ap_fixed<W_+1,I_+1> x1 = x;
     ap_fixed<W_+1,I_+1> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int I_>
    ap_int<I_> generic_divide(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> x1 = x;
     ap_fixed<I_,I_> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int I_>
    ap_uint<I_> generic_divide(ap_uint<I_> x, ap_uint<I_> y){
     ap_ufixed<I_,I_> x1 = x;
     ap_ufixed<I_,I_> y1 = y;
     return generic_divide(x1,y1);
    }

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_fmod(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
        ap_ufixed<W_,I_> y_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)y);


        if(x_pos==0 || y_pos==0) return 0;
     else if(x_pos == y_pos) return 0;
        else if(x_pos < y_pos) return x;
        else {
            ap_uint<W_> x_int = 0;
            ap_uint<W_> y_int = 0;
            x_int(W_-1,0) = x_pos(W_-1,0);
            y_int(W_-1,0) = y_pos(W_-1,0);






            ap_uint<W_> d = x_int/y_int;

            ap_uint<W_> rem = x_int - d*y_int;

            ap_fixed<W_,I_> r = 0;
            r(W_-1,0) = rem(W_-1,0);
            if(x[W_-1]) return -r;
            else return r;
        }
    }


    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_fmod(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
        ap_fixed<W_+1,I_+1> xi = x;
        ap_fixed<W_+1,I_+1> yi = y;
        return generic_fmod(xi,yi);
    }

    template <int I_>
    ap_int<I_> generic_fmod(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_fmod(xi,yi);
    }

    template <int I_>
    ap_uint<I_> generic_fmod(ap_uint<I_> x, ap_uint<I_> y){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_fmod(xi,yi);
    }


    template <int W_, int I_>
    ap_fixed<W_,I_> generic_remquo(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y, int* quo){
        ap_ufixed<W_,I_> x_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)x);
        ap_ufixed<W_,I_> y_pos = fabs_fixed((ap_fixed<W_+1,I_+1>)y);
        if(x_pos==0 || y_pos==0) {
           *quo = 0;
           return 0;
        } else if(x_pos == y_pos) {
           if(x[W_-1]==y[W_-1]) *quo = 1;
           else *quo = -1;
           return 0;
        }

        else {
            ap_uint<W_> x_int = 0;
            ap_uint<W_> y_int = 0;
            x_int(W_-1,0) = x_pos(W_-1,0);
            y_int(W_-1,0) = y_pos(W_-1,0);





            ap_uint<W_> d = x_int/y_int;
            ap_uint<W_> rem = x_int - d*y_int;

            ap_uint<W_> y_half = 0;
            y_half(W_-2,0) = y_int(W_-1,1);
            ap_uint<1> r_sig = x[W_-1];
            if(rem > y_half) {
                rem = y_int - rem;
                d++;
                if(x[W_-1]) r_sig = 0;
                else r_sig = 1;
            }

            if(x[W_-1]==y[W_-1]) *quo = d;
            else *quo = -d;
            ap_fixed<W_,I_> r = 0;
            r(W_-1,0) = rem(W_-1,0);
            if(r_sig) return -r;
            else return r;
        }
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_remquo(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y, int* quo){
     ap_fixed<W_+1,I_+1> xi = x;
     ap_fixed<W_+1,I_+1> yi = y;
     return generic_remquo(xi,yi,quo);
    }

    template <int I_>
    ap_int<I_> generic_remquo(ap_int<I_> x, ap_int<I_> y, int* quo){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_remquo(xi,yi,quo);
    }

    template <int I_>
    ap_uint<I_> generic_remquo(ap_uint<I_> x, ap_uint<I_> y, int* quo){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_remquo(xi,yi,quo);
    }


    template <int W_, int I_>
    ap_fixed<W_,I_> generic_remainder(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
        int quo = 0;
        return generic_remquo(x, y, &quo);
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_remainder(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
        ap_fixed<W_+1, I_+1> xi = x;
        ap_fixed<W_+1, I_+1> yi = y;
        return generic_remainder(xi,yi);
    }

    template <int I_>
    ap_int<I_> generic_remainder(ap_int<I_> x, ap_int<I_> y){
     ap_fixed<I_,I_> xi = x;
     ap_fixed<I_,I_> yi = y;
     return generic_remainder(xi,yi);
    }

    template <int I_>
    ap_uint<I_> generic_remainder(ap_uint<I_> x, ap_uint<I_> y){
     ap_fixed<I_+1,I_+1> xi = x;
     ap_fixed<I_+1,I_+1> yi = y;
     return generic_remainder(xi,yi);
    }
}
# 1081 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_lgamma_apfixed.h" 1
# 35 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_lgamma_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 36 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_lgamma_apfixed.h" 2

# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_traits.h" 1
# 37 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_traits.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 38 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_traits.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_x_complex.h" 1
# 42 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_x_complex.h"
namespace std {
template<typename _Tp> class complex;
}

namespace hls {
# 59 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_x_complex.h"
template<typename T> class x_complex {

  private:
    T re, im;

  public:

    typedef x_complex<T> MULT_RT;

    x_complex() {};
    x_complex(const T& r, const T& i) { re = r; im = i; };
    x_complex(const T& r) { re = r; im = 0; };
    x_complex(const std::complex<T> &z) : re(z.real()),im(z.imag()) {}
    template<typename T2>
    x_complex(const x_complex<T2> &z) : re(z.real()),im(z.imag()) {};


    inline T real() const { return(re); };
    inline T& real() { return(re); };

    inline void real(const T& r) { re = r; };

    inline T imag() const { return(im); };
    inline T& imag() { return(im); };

    inline void imag(const T& i) { im = i; };


    inline x_complex<T>& operator= (const T& rhs) {
      re = rhs; im = 0; return *this; };
    inline x_complex<T>& operator= (const x_complex<T>& rhs) {
      re = rhs.real(); im = rhs.imag(); return *this; };
    template<typename T2>
    inline x_complex<T>& operator= (const x_complex<T2>& rhs) {
      re = rhs.real(); im = rhs.imag(); return *this; };


    inline x_complex<T>& operator*= (const T& rhs) {
      re *= rhs;
      im *= rhs;
      return *this;
    };
    inline x_complex<T>& operator*= (const x_complex<T>& rhs) {
      T tmp1 = re*rhs.real();
      T tmp2 = im*rhs.imag();
      T tmp3 = re*rhs.imag();
      T tmp4 = im*rhs.real();
      re = tmp1 - tmp2;
      im = tmp3 + tmp4;
      return *this;
    };
    template<typename T2>
    inline x_complex<T>& operator*= (const x_complex<T2>& rhs) {
      x_complex<T> tmp(rhs.real(), rhs.imag());
      *this *= tmp;
      return *this;
    };

    inline MULT_RT operator* (const T& rhs) {
      x_complex_mult_real:;
      x_complex<T> tmp(*this);
      tmp *= rhs;
      return tmp;
    };
    inline MULT_RT operator* (const x_complex<T>& rhs) {
      x_complex_mult_complex:;
      x_complex<T> tmp(*this);
      tmp *= rhs;
      return tmp;
    }
    template<typename T2>
    inline MULT_RT operator* (const x_complex<T2>& rhs) {
      x_complex_mult_complex:;
      x_complex<T> tmp(rhs.real(), rhs.imag());
      MULT_RT res = *this * tmp;
      return res;
    };


    inline x_complex<T>& operator/= (const T& rhs) {;
      re /= rhs;
      im /= rhs;
      return *this;
    };
    inline x_complex<T>& operator/= (const x_complex<T>& rhs) {
      x_complex<T> conj ( rhs.real(), -rhs.imag());
      x_complex<T> a = (*this)*conj;
      x_complex<T> b = conj*rhs;
      re = a.real() / b.real();
      im = a.imag() / b.real();
      return *this;
    };
    template<typename T2>
    inline x_complex<T>& operator/= (const x_complex<T2>& rhs) {
      x_complex<T> tmp(rhs.real(), rhs.imag());
      *this /= tmp;
      return *this;
    };

    inline x_complex<T> operator/ (const T& rhs) {
      x_complex<T> tmp(*this);
      tmp /= rhs; return tmp;
    };
    inline x_complex<T> operator/ (const x_complex<T>& rhs) {
      x_complex<T> tmp(*this);
      tmp /= rhs;
      return tmp;
    };
    template<typename T2>
    inline x_complex<T> operator/ (const x_complex<T2>& rhs) {
      x_complex<T> tmp(*this);
      tmp /= rhs;
      return tmp;
    };


    inline x_complex<T>& operator+= (const T& rhs) {
      re += rhs;
      return *this;
    };
    inline x_complex<T> operator+= (const x_complex<T>& rhs) {
      re += rhs.real();
      im += rhs.imag();
      return *this;
    };
    template<typename T2>
    inline x_complex<T> operator+= (const x_complex<T2>& rhs) {
      re += rhs.real();
      im += rhs.imag();
      return *this; };

    inline x_complex<T> operator+ (const T& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp += rhs;
      return tmp;
    };
    inline x_complex<T> operator+ (const x_complex<T>& rhs) {
       x_complex<T> tmp ;
       tmp = *this;
       tmp += rhs;
       return tmp;
    };
    template<typename T2>
    inline x_complex<T> operator+ (const x_complex<T2>& rhs) {
       x_complex<T> tmp ;
       tmp = *this;
       tmp += rhs;
       return tmp;
    };



    inline x_complex<T>& operator-= (const T& rhs) {
      re -= rhs;
      return *this;
    }
    inline x_complex<T>& operator-= (const x_complex<T>& rhs) {
      re -= rhs.real();
      im -= rhs.imag();
      return *this;
    };
    template<typename T2>
    inline x_complex<T>& operator-= (const x_complex<T2>& rhs) {
      re -= rhs.real();
      im -= rhs.imag();
      return *this;
    };

    inline x_complex<T> operator- (const T& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp -= rhs;
      return tmp;
    };
    inline x_complex<T> operator- (const x_complex<T>& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp -= rhs;
      return tmp;
    };
    template<typename T2>
    inline x_complex<T> operator- (const x_complex<T2>& rhs) {
      x_complex<T> tmp ;
      tmp = *this;
      tmp -= rhs;
      return tmp;
    };

    inline x_complex<T> operator- () {
      x_complex<T> tmp(*this);
      tmp.real(-real());
      tmp.imag(-imag());
      return tmp;
    };


  x_complex<T> &operator=(const std::complex<T> &t) {
    re = t.real();
    im = t.imag();
    return *this;
  }

  operator std::complex<T> () const {
    return std::complex<T>(re, im);
  }

  std::complex<T> to_std_complex(){
     return std::complex<T>(re ,im);
  }
# 281 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_x_complex.h"
  };


  template<typename T>
  inline bool operator== (const T& lhs, const x_complex<T>& rhs) {
    return (lhs == rhs.real()) && (0 == rhs.imag());
  }
  template<typename T>
  inline bool operator== (const x_complex<T>& lhs, const T& rhs) {
    return (lhs.real() == rhs) && (lhs.imag() == 0);
  }
  template<typename T>
  inline bool operator== (const x_complex<T>& lhs, const x_complex<T>& rhs) {
    return (lhs.real() == rhs.real()) && (lhs.imag() == rhs.imag());
  }

  template<typename T>
  inline bool operator!= (const T& lhs, const x_complex<T>& rhs) {
    return (lhs != rhs.real()) || (0 != rhs.imag());
  }
  template<typename T>
  inline bool operator!= (const x_complex<T>& lhs, const T& rhs) {
    return (lhs.real() != rhs) || (lhs.imag() != 0);
  }
  template<typename T>
  inline bool operator!= (const x_complex<T>& lhs, const x_complex<T>& rhs) {
    return (lhs.real() != rhs.real()) || (lhs.imag() != rhs.imag());
  }

  template<typename T>
  x_complex<T> x_neg(x_complex<T> &din) {
    x_complex<T> tmp;
    tmp.real(-din.real());
    tmp.imag(-din.imag());
    return(tmp);
  }

  template<typename T>
  x_complex<T> x_conj_sq(x_complex<T> &din) {
    x_conj_sq_complex:;
    return ( (din.real()*din.real()) + (din.imag()*din.imag()));
  }

  template<typename T>
  x_complex<T> x_conj(const x_complex<T> &din) {
    x_conj_complex:;
    x_complex<T> tmp;
    tmp.real(din.real());
    tmp.imag(-din.imag());
    return(tmp);
  }



  template<typename T>
  x_complex<T> x_conj(x_complex<T> &din) {
    const x_complex<T> tmp = din;
    return(x_conj(tmp));
  }

  template<int W, int I> void set_to_one(x_complex<ap_fixed<W,I> > &a) {
    ap_int<W> tmp_sat = ((ap_int<W-I+1>)1<<(W-I)) - 1;
    ap_fixed<W,I> tmp;
    tmp.range() = tmp_sat;
    a = tmp;
  }

  template<typename T>
  T x_real(const x_complex<T> &din) {
    return(din.real());
  }

  template<typename T>
  T x_imag(const x_complex<T> &din) {
    return(din.imag());
  }

  template<typename T1>
  typename x_complex<T1>::MULT_RT operator* (const T1& lhs, x_complex<T1>& rhs) {
    return (rhs*lhs);
  }

}
# 39 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_traits.h" 2





namespace hls
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
# 69 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_traits.h"
};
template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };
# 102 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_traits.h"
template<>
struct x_traits< char , char > : public x_traits_default< char > {};

template<>
struct x_traits< char , signed char > : public x_traits_default< signed char > {};

template<>
struct x_traits< char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< char , short > : public x_traits_default< short > {};

template<>
struct x_traits< char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< char , int > : public x_traits_default< int > {};

template<>
struct x_traits< char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< char , long > : public x_traits_default< long > {};

template<>
struct x_traits< char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< char , half > : public x_traits_default< float > {};

template<>
struct x_traits< char , float > : public x_traits_default< float > {};

template<>
struct x_traits< char , double > : public x_traits_default< double > {};

template<>
struct x_traits< signed char , char > : public x_traits_default< signed char > {};

template<>
struct x_traits< signed char , signed char > : public x_traits_default< signed char > {};

template<>
struct x_traits< signed char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< signed char , short > : public x_traits_default< short > {};

template<>
struct x_traits< signed char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< signed char , int > : public x_traits_default< int > {};

template<>
struct x_traits< signed char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< signed char , long > : public x_traits_default< long > {};

template<>
struct x_traits< signed char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< signed char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< signed char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< signed char , half > : public x_traits_default< float > {};

template<>
struct x_traits< signed char , float > : public x_traits_default< float > {};

template<>
struct x_traits< signed char , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned char , char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , signed char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , unsigned char > : public x_traits_default< unsigned char > {};

template<>
struct x_traits< unsigned char , short > : public x_traits_default< short > {};

template<>
struct x_traits< unsigned char , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned char , int > : public x_traits_default< int > {};

template<>
struct x_traits< unsigned char , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned char , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned char , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned char , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned char , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned char , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned char , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned char , double > : public x_traits_default< double > {};

template<>
struct x_traits< short , char > : public x_traits_default< short > {};

template<>
struct x_traits< short , signed char > : public x_traits_default< short > {};

template<>
struct x_traits< short , unsigned char > : public x_traits_default< short > {};

template<>
struct x_traits< short , short > : public x_traits_default< short > {};

template<>
struct x_traits< short , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< short , int > : public x_traits_default< int > {};

template<>
struct x_traits< short , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< short , long > : public x_traits_default< long > {};

template<>
struct x_traits< short , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< short , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< short , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< short , half > : public x_traits_default< float > {};

template<>
struct x_traits< short , float > : public x_traits_default< float > {};

template<>
struct x_traits< short , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned short , char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , signed char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , unsigned char > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , unsigned short > : public x_traits_default< unsigned short > {};

template<>
struct x_traits< unsigned short , int > : public x_traits_default< int > {};

template<>
struct x_traits< unsigned short , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned short , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned short , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned short , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned short , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned short , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned short , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned short , double > : public x_traits_default< double > {};

template<>
struct x_traits< int , char > : public x_traits_default< int > {};

template<>
struct x_traits< int , signed char > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned char > : public x_traits_default< int > {};

template<>
struct x_traits< int , short > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned short > : public x_traits_default< int > {};

template<>
struct x_traits< int , int > : public x_traits_default< int > {};

template<>
struct x_traits< int , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< int , long > : public x_traits_default< long > {};

template<>
struct x_traits< int , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< int , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< int , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< int , half > : public x_traits_default< float > {};

template<>
struct x_traits< int , float > : public x_traits_default< float > {};

template<>
struct x_traits< int , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned int , char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , signed char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned char > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , short > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned short > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , unsigned int > : public x_traits_default< unsigned int > {};

template<>
struct x_traits< unsigned int , long > : public x_traits_default< long > {};

template<>
struct x_traits< unsigned int , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned int , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned int , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned int , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned int , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned int , double > : public x_traits_default< double > {};

template<>
struct x_traits< long , char > : public x_traits_default< long > {};

template<>
struct x_traits< long , signed char > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned char > : public x_traits_default< long > {};

template<>
struct x_traits< long , short > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned short > : public x_traits_default< long > {};

template<>
struct x_traits< long , int > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned int > : public x_traits_default< long > {};

template<>
struct x_traits< long , long > : public x_traits_default< long > {};

template<>
struct x_traits< long , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< long , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< long , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< long , half > : public x_traits_default< float > {};

template<>
struct x_traits< long , float > : public x_traits_default< float > {};

template<>
struct x_traits< long , double > : public x_traits_default< double > {};

template<>
struct x_traits< unsigned long , char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , signed char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned char > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , short > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned short > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , int > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned int > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , unsigned long > : public x_traits_default< unsigned long > {};

template<>
struct x_traits< unsigned long , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< unsigned long , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< unsigned long , half > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned long , float > : public x_traits_default< float > {};

template<>
struct x_traits< unsigned long , double > : public x_traits_default< double > {};

template<>
struct x_traits< ap_slong , char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , signed char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned char > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , short > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned short > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , int > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned int > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , long > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , unsigned long > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , ap_slong > : public x_traits_default< ap_slong > {};

template<>
struct x_traits< ap_slong , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_slong , half > : public x_traits_default< float > {};

template<>
struct x_traits< ap_slong , float > : public x_traits_default< float > {};

template<>
struct x_traits< ap_slong , double > : public x_traits_default< double > {};

template<>
struct x_traits< ap_ulong , char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , signed char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned char > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , short > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned short > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , int > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned int > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , long > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , unsigned long > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , ap_slong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , ap_ulong > : public x_traits_default< ap_ulong > {};

template<>
struct x_traits< ap_ulong , half > : public x_traits_default< float > {};

template<>
struct x_traits< ap_ulong , float > : public x_traits_default< float > {};

template<>
struct x_traits< ap_ulong , double > : public x_traits_default< double > {};

template<>
struct x_traits< half , char > : public x_traits_default< float > {};

template<>
struct x_traits< half , signed char > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned char > : public x_traits_default< float > {};

template<>
struct x_traits< half , short > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned short > : public x_traits_default< float > {};

template<>
struct x_traits< half , int > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned int > : public x_traits_default< float > {};

template<>
struct x_traits< half , long > : public x_traits_default< float > {};

template<>
struct x_traits< half , unsigned long > : public x_traits_default< float > {};

template<>
struct x_traits< half , ap_slong > : public x_traits_default< float > {};

template<>
struct x_traits< half , ap_ulong > : public x_traits_default< float > {};

template<>
struct x_traits< half , half > : public x_traits_default< half > {};

template<>
struct x_traits< half , float > : public x_traits_default< float > {};

template<>
struct x_traits< half , double > : public x_traits_default< double > {};

template<>
struct x_traits< float , char > : public x_traits_default< float > {};

template<>
struct x_traits< float , signed char > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned char > : public x_traits_default< float > {};

template<>
struct x_traits< float , short > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned short > : public x_traits_default< float > {};

template<>
struct x_traits< float , int > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned int > : public x_traits_default< float > {};

template<>
struct x_traits< float , long > : public x_traits_default< float > {};

template<>
struct x_traits< float , unsigned long > : public x_traits_default< float > {};

template<>
struct x_traits< float , ap_slong > : public x_traits_default< float > {};

template<>
struct x_traits< float , ap_ulong > : public x_traits_default< float > {};

template<>
struct x_traits< float , half > : public x_traits_default< float > {};

template<>
struct x_traits< float , float > : public x_traits_default< float > {};

template<>
struct x_traits< float , double > : public x_traits_default< double > {};

template<>
struct x_traits< double , char > : public x_traits_default< double > {};

template<>
struct x_traits< double , signed char > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned char > : public x_traits_default< double > {};

template<>
struct x_traits< double , short > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned short > : public x_traits_default< double > {};

template<>
struct x_traits< double , int > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned int > : public x_traits_default< double > {};

template<>
struct x_traits< double , long > : public x_traits_default< double > {};

template<>
struct x_traits< double , unsigned long > : public x_traits_default< double > {};

template<>
struct x_traits< double , ap_slong > : public x_traits_default< double > {};

template<>
struct x_traits< double , ap_ulong > : public x_traits_default< double > {};

template<>
struct x_traits< double , half > : public x_traits_default< double > {};

template<>
struct x_traits< double , float > : public x_traits_default< double > {};

template<>
struct x_traits< double , double > : public x_traits_default< double > {};





template<int A,int B> class MAX{
  public:
    const static int value = (A > B) ? A : B;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<MAX<W1,W2+1>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2+1>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1+1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1+1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};




    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <int,DIM>:x_traits_d_default<int, DIM> {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<typename T>
struct x_traits<x_complex<T>, x_complex<T> > {
    typedef x_complex<T> ADD_T;
    typedef x_complex<T> SAT_T;
    typedef x_complex<T> MULT_T;
    typedef x_complex<T> MADD_T;
    typedef x_complex<int> INT_T;
    typedef x_complex<float_struct<24,8> > FLOAT_STRUCT_T;
};



template<int W1, int I1, int W2, int I2>
struct x_traits<x_complex<ap_fixed<W1,I1> >,x_complex<ap_fixed<W2,I2> > > {
    typedef x_complex<ap_fixed<((I1) > (I2) ? (I1) : (I2))+1+((W1-I1) > (W2-I2) ? (W1-I1) : (W2-I2)),((I1) > (I2) ? (I1) : (I2))+1> > ADD_T;
    typedef x_complex<ap_fixed<W1,I1,AP_RND,AP_SAT> > SAT_T;
    typedef x_complex<ap_fixed<W1+W2+1,I1+I2+1> > MULT_T;
    typedef x_complex<ap_fixed<W1+W2+2,I1+I2+2> > MADD_T;
    typedef x_complex<ap_fixed<(2*W1)+1,(2*I1)+1> > CONJ_SQ_T;
    typedef x_complex<int> INT_T;
    typedef x_complex<float_struct<24,8> > FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<x_complex<ap_int<W1> >,x_complex<ap_int<W2> > > {
    typedef x_complex<ap_int<((W1) > (W2) ? (W1) : (W2))+1> > ADD_T;
    typedef x_complex<ap_int<W1> > SAT_T;
    typedef x_complex<ap_int<W1+W2+1> > MULT_T;
    typedef x_complex<ap_int<W1+W2+2> > MADD_T;
    typedef x_complex<ap_int<(2*W1)+1> > CONJ_SQ_T;
    typedef x_complex<int> INT_T;
    typedef x_complex<float_struct<24,8> > FLOAT_STRUCT_T;
};



template<int DIM, typename T>
struct x_traits_d <x_complex<T>,DIM> {
    typedef x_complex<T> ACCUM_T;
    typedef x_complex<T> ACCUM2_T;
    typedef x_complex<ap_int<25+DIM> > ADD_TREE_T;
};

template<int DIM, int W, int I>
struct x_traits_d <x_complex<ap_fixed<W,I> >,DIM> {
    typedef x_complex<ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value> > ACCUM_T;
    typedef x_complex<ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value> > ACCUM2_T;
};

}



namespace hlstmp
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
# 944 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/utils/x_hls_traits.h"
};

template<>
struct x_traits<double, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<>
struct x_traits<float, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<>
struct x_traits<half, half> : public x_traits_default<half> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };

template<>
struct x_traits<double, float> : public x_traits_default<double> { };

template<>
struct x_traits<float, double> : public x_traits_default<double> { };

template<>
struct x_traits<double, half> : public x_traits_default<double> { };

template<>
struct x_traits<half, double> : public x_traits_default<double> { };

template<>
struct x_traits<int, int> : public x_traits_default<int> { };

template<>
struct x_traits<unsigned int, unsigned int> : public x_traits_default<unsigned int> { };

template<>
struct x_traits<int64_t, int64_t> : public x_traits_default<int64_t> { };

template<int A,int B> class MAX{
  public:
    const static int value = (A > B) ? A : B;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<MAX<W1,W2+1>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2+1>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1+1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1+1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<typename T>
struct x_traits<std::complex<T>, std::complex<T> > {
    typedef std::complex<T> ADD_T;
    typedef std::complex<T> SAT_T;
    typedef std::complex<T> MULT_T;
    typedef std::complex<T> MADD_T;
    typedef std::complex<int> INT_T;
    typedef std::complex<float_struct<24,8> > FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};




    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <int,DIM>:x_traits_d_default<int, DIM> {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int DIM, typename T>
struct x_traits_d <std::complex<T>, DIM> {
    typedef std::complex<T> ACCUM_T;
    typedef std::complex<T> ACCUM2_T;
    typedef std::complex<ap_int<25+DIM> > ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

}
# 38 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_lgamma_apfixed.h" 2


namespace lgamma_fixed {

template <int W, int I> ap_fixed<W, I> lgamma_generic(ap_fixed<W, I> x_fixed) {
#pragma HLS pipeline

 double x = x_fixed.to_double();
  double r = hls::lgamma(x);
  fp_struct<double> out(r);
  ap_ufixed<W+1, I+1> ret = 1;
  int F = W - I;
  if (F > 52) F = 52;
  if (W > I) ret(F - 1, 0) = out.sig(52 - 1, 52 - F);
  ret = (ret << (out.exp - fp_struct<double>::EXP_BIAS));
  return ap_fixed<W, I>(ret);
}

template <int W, int I> ap_ufixed<W, I> lgamma_generic(ap_ufixed<W, I> x) {
  ap_fixed<W + 1, I + 1> xf = x;
  return lgamma_generic(xf);
}
template <int I_> ap_int<I_> lgamma_generic(ap_int<I_> x) {
  ap_fixed<I_, I_> xf = x;
  return lgamma_generic(xf);
}
template <int I_> ap_uint<I_> lgamma_generic(ap_uint<I_> x) {
  ap_fixed<I_ + 1, I_ + 1> xf = x;
  return lgamma_generic(xf);
}


template <int W, int I> ap_fixed<W, I> lgamma_r_generic(ap_fixed<W, I> x, int *signgamp) {
  *signgamp = 1;
  return lgamma_generic(x);
}

template <int W, int I> ap_ufixed<W, I> lgamma_r_generic(ap_ufixed<W, I> x, int *signgamp) {
  ap_fixed<W + 1, I + 1> xf = x;
  return lgamma_r_generic(xf, signgamp);
}

template <int I_> ap_int<I_> lgamma_r_generic(ap_int<I_> x, int *signgamp) {
  ap_fixed<I_, I_> xf = x;
  return lgamma_r_generic(xf, signgamp);
}

template <int I_> ap_uint<I_> lgamma_r_generic(ap_uint<I_> x, int *signgamp) {
  ap_fixed<I_ + 1, I_ + 1> xf = x;
  return lgamma_r_generic(xf, signgamp);
}

}
# 1082 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_tgamma_apfixed.h" 1
# 35 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_tgamma_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 36 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_tgamma_apfixed.h" 2





namespace tgamma_fixed {

template <int W, int I> ap_fixed<W, I> tgamma_generic(ap_fixed<W, I> x_fixed) {
#pragma HLS pipeline

 double x = x_fixed.to_double();
  double r = hls::tgamma(x);
  fp_struct<double> out(r);
  ap_ufixed<W+1, I+1> ret = 1;
  int F = W - I;
  if (F > 52) F = 52;
  if (W > I) ret(F - 1, 0) = out.sig(52 - 1, 52 - F);
  ret = (ret << (out.exp - fp_struct<double>::EXP_BIAS));
  return ap_fixed<W, I>(ret);
}

template <int W, int I> ap_ufixed<W, I> tgamma_generic(ap_ufixed<W, I> x) {
  ap_fixed<W + 1, I + 1> xf = x;
  return tgamma_generic(xf);
}
template <int I_> ap_int<I_> tgamma_generic(ap_int<I_> x) {
  ap_fixed<I_, I_> xf = x;
  return tgamma_generic(xf);
}
template <int I_> ap_uint<I_> tgamma_generic(ap_uint<I_> x) {
  ap_fixed<I_ + 1, I_ + 1> xf = x;
  return tgamma_generic(xf);
}

}
# 1083 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_fract_apfixed.h" 1








namespace hls_fract {

template <int W_, int I_>
ap_fixed<W_,I_> generic_fract(ap_fixed<W_,I_> x){
 if (W_==I_)return 0;
 ap_fixed<W_-I_+1,1> x1=x;
 ap_fixed<W_-I_+1,1> x2=x1+ap_int<2>(1);
 return x[W_-1]?x2:x1;
}

template <int W_, int I_>
ap_ufixed<W_,I_> generic_fract(ap_ufixed<W_,I_> x){
 ap_fixed<W_+1,I_+1> x1=x;
 return generic_fract(x1);
}

template <int I_>
ap_int<I_> generic_fract(ap_int<I_> x){
 ap_fixed<I_,I_> x1 = x;
 return generic_fract(x1);
}

template <int I_>
ap_uint<I_> generic_fract(ap_uint<I_> x){
 ap_ufixed<I_,I_> x1 = x;
 return generic_fract(x1);
}
}
# 1084 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_mad_apfixed.h" 1




namespace hls_mad {

    template <int W_, int I_>
    ap_fixed<W_,I_> generic_mad(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y, ap_fixed<W_,I_> z){
        const int F_ = W_ - I_;
        ap_fixed<2*W_, 2*I_> mul = x * y;

        ap_fixed<2, -F_> delta = 0;
        delta[0] = 1;
        delta[1] = mul[2*W_-1];

        mul += delta;

        ap_fixed<W_+1, I_+1> mul_s = mul;
        ap_fixed<W_+1, I_+1> sum = mul_s + z;
        ap_fixed<W_,I_> r = 0;

        if(sum[W_-1]!=sum[W_]) {
           VITIS_LOOP_23_1: for(int i = 0; i < W_-1; ++i) {
#pragma HLS unroll
 r[i] = !sum[W_];
           }
           r[W_-1] = sum[W_];
        } else {
           r = sum;
        }
        return r;
    }

    template <int W_, int I_>
    ap_ufixed<W_,I_> generic_mad(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y, ap_ufixed<W_,I_> z){
        ap_fixed<W_+1, I_+1> xi = x;
        ap_fixed<W_+1, I_+1> yi = y;
        ap_fixed<W_+1, I_+1> zi = z;
        return generic_mad(xi, yi, zi);
    }

    template <int I_>
    ap_int<I_> generic_mad(ap_int<I_> x, ap_int<I_> y, ap_int<I_> z){
        ap_fixed<I_, I_> xi = x;
        ap_fixed<I_, I_> yi = y;
        ap_fixed<I_, I_> zi = z;
        return generic_mad(xi, yi, zi);
    }

    template <int I_>
    ap_uint<I_> generic_mad(ap_uint<I_> x, ap_uint<I_> y, ap_uint<I_> z){
        ap_fixed<I_+1,I_+1> xi = x;
        ap_fixed<I_+1,I_+1> yi = y;
        ap_fixed<I_+1,I_+1> zi = z;
        return generic_mad(xi,yi,zi);
    }
}
# 1085 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cbrt_apfixed.h" 1
# 40 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cbrt_apfixed.h"
namespace cbrt_internal{
template <int W, int I>
ap_fixed<W, I> cbrt_fixed(ap_fixed<W,I> x) {






   const int F = W - I;
   if(I > 33) return 0;
   else if(F > 32) return 0;

   ap_fixed<W+1, I+1> xi = x;
   ap_ufixed<W, I> x_p = fabs_fixed(xi);





   ap_ufixed<F +(I+2)/3, (I+2)/3> r = 0;;
      const static int prcs = (F+1)*3;
      const static int msbr = (I>0)? (I+2)/3 : 1;
      ap_ufixed<2*msbr+prcs+2,2*msbr+2> resq = 0;
      ap_ufixed<msbr+prcs+1, msbr+1> res = 0;
      ap_ufixed<3*msbr+prcs+4, 3*msbr+4> x_rem = x_p;
      VITIS_LOOP_66_1: for(int pos = msbr - 1 ; pos >= -F-1; pos--) {
          ap_ufixed<3*msbr+prcs+2, 3*msbr+2> mul1a = 0;
          ap_ufixed<3*msbr+prcs+1, 3*msbr+1> mul1b = 0;




          mul1a(pos+2*msbr+prcs+2, prcs+3*pos+3) = resq(prcs+2*msbr+1, prcs+2*pos+2);

          mul1b(pos+2*msbr+prcs+1, prcs+3*pos+2) = resq(prcs+2*msbr+1, prcs+2*pos+2);



          ap_ufixed<3*msbr+prcs, 3*msbr> mul2a = 0;
          ap_ufixed<3*msbr+prcs-1, 3*msbr-1> mul2b = 0;

          mul2a(pos*2+msbr+prcs+1, pos*3+2+prcs) = res(msbr+prcs, pos+1+prcs);

          mul2b(pos*2+msbr+prcs, pos*3+1+prcs) = res(msbr+prcs, pos+1+prcs);

          ap_ufixed<3*msbr+prcs+3, 3*msbr+3> mulL = 0;
          ap_ufixed<3*msbr+prcs+3, 3*msbr+3> mulH = 0;


          mulL(pos*2+msbr+prcs+3, pos*3+1+prcs) = mul2b(pos*2+msbr+prcs, pos*3+1+prcs) + mul2a(pos*2+msbr+prcs+1, pos*3+1+prcs) + mul1a(pos*2+msbr+prcs+1, pos*3+1+prcs) + mul1b(pos*2+msbr+prcs+1,pos*3+1+prcs);

          mulH(pos+2*msbr+prcs+3, pos*2+msbr+prcs+2) = mulL(pos*2+msbr+prcs+3, pos*2+msbr+prcs+2) + mul1a(pos+2*msbr+prcs+2,pos*2+msbr+prcs+2) + mul1b(pos+2*msbr+prcs+1,pos*2+msbr+prcs+2);
          mulL[3*pos+prcs] = 1;







          bool cond1 = (x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) > mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2));
          bool cond2 = (x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) == mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2));
          bool cond3 = (x_rem(pos*2+msbr+prcs+1,pos*3+prcs) >= mulL(pos*2+msbr+prcs+1,pos*3+prcs));
          if(cond1 | (cond2 & cond3)) {
             ap_ufixed<3*msbr+prcs+3,3*msbr+3> x_rem_L = 0;
             x_rem_L(pos*2+msbr+prcs+1, pos*3+prcs) = x_rem(pos*2+msbr+prcs+1, pos*3+prcs);

             x_rem_L[pos*2+msbr+prcs+2] = cond3? 0 : 1;
             x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) = x_rem(pos+2*msbr+prcs+4, pos*2+msbr+prcs+2) - mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2) - x_rem_L(pos*2+msbr+prcs+2,pos*2+msbr+prcs+2);
             x_rem(pos*2+msbr+prcs+1,pos*3+prcs) = x_rem_L(pos*2+msbr+prcs+2, pos*3+prcs) - mulL(pos*2+msbr+prcs+1,pos*3+prcs);





             ap_ufixed<2*msbr+prcs+1,2*msbr+1> mul1 = 0;
             mul1(pos+msbr+prcs+1, 2*pos+2+prcs) = res(msbr+prcs, pos+1+prcs);
             ap_ufixed<2*msbr+prcs+2,2*msbr+2> resq_L = 0;
             resq_L(pos+msbr+prcs+2,2*pos+2+prcs) = resq(pos+msbr+prcs+1,2*pos+2+prcs) + mul1(pos+msbr+prcs+1,2*pos+2+prcs);
             resq(pos+msbr+prcs+1,2*pos+2+prcs) = resq_L(pos+msbr+prcs+1,2*pos+2+prcs);
             resq(2*msbr+prcs+1,pos+msbr+2+prcs) = resq(2*msbr+prcs+1,pos+msbr+2+prcs) + resq_L(pos+msbr+2+prcs,pos+msbr+2+prcs);
             resq[2*pos+prcs] = 1;
             res[pos+prcs] = 1;
         }
# 133 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_cbrt_apfixed.h"
      }





      ap_ufixed<1,-F-1> delta;
      delta[0] = 1;
      ap_ufixed<msbr+F+1,msbr> res_s = res;
      res_s += delta;
      r = res_s;
      if(x[W-1]) return -r;
      else return r;
}

template<int W, int I>
ap_ufixed<W, I> cbrt_fixed(ap_ufixed<W, I> x) {
   ap_fixed<W+1,I+1> xi = x;
   return cbrt_fixed(xi);
}
template<int I>
ap_int<I> cbrt_fixed(ap_int<I> x) {
   ap_fixed<I,I> xi = x;
   return cbrt_fixed(xi);
}
template<int I>
ap_uint<I> cbrt_fixed(ap_uint<I> x) {
   ap_fixed<I+1,I+1> xi = x;
   return cbrt_fixed(xi);
}
}
# 1086 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hypot_apfixed.h" 1
# 39 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hypot_apfixed.h"
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/ap_int.h" 1
# 40 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hypot_apfixed.h" 2

namespace hypot_internal {
template<int W, int I>
ap_fixed<W, I> hypot_fixed(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    const static int F = W - I;
    if(I > 33) return 0;
    else if(F > 32) return 0;
# 55 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hypot_apfixed.h"
    if(x==0) return fabs_fixed(y);
    if(y==0) return fabs_fixed(x);

    ap_ufixed<2*W, I*2> x_sq = x * x;
    ap_ufixed<2*W, I*2> y_sq = y * y;
    ap_ufixed<2*W, I*2> xy_sq = x_sq + y_sq;
# 69 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hypot_apfixed.h"
    const static int prcs = (F+1)*2;
    const static int msbr = I > 0? I : 1;
    ap_ufixed<msbr, msbr> res_I = 0;
    ap_ufixed<2*msbr+1,2*msbr+1> x_l_I = 0;
    if(I>0) {
        x_l_I = xy_sq(2*W-1, 2*W-2*I);
        VITIS_LOOP_75_1: for(int pos = msbr - 1; pos >= 0; pos--) {
            ap_ufixed<2*msbr,2*msbr> mul_I = 0;



            mul_I(msbr+pos, 2*pos+1) = res_I(msbr-1, pos);
            mul_I[2*pos] = 1;
            if(x_l_I(msbr+pos+1, 2*pos) >= mul_I(msbr+pos, 2*pos)){



                ap_ufixed<2*msbr+1, 2*msbr+1> x_l_I_ = x_l_I;
                x_l_I(msbr+pos+1, 2*pos) = x_l_I(msbr+pos+1,2*pos) - mul_I(msbr+pos, 2*pos);



                res_I[pos] = 1;
           }
       }
    }
    ap_ufixed<msbr+1, msbr+1> x_l_I_s = x_l_I;
# 104 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hypot_apfixed.h"
    ap_ufixed<prcs/2,0> res_F = 0;
    ap_ufixed<prcs/2,0> x_l_FH = xy_sq;
    ap_ufixed<prcs/2, -prcs/2> x_l_FL = xy_sq;
    VITIS_LOOP_107_2: for(int pos = -1; pos >= -F-1; pos--) {
        ap_ufixed<msbr+prcs, msbr> mul = 0;



        mul(msbr+pos+prcs, pos+1+prcs) = res_I(msbr-1, 0);
        mul(pos+prcs, 2*pos+1+prcs) = res_F(prcs/2-1,pos+prcs/2);
        mul[2*pos+prcs] = 1;

        ap_ufixed<msbr, msbr> mul_I = 0;
        mul_I = mul;
        ap_ufixed<prcs/2, 0> mul_FH = mul;
        ap_ufixed<prcs/2, -prcs/2> mul_FL = mul;
# 139 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_hypot_apfixed.h"
        if((x_l_I_s > mul_I) || ((x_l_I_s == mul_I) && (x_l_FH > mul_FH)) || ((x_l_I_s == mul_I) && (x_l_FH == mul_FH) && (x_l_FL >= mul_FL))) {







           ap_ufixed<prcs/2+1, -prcs/2+1> x_l_FL_1 = x_l_FL;

           if(x_l_FL < mul_FL) x_l_FL_1[prcs/2] = 1;
           x_l_FL_1 -= mul_FL;



           ap_ufixed<prcs/2+1,1> x_l_FH_1 = x_l_FH;

           if((x_l_FH < mul_FH) || ((x_l_FH == mul_FH) && (x_l_FL < mul_FL))) x_l_FH_1[prcs/2] = 1;
           ap_ufixed<1, -prcs/2+1> delta = 0;
           if(x_l_FL < mul_FL) delta[0] = 1;

           x_l_FH_1 -= delta;
           x_l_FH_1 -= mul_FH;

           if((x_l_FH < mul_FH) || ((x_l_FH == mul_FH) && (x_l_FL < mul_FL))) x_l_I_s--;
           x_l_I_s -= mul_I;
           x_l_FH = x_l_FH_1;
           x_l_FL = x_l_FL_1;







           res_F[pos+prcs/2] = 1;
       }
    }
    ap_ufixed<prcs/2+1, 1> res_F_1 = res_F;

    ap_ufixed<1, -prcs/2+1> delta = 0;
    delta[0] = 1;
    res_F_1 += delta;
    if(res_F_1[prcs/2]) res_I++;
    ap_ufixed<msbr+prcs/2, msbr> res = 0;
    res(msbr+prcs/2-1, prcs/2) = res_I(msbr-1,0);
    res(prcs/2-1, 0) = res_F(prcs/2-1, 0);






    ap_fixed<W,I> r = 0;
    if(res[msbr+prcs/2-1]) {

       VITIS_LOOP_195_3: for(int i = 0; i < W - 1; ++i) {
#pragma HLS unroll
 r[i] = 1;
       }
    } else {
       r = res;
    }





    return r;
}
template<int W, int I>
ap_ufixed<W, I> hypot_fixed(ap_ufixed<W, I> x, ap_fixed<W, I> y) {
   ap_fixed<W+1, I+1> xi = x;
   ap_fixed<W+1, I+1> yi = y;
   return hypot_fixed(xi, yi);
}
template<int I>
ap_int<I> hypot_fixed(ap_int<I> x, ap_int<I> y) {
   ap_fixed<I, I> xi = x;
   ap_fixed<I, I> yi = y;
   return hypot_fixed(xi, yi);
}
template<int I>
ap_uint<I> hypot_fixed(ap_uint<I> x, ap_uint<I> y) {
   ap_fixed<I+1, I+1> xi = x;
   ap_fixed<I+1, I+1> yi = y;
   return hypot_fixed(xi, yi);
}
}
# 1087 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2
# 1 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_ldexp_apfixed.h" 1
# 36 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot/hls_ldexp_apfixed.h"
namespace hls_ldexp {

template<int W, int I>
ap_fixed<W,I> ldexp(ap_fixed<W,I> x, int exp) {
    ap_fixed<W,I> result;
    if(exp >= W || exp <= -W) {
        result = 0;
    } else {
        result = x << exp;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> ldexp(ap_ufixed<W,I> x, int exp) {
    ap_fixed<W+1,I+1> xf = x;
    return ldexp(xf, exp);
}

template<int I>
ap_int<I> ldexp(ap_int<I> x, int exp) {
    ap_fixed<I,I> xf = x;
    return ldexp(xf, exp);
}

template<int I>
ap_uint<I> ldexp(ap_uint<I> x, int exp) {
    ap_fixed<I+1,I+1> xf = x;
    return ldexp(xf, exp);
}

template<int W, int I>
ap_fixed<W,I> scalbn(ap_fixed<W,I> x, int n) {
    ap_fixed<W,I> result;
    if(n >= W || n <= -W) {
        result = 0;
    } else {
        result = x << n;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> scalbn(ap_ufixed<W,I> x, int n) {
    ap_fixed<W+1,I+1> xf = x;
    return scalbn(xf, n);
}

template<int I>
ap_int<I> scalbn(ap_int<I> x, int n) {
    ap_fixed<I,I> xf = x;
    return scalbn(xf, n);
}

template<int I>
ap_uint<I> scalbn(ap_uint<I> x, int n) {
    ap_fixed<I+1,I+1> xf = x;
    return scalbn(xf, n);
}

template<int W, int I>
ap_fixed<W,I> scalbln(ap_fixed<W,I> x, long int n) {
    ap_fixed<W,I> result;
    if(n >= W || n <= -W) {
        result = 0;
    } else {
        result = x << n;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> scalbln(ap_ufixed<W,I> x, long int n) {
    ap_fixed<W+1,I+1> xf = x;
    return scalbln(xf, n);
}

template<int I>
ap_int<I> scalbln(ap_int<I> x, long int n) {
    ap_fixed<I,I> xf = x;
    return scalbln(xf, n);
}

template<int I>
ap_uint<I> scalbln(ap_uint<I> x, long int n) {
    ap_fixed<I+1,I+1> xf = x;
    return scalbln(xf, n);
}

}
# 1088 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h" 2

namespace hls {
# 1112 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h"
  template<int W, int I>
  ap_fixed<W, 2> sinpi(ap_fixed<W,I> x){
    return hotbm_apfixed::sinf_or_cosf<W,I>(x, 0, 1);
  }




  template<int W, int I>
  ap_ufixed<W, 2> sinpi(ap_ufixed<W,I> x){
      ap_fixed<W+1, I+1> xin = x;
      ap_fixed<W+1, 3> xout = hls::sinpi<W+1, I+1>(x);
   ap_ufixed<W, 2> out = 0;
   if(xout[W]==0){
    out = xout;
   }
   return out;
  }

  template<int W, int I>
  ap_fixed<W, 2> cospi(ap_fixed<W,I> x){
    return hotbm_apfixed::sinf_or_cosf<W,I>(x, 1, 1);
  }
  template<int W, int I>
  ap_ufixed<W, 2> cospi(ap_ufixed<W,I> x){
   ap_fixed<W+1, I+1> xin = x;
   ap_fixed<W+1, 3> xout = hls::cospi<W+1, I+1>(x);
   ap_ufixed<W, 2> out = 0;
   if(xout[W]==0){
    out = xout;
   }
   return out;
  }





  template<int I>
  ap_int<I> sinpi(ap_int<I> in){
        (void)(in);
 return ap_int<I>(0);
  }

  template<int I>
  ap_int<I> cospi(ap_int<I> in){
        (void)(in);
 return ap_int<I>(0);
  }

  template<int I>
  ap_uint<I> sinpi(ap_uint<I> in){
        (void)(in);
 return ap_uint<I>(0);
  }

  template<int I>
  ap_uint<I> cospi(ap_uint<I> in){
        (void)(in);
 return ap_uint<I>(0);
  }
  int8_t sinpi(int8_t);
  uint8_t sinpi(uint8_t);
  int16_t sinpi(int16_t);
  uint16_t sinpi(uint16_t);
  int32_t sinpi(int32_t);
  uint32_t sinpi(uint32_t);

  int8_t cospi(int8_t);
  uint8_t cospi(uint8_t);
  int16_t cospi(int16_t);
  uint16_t cospi(uint16_t);
  int32_t cospi(int32_t);
  uint32_t cospi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> exp(ap_fixed<W,I> x){
    return exp_reduce::exp(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> exp(ap_ufixed<W,I> x){
    return exp_reduce::exp(x);
  }
  template<int I>
  ap_int<I> exp(ap_int<I> x){
    return exp_reduce::exp(x);
  }
  template<int I>
  ap_uint<I> exp(ap_uint<I> x){
    return exp_reduce::exp(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log(ap_fixed<W,I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int I>
  ap_int<I> log(ap_int<I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int I>
  ap_uint<I> log(ap_uint<I> x){
    return log_apfixed_reduce::log(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log10(ap_fixed<W,I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log10(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int I>
  ap_int<I> log10(ap_int<I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int I>
  ap_uint<I> log10(ap_uint<I> x){
 return log_apfixed_reduce::log10(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log2(ap_fixed<W,I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log2(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int I>
  ap_int<I> log2(ap_int<I> x){
    return log_apfixed_reduce::log2(x);
  }
  template<int I>
  ap_uint<I> log2(ap_uint<I> x){
 return log_apfixed_reduce::log2(x);
  }


  template<int W, int I>
  ap_fixed<W,I> logb(ap_fixed<W,I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> logb(ap_ufixed<W,I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int I>
  ap_int<I> logb(ap_int<I> x){
    return log_apfixed_reduce::logb(x);
  }
  template<int I>
  ap_uint<I> logb(ap_uint<I> x){
 return log_apfixed_reduce::logb(x);
  }


  template<int W, int I>
  ap_fixed<W,I> sqrt(ap_fixed<W,I> x){
    return sqrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> sqrt(ap_ufixed<W,I> x){
    return sqrt_fixed(x);
  }
  template<int I>
  ap_int<I> sqrt(ap_int<I> x){
    return sqrt_fixed(x);
  }
  template<int I>
  ap_uint<I> sqrt(ap_uint<I> x){
    return sqrt_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> rsqrt(ap_fixed<W,I> x){
    return rsqrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> rsqrt(ap_ufixed<W,I> x){
    return rsqrt_fixed(x);
  }
  template<int I>
  ap_int<I> rsqrt(ap_int<I> x){
    return rsqrt_fixed(x);
  }
  template<int I>
  ap_uint<I> rsqrt(ap_uint<I> x){
    return rsqrt_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> recip(ap_fixed<W,I> x){
    return recip_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> recip(ap_ufixed<W,I> x){
    return recip_fixed(x);
  }
  template<int I>
  ap_int<I> recip(ap_int<I> x){
    return recip_fixed(x);
  }
  template<int I>
  ap_uint<I> recip(ap_uint<I> x){
    return recip_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> ceil(ap_fixed<W,I> x){
    return ceil_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> ceil(ap_ufixed<W,I> x){
    return ceil_fixed(x);
  }
  template<int I>
  ap_int<I> ceil(ap_int<I> x){
    return ceil_fixed(x);
  }
  template<int I>
  ap_uint<I> ceil(ap_uint<I> x){
    return ceil_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> floor(ap_fixed<W,I> x){
    return floor_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> floor(ap_ufixed<W,I> x){
    return floor_fixed(x);
  }
  template<int I>
  ap_int<I> floor(ap_int<I> x){
    return floor_fixed(x);
  }
  template<int I>
  ap_uint<I> floor(ap_uint<I> x){
    return floor_fixed(x);
  }

  template<int W, int I>
  ap_fixed<W,I> trunc(ap_fixed<W,I> x){
    return trunc_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> trunc(ap_ufixed<W,I> x){
    return trunc_fixed(x);
  }
  template<int I>
  ap_int<I> trunc(ap_int<I> x){
    return trunc_fixed(x);
  }
  template<int I>
  ap_uint<I> trunc(ap_uint<I> x){
    return trunc_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> copysign(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return copysign_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> copysign(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return copysign_fixed(x,y);
  }
  template<int I>
  ap_int<I> copysign(ap_int<I> x, ap_int<I> y){
    return copysign_fixed(x,y);
  }
  template<int I>
  ap_uint<I> copysign(ap_uint<I> x, ap_uint<I> y){
    return copysign_fixed(x,y);
  }


  template<int W, int I>
  ap_fixed<W,I> fabs(ap_fixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> fabs(ap_ufixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_int<I> fabs(ap_int<I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_uint<I> fabs(ap_uint<I> x){
    return fabs_fixed(x);
  }

  template<int W, int I>
  ap_fixed<W,I> abs(ap_fixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> abs(ap_ufixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_int<I> abs(ap_int<I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_uint<I> abs(ap_uint<I> x){
    return fabs_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> fdim(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fdim_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fdim(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fdim_fixed(x,y);
  }
  template<int I>
  ap_int<I> fdim(ap_int<I> x, ap_int<I> y){
    return fdim_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fdim(ap_uint<I> x, ap_uint<I> y){
    return fdim_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> fmax(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fmax_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmax(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fmax_fixed(x,y);
  }
  template<int I>
  ap_int<I> fmax(ap_int<I> x, ap_int<I> y){
    return fmax_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fmax(ap_uint<I> x, ap_uint<I> y){
    return fmax_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> fmin(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fmin_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmin(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fmin_fixed(x,y);
  }
  template<int I>
  ap_int<I> fmin(ap_int<I> x, ap_int<I> y){
    return fmin_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fmin(ap_uint<I> x, ap_uint<I> y){
    return fmin_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> maxmag(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return maxmag_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> maxmag(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return maxmag_fixed(x,y);
  }
  template<int I>
  ap_int<I> maxmag(ap_int<I> x, ap_int<I> y){
    return maxmag_fixed(x,y);
  }
  template<int I>
  ap_uint<I> maxmag(ap_uint<I> x, ap_uint<I> y){
    return maxmag_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> minmag(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return minmag_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> minmag(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return minmag_fixed(x,y);
  }
  template<int I>
  ap_int<I> minmag(ap_int<I> x, ap_int<I> y){
    return minmag_fixed(x,y);
  }
  template<int I>
  ap_uint<I> minmag(ap_uint<I> x, ap_uint<I> y){
    return minmag_fixed(x,y);
  }



  template<int W, int I>
  ap_fixed<W,I> sinh(ap_fixed<W,I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> sinh(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int I>
  ap_int<I> sinh(ap_int<I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int I>
  ap_uint<I> sinh(ap_uint<I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> cosh(ap_fixed<W,I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> cosh(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int I>
  ap_int<I> cosh(ap_int<I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int I>
  ap_uint<I> cosh(ap_uint<I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> tanh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> tanh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int I>
  ap_int<I> tanh(ap_int<I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int I>
  ap_uint<I> tanh(ap_uint<I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> atanh(ap_fixed<W,I> x){
    ap_fixed<W,I> one_plus_x = 1 + x;
    ap_fixed<W,I> one_minus_x = 1 - x;
    ap_fixed<W,I> input = one_plus_x / one_minus_x ;
    ap_fixed<W,I> result = log_apfixed_reduce::log(input);
    result >>= 1;
    return result;
  }


  template<int W, int I>
  ap_ufixed<W,I> atanh(ap_ufixed<W,I> x){
  ap_fixed<W+1,I+1> input = x;
    ap_fixed<W+1,I+1> result = hls::atanh(input);
    return result;
  }


  template<int I>
  ap_int<I> atanh(ap_int<I> x){
    ap_fixed<I,I> input = x;
    ap_fixed<I,I> result = hls::atanh(input);
    return result;
  }


  template<int I>
  ap_uint<I> atanh(ap_uint<I> x){
    ap_fixed<I+1,I+1> input = x;
    ap_fixed<I+1,I+1> result = hls::atanh(input);
    return result;
  }


  template<int W, int I>
  ap_fixed<W,I> asinh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> asinh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int I>
  ap_int<I> asinh(ap_int<I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int I>
  ap_uint<I> asinh(ap_uint<I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> acosh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> acosh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int I>
  ap_int<I> acosh(ap_int<I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int I>
  ap_uint<I> acosh(ap_uint<I> x){
    return cordic_apfixed::generic_acosh(x);
  }

  int8_t sinh(int8_t);
  uint8_t sinh(uint8_t);
  int16_t sinh(int16_t);
  uint16_t sinh(uint16_t);
  int32_t sinh(int32_t);
  uint32_t sinh(uint32_t);

  int8_t cosh(int8_t);
  uint8_t cosh(uint8_t);
  int16_t cosh(int16_t);
  uint16_t cosh(uint16_t);
  int32_t cosh(int32_t);
  uint32_t cosh(uint32_t);

  int8_t tanh(int8_t);
  uint8_t tanh(uint8_t);
  int16_t tanh(int16_t);
  uint16_t tanh(uint16_t);
  int32_t tanh(int32_t);
  uint32_t tanh(uint32_t);

  int8_t atanh(int8_t);
  uint8_t atanh(uint8_t);
  int16_t atanh(int16_t);
  uint16_t atanh(uint16_t);
  int32_t atanh(int32_t);
  uint32_t atanh(uint32_t);

  int8_t asinh(int8_t);
  uint8_t asinh(uint8_t);
  int16_t asinh(int16_t);
  uint16_t asinh(uint16_t);
  int32_t asinh(int32_t);
  uint32_t asinh(uint32_t);

  int8_t acosh(int8_t);
  uint8_t acosh(uint8_t);
  int16_t acosh(int16_t);
  uint16_t acosh(uint16_t);
  int32_t acosh(int32_t);
  uint32_t acosh(uint32_t);


  template<int W, int I>
  ap_fixed<W-I+3,3> asin(ap_fixed<W,I> x){
 return cordic_apfixed::generic_asin(x);
  }


  template<int W, int I>
  ap_fixed<W-I+3,3> acos(ap_fixed<W,I> x){
 return cordic_apfixed::generic_acos(x);
  }


  template<int W, int I>
  ap_fixed<W,2> atan(ap_fixed<W,I> x){
 return cordic_apfixed::generic_atan(x);
  }


  template<int W, int I>
  ap_ufixed<W,2> atan(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_atan(x);
  }


  template<int I>
  ap_int<2> atan(ap_int<I> x){
   return cordic_apfixed::generic_atan(x);
  }


  template<int I>
  ap_uint<1> atan(ap_uint<I> x){
   return cordic_apfixed::generic_atan(x);
  }

  int8_t asin(int8_t);
  uint8_t asin(uint8_t);
  int16_t asin(int16_t);
  uint16_t asin(uint16_t);
  int32_t asin(int32_t);
  uint32_t asin(uint32_t);

  int8_t acos(int8_t);
  uint8_t acos(uint8_t);
  int16_t acos(int16_t);
  uint16_t acos(uint16_t);
  int32_t acos(int32_t);
  uint32_t acos(uint32_t);

  int8_t atan(int8_t);
  uint8_t atan(uint8_t);
  int16_t atan(int16_t);
  uint16_t atan(uint16_t);
  int32_t atan(int32_t);
  uint32_t atan(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> asinpi(ap_fixed<W,I> x){
      return cordic_apfixed::generic_asinpi(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> asinpi(ap_ufixed<W,I> x){
      return cordic_apfixed::generic_asinpi(x);
  }

  template<int I>
  ap_int<I> asinpi(ap_int<I> x){
     return cordic_apfixed::generic_asinpi(x);
  }

  template<int I>
  ap_uint<I> asinpi(ap_uint<I> x){
     return cordic_apfixed::generic_asinpi(x);
  }


  int8_t asinpi(int8_t);
  uint8_t asinpi(uint8_t);
  int16_t asinpi(int16_t);
  uint16_t asinpi(uint16_t);
  int32_t asinpi(int32_t);
  uint32_t asinpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> acospi(ap_fixed<W,I> x){
      return cordic_apfixed::generic_acospi(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> acospi(ap_ufixed<W,I> x){
      return cordic_apfixed::generic_acospi(x);
  }

  template<int I>
  ap_int<I> acospi(ap_int<I> x){
     return cordic_apfixed::generic_acospi(x);
  }

  template<int I>
  ap_uint<I> acospi(ap_uint<I> x){
     return cordic_apfixed::generic_acospi(x);
  }

  int8_t acospi(int8_t);
  uint8_t acospi(uint8_t);
  int16_t acospi(int16_t);
  uint16_t acospi(uint16_t);
  int32_t acospi(int32_t);
  uint32_t acospi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> atanpi(ap_fixed<W,I> x){
 return cordic_apfixed::generic_atanpi(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> atanpi(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_atanpi(x);
  }


  template<int I>
  ap_int<2> atanpi(ap_int<I> x){
   return cordic_apfixed::generic_atanpi(x);
  }


  template<int I>
  ap_uint<1> atanpi(ap_uint<I> x){
   return cordic_apfixed::generic_atanpi(x);
  }

  int8_t atanpi(int8_t);
  uint8_t atanpi(uint8_t);
  int16_t atanpi(int16_t);
  uint16_t atanpi(uint16_t);
  int32_t atanpi(int32_t);
  uint32_t atanpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,3> atan2(ap_fixed<W,I> x, ap_fixed<W,I> y){
 return cordic_apfixed::generic_atan2(x,y);
  }


  template<int W, int I>
  ap_ufixed<W,3> atan2(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
 return cordic_apfixed::generic_atan2(x,y);
  }


  template<int I>
  ap_int<3> atan2(ap_int<I> x, ap_int<I> y){
   return cordic_apfixed::generic_atan2(x,y);
  }


  template<int I>
  ap_uint<2> atan2(ap_uint<I> x, ap_uint<I> y){
   return cordic_apfixed::generic_atan2(x,y);
  }

  int8_t atan2(int8_t, int8_t);
  uint8_t atan2(uint8_t, uint8_t);
  int16_t atan2(int16_t, int16_t);
  uint16_t atan2(uint16_t, uint16_t);
  int32_t atan2(int32_t, int32_t);
  uint32_t atan2(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> atan2pi(ap_fixed<W,I> x, ap_fixed<W,I> y){
 return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int W, int I>
  ap_ufixed<W,I> atan2pi(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
 return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int I>
  ap_int<I> atan2pi(ap_int<I> x, ap_int<I> y){
   return cordic_apfixed::generic_atan2pi(x,y);
  }


  template<int I>
  ap_uint<I> atan2pi(ap_uint<I> x, ap_uint<I> y){
   return cordic_apfixed::generic_atan2pi(x,y);
  }

  int8_t atan2pi(int8_t, int8_t);
  uint8_t atan2pi(uint8_t, uint8_t);
  int16_t atan2pi(int16_t, int16_t);
  uint16_t atan2pi(uint16_t, uint16_t);
  int32_t atan2pi(int32_t, int32_t);
  uint32_t atan2pi(uint32_t, uint32_t);
  template<int W, int I>
  void sincos(ap_fixed<W,I> in,
       ap_fixed<W-I+2,2>* outsin, ap_fixed<W-I+2,2>* outcos){
   cordic_apfixed::generic_sincos(in, *outsin, *outcos);
  }

  template<int W, int I>
  ap_fixed<W-I+2,2> sin(ap_fixed<W,I> x){
        ap_fixed<W-I+2,2> outsin;
        ap_fixed<W-I+2,2> outcos;
        cordic_apfixed::generic_sincos(x, outsin, outcos);
        return outsin;
  }

  template<int W, int I>
  ap_ufixed<W-I+2,2> sin(ap_ufixed<W,I> x){
  ap_fixed<W+1, I+1> xin = x;
  ap_fixed<W-I+3, 3> xout = hls::sin(x);
  ap_fixed<W-I+2, 2> out = 0;
  if(xout[W-I+2]==0){
   out=xout;
  }
  return out;
  }

  template<int W, int I>
  ap_fixed<W-I+2,2> cos(ap_fixed<W,I> x){
        ap_fixed<W-I+2,2> outsin;
        ap_fixed<W-I+2,2> outcos;
        cordic_apfixed::generic_sincos(x, outsin, outcos);
        return outcos;
  }

  template<int W, int I>
  ap_ufixed<W-I+2,2> cos(ap_ufixed<W,I> x){
  ap_fixed<W+1, I+1> xin = x;
  ap_fixed<W-I+3, 3> xout = hls::cos(x);
  ap_fixed<W-I+2, 2> out = 0;
  if(xout[W-I+2]==0){
   out=xout;
  }
  return out;
  }
# 1988 "D:/xilinx/Vitis_HLS/2022.2/common/technology/autopilot\\hls_math.h"
  template<int I>
  ap_int<I> sin(ap_int<I> in) {
        (void)(in);
 return ap_int<I>(0);
  };
  template<int I>
  ap_int<I> cos(ap_int<I> in) {
        (void)(in);
 return ap_int<I>(0);
  };


  template<int I>
  ap_uint<I> sin(ap_uint<I> in) {
        (void)(in);
 return ap_uint<I>(0);
  };
  template<int I>
  ap_uint<I> cos(ap_uint<I> in) {
        (void)(in);
 return ap_uint<I>(0);
  };

  void sincos(int8_t, int8_t*, int8_t*);
  void sincos(uint8_t, uint8_t*, uint8_t*);
  void sincos(int16_t, int16_t*, int16_t*);
  void sincos(uint16_t, uint16_t*, uint16_t*);
  void sincos(int32_t, int32_t*, int32_t*);
  void sincos(uint32_t, uint32_t*, uint32_t*);

  int8_t sin(int8_t);
  uint8_t sin(uint8_t);
  int16_t sin(int16_t);
  uint16_t sin(uint16_t);
  int32_t sin(int32_t);
  uint32_t sin(uint32_t);

  int8_t cos(int8_t);
  uint8_t cos(uint8_t);
  int16_t cos(int16_t);
  uint16_t cos(uint16_t);
  int32_t cos(int32_t);
  uint32_t cos(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tan(ap_fixed<W,I> x){
 return cordic_apfixed::generic_tan(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tan(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_tan(x);
  }
  template<int I>
  ap_int<I> tan(ap_int<I> x){
   return cordic_apfixed::generic_tan(x);
  }
  template<int I>
  ap_uint<I> tan(ap_uint<I> x){
   return cordic_apfixed::generic_tan(x);
  }

  int8_t tan(int8_t);
  uint8_t tan(uint8_t);
  int16_t tan(int16_t);
  uint16_t tan(uint16_t);
  int32_t tan(int32_t);
  uint32_t tan(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tanpi(ap_fixed<W,I> x){
 return cordic_apfixed::generic_tanpi(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tanpi(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_tanpi(x);
  }
  template<int I>
  ap_int<I> tanpi(ap_int<I> x){
   return cordic_apfixed::generic_tanpi(x);
  }
  template<int I>
  ap_uint<I> tanpi(ap_uint<I> x){
   return cordic_apfixed::generic_tanpi(x);
  }

  int8_t tanpi(int8_t);
  uint8_t tanpi(uint8_t);
  int16_t tanpi(int16_t);
  uint16_t tanpi(uint16_t);
  int32_t tanpi(int32_t);
  uint32_t tanpi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> pow(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return pow_apfixed_reduce::pow(x,y);
  }

  template<int W, int I>
  ap_ufixed<W,I> pow(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return pow_apfixed_reduce::pow(x,y);
  }
  template<int I>
  ap_int<I> pow(ap_int<I> x, ap_int<I> y){
    return pow_apfixed_reduce::pow(x,y);
  }
  template<int I>
  ap_uint<I> pow(ap_uint<I> x,ap_uint<I> y){
    return pow_apfixed_reduce::pow(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> pown(ap_fixed<W,I> x, int n) {
    return pow_apfixed_reduce::pown(x,n);
  }

  template<int W, int I>
  ap_ufixed<W,I> pown(ap_ufixed<W,I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  template<int I>
  ap_int<I> pown(ap_int<I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  template<int I>
  ap_uint<I> pown(ap_uint<I> x, int n){
    return pow_apfixed_reduce::pown(x,n);
  }
  int8_t pown(int8_t, int n);
  uint8_t pown(uint8_t, int n);
  int16_t pown(int16_t, int n);
  uint16_t pown(uint16_t, int n);
  int32_t pown(int32_t, int n);
  uint32_t pown(uint32_t, int n);

  template<int W, int I>
  ap_fixed<W,I> rootn(ap_fixed<W,I> x, int n) {
    return pow_apfixed_reduce::rootn(x,n);
  }

  template<int W, int I>
  ap_ufixed<W,I> rootn(ap_ufixed<W,I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  template<int I>
  ap_int<I> rootn(ap_int<I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  template<int I>
  ap_uint<I> rootn(ap_uint<I> x, int n){
    return pow_apfixed_reduce::rootn(x,n);
  }
  int8_t rootn(int8_t, int n);
  uint8_t rootn(uint8_t, int n);
  int16_t rootn(int16_t, int n);
  uint16_t rootn(uint16_t, int n);
  int32_t rootn(int32_t, int n);
  uint32_t rootn(uint32_t, int n);

  template<int W, int I>
  ap_fixed<W,I> powr(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return pow_apfixed_reduce::powr(x,y);
  }

  template<int W, int I>
  ap_ufixed<W,I> powr(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return pow_apfixed_reduce::powr(x,y);
  }
  template<int I>
  ap_int<I> powr(ap_int<I> x, ap_int<I> y){
    return pow_apfixed_reduce::powr(x,y);
  }
  template<int I>
  ap_uint<I> powr(ap_uint<I> x,ap_uint<I> y){
    return pow_apfixed_reduce::powr(x,y);
  }



  template<int W, int I>
  ap_fixed<W,I> round(ap_fixed<W,I> x){
    return round_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> round(ap_ufixed<W,I> x){
    return round_fixed(x);
  }
  template<int I>
  ap_int<I> round(ap_int<I> x){
    return round_fixed(x);
  }
  template<int I>
  ap_uint<I> round(ap_uint<I> x){
    return round_fixed(x);
  }
  int8_t round(int8_t);
  uint8_t round(uint8_t);
  int16_t round(int16_t);
  uint16_t round(uint16_t);
  int32_t round(int32_t);
  uint32_t round(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> rint(ap_fixed<W,I> x){
    return rint_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> rint(ap_ufixed<W,I> x){
    return rint_fixed(x);
  }
  template<int I>
  ap_int<I> rint(ap_int<I> x){
    return rint_fixed(x);
  }
  template<int I>
  ap_uint<I> rint(ap_uint<I> x){
    return rint_fixed(x);
  }
  int8_t rint(int8_t);
  uint8_t rint(uint8_t);
  int16_t rint(int16_t);
  uint16_t rint(uint16_t);
  int32_t rint(int32_t);
  uint32_t rint(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> nearbyint(ap_fixed<W,I> x){
    return nearbyint_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> nearbyint(ap_ufixed<W,I> x){
    return nearbyint_fixed(x);
  }
  template<int I>
  ap_int<I> nearbyint(ap_int<I> x){
    return nearbyint_fixed(x);
  }
  template<int I>
  ap_uint<I> nearbyint(ap_uint<I> x){
    return nearbyint_fixed(x);
  }
  int8_t nearbyint(int8_t);
  uint8_t nearbyint(uint8_t);
  int16_t nearbyint(int16_t);
  uint16_t nearbyint(uint16_t);
  int32_t nearbyint(int32_t);
  uint32_t nearbyint(uint32_t);


  template<int W, int I>
  long long int llround(ap_fixed<W,I> x){
    return llround_fixed(x);
  }
  template<int W, int I>
  long long int llround(ap_ufixed<W,I> x){
    return llround_fixed(x);
  }
  template<int I>
  long long int llround(ap_int<I> x){
    return llround_fixed(x);
  }
  template<int I>
  long long int llround(ap_uint<I> x){
    return llround_fixed(x);
  }


  long long int llround(int8_t);
  long long int llround(uint8_t);
  long long int llround(int16_t);
  long long int llround(uint16_t);
  long long int llround(int32_t);
  long long int llround(uint32_t);


  template<int W, int I>
  long int lround(ap_fixed<W,I> x){
    return lround_fixed(x);
  }
  template<int W, int I>
  long int lround(ap_ufixed<W,I> x){
    return lround_fixed(x);
  }
  template<int I>
  long int lround(ap_int<I> x){
    return lround_fixed(x);
  }
  template<int I>
  long int lround(ap_uint<I> x){
    return lround_fixed(x);
  }


  long int lround(int8_t);
  long int lround(uint8_t);
  long int lround(int16_t);
  long int lround(uint16_t);
  long int lround(int32_t);
  long int lround(uint32_t);


  template<int W, int I>
  long long int llrint(ap_fixed<W,I> x){
    return llrint_fixed(x);
  }
  template<int W, int I>
  long long int llrint(ap_ufixed<W,I> x){
    return llrint_fixed(x);
  }
  template<int I>
  long long int llrint(ap_int<I> x){
    return llrint_fixed(x);
  }
  template<int I>
  long long int llrint(ap_uint<I> x){
    return llrint_fixed(x);
  }


  long long int llrint(int8_t);
  long long int llrint(uint8_t);
  long long int llrint(int16_t);
  long long int llrint(uint16_t);
  long long int llrint(int32_t);
  long long int llrint(uint32_t);


  template<int W, int I>
  long int lrint(ap_fixed<W,I> x){
    return lrint_fixed(x);
  }
  template<int W, int I>
  long int lrint(ap_ufixed<W,I> x){
    return lrint_fixed(x);
  }
  template<int I>
  long int lrint(ap_int<I> x){
    return lrint_fixed(x);
  }
  template<int I>
  long int lrint(ap_uint<I> x){
    return lrint_fixed(x);
  }


  long int lrint(int8_t);
  long int lrint(uint8_t);
  long int lrint(int16_t);
  long int lrint(uint16_t);
  long int lrint(int32_t);
  long int lrint(uint32_t);


  template<int W, int I>
  bool isgreater(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int W, int I>
  bool isgreater(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int I>
  bool isgreater(ap_int<I> x1, ap_int<I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int I>
  bool isgreater(ap_uint<I> x1, ap_uint<I> x2){
    return isgreater_fixed(x1, x2);
  }
  bool isgreater(int8_t, int8_t);
  bool isgreater(uint8_t, uint8_t);
  bool isgreater(int16_t, int16_t);
  bool isgreater(uint16_t, uint16_t);
  bool isgreater(int32_t, int32_t);
  bool isgreater(uint32_t, uint32_t);


  template<int W, int I>
  bool isgreaterequal(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  template<int W, int I>
  bool isgreaterequal(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  template<int I>
  bool isgreaterequal(ap_int<I> x1, ap_int<I> x2){
    return isgreaterequal_int(x1, x2);
  }
  template<int I>
  bool isgreaterequal(ap_uint<I> x1, ap_uint<I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  bool isgreaterequal(int8_t, int8_t);
  bool isgreaterequal(uint8_t, uint8_t);
  bool isgreaterequal(int16_t, int16_t);
  bool isgreaterequal(uint16_t, uint16_t);
  bool isgreaterequal(int32_t, int32_t);
  bool isgreaterequal(uint32_t, uint32_t);


  template<int W, int I>
  bool isless(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isless_fixed(x1, x2);
  }
  template<int W, int I>
  bool isless(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isless_fixed(x1, x2);
  }
  template<int I>
  bool isless(ap_int<I> x1, ap_int<I> x2){
    return isless_fixed(x1, x2);
  }
  template<int I>
  bool isless(ap_uint<I> x1, ap_uint<I> x2){
    return isless_fixed(x1, x2);
  }
  bool isless(int8_t, int8_t);
  bool isless(uint8_t, uint8_t);
  bool isless(int16_t, int16_t);
  bool isless(uint16_t, uint16_t);
  bool isless(int32_t, int32_t);
  bool isless(uint32_t, uint32_t);


  template<int W, int I>
  bool islessequal(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int W, int I>
  bool islessequal(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int I>
  bool islessequal(ap_int<I> x1, ap_int<I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int I>
  bool islessequal(ap_uint<I> x1, ap_uint<I> x2){
    return islessequal_fixed(x1, x2);
  }
  bool islessequal(int8_t, int8_t);
  bool islessequal(uint8_t, uint8_t);
  bool islessequal(int16_t, int16_t);
  bool islessequal(uint16_t, uint16_t);
  bool islessequal(int32_t, int32_t);
  bool islessequal(uint32_t, uint32_t);


  template<int W, int I>
  bool islessgreater(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int W, int I>
  bool islessgreater(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int I>
  bool islessgreater(ap_int<I> x1, ap_int<I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int I>
  bool islessgreater(ap_uint<I> x1, ap_uint<I> x2){
    return islessgreater_fixed(x1, x2);
  }

  bool islessgreater(int8_t, int8_t);
  bool islessgreater(uint8_t, uint8_t);
  bool islessgreater(int16_t, int16_t);
  bool islessgreater(uint16_t, uint16_t);
  bool islessgreater(int32_t, int32_t);
  bool islessgreater(uint32_t, uint32_t);

  int8_t frexp(int8_t,int8_t*);
  uint8_t frexp(uint8_t, uint8_t*);
  int16_t frexp(int16_t, int16_t*);
  uint16_t frexp(uint16_t, uint16_t*);
  int32_t frexp(int32_t, int32_t*);
  uint32_t frexp(uint32_t, uint32_t*);

  template<int W, int I>
  ap_fixed<W,I> frexp(ap_fixed<W,I> x, ap_fixed<W,I>* exp) {
    return frexp_internal::frexp(x,exp);
  }

  template<int W, int I>
  ap_ufixed<W,I> frexp(ap_ufixed<W,I> x, ap_ufixed<W,I>* exp){
    return frexp_internal::frexp(x,exp);
  }
  template<int I>
  ap_int<I> frexp(ap_int<I> x, ap_int<I>* exp){
    return frexp_internal::frexp(x,exp);
  }
  template<int I>
  ap_uint<I> frexp(ap_uint<I> x,ap_uint<I>* exp){
    return frexp_internal::frexp(x,exp);
  }

  int8_t modf(int8_t, int8_t*);
  uint8_t modf(uint8_t, uint8_t*);
  int16_t modf(int16_t, int16_t*);
  uint16_t modf(uint16_t, uint16_t*);
  int32_t modf(int32_t, int32_t*);
  uint32_t modf(uint32_t, uint32_t*);

  template<int W, int I>
  ap_fixed<W,I> modf(ap_fixed<W,I> x, ap_fixed<W,I>* intpart) {
    return modf_internal::modf(x,intpart);
  }

  template<int W, int I>
  ap_ufixed<W,I> modf(ap_ufixed<W,I> x, ap_ufixed<W,I>* intpart){
    return modf_internal::modf(x,intpart);
  }
  template<int I>
  ap_int<I> modf(ap_int<I> x, ap_int<I>* intpart){
    return modf_internal::modf(x,intpart);
  }
  template<int I>
  ap_uint<I> modf(ap_uint<I> x,ap_uint<I>* intpart){
    return modf_internal::modf(x,intpart);
  }


  bool isequal(int8_t,int8_t);
  bool isequal(uint8_t,uint8_t);
  bool isequal(int16_t,int16_t);
  bool isequal(uint16_t,uint16_t);
  bool isequal(int32_t,int32_t);
  bool isequal(uint32_t,uint32_t);

  bool isnotequal(int8_t,int8_t);
  bool isnotequal(uint8_t,uint8_t);
  bool isnotequal(int16_t,int16_t);
  bool isnotequal(uint16_t,uint16_t);
  bool isnotequal(int32_t,int32_t);
  bool isnotequal(uint32_t,uint32_t);

  template<int W,int I>
  bool isequal(ap_fixed<W,I> x,ap_fixed<W,I> y){
    return generic_isequal(x,y);
  };
  template<int W,int I>
  bool isequal(ap_ufixed<W,I> x,ap_ufixed<W,I> y){
    return generic_isequal(x,y);
  };
  template<int I>
  bool isequal(ap_int<I> x,ap_int<I> y){
    return generic_isequal(x,y);
  };
  template<int I>
  bool isequal(ap_uint<I> x,ap_uint<I> y){
    return generic_isequal(x,y);
  };

  template<int W,int I>
  bool isnotequal(ap_fixed<W,I> x,ap_fixed<W,I> y){
    return generic_isnotequal(x,y);
  };
  template<int W,int I>
  bool isnotequal(ap_ufixed<W,I> x,ap_ufixed<W,I> y){
    return generic_isnotequal(x,y);
  };
  template<int I>
  bool isnotequal(ap_int<I> x,ap_int<I> y){
    return generic_isnotequal(x,y);
  };
  template<int I>
  bool isnotequal(ap_uint<I> x,ap_uint<I> y){
    return generic_isnotequal(x,y);
  };

  template<int W,int I>
  bool any(ap_fixed<W,I> x){
    return generic_any(x);
  };
  template<int W,int I>
  bool any(ap_ufixed<W,I> x){
    return generic_any(x);
  };
  template<int I>
  bool any(ap_int<I> x){
    return generic_any(x);
  };
  template<int I>
  bool any(ap_uint<I> x){
    return generic_any(x);
  };

  template<int W,int I>
  bool all(ap_fixed<W,I> x){
    return generic_all(x);
  };
  template<int W,int I>
  bool all(ap_ufixed<W,I> x){
    return generic_all(x);
  };
  template<int I>
  bool all(ap_int<I> x){
    return generic_all(x);
  };
  template<int I>
  bool all(ap_uint<I> x){
    return generic_all(x);
  };

  template<int W,int I>
  ap_fixed<W,I> bitselect(ap_fixed<W,I> x,ap_fixed<W,I> y, ap_fixed<W,I> z){
    return generic_bitselect(x,y,z);
  };
  template<int W,int I>
  ap_ufixed<W,I> bitselect(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return generic_bitselect(x,y,z);
  };
  template<int I>
  ap_int<I> bitselect(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return generic_bitselect(x,y,z);
  };
  template<int I>
  ap_uint<I> bitselect(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return generic_bitselect(x,y,z);
  };

  template<int W, int I>
  ap_fixed<W,I> erf(ap_fixed<W,I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> erf(ap_ufixed<W,I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int I>
  ap_int<I> erf(ap_int<I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int I>
  ap_uint<I> erf(ap_uint<I> x){
    return erf_erfc_fixed::erf(x);
  }

  template<int W, int I>
  ap_fixed<W,I> erfc(ap_fixed<W,I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> erfc(ap_ufixed<W,I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int I>
  ap_int<I> erfc(ap_int<I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int I>
  ap_uint<I> erfc(ap_uint<I> x){
    return erf_erfc_fixed::erfc(x);
  }

  int8_t divide(int8_t,int8_t);
  int16_t divide(int16_t,int16_t);
  int32_t divide(int32_t,int32_t);
  uint8_t divide(uint8_t,uint8_t);
  uint16_t divide(uint16_t,uint16_t);
  uint32_t divide(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> divide(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> divide(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int I>
  ap_int<I> divide(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_divide(x, y);
  }
  template<int I>
  ap_uint<I> divide(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_divide(x, y);
  }

  int8_t fmod(int8_t,int8_t);
  int16_t fmod(int16_t,int16_t);
  int32_t fmod(int32_t,int32_t);
  uint8_t fmod(uint8_t,uint8_t);
  uint16_t fmod(uint16_t,uint16_t);
  uint32_t fmod(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fmod(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmod(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int I>
  ap_int<I> fmod(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_fmod(x, y);
  }
  template<int I>
  ap_uint<I> fmod(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_fmod(x, y);
  }

  int8_t remainder(int8_t,int8_t);
  int16_t remainder(int16_t,int16_t);
  int32_t remainder(int32_t,int32_t);
  uint8_t remainder(uint8_t,uint8_t);
  uint16_t remainder(uint16_t,uint16_t);
  uint32_t remainder(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> remainder(ap_fixed<W,I> x, ap_fixed<W, I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> remainder(ap_ufixed<W,I> x, ap_ufixed<W, I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int I>
  ap_int<I> remainder(ap_int<I> x, ap_int<I> y){
    return hls_internal::generic_remainder(x, y);
  }
  template<int I>
  ap_uint<I> remainder(ap_uint<I> x, ap_uint<I> y){
    return hls_internal::generic_remainder(x, y);
  }

  int8_t remquo(int8_t,int8_t,int*);
  int16_t remquo(int16_t,int16_t,int*);
  int32_t remquo(int32_t,int32_t,int*);
  uint8_t remquo(uint8_t,uint8_t,int*);
  uint16_t remquo(uint16_t,uint16_t,int*);
  uint32_t remquo(uint32_t,uint32_t,int*);

  template<int W, int I>
  ap_fixed<W,I> remquo(ap_fixed<W,I> x, ap_fixed<W,I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int W, int I>
  ap_ufixed<W,I> remquo(ap_ufixed<W,I> x, ap_ufixed<W, I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int I>
  ap_int<I> remquo(ap_int<I> x, ap_int<I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }
  template<int I>
  ap_uint<I> remquo(ap_uint<I> x, ap_uint<I> y, int* quo){
    return hls_internal::generic_remquo(x, y, quo);
  }

  template<int W, int I>
  bool signbit(ap_fixed<W, I> x) {
    return signbit_fixed(x);
  }
  template<int W, int I>
  bool signbit(ap_ufixed<W, I> x) {
    return signbit_fixed(x);
  }
  template<int I>
  bool signbit(ap_int<I> x) {
    return signbit_fixed(x);
  }
  template<int I>
  bool signbit(ap_uint<I> x) {
    return signbit_fixed(x);
  }
  bool signbit(int8_t);
  bool signbit(uint8_t);
  bool signbit(int16_t);
  bool signbit(uint16_t);
  bool signbit(int32_t);
  bool signbit(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> lgamma_r(ap_fixed<W,I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int W, int I>
  ap_ufixed<W,I> lgamma_r(ap_ufixed<W,I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int I>
  ap_int<I> lgamma_r(ap_int<I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int I>
  ap_uint<I> lgamma_r(ap_uint<I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }

  template<int W, int I>
  ap_fixed<W,I> lgamma(ap_fixed<W,I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> lgamma(ap_ufixed<W,I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int I>
  ap_int<I> lgamma(ap_int<I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int I>
  ap_uint<I> lgamma(ap_uint<I> x){
    return lgamma_fixed::lgamma_generic(x);
  }

  int8_t mad(int8_t,int8_t,int8_t);
  int16_t mad(int16_t,int16_t,int16_t);
  int32_t mad(int32_t,int32_t,int32_t);
  uint8_t mad(uint8_t,uint8_t,uint8_t);
  uint16_t mad(uint16_t,uint16_t,uint16_t);
  uint32_t mad(uint32_t,uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> mad(ap_fixed<W,I> x,ap_fixed<W,I> y,ap_fixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int W, int I>
  ap_ufixed<W,I> mad(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_int<I> mad(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_uint<I> mad(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return hls_mad::generic_mad(x,y,z);
  }

  int8_t fma(int8_t,int8_t,int8_t);
  int16_t fma(int16_t,int16_t,int16_t);
  int32_t fma(int32_t,int32_t,int32_t);
  uint8_t fma(uint8_t,uint8_t,uint8_t);
  uint16_t fma(uint16_t,uint16_t,uint16_t);
  uint32_t fma(uint32_t,uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fma(ap_fixed<W,I> x,ap_fixed<W,I> y,ap_fixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int W, int I>
  ap_ufixed<W,I> fma(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_int<I> fma(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return hls_mad::generic_mad(x,y,z);
  }
  template<int I>
  ap_uint<I> fma(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return hls_mad::generic_mad(x,y,z);
  }

  int8_t fract(int8_t);
  int16_t fract(int16_t);
  int32_t fract(int32_t);
  uint8_t fract(uint8_t);
  uint16_t fract(uint16_t);
  uint32_t fract(uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fract(ap_fixed<W,I> x){
    return hls_fract::generic_fract(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> fract(ap_ufixed<W,I> x){
    return hls_fract::generic_fract(x);
  }
  template<int I>
  ap_int<I> fract(ap_int<I> x){
    return hls_fract::generic_fract(x);
  }
  template<int I>
  ap_uint<I> fract(ap_uint<I> x){
    return hls_fract::generic_fract(x);
  }

  template<int W, int I>
  ap_fixed<W,I> cbrt(ap_fixed<W,I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> cbrt(ap_ufixed<W,I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int I>
  ap_int<I> cbrt(ap_int<I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int I>
  ap_uint<I> cbrt(ap_uint<I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  int8_t cbrt(int8_t);
  uint8_t cbrt(uint8_t);
  int16_t cbrt(int16_t);
  uint16_t cbrt(uint16_t);
  int32_t cbrt(int32_t);
  uint32_t cbrt(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tgamma(ap_fixed<W,I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tgamma(ap_ufixed<W,I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int I>
  ap_int<I> tgamma(ap_int<I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int I>
  ap_uint<I> tgamma(ap_uint<I> x){
    return tgamma_fixed::tgamma_generic(x);
  }


  template<int W, int I>
  ap_fixed<W,I> nextafter(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> nextafter(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int I>
  ap_int<I> nextafter(ap_int<I> x, ap_int<I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int I>
  ap_uint<I> nextafter(ap_uint<I> x, ap_uint<I> y) {
    return fp_internal::nextafter(x, y);
  }
  int8_t nextafter(int8_t, int8_t);
  uint8_t nextafter(uint8_t, uint8_t);
  int16_t nextafter(int16_t, int16_t);
  uint16_t nextafter(uint16_t, uint16_t);
  int32_t nextafter(int32_t, int32_t);
  uint32_t nextafter(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> nexttoward(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> nexttoward(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int I>
  ap_int<I> nexttoward(ap_int<I> x, ap_int<I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int I>
  ap_uint<I> nexttoward(ap_uint<I> x, ap_uint<I> y) {
    return fp_internal::nexttoward(x, y);
  }
  int8_t nexttoward(int8_t, int8_t);
  uint8_t nexttoward(uint8_t, uint8_t);
  int16_t nexttoward(int16_t, int16_t);
  uint16_t nexttoward(uint16_t, uint16_t);
  int32_t nexttoward(int32_t, int32_t);
  uint32_t nexttoward(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> hypot(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> hypot(ap_ufixed<W,I> x, ap_ufixed<W,I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int I>
  ap_int<I> hypot(ap_int<I> x, ap_int<I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int I>
  ap_uint<I> hypot(ap_uint<I> x, ap_uint<I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  int8_t hypot(int8_t, int8_t);
  uint8_t hypot(uint8_t, uint8_t);
  int16_t hypot(int16_t, int16_t);
  uint16_t hypot(uint16_t, uint16_t);
  int32_t hypot(int32_t, int32_t);
  uint32_t hypot(uint32_t, uint32_t);

  template<int W, int I>
  ap_fixed<W,I> exp2(ap_fixed<W,I> x) {
    return exp_reduce::exp2(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> exp2(ap_ufixed<W,I> x) {
    return exp_reduce::exp2(x);
  }

  template<int I>
  ap_int<I> exp2(ap_int<I> x) {
    return exp_reduce::exp2(x);
  }

  template<int I>
  ap_uint<I> exp2(ap_uint<I> x) {
    return exp_reduce::exp2(x);
  }

  template<int W, int I>
  ap_fixed<W,I> exp10(ap_fixed<W,I> x) {
    return exp_reduce::exp10(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> exp10(ap_ufixed<W,I> x) {
    return exp_reduce::exp10(x);
  }

  template<int I>
  ap_int<I> exp10(ap_int<I> x) {
    return exp_reduce::exp10(x);
  }

  template<int I>
  ap_uint<I> exp10(ap_uint<I> x) {
    return exp_reduce::exp10(x);
  }

  template<int W, int I>
  ap_fixed<W,I> expm1(ap_fixed<W,I> x) {
    return exp_reduce::expm1(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> expm1(ap_ufixed<W,I> x) {
    return exp_reduce::expm1(x);
  }

  template<int I>
  ap_int<I> expm1(ap_int<I> x) {
    return exp_reduce::expm1(x);
  }

  template<int I>
  ap_uint<I> expm1(ap_uint<I> x) {
    return exp_reduce::expm1(x);
  }

  template<int W, int I>
  ap_fixed<W,I> log1p(ap_fixed<W,I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> log1p(ap_ufixed<W,I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int I>
  ap_int<I> log1p(ap_int<I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int I>
  ap_uint<I> log1p(ap_uint<I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int W, int I>
  ap_fixed<W,I> ilogb(ap_fixed<W,I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> ilogb(ap_ufixed<W,I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int I>
  ap_int<I> ilogb(ap_int<I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int I>
  ap_uint<I> ilogb(ap_uint<I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int W, int I>
  ap_fixed<W,I> ldexp(ap_fixed<W,I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int W, int I>
  ap_ufixed<W,I> ldexp(ap_ufixed<W,I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int I>
  ap_int<I> ldexp(ap_int<I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int I>
  ap_uint<I> ldexp(ap_uint<I> x, int exp) {
    return hls_ldexp::ldexp(x, exp);
  }

  template<int W, int I>
  ap_fixed<W,I> scalbn(ap_fixed<W,I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int W, int I>
  ap_ufixed<W,I> scalbn(ap_ufixed<W,I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int I>
  ap_int<I> scalbn(ap_int<I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int I>
  ap_uint<I> scalbn(ap_uint<I> x, int n) {
    return hls_ldexp::scalbn(x, n);
  }

  template<int W, int I>
  ap_fixed<W,I> scalbln(ap_fixed<W,I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int W, int I>
  ap_ufixed<W,I> scalbln(ap_ufixed<W,I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int I>
  ap_int<I> scalbln(ap_int<I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

  template<int I>
  ap_uint<I> scalbln(ap_uint<I> x, long int n) {
    return hls_ldexp::scalbln(x, n);
  }

    int8_t ldexp(int8_t x, int exp);
    int16_t ldexp(int16_t x, int exp);
    int32_t ldexp(int32_t x, int exp);
    uint8_t ldexp(uint8_t x, int exp);
    uint16_t ldexp(uint16_t x, int exp);
    uint32_t ldexp(uint32_t x, int exp);

    int8_t scalbn(int8_t x, int n);
    int16_t scalbn(int16_t x, int n);
    int32_t scalbn(int32_t x, int n);
    uint8_t scalbn(uint8_t x, int n);
    uint16_t scalbn(uint16_t x, int n);
    uint32_t scalbn(uint32_t x, int n);

    int8_t scalbln(int8_t x, int n);
    int16_t scalbln(int16_t x, int n);
    int32_t scalbln(int32_t x, int n);
    uint8_t scalbln(uint8_t x, int n);
    uint16_t scalbln(uint16_t x, int n);
    uint32_t scalbln(uint32_t x, int n);

    int8_t exp2(int8_t x);
    int16_t exp2(int16_t x);
    int32_t exp2(int32_t x);
    uint8_t exp2(uint8_t x);
    uint16_t exp2(uint16_t x);
    uint32_t exp2(uint32_t x);

    int8_t exp10(int8_t x);
    int16_t exp10(int16_t x);
    int32_t exp10(int32_t x);
    uint8_t exp10(uint8_t x);
    uint16_t exp10(uint16_t x);
    uint32_t exp10(uint32_t x);

    int8_t expm1(int8_t x);
    int16_t expm1(int16_t x);
    int32_t expm1(int32_t x);
    uint8_t expm1(uint8_t x);
    uint16_t expm1(uint16_t x);
    uint32_t expm1(uint32_t x);

    int8_t ilogb(int8_t x);
    int16_t ilogb(int16_t x);
    int32_t ilogb(int32_t x);
    uint8_t ilogb(uint8_t x);
    uint16_t ilogb(uint16_t x);
    uint32_t ilogb(uint32_t x);

    int8_t log1p(int8_t x);
    int16_t log1p(int16_t x);
    int32_t log1p(int32_t x);
    uint8_t log1p(uint8_t x);
    uint16_t log1p(uint16_t x);
    uint32_t log1p(uint32_t x);

    int8_t log2(int8_t);
    uint8_t log2(uint8_t);
    int16_t log2(int16_t);
    uint16_t log2(uint16_t);
    int32_t log2(int32_t);
    uint32_t log2(uint32_t);

    int8_t logb(int8_t);
    uint8_t logb(uint8_t);
    int16_t logb(int16_t);
    uint16_t logb(uint16_t);
    int32_t logb(int32_t);
    uint32_t logb(uint32_t);

};
# 4 "conv2d_layer2.cpp" 2

# 1 "./conv2d_layer2.h" 1
# 10 "./conv2d_layer2.h"
static const float CONV2_W[32][32][5][5] =
{
  {
    {
      { -1.16834175e-02f, 1.37580559e-02f, 2.21107621e-02f, -4.30279635e-02f, -2.77326684e-02f },
      { -1.43784564e-02f, -5.71509041e-02f, -3.44437361e-02f, 4.60169540e-04f, -3.08003165e-02f },
      { 4.21411395e-02f, -7.17754066e-02f, 5.52176945e-02f, -4.31234576e-02f, -2.92819701e-02f },
      { 2.81457826e-02f, 3.58085409e-02f, -2.58342177e-02f, -2.15448756e-02f, -4.86090034e-02f },
      { -5.47445146e-03f, -6.19444139e-02f, 2.04244405e-02f, -4.57009077e-02f, -1.02818990e-02f },
    },
    {
      { -6.34719282e-02f, -1.68008693e-02f, -4.30676341e-02f, 4.46833251e-03f, -2.31834203e-02f },
      { -3.92130902e-03f, -2.19235346e-02f, 8.52460880e-03f, 3.18115875e-02f, -3.64840068e-02f },
      { -3.78896222e-02f, -3.77429016e-02f, 1.80252418e-02f, -2.84825116e-02f, 5.14602773e-02f },
      { -4.25343700e-02f, -1.49708549e-02f, 3.47449072e-02f, -4.71451469e-02f, 2.01442256e-03f },
      { 9.29209345e-04f, 3.09680905e-02f, -4.88807932e-02f, -5.53291216e-02f, -3.33333835e-02f },
    },
    {
      { 3.04565039e-02f, 4.05656397e-02f, 8.33753264e-04f, -2.59469766e-02f, -2.40359586e-02f },
      { -5.57198748e-02f, 4.47468348e-02f, -3.69842388e-02f, 5.92037523e-03f, 5.90287754e-03f },
      { -3.22208107e-02f, -5.43922558e-02f, -6.03100024e-02f, -2.08583660e-02f, -5.27073145e-02f },
      { 4.42987744e-04f, -2.79363822e-02f, -1.04114784e-04f, 4.27086391e-02f, -5.45499958e-02f },
      { -6.47641942e-02f, 8.34607170e-04f, 2.71057896e-03f, 1.38116395e-02f, -3.17746922e-02f },
    },
    {
      { -6.88700601e-02f, -6.49111404e-04f, -5.87791577e-02f, -5.55374101e-02f, -7.12529151e-03f },
      { 1.14647322e-03f, -5.75658903e-02f, 9.00671259e-03f, -5.80003671e-02f, 2.84807780e-03f },
      { 7.86826666e-03f, 1.96363609e-02f, -3.55680026e-02f, 3.74724567e-02f, 1.68189337e-03f },
      { 2.29157484e-03f, -3.82370688e-02f, -5.68216741e-02f, -1.60206407e-02f, -2.06025392e-02f },
      { -1.35725713e-03f, -1.30827688e-02f, 3.82001176e-02f, -2.72035636e-02f, -2.20130291e-02f },
    },
    {
      { -2.04416513e-02f, -2.89311190e-03f, 2.27873977e-02f, 3.09391469e-02f, -3.82931605e-02f },
      { 9.16480832e-03f, 3.43779251e-02f, -6.32845163e-02f, 5.15036322e-02f, 4.17211093e-02f },
      { 3.92172858e-02f, -6.66127633e-03f, 1.29235489e-02f, -2.94686332e-02f, -9.58867278e-03f },
      { -5.13240062e-02f, 8.34727101e-03f, -2.30768899e-04f, 3.45803685e-02f, 3.05522513e-02f },
      { -5.34412526e-02f, -6.25467375e-02f, -2.85478253e-02f, -2.39864714e-03f, -3.78394462e-02f },
    },
    {
      { 1.91894323e-02f, -6.30588923e-03f, -3.70847248e-02f, 2.10802141e-03f, -6.13465905e-02f },
      { -5.50671481e-02f, 4.09256034e-02f, 2.79557463e-02f, 9.84210521e-03f, 4.43834476e-02f },
      { -2.66399868e-02f, -2.29769088e-02f, -1.21428985e-02f, 7.71176629e-03f, 2.77295038e-02f },
      { 4.32571247e-02f, 1.92114599e-02f, -6.31558672e-02f, 3.33755910e-02f, -3.63519676e-02f },
      { 1.48447813e-03f, 2.79664826e-02f, 2.94920951e-02f, 3.54025401e-02f, 3.93347768e-03f },
    },
    {
      { 5.01869479e-03f, -3.71165806e-03f, -6.20006472e-02f, 4.98094410e-03f, 2.99025811e-02f },
      { -1.86376683e-02f, -4.15968485e-02f, -1.83836166e-02f, 4.15545925e-02f, -3.97541653e-03f },
      { -2.69224998e-02f, -2.69954912e-02f, -5.51634766e-02f, -3.66129950e-02f, 3.22539397e-02f },
      { 7.05590518e-03f, -1.97641589e-02f, 1.14473775e-02f, -3.54053266e-02f, 3.07586733e-02f },
      { 4.68931012e-02f, 3.84952649e-02f, -4.75604273e-02f, 6.59329398e-03f, 5.74629977e-02f },
    },
    {
      { -1.94210652e-02f, 3.08821667e-02f, -1.62585359e-02f, 2.63238121e-02f, 2.60998849e-02f },
      { 5.80987260e-02f, 1.11716641e-02f, -7.55394949e-03f, -5.94633780e-02f, 2.88195815e-02f },
      { 8.60308646e-04f, 5.48426174e-02f, -4.32599820e-02f, 1.76280160e-02f, -4.88816574e-03f },
      { -8.44796002e-03f, 5.48268631e-02f, -5.74011914e-02f, -4.29143868e-02f, 2.03663446e-02f },
      { 4.29653712e-02f, 6.04657084e-02f, -4.35237810e-02f, -4.69804369e-02f, -4.30541895e-02f },
    },
    {
      { 4.65028770e-02f, 1.10124182e-02f, -2.58872379e-02f, -1.69772040e-02f, 3.95430736e-02f },
      { -4.20698710e-02f, 4.56752665e-02f, -3.03234626e-03f, 5.86639456e-02f, -2.96257157e-02f },
      { -5.87480776e-02f, -4.38625284e-04f, 1.80078838e-02f, 3.64523269e-02f, -3.28797586e-02f },
      { 2.28616297e-02f, 4.78890687e-02f, 2.10944060e-02f, -2.00939793e-02f, -4.32917476e-02f },
      { -4.70031276e-02f, 3.83221209e-02f, 4.70076986e-02f, -1.67572089e-02f, -3.79558466e-02f },
    },
    {
      { -5.83249293e-02f, 1.11710941e-02f, 3.97655964e-02f, -7.24182948e-02f, -4.40671816e-02f },
      { -1.90295447e-02f, 2.84488220e-02f, 4.15531732e-02f, 1.35446200e-02f, 2.94759665e-02f },
      { 1.98952574e-03f, 3.59987468e-02f, 3.33478232e-03f, -7.36914203e-02f, -6.88089877e-02f },
      { 3.99822146e-02f, 1.93035007e-02f, -1.58823375e-02f, -4.11886014e-02f, 1.39208343e-02f },
      { 2.82052881e-03f, 2.23222803e-02f, 4.10636142e-02f, -2.10470241e-02f, 4.51355129e-02f },
    },
    {
      { 2.09085792e-02f, -2.61627585e-02f, -1.06206648e-02f, 7.21602608e-03f, -9.95313190e-03f },
      { -2.55056322e-02f, -4.59068231e-02f, 2.56499369e-02f, -4.74607870e-02f, -2.41635237e-02f },
      { -5.83643503e-02f, 5.74497990e-02f, -3.74010056e-02f, -5.69239520e-02f, 4.66404818e-02f },
      { -1.55572724e-02f, -4.12729383e-02f, 1.83937028e-02f, 3.85912918e-02f, -1.14851641e-02f },
      { -6.90126643e-02f, -2.95445286e-02f, -2.85419878e-02f, -3.29912640e-04f, -6.66517839e-02f },
    },
    {
      { -4.08734791e-02f, -6.05799742e-02f, 1.40486816e-02f, 4.92150821e-02f, 4.20723818e-02f },
      { 2.76645944e-02f, 3.36522609e-02f, -6.41790181e-02f, -3.54112312e-02f, -5.11698946e-02f },
      { 8.18597910e-04f, 2.56364010e-02f, 2.84289122e-02f, -2.54559424e-02f, -9.39728692e-03f },
      { 1.03525082e-02f, -6.63340688e-02f, -8.13826546e-03f, -4.32588793e-02f, 5.53913675e-02f },
      { -1.57942921e-02f, -1.03095863e-02f, 5.21359406e-02f, 1.41821690e-02f, -4.75016870e-02f },
    },
    {
      { 3.41935270e-02f, -9.74674523e-03f, -3.38933915e-02f, -2.81674545e-02f, 1.55981127e-02f },
      { -1.61325354e-02f, -5.35990484e-02f, 3.56804505e-02f, 8.64862278e-03f, -8.52741022e-03f },
      { -1.25107393e-02f, 2.16850415e-02f, 4.49944325e-02f, -1.01447469e-02f, 4.38904054e-02f },
      { -3.60272974e-02f, 5.54340845e-03f, -1.17837004e-02f, 4.39950358e-03f, 1.17607396e-02f },
      { -7.76751898e-03f, -2.85216216e-02f, -3.08609079e-03f, -3.92808439e-03f, 1.06320390e-02f },
    },
    {
      { -4.87445742e-02f, -3.10968757e-02f, -2.24720296e-02f, 8.53232853e-03f, 2.10623574e-02f },
      { 1.56713277e-02f, 4.57373932e-02f, -5.18433824e-02f, -2.03573387e-02f, -7.04608019e-03f },
      { 4.50096419e-03f, -2.65305787e-02f, 3.90625698e-03f, 7.08045118e-05f, -2.70315111e-02f },
      { 3.70841585e-02f, 3.61253098e-02f, -5.88380881e-02f, 3.15972865e-02f, 1.52818514e-02f },
      { -7.65119717e-02f, -5.60367992e-03f, 5.03061749e-02f, -4.11412045e-02f, 4.01396416e-02f },
    },
    {
      { -2.56622452e-02f, 1.86486430e-02f, -5.52786961e-02f, 5.33673503e-02f, 1.74539313e-02f },
      { 4.80449051e-02f, 9.09611583e-04f, 4.05162796e-02f, -4.52091135e-02f, -4.78217825e-02f },
      { 3.36862952e-02f, 2.48464122e-02f, 1.61240064e-03f, 3.13988887e-02f, -3.74926324e-03f },
      { 1.20272189e-02f, 1.12709180e-02f, -1.06639555e-02f, 5.79045061e-03f, -5.62407076e-03f },
      { -3.36739086e-02f, 1.01936199e-02f, -7.38449674e-03f, 2.12745797e-02f, -3.94920371e-02f },
    },
    {
      { -6.82453439e-02f, -6.57082126e-02f, 2.05879528e-02f, 8.48237891e-03f, -2.11247373e-02f },
      { -4.31627408e-02f, -6.88745528e-02f, -1.76631529e-02f, 3.17337476e-02f, 1.98903624e-02f },
      { 3.31304744e-02f, -4.67500761e-02f, 2.22886149e-02f, -3.81496269e-03f, 2.08895504e-02f },
      { -2.05259118e-02f, 2.79625617e-02f, -5.45961261e-02f, 1.23187155e-03f, -3.95960882e-02f },
      { -1.15139019e-02f, 4.31204587e-02f, -8.01966432e-03f, 4.48726043e-02f, -1.09549873e-02f },
    },
    {
      { 3.17610055e-02f, -6.27317503e-02f, 1.64800454e-02f, -1.03704249e-02f, 2.34903838e-03f },
      { -4.23000641e-02f, 3.73737141e-02f, -6.85624257e-02f, -5.45811318e-02f, 2.56117657e-02f },
      { 1.20467627e-02f, -4.07650555e-03f, 2.34792177e-02f, -3.11700185e-03f, 3.03281285e-02f },
      { -2.24384125e-02f, -1.23486593e-02f, 3.10344864e-02f, -1.53318411e-02f, -6.08649142e-02f },
      { 1.18979532e-02f, 1.85254179e-02f, -5.18188626e-02f, -2.45793257e-02f, 5.09857154e-03f },
    },
    {
      { -6.62015602e-02f, -5.64507358e-02f, 1.47978486e-02f, -1.15132134e-03f, 4.14212495e-02f },
      { -4.41991240e-02f, -6.29456639e-02f, -5.14539219e-02f, 4.56303880e-02f, 3.61748785e-02f },
      { -6.71614008e-03f, 3.69146317e-02f, -1.27232159e-02f, 1.79115143e-02f, 1.18058152e-03f },
      { 4.74749366e-03f, -3.45478319e-02f, -4.06954624e-02f, 2.33046897e-02f, -2.36503724e-02f },
      { -6.16419390e-02f, -2.51088198e-02f, 3.23789455e-02f, -4.66410816e-03f, -1.80611499e-02f },
    },
    {
      { -5.33466227e-02f, -6.07559420e-02f, 3.33252735e-02f, -5.77833466e-02f, 2.58207042e-02f },
      { -3.10955476e-03f, 5.17572686e-02f, -2.70730201e-02f, -3.41235958e-02f, -1.49634341e-02f },
      { -5.34494743e-02f, -4.93827127e-02f, 2.72190385e-02f, 2.19461657e-02f, -5.74952215e-02f },
      { 1.41562149e-02f, 1.07465088e-02f, 6.00127457e-03f, 5.05805165e-02f, 3.76124270e-02f },
      { -1.94973499e-02f, -6.77866340e-02f, -6.68142140e-02f, -2.75599025e-02f, -9.72316880e-03f },
    },
    {
      { -4.01976816e-02f, -9.65412427e-03f, -2.40410101e-02f, 1.06162056e-02f, -6.64891750e-02f },
      { -1.06628006e-02f, -1.91682242e-02f, 2.49237078e-03f, -2.43797395e-02f, 4.42106798e-02f },
      { 7.82614201e-03f, -1.85954582e-03f, 3.55714522e-02f, 5.08581405e-04f, 4.04421017e-02f },
      { -5.19955568e-02f, 1.51342917e-02f, -3.20945494e-02f, -5.94572648e-02f, 3.45389023e-02f },
      { -1.95018128e-02f, -3.14676128e-02f, -3.12552266e-02f, -6.04567565e-02f, -2.78795101e-02f },
    },
    {
      { 2.06146315e-02f, 2.96034198e-02f, 2.53213290e-02f, -5.58277108e-02f, 5.11681102e-02f },
      { -1.40029183e-02f, -5.19976169e-02f, 3.73693532e-03f, 6.12820592e-03f, 3.74714360e-02f },
      { -6.42833784e-02f, 1.14830048e-03f, -6.15664832e-02f, -3.07841767e-02f, -4.12461124e-02f },
      { -2.75593679e-02f, 1.29033569e-02f, 4.66185175e-02f, -6.51413873e-02f, 3.49538065e-02f },
      { 2.85115913e-02f, -9.17168334e-03f, -3.98076810e-02f, 1.35043683e-02f, 5.76317729e-03f },
    },
    {
      { -4.98583242e-02f, 4.30555344e-02f, 3.13674808e-02f, -4.77394089e-02f, 2.58134585e-02f },
      { -4.99186963e-02f, -3.49278748e-02f, -1.74650494e-02f, -3.90071273e-02f, 5.17893583e-02f },
      { 2.25132760e-02f, 1.79366656e-02f, -1.28600560e-02f, -1.13938656e-02f, -6.51365053e-03f },
      { 3.42763588e-02f, 1.07456185e-02f, -5.39698005e-02f, 2.81403828e-02f, -1.30971801e-02f },
      { -4.19103056e-02f, -1.09691927e-02f, 4.30876277e-02f, -1.69130191e-02f, 2.76164636e-02f },
    },
    {
      { 1.85986571e-02f, -2.80109164e-03f, 5.42388968e-02f, 9.46262479e-03f, 9.67917126e-03f },
      { -5.56138009e-02f, 2.02993434e-02f, 3.61143053e-02f, 2.57483050e-02f, -1.40149822e-03f },
      { 4.29708920e-02f, -6.54947609e-02f, -9.77817574e-04f, 3.64109389e-02f, -1.25445407e-02f },
      { -3.03619504e-02f, -4.52111624e-02f, -6.20612949e-02f, 2.00123414e-02f, 2.90746335e-02f },
      { -3.03292344e-03f, 3.97375673e-02f, 1.87967364e-02f, 3.36272456e-02f, 5.13277538e-02f },
    },
    {
      { 1.91090871e-02f, -5.19666448e-02f, 1.87547430e-02f, 2.04567183e-02f, -5.86653985e-02f },
      { 1.36601580e-02f, 3.46818604e-02f, -4.10486534e-02f, 1.87982507e-02f, 5.07273385e-03f },
      { -6.84268773e-04f, 2.12707184e-02f, -4.38981056e-02f, -6.02318011e-02f, 1.77926067e-02f },
      { 3.70607595e-03f, 9.01214592e-03f, 4.54541929e-02f, 3.18929516e-02f, 7.97631405e-03f },
      { -3.97039950e-02f, 2.32503284e-02f, 4.41334471e-02f, 2.97454782e-02f, -1.49750281e-02f },
    },
    {
      { -2.81868447e-02f, -3.24303173e-02f, 1.13801574e-02f, -7.21840486e-02f, -2.73164399e-02f },
      { 4.38036509e-02f, -6.30310178e-02f, 9.71134519e-04f, -5.18068112e-02f, 2.81481985e-02f },
      { 1.98123977e-03f, -6.03177398e-02f, 2.12138481e-02f, -4.21240106e-02f, 3.80764268e-02f },
      { -2.80635222e-03f, 4.12434246e-03f, -2.88428161e-02f, 7.13199377e-03f, -5.78661356e-03f },
      { -5.70720993e-02f, -5.48684457e-03f, -4.86963987e-02f, -5.91210276e-02f, 4.75485902e-03f },
    },
    {
      { 3.81602906e-02f, 5.14344461e-02f, -3.28073241e-02f, 1.56067442e-02f, -5.07180430e-02f },
      { -3.50086577e-02f, 2.48228461e-02f, -5.29059470e-02f, -6.22440763e-02f, -5.92331402e-02f },
      { 2.46244632e-02f, -1.31779350e-02f, 8.85207951e-03f, 2.19413023e-02f, 4.52879467e-04f },
      { 2.00123079e-02f, 1.60921440e-02f, -6.30659536e-02f, 1.44461812e-02f, 4.71350476e-02f },
      { -5.77308945e-02f, 8.96491483e-03f, -1.00287087e-02f, -5.71501814e-02f, 1.58559904e-02f },
    },
    {
      { -2.81536933e-02f, -3.92870530e-02f, -7.14132041e-02f, 4.74976711e-02f, 5.25675714e-03f },
      { 3.77773754e-02f, -2.45603584e-02f, -4.16508317e-02f, -3.12578008e-02f, 4.63558622e-02f },
      { 2.74847075e-02f, -9.52374935e-03f, 5.15941456e-02f, -2.82625053e-02f, -4.22135964e-02f },
      { -1.29943178e-03f, -1.00028198e-02f, 7.65167468e-04f, 2.86979415e-02f, 1.88731849e-02f },
      { -3.51497927e-03f, -1.75630245e-02f, -6.51186258e-02f, 1.46769211e-02f, 5.18351011e-02f },
    },
    {
      { 3.48360948e-02f, -4.71982099e-02f, 3.93073224e-02f, -3.79174203e-02f, -4.56046350e-02f },
      { -4.10701521e-02f, -6.46597967e-02f, -6.15708232e-02f, -4.28500734e-02f, 2.38494799e-02f },
      { 2.03798804e-03f, -2.93605067e-02f, 4.13397141e-02f, -3.73491235e-02f, 8.47154669e-03f },
      { -5.68297878e-02f, 2.60217898e-02f, -3.64030525e-02f, 2.84710601e-02f, -2.44590677e-02f },
      { 6.56981692e-02f, -4.66734171e-02f, -2.30509806e-02f, -4.23656637e-03f, -2.22954024e-02f },
    },
    {
      { 4.02745493e-02f, 1.66266430e-02f, 1.74594428e-02f, -6.66663945e-02f, 2.32776459e-02f },
      { 4.99360710e-02f, -4.38957959e-02f, -3.16961892e-02f, -2.33444944e-02f, -1.81663949e-02f },
      { -1.92519836e-03f, -5.14637195e-02f, -4.56445031e-02f, 3.84255834e-02f, 4.77381274e-02f },
      { -1.28630521e-02f, 2.61987876e-02f, -2.44805720e-02f, -1.93620585e-02f, -5.09975404e-02f },
      { -1.23582212e-02f, -1.82995182e-02f, 1.79694127e-02f, -5.57424314e-02f, 5.02487831e-03f },
    },
    {
      { -2.10024472e-02f, 4.08061892e-02f, -1.26184954e-03f, 3.32138352e-02f, -2.60260757e-02f },
      { 4.74706069e-02f, -2.68560107e-04f, 5.31023405e-02f, 5.40318154e-02f, 4.00404111e-02f },
      { -5.97732551e-02f, 1.67882927e-02f, 2.27401573e-02f, -4.14424501e-02f, -8.94807372e-03f },
      { -3.99118215e-02f, -2.08309535e-02f, -6.94150804e-04f, -4.86475788e-02f, -3.92672718e-02f },
      { -3.62845697e-02f, -6.33983463e-02f, -1.45701328e-02f, -2.26832405e-02f, -3.51219885e-02f },
    },
    {
      { -1.17804790e-02f, -1.28900250e-02f, -1.07364552e-02f, -2.98402272e-02f, -3.32168303e-02f },
      { 1.99004468e-02f, -1.26534589e-02f, -3.02497507e-03f, -3.75783183e-02f, -1.40954657e-02f },
      { 3.74584347e-02f, -3.25006954e-02f, -9.77777503e-03f, 3.72318849e-02f, 4.21446515e-04f },
      { 2.82933284e-03f, -4.98025566e-02f, 7.83318374e-03f, -1.87822711e-02f, -5.17917611e-03f },
      { 1.80514939e-02f, -6.54685274e-02f, -6.99395910e-02f, -1.57716479e-02f, 2.21224166e-02f },
    },
    {
      { -6.63782004e-03f, 2.35964768e-02f, -1.62335001e-02f, -4.17320020e-02f, -5.21683134e-02f },
      { 6.17247298e-02f, -3.11360657e-02f, 2.38052122e-02f, 3.25114876e-02f, -2.79901214e-02f },
      { -5.99132702e-02f, 3.62436809e-02f, 1.23212524e-02f, 1.10631762e-02f, 5.12290113e-02f },
      { 1.42358365e-02f, 4.23698388e-02f, -4.69633378e-02f, -4.25657369e-02f, -4.29732986e-02f },
      { 4.80217747e-02f, -5.37085123e-02f, -2.27241637e-03f, 3.75987254e-02f, 2.03752797e-02f },
    },
  },
  {
    {
      { -9.03699473e-02f, -2.59382911e-02f, -1.22311413e-01f, 1.80565808e-02f, 5.90064190e-02f },
      { 9.17563364e-02f, 1.71059981e-01f, 8.63092914e-02f, 6.60968721e-02f, 6.86771944e-02f },
      { 1.41924143e-01f, 2.20064849e-01f, 1.90683737e-01f, 9.02862102e-02f, 1.91037685e-01f },
      { 1.57491952e-01f, 1.78457290e-01f, 1.50220901e-01f, 9.30442661e-02f, -3.47789489e-02f },
      { 1.65515706e-01f, 5.62943779e-02f, 3.17204408e-02f, 8.60345587e-02f, -2.43756726e-01f },
    },
    {
      { -1.13010220e-01f, -2.03260958e-01f, -2.50532895e-01f, 7.10269511e-02f, -3.54109854e-02f },
      { -1.00335799e-01f, -1.78796440e-01f, -1.57442838e-02f, -1.18650710e-02f, -1.45835355e-01f },
      { -8.05081353e-02f, -8.54578167e-02f, 5.04802056e-02f, -3.50906588e-02f, 3.05858552e-02f },
      { 5.40389959e-03f, 7.19705001e-02f, 2.31046453e-01f, 5.93812950e-02f, 1.53708071e-01f },
      { 3.03997356e-03f, 1.46119788e-01f, 5.06820492e-02f, 8.29556957e-02f, 1.46047994e-01f },
    },
    {
      { -2.16787113e-04f, -1.29603788e-01f, -1.71135813e-01f, -1.12135664e-01f, -2.19888091e-01f },
      { 2.97266450e-02f, 5.07611223e-02f, -1.85335930e-02f, -1.33004114e-01f, -1.52593195e-01f },
      { -3.16447109e-01f, -1.53939128e-01f, -5.92123382e-02f, -2.31335282e-01f, -8.46506581e-02f },
      { -3.51650804e-01f, 1.59482434e-02f, 4.45449948e-02f, -1.72516201e-02f, 1.44870341e-01f },
      { 1.97478365e-02f, 1.00335792e-01f, -9.98836011e-02f, 7.38544613e-02f, 2.22497031e-01f },
    },
    {
      { -3.76112722e-02f, 2.48792358e-02f, 5.48162609e-02f, -1.90553349e-02f, 3.39128412e-02f },
      { 8.10573921e-02f, 4.45645899e-02f, 2.32238956e-02f, 6.23744912e-02f, 2.16572825e-02f },
      { 5.40553145e-02f, 6.46602735e-02f, 2.27015540e-02f, 3.63523290e-02f, 3.99301527e-03f },
      { 1.09344460e-01f, -1.08589726e-02f, 2.48863995e-02f, 1.20394245e-01f, -2.25107476e-01f },
      { 1.41638190e-01f, 3.82215120e-02f, 7.06573129e-02f, -7.65496418e-02f, -2.93206066e-01f },
    },
    {
      { 1.88533694e-01f, 1.59796521e-01f, 1.20952062e-01f, 1.77375716e-03f, 5.17984554e-02f },
      { 1.74694195e-01f, 1.21052749e-01f, 6.13739304e-02f, 6.15916774e-02f, 9.38274339e-02f },
      { -2.66984832e-02f, 2.80932542e-02f, 1.48233194e-02f, -5.61019890e-02f, 5.83491586e-02f },
      { 1.30020455e-02f, -1.46575840e-02f, -1.29430071e-01f, -6.33615553e-02f, -1.38964280e-01f },
      { 1.21391013e-01f, 4.94378768e-02f, -4.79585379e-02f, -4.53572273e-02f, -2.89865941e-01f },
    },
    {
      { 8.02450478e-02f, 1.32394403e-01f, 3.45793664e-02f, -6.57435227e-03f, -2.79340129e-02f },
      { -7.24462867e-02f, -3.34621966e-02f, -6.15503266e-03f, -3.34009603e-02f, -2.45546475e-02f },
      { -2.29357928e-01f, -1.06335483e-01f, 3.35546508e-02f, 5.53023927e-02f, -6.95729977e-05f },
      { 5.17528951e-02f, -7.29186386e-02f, -9.99303162e-02f, 5.22237690e-03f, -1.67489231e-01f },
      { 9.17388219e-03f, 2.45116111e-02f, 6.99091852e-02f, 4.24445458e-02f, 1.82615258e-04f },
    },
    {
      { 1.92250814e-02f, 1.38247237e-01f, -7.14124218e-02f, 5.68698980e-02f, -6.74731191e-03f },
      { -1.43871069e-01f, -9.17335525e-02f, -7.25302398e-02f, -2.03806132e-01f, -1.10927388e-01f },
      { -1.10158376e-01f, 7.73746222e-02f, -7.06597865e-02f, -2.12072715e-01f, -3.19617465e-02f },
      { -2.15792358e-01f, 1.80837512e-01f, -8.47047567e-02f, -1.26047954e-01f, 6.52830005e-02f },
      { -2.21932024e-01f, 1.89593881e-01f, -1.60471112e-01f, 6.05686009e-02f, -4.76854518e-02f },
    },
    {
      { 6.53444678e-02f, 1.50277857e-02f, -1.01401620e-01f, -4.64496091e-02f, -1.39451206e-01f },
      { -9.13303047e-02f, -1.88771397e-01f, -1.99725762e-01f, -1.16132170e-01f, -1.61152989e-01f },
      { -3.25010121e-01f, -2.38586128e-01f, -3.35776508e-02f, -1.71575874e-01f, -1.16067141e-01f },
      { -2.83725649e-01f, 6.66556694e-03f, -6.85100630e-02f, -2.27999806e-01f, 6.30678311e-02f },
      { -1.32570997e-01f, 9.14180651e-03f, -1.27210453e-01f, 7.35372603e-02f, 1.66471109e-01f },
    },
    {
      { -3.02636683e-01f, -3.63464028e-01f, -2.82267392e-01f, 5.21624982e-02f, -1.35859074e-02f },
      { 2.43761335e-02f, -2.07217574e-01f, -1.76592655e-02f, 2.55381558e-02f, -4.03392240e-02f },
      { -3.63721997e-02f, 1.02204651e-01f, 5.95890507e-02f, -6.29680008e-02f, 6.96930960e-02f },
      { 5.57477102e-02f, 1.70413777e-02f, 1.63415492e-01f, 1.18767984e-01f, 2.21875474e-01f },
      { 8.41773376e-02f, -9.92332995e-02f, 1.45461991e-01f, -4.83089918e-03f, 6.64971173e-02f },
    },
    {
      { -1.10418297e-01f, -6.03785403e-02f, 3.98854092e-02f, -2.85623875e-02f, 1.51427034e-02f },
      { -1.08575158e-01f, -8.48136283e-03f, -6.30716458e-02f, 1.68888904e-02f, -9.42484941e-03f },
      { -1.08227722e-01f, -2.76053436e-02f, -3.98294441e-02f, 1.46705732e-01f, 4.07960378e-02f },
      { 4.19750847e-02f, -1.73361637e-02f, 2.51869168e-02f, 1.60396114e-01f, -6.98141903e-02f },
      { 7.32527301e-02f, 1.11345455e-01f, 1.26792043e-01f, 5.30676171e-02f, -1.19959824e-01f },
    },
    {
      { 2.13109747e-01f, 2.07538947e-01f, 9.68861803e-02f, -1.18857836e-02f, -1.10484893e-02f },
      { 7.98149109e-02f, 4.80343252e-02f, 9.68357548e-02f, 9.49137099e-03f, -2.37767324e-02f },
      { -3.49078566e-01f, -3.44466656e-01f, 1.60156749e-02f, 4.56091948e-02f, -4.42802208e-03f },
      { -1.82503000e-01f, -1.93051562e-01f, -3.13893437e-01f, -1.82195768e-01f, -4.99826483e-02f },
      { -4.80102301e-02f, 2.93140374e-02f, -1.51088715e-01f, -2.16572825e-02f, -5.38192913e-02f },
    },
    {
      { -3.57060760e-01f, -1.86476767e-01f, -1.18626647e-01f, -4.12051529e-02f, 4.48005870e-02f },
      { -2.18650550e-01f, -1.41183242e-01f, -5.21798171e-02f, -5.07286601e-02f, 3.05804312e-02f },
      { -6.14668382e-03f, 4.35252227e-02f, -2.03278818e-04f, 5.47690690e-02f, 9.32671651e-02f },
      { 5.27524836e-02f, 9.75159779e-02f, 1.23463623e-01f, 2.61054724e-01f, 2.01654643e-01f },
      { 2.28833444e-02f, 1.50448084e-01f, 1.88425794e-01f, 1.97073489e-01f, 1.09239958e-01f },
    },
    {
      { -1.58273354e-01f, -1.84940547e-01f, -2.29187578e-01f, -9.81866345e-02f, -1.17534183e-01f },
      { -2.39770874e-01f, -1.98536560e-01f, -4.44296859e-02f, -9.89264026e-02f, -1.26017302e-01f },
      { -1.34605467e-01f, 6.42066151e-02f, 2.00714357e-02f, 4.44977311e-03f, 7.83955455e-02f },
      { -2.06733830e-02f, 1.76332414e-01f, 9.30300131e-02f, 8.13057423e-02f, 1.01888761e-01f },
      { 1.39523493e-02f, 1.08144462e-01f, 4.49129157e-02f, 1.25781268e-01f, 1.76392063e-01f },
    },
    {
      { -5.17430604e-02f, -9.70306024e-02f, -1.52202457e-01f, 8.84778649e-02f, 7.23634511e-02f },
      { -5.41549213e-02f, -2.37250358e-01f, -6.14752993e-02f, -4.52778786e-02f, -1.27734944e-01f },
      { -1.43997684e-01f, -6.28636628e-02f, -8.19448829e-02f, -8.13146383e-02f, 6.30991533e-02f },
      { -1.62065607e-02f, 7.89303109e-02f, 7.39997327e-02f, -6.09838814e-02f, 1.09623104e-01f },
      { -1.21766115e-02f, 4.87769432e-02f, -4.84687947e-02f, 7.68548027e-02f, 1.56445622e-01f },
    },
    {
      { -3.65547016e-02f, -1.30254235e-02f, -7.09867999e-02f, 3.42721827e-02f, 1.21657737e-02f },
      { 4.88253646e-02f, -1.58227962e-02f, -2.85324287e-02f, 1.84520502e-02f, -5.75680891e-03f },
      { 3.92005406e-03f, 3.34694348e-02f, -2.19745934e-02f, 1.77025031e-02f, 5.64278942e-03f },
      { -2.39181891e-02f, 6.29923493e-02f, 1.63518600e-02f, 4.33041044e-02f, -1.50552299e-02f },
      { -5.24214432e-02f, -5.13555482e-02f, -4.68728738e-03f, -5.00919111e-02f, -3.23653407e-02f },
    },
    {
      { -2.70890426e-02f, 1.80237517e-02f, -1.32726785e-02f, -2.81872451e-02f, -1.54050104e-02f },
      { -8.56408104e-02f, -1.34179384e-01f, -2.50091739e-02f, -6.13616034e-02f, 4.13047001e-02f },
      { -1.21230327e-01f, -3.34182940e-02f, -3.32041308e-02f, -3.22127864e-02f, 7.25368783e-02f },
      { 1.20514613e-02f, 3.34490798e-02f, -1.82481892e-02f, 1.16761141e-02f, 1.30411625e-01f },
      { 1.90025233e-02f, 1.35084912e-01f, 9.14880037e-02f, 1.61456719e-01f, 6.48231432e-02f },
    },
    {
      { 6.45625368e-02f, 8.70705489e-03f, 9.51335356e-02f, 4.47767712e-02f, -2.57080309e-02f },
      { 8.91893730e-02f, -1.97102036e-03f, -3.04356068e-02f, 9.91975050e-03f, 2.76983771e-02f },
      { 2.12408565e-02f, -1.03230804e-01f, -5.69623634e-02f, 3.63328382e-02f, 2.80440897e-02f },
      { -9.39149689e-03f, -9.97949690e-02f, -7.79793710e-02f, -1.59600616e-01f, 2.56626364e-02f },
      { -1.75048143e-03f, -9.19483677e-02f, -6.02747723e-02f, -3.34491022e-02f, 7.87527114e-02f },
    },
    {
      { 8.61208364e-02f, -2.10642908e-02f, 3.21514159e-02f, 2.64052562e-02f, -1.15125358e-01f },
      { -1.17450893e-01f, -4.50210385e-02f, -1.16944453e-02f, -3.87592502e-02f, 5.62004047e-03f },
      { -3.24629992e-01f, -8.50343853e-02f, -1.26728406e-02f, -9.22477096e-02f, -5.18081337e-02f },
      { -1.06357209e-01f, -6.25861287e-02f, -1.11485690e-01f, -4.25524916e-03f, 1.33323902e-02f },
      { -9.58289057e-02f, 2.28017922e-02f, 1.48119954e-02f, 7.21297413e-02f, 9.01651755e-02f },
    },
    {
      { 2.08428353e-01f, 2.11298138e-01f, 1.06519312e-01f, 1.49572253e-01f, 5.46440594e-02f },
      { 3.37075330e-02f, 7.87329152e-02f, -2.80322582e-02f, 3.31533477e-02f, 1.20475858e-01f },
      { -1.21383660e-01f, -2.69358516e-01f, 4.49490286e-02f, 1.31013379e-01f, -3.66918966e-02f },
      { -8.54180008e-02f, -2.95031399e-01f, -3.34969401e-01f, -1.97567388e-01f, -1.14604555e-01f },
      { 3.57200252e-03f, -8.50899965e-02f, -1.51619092e-01f, -1.22051798e-01f, -3.60990292e-03f },
    },
    {
      { 8.11358392e-02f, 3.64094563e-02f, 3.41343135e-02f, 3.95913161e-02f, 6.50287122e-02f },
      { 6.33792430e-02f, 5.73195629e-02f, 1.14906505e-01f, 1.04380362e-02f, 3.04943658e-02f },
      { 8.14415291e-02f, 1.11266442e-01f, -7.52914348e-04f, -6.38589561e-02f, 1.12006567e-01f },
      { 2.71616206e-02f, -4.57974821e-02f, -8.07583109e-02f, -7.81485531e-03f, -5.70484363e-02f },
      { 1.76568870e-02f, -9.15617496e-02f, -8.90340135e-02f, -1.57696173e-01f, -8.13021958e-02f },
    },
    {
      { -2.23711014e-01f, -1.23161592e-01f, -5.80267794e-03f, 1.54311582e-02f, 2.24014390e-02f },
      { -2.13147268e-01f, -4.50932458e-02f, -4.31032740e-02f, 3.99584658e-02f, -8.50689877e-03f },
      { 2.95571107e-02f, 9.83944386e-02f, 8.65357071e-02f, 7.49287084e-02f, 6.63714707e-02f },
      { 3.08083948e-02f, 2.81033516e-02f, 1.18087947e-01f, 1.23310558e-01f, 6.82535842e-02f },
      { -3.86620536e-02f, 5.77593707e-02f, 1.45494893e-01f, 1.13282353e-01f, 1.03631683e-01f },
    },
    {
      { 3.43800671e-02f, -3.41962837e-02f, -1.38486505e-01f, -2.57324129e-01f, -3.41406733e-01f },
      { 5.19311279e-02f, 3.54545079e-02f, -7.32723475e-02f, -1.66593015e-01f, -2.91673839e-01f },
      { -2.97859088e-02f, -1.36682302e-01f, -1.23027787e-01f, -1.20842326e-02f, -1.32801279e-01f },
      { -3.76898676e-01f, -2.48559579e-01f, -2.14869916e-01f, -3.12710106e-01f, -1.27086967e-01f },
      { -1.28534034e-01f, 3.34922262e-02f, -2.08094954e-01f, -1.97801247e-01f, -8.67303312e-02f },
    },
    {
      { -2.55883411e-02f, -1.75514482e-02f, -9.20800865e-02f, -1.46713071e-02f, 7.74876447e-03f },
      { -9.68272313e-02f, -7.52297863e-02f, 4.32019196e-02f, 2.69145914e-03f, -1.79551207e-02f },
      { -1.38132364e-01f, -7.37956315e-02f, 7.96601549e-02f, 2.66746450e-02f, 7.52988905e-02f },
      { -3.69606055e-02f, -8.60194489e-02f, 1.12546235e-01f, 1.92072555e-01f, 1.09358847e-01f },
      { 7.46894479e-02f, 1.19771034e-01f, 9.96449366e-02f, 1.41128287e-01f, 1.25064924e-01f },
    },
    {
      { -1.18159831e-01f, -2.23676190e-02f, -1.01020940e-01f, 1.70688946e-02f, 4.74624671e-02f },
      { -1.31468251e-01f, -1.23472765e-01f, -5.99550530e-02f, -6.23668656e-02f, 2.19916154e-04f },
      { -1.25297233e-01f, 9.87565704e-03f, 3.67121547e-02f, -1.28021181e-01f, 4.75065336e-02f },
      { -6.31028563e-02f, 4.03419882e-02f, 6.13974594e-02f, 7.95494318e-02f, 1.27392963e-01f },
      { -4.96770665e-02f, 6.28540516e-02f, 3.01246792e-02f, 1.15177043e-01f, 8.82068127e-02f },
    },
    {
      { 1.77256361e-01f, 1.42930761e-01f, 8.77943188e-02f, 8.12365767e-03f, -2.43354924e-02f },
      { 6.74881712e-02f, 6.73950985e-02f, 3.10642943e-02f, -5.66389672e-02f, -5.60018159e-02f },
      { -2.53000617e-01f, -3.64926517e-01f, -8.49797204e-02f, -1.42321028e-02f, -7.12460279e-02f },
      { -1.91004813e-01f, -1.75348103e-01f, -2.28205606e-01f, -1.35139242e-01f, -3.50692198e-02f },
      { -7.72335902e-02f, 3.04279942e-03f, -2.09037703e-03f, 4.52122092e-02f, 6.16250820e-02f },
    },
    {
      { 2.29099840e-01f, 1.10132851e-01f, 6.90891147e-02f, 1.07501656e-01f, 2.20310036e-02f },
      { -2.47919392e-02f, -1.06682308e-01f, -1.28351584e-01f, -2.66595092e-03f, 2.94242408e-02f },
      { -1.70285985e-01f, -2.26105601e-01f, 4.22981083e-02f, -8.59133527e-02f, -1.11173563e-01f },
      { -9.34011787e-02f, 5.10241240e-02f, -5.51880933e-02f, -2.30402797e-01f, 1.36560932e-01f },
      { -1.32688701e-01f, 1.95437614e-02f, -1.09874448e-02f, 5.67932837e-02f, 1.50735125e-01f },
    },
    {
      { 1.78461254e-01f, 8.72230083e-02f, 1.39864936e-01f, 9.35235098e-02f, 5.05999960e-02f },
      { 1.24594457e-01f, 2.66704392e-02f, 1.30517213e-02f, -2.23996341e-02f, 1.66008249e-02f },
      { -2.10081339e-02f, -7.84283131e-02f, -4.76086475e-02f, 9.84956697e-03f, 2.84553692e-02f },
      { -9.68620181e-02f, -1.05163738e-01f, -2.20479935e-01f, -1.05090730e-01f, -3.37914824e-02f },
      { -1.07404375e-02f, -1.03900999e-01f, -6.75639659e-02f, -6.83042854e-02f, -4.26707305e-02f },
    },
    {
      { -1.75391123e-01f, -7.73865208e-02f, 2.08856687e-02f, -7.81503320e-03f, -5.85906096e-02f },
      { -1.67544141e-01f, -4.41962108e-02f, -3.62167545e-02f, 1.27254408e-02f, 5.88830300e-02f },
      { -1.24384291e-01f, 7.13838637e-03f, 3.04094460e-02f, 1.03241421e-01f, 6.92963898e-02f },
      { 3.04965340e-02f, 7.05453455e-02f, 1.72458917e-01f, 1.28031790e-01f, 1.62300259e-01f },
      { 1.01979591e-01f, 1.60243556e-01f, 1.32541656e-01f, 1.66868463e-01f, 1.21970467e-01f },
    },
    {
      { -2.22130015e-01f, -1.56977758e-01f, -3.51081267e-02f, -3.29444446e-02f, 1.02402054e-01f },
      { -1.91368550e-01f, -1.24331200e-02f, -5.53248301e-02f, -1.99675187e-02f, 1.36040086e-02f },
      { 1.05750136e-01f, 7.49564022e-02f, 5.97018674e-02f, 8.25900510e-02f, 1.06000021e-01f },
      { 6.94084018e-02f, 1.31161734e-01f, 1.65086344e-01f, 1.97037876e-01f, 1.82859570e-01f },
      { 3.19404751e-02f, 1.01629555e-01f, 1.83871329e-01f, 1.81612775e-01f, 7.12076649e-02f },
    },
    {
      { 2.51752650e-03f, -5.10755219e-02f, -8.80691595e-03f, 4.06526960e-03f, -5.15686721e-02f },
      { -1.20669352e-02f, -3.84296104e-02f, 2.80062482e-02f, 3.06761190e-02f, -2.60634627e-02f },
      { 9.64298658e-03f, -2.14753556e-03f, -3.08646765e-02f, 3.78335565e-02f, -4.17900719e-02f },
      { -5.71902804e-02f, -3.14715430e-02f, 2.73686666e-02f, 6.64031580e-02f, -1.37777217e-02f },
      { 3.17677893e-02f, 2.63338853e-02f, -1.93550587e-02f, 3.54437679e-02f, -3.13586630e-02f },
    },
    {
      { -1.11588649e-01f, -1.15883239e-01f, -1.00364543e-01f, 1.41728923e-01f, 5.80131561e-02f },
      { -7.26721659e-02f, -1.13073371e-01f, -9.83246975e-03f, 5.12705445e-02f, -1.13707602e-01f },
      { -3.17630246e-02f, -8.67345743e-03f, -3.85807566e-02f, 2.55139023e-02f, 1.66631237e-01f },
      { -5.41381426e-02f, 1.10508777e-01f, 1.79673433e-01f, 1.12113856e-01f, 1.13673821e-01f },
      { -4.39350829e-02f, -2.68039256e-02f, -4.86513786e-02f, 6.92921970e-03f, 1.06424443e-01f },
    },
    {
      { 8.55834037e-02f, 8.54032487e-03f, -1.85130447e-01f, 2.84361281e-02f, -4.23473455e-02f },
      { 1.50604144e-01f, -1.06760852e-01f, -4.12557833e-02f, 4.86884080e-02f, -9.80622917e-02f },
      { 1.33682579e-01f, -1.63728461e-01f, 1.68240350e-02f, -1.98242560e-01f, -5.37083037e-02f },
      { -8.53545219e-02f, -5.00297099e-02f, -5.83232986e-03f, -2.38513052e-01f, 1.90046206e-02f },
      { -1.85711995e-01f, -1.29802302e-01f, -1.08989850e-01f, -2.81201094e-01f, 1.04031965e-01f },
    },
  },
  {
    {
      { -3.78013737e-02f, 3.27478303e-03f, -7.52927910e-04f, -4.14385162e-02f, -3.78602557e-02f },
      { 4.36550975e-02f, -1.64264720e-02f, 4.51834723e-02f, 4.87699034e-03f, 4.36418429e-02f },
      { 1.30548952e-02f, -7.38212690e-02f, 4.35068905e-02f, -3.20816897e-02f, 2.41768826e-02f },
      { -6.03804998e-02f, -4.46974374e-02f, 1.31534431e-02f, -4.91596609e-02f, 2.64773797e-02f },
      { -4.79392223e-02f, 2.86737029e-02f, 9.74872522e-03f, 2.62538483e-03f, -3.52875562e-03f },
    },
    {
      { 1.00163771e-02f, 4.79312949e-02f, -6.53391629e-02f, 5.15114963e-02f, 7.10886763e-03f },
      { 1.95774361e-02f, 1.45376688e-02f, 4.37282696e-02f, -4.47721109e-02f, -4.78253439e-02f },
      { 1.44556304e-02f, -5.57477809e-02f, 2.86972467e-02f, 2.28338651e-02f, -2.55358964e-02f },
      { -4.60115075e-02f, -2.30934173e-02f, -4.11770679e-02f, -3.93668637e-02f, -6.83622658e-02f },
      { -6.93367422e-02f, -4.93347980e-02f, -2.59556416e-02f, 1.49945980e-02f, 4.19031493e-02f },
    },
    {
      { -7.03168213e-02f, 1.63232870e-02f, -2.47794483e-02f, -6.99585527e-02f, 3.89415771e-02f },
      { -4.04529795e-02f, 3.23850550e-02f, 2.19573025e-02f, -2.65472587e-02f, -3.27141769e-02f },
      { 5.73253743e-02f, 2.69723404e-02f, 3.18686431e-03f, 1.61434319e-02f, 4.24436592e-02f },
      { 3.68556865e-02f, 1.26682557e-02f, 2.11977288e-02f, -5.76321967e-02f, 3.46212648e-02f },
      { -5.84012941e-02f, -3.09746563e-02f, 1.44605031e-02f, 5.20003214e-03f, 3.43120657e-02f },
    },
    {
      { -5.62611632e-02f, 4.61358242e-02f, 3.12004387e-02f, 1.44822681e-02f, -3.73674892e-02f },
      { 2.98297685e-02f, 2.66471524e-02f, -6.72894716e-02f, -5.42985983e-02f, -4.74482402e-02f },
      { -5.55574484e-02f, 4.10873219e-02f, 2.41382793e-02f, -2.52241618e-03f, 4.30717058e-02f },
      { -1.21838050e-02f, 1.31777218e-02f, -2.75704898e-02f, 2.41311993e-02f, 4.08597514e-02f },
      { -5.55203557e-02f, -5.26850149e-02f, -6.08339300e-03f, 4.68910970e-02f, 1.54148554e-02f },
    },
    {
      { 7.17418268e-03f, -1.26232002e-02f, 3.82664539e-02f, -4.55040857e-02f, -2.06265114e-02f },
      { -1.98729485e-02f, -4.32140268e-02f, -4.34174500e-02f, -1.70167517e-02f, 2.24190447e-02f },
      { -1.01179974e-02f, 4.33030128e-02f, 1.15724616e-02f, 3.70308533e-02f, -6.83074212e-03f },
      { 1.75159499e-02f, -2.69190706e-02f, 3.14698517e-02f, -7.69044086e-02f, -7.54240677e-02f },
      { -2.73555145e-02f, -3.31061296e-02f, -3.99092622e-02f, 2.30269358e-02f, -4.49482305e-03f },
    },
    {
      { 2.68422328e-02f, 1.28518017e-02f, -6.87366491e-03f, -6.75623715e-02f, -1.34555325e-02f },
      { -3.00848354e-02f, -3.60689349e-02f, -6.59381598e-02f, -1.27140880e-02f, -9.75477975e-03f },
      { 1.81966077e-03f, -4.33667786e-02f, 3.35582830e-02f, -5.72077259e-02f, -2.58342139e-02f },
      { -4.51359935e-02f, -6.09970242e-02f, -6.24768585e-02f, -3.53750363e-02f, -6.23459332e-02f },
      { 3.20606567e-02f, -1.87208429e-02f, -6.04435578e-02f, -4.00995649e-03f, -9.20081045e-03f },
    },
    {
      { 4.54161540e-02f, 5.52170388e-02f, -1.71368141e-02f, 7.06960727e-03f, -5.78538775e-02f },
      { -4.58573475e-02f, -5.57336677e-03f, 4.16068658e-02f, 8.24440271e-03f, 1.54597382e-03f },
      { 7.85979815e-03f, 5.43937497e-02f, -2.89401263e-02f, -1.47384927e-02f, 1.93548612e-02f },
      { -1.70943625e-02f, -2.22196355e-02f, -3.51011641e-02f, -4.87542748e-02f, 3.22534591e-02f },
      { -1.01942394e-03f, -2.04593409e-02f, 1.78362690e-02f, -1.57715399e-02f, 2.55140793e-02f },
    },
    {
      { 3.08688506e-02f, -5.91132455e-02f, -9.47673991e-03f, -4.90827076e-02f, -4.10887189e-02f },
      { -1.20188333e-02f, -3.29867378e-02f, -5.72771169e-02f, 7.88015407e-03f, -2.08589137e-02f },
      { -3.92634086e-02f, 1.86696108e-02f, -5.02293669e-02f, -1.83539838e-02f, -5.02851829e-02f },
      { -5.07560112e-02f, -6.31603003e-02f, -1.09734684e-02f, -5.84117025e-02f, 1.83507167e-02f },
      { -5.70610017e-02f, 6.45400211e-03f, -3.85265835e-02f, 7.10722432e-03f, 1.44493952e-03f },
    },
    {
      { 4.91821803e-02f, -4.01242748e-02f, -1.74596682e-02f, -3.98898218e-03f, -4.74246703e-02f },
      { -5.92330992e-02f, 1.30567960e-02f, -5.26773967e-02f, -1.17200762e-02f, -5.94052151e-02f },
      { -2.34121680e-02f, -4.62957174e-02f, 2.63140183e-02f, -6.06125593e-02f, 8.16314574e-03f },
      { 2.49505043e-02f, -2.58541256e-02f, -1.69445686e-02f, 7.18945824e-03f, -1.49244042e-02f },
      { -6.99216127e-02f, -2.75034141e-02f, -6.06095158e-02f, -5.81225939e-02f, -4.02479433e-02f },
    },
    {
      { 1.95234863e-03f, -2.95606442e-02f, 3.71180139e-02f, -5.23887314e-02f, 3.58280651e-02f },
      { -4.11134660e-02f, 2.18557492e-02f, 6.40450791e-03f, 2.43962500e-02f, -2.39169057e-02f },
      { 5.06079495e-02f, -5.24456389e-02f, 1.23965992e-02f, -2.71368250e-02f, -2.73606344e-03f },
      { -6.12286329e-02f, -2.91310083e-02f, -5.53732663e-02f, -1.61625668e-02f, 1.79841425e-02f },
      { -7.20224297e-03f, 2.96746120e-02f, 3.12737143e-03f, -1.30717395e-04f, 1.16362702e-02f },
    },
    {
      { -3.63839790e-02f, -6.51377141e-02f, 3.72699611e-02f, -3.81467231e-02f, -5.03136069e-02f },
      { -5.75528592e-02f, -1.25201121e-02f, -6.87214956e-02f, -3.15040872e-02f, -8.06745440e-02f },
      { -4.13682573e-02f, -6.21838383e-02f, 3.29035670e-02f, -6.03718869e-02f, -3.86238955e-02f },
      { -3.86954658e-02f, -1.25849480e-02f, -1.94888469e-02f, -5.53929321e-02f, 3.96371679e-03f },
      { -7.25235045e-02f, -5.50038330e-02f, 8.58495757e-03f, -7.92322867e-03f, 1.63237061e-02f },
    },
    {
      { -3.83019857e-02f, 7.43468106e-03f, -3.71015891e-02f, -5.40955216e-02f, 1.81243867e-02f },
      { 1.42335156e-02f, -3.49304155e-02f, -5.71923815e-02f, -4.17272523e-02f, 2.92043239e-02f },
      { -3.35520543e-02f, -3.46883223e-03f, -6.39280006e-02f, 2.30447222e-02f, 4.72728815e-03f },
      { -5.49427085e-02f, -1.95424948e-02f, -6.25736713e-02f, -3.88812944e-02f, -4.40373793e-02f },
      { -6.11054711e-02f, -3.37161347e-02f, -6.10514805e-02f, -8.93835817e-03f, 1.83242392e-02f },
    },
    {
      { 3.29049677e-02f, 1.08279688e-02f, 9.43177566e-03f, 2.29706559e-02f, 5.06776422e-02f },
      { 3.79205719e-02f, -6.49032295e-02f, 3.76063655e-03f, 8.93911696e-04f, 1.34130577e-02f },
      { 4.08056863e-02f, 4.46263589e-02f, 4.05971818e-02f, -6.52634874e-02f, 5.37200533e-02f },
      { -4.77064028e-02f, 4.82717641e-02f, 1.88437011e-02f, -5.86334877e-02f, 4.44819033e-02f },
      { 6.58203475e-03f, 2.57836282e-02f, 4.74675111e-02f, -6.49453402e-02f, -3.06998473e-02f },
    },
    {
      { -5.54786809e-02f, -1.39919342e-02f, 3.15481401e-03f, 2.40985807e-02f, 2.42445245e-02f },
      { 3.59909832e-02f, -4.89646494e-02f, -9.78194643e-03f, -4.36689779e-02f, -3.46871950e-02f },
      { 5.41995326e-03f, -6.55563995e-02f, 1.40106920e-02f, 5.27934656e-02f, -4.01591435e-02f },
      { 5.20555042e-02f, -3.89451571e-02f, -2.70699374e-02f, -5.92060201e-02f, -4.91155349e-02f },
      { -4.55495864e-02f, 7.73541117e-03f, -2.08290271e-03f, -5.57506271e-02f, -6.54061139e-02f },
    },
    {
      { 3.24398689e-02f, -4.70289439e-02f, -6.15745932e-02f, 1.73877180e-02f, -3.09470743e-02f },
      { -2.74763294e-02f, -3.53199393e-02f, 4.29163985e-02f, 3.26770730e-02f, -3.09682786e-02f },
      { -5.51825091e-02f, -2.68873665e-02f, -1.05008604e-02f, -2.26967409e-02f, -5.94067685e-02f },
      { 9.93290171e-03f, -5.99433109e-03f, -3.08454894e-02f, -4.94657308e-02f, 1.79508552e-02f },
      { 2.08033882e-02f, -1.26536563e-02f, 1.18427686e-02f, -5.23336157e-02f, 2.93697752e-02f },
    },
    {
      { 3.34696397e-02f, 2.25734077e-02f, -6.51087388e-02f, 3.67920958e-02f, -5.05624674e-02f },
      { 3.42371427e-02f, -6.05893321e-02f, 3.47350317e-04f, 3.19382697e-02f, 4.80855852e-02f },
      { 3.23107913e-02f, 2.38212086e-02f, 2.31182668e-02f, 5.07064424e-02f, 2.82378439e-02f },
      { -3.18019763e-02f, -3.00358739e-02f, -4.07442227e-02f, -5.36025278e-02f, -6.42539188e-02f },
      { 4.47207950e-02f, 4.43692207e-02f, 4.62201573e-02f, -6.56771362e-02f, -5.14862798e-02f },
    },
    {
      { -5.94137125e-02f, 2.36252379e-02f, 7.93664530e-03f, 1.24673108e-02f, -3.63362283e-02f },
      { -6.01439476e-02f, -3.21289264e-02f, 2.03223582e-02f, 1.52551197e-02f, -4.36230637e-02f },
      { 1.91085378e-03f, -1.53637771e-02f, -5.00654019e-02f, 2.08359938e-02f, -5.14733754e-02f },
      { -5.17305955e-02f, -6.05532788e-02f, 4.21134531e-02f, -4.08005342e-02f, 4.28969488e-02f },
      { -1.37932794e-02f, 2.54676752e-02f, -7.77721778e-03f, -2.60352045e-02f, 2.43543722e-02f },
    },
    {
      { -2.37325393e-02f, -5.93696609e-02f, -1.10325345e-04f, -2.45093051e-02f, 2.47365292e-02f },
      { 4.17690948e-02f, -1.10936845e-02f, 1.59604046e-02f, 6.21546200e-03f, 3.29309404e-02f },
      { -9.19930544e-03f, -2.52038408e-02f, -1.60515402e-02f, -4.52794470e-02f, 4.93613482e-02f },
      { -5.43616228e-02f, 1.75538193e-02f, 2.50001401e-02f, 1.16326381e-02f, -2.13948134e-02f },
      { 8.50431714e-03f, 8.70729797e-03f, -1.38980029e-02f, 5.42149395e-02f, -4.18756418e-02f },
    },
    {
      { -7.27990493e-02f, -5.76376989e-02f, -4.58494797e-02f, 2.80340016e-02f, -6.80753216e-02f },
      { 2.87396684e-02f, -2.75651868e-02f, 1.16219623e-02f, -3.81732034e-03f, -6.92301691e-02f },
      { -2.70078261e-03f, -6.40292559e-03f, -4.95193750e-02f, 2.25906763e-02f, -5.08883633e-02f },
      { -5.26772402e-02f, 2.23488100e-02f, -1.78144779e-02f, -1.73987802e-02f, -2.15616021e-02f },
      { 8.34432431e-03f, 3.10678240e-02f, -3.19152474e-02f, -2.23873686e-02f, 3.06501146e-02f },
    },
    {
      { -4.52654250e-02f, -1.10295750e-02f, 3.34422402e-02f, -3.34989578e-02f, -5.92875518e-02f },
      { 2.19920184e-02f, 4.97201942e-02f, 4.29762155e-02f, -5.79052269e-02f, -2.83558387e-02f },
      { 2.26006610e-03f, -2.50360277e-02f, -4.01039012e-02f, -6.10848404e-02f, 4.95790318e-02f },
      { 1.20694861e-02f, 2.52051372e-02f, 2.42483616e-03f, -8.65040987e-04f, -4.28973623e-02f },
      { -4.81165685e-02f, 2.52537951e-02f, -5.00689633e-02f, 1.22250067e-02f, -1.60606299e-02f },
    },
    {
      { -5.11858501e-02f, -3.77881341e-02f, -4.26852740e-02f, -5.14014661e-02f, 6.98772445e-03f },
      { -4.85515259e-02f, -6.16440885e-02f, 2.34486777e-02f, -4.58955504e-02f, -6.34428784e-02f },
      { -5.03231622e-02f, -6.00832850e-02f, -2.26106122e-02f, 5.23157492e-02f, 3.96372937e-02f },
      { 4.35935743e-02f, -4.97155115e-02f, -2.05256641e-02f, -3.25813778e-02f, -6.43380731e-02f },
      { 1.22517208e-02f, 1.10385315e-02f, -6.95999935e-02f, 9.60971974e-03f, 3.81695963e-02f },
    },
    {
      { 3.18512805e-02f, 3.05970721e-02f, 3.56794521e-03f, -1.84988033e-03f, 2.19332110e-02f },
      { -4.22786549e-02f, -3.08496822e-02f, -8.27451795e-03f, 1.04376655e-02f, -6.32971525e-02f },
      { -2.71595381e-02f, -6.09246120e-02f, -5.57187386e-02f, 3.58779691e-02f, 2.84659513e-03f },
      { 5.04007079e-02f, -1.37774618e-02f, 1.23276084e-03f, 2.02427432e-02f, -6.26428649e-02f },
      { 3.49353850e-02f, -3.71078476e-02f, -3.63512076e-02f, -7.78271407e-02f, -1.14757279e-02f },
    },
    {
      { -5.79088144e-02f, 6.97333307e-04f, -3.11044417e-02f, -7.07176328e-02f, 6.93853758e-03f },
      { -6.61280425e-03f, 1.94679927e-02f, -5.07269166e-02f, -5.35591431e-02f, -5.23271486e-02f },
      { 2.65458692e-02f, -3.39587778e-02f, 1.63997784e-02f, 4.70384546e-02f, -6.21169321e-02f },
      { -7.05424398e-02f, 4.25292812e-02f, 2.20151595e-03f, -7.15546194e-05f, -2.69607529e-02f },
      { 1.89678799e-02f, -2.21432764e-02f, -7.05780238e-02f, -2.38267742e-02f, -6.58223182e-02f },
    },
    {
      { -5.64421266e-02f, -4.15870585e-02f, -4.50914092e-02f, 2.27510165e-02f, -9.69841331e-03f },
      { -3.71354930e-02f, -3.97778265e-02f, -6.02980107e-02f, 1.29977930e-02f, -3.29817422e-02f },
      { 3.58006847e-03f, -6.25144467e-02f, 1.79574732e-02f, 3.52193415e-02f, 4.10656035e-02f },
      { -2.63099596e-02f, 2.68061962e-02f, 4.78812642e-02f, -4.74226102e-02f, -4.99005727e-02f },
      { 2.47289706e-02f, -2.35785134e-02f, 1.18497768e-02f, 5.05223088e-02f, 4.16176803e-02f },
    },
    {
      { -3.97764444e-02f, 3.60195674e-02f, -5.07708862e-02f, 2.68099699e-02f, -2.33950056e-02f },
      { 1.30711906e-02f, -4.95830141e-02f, -8.24118778e-03f, 2.95762345e-02f, -4.54837717e-02f },
      { -5.42896148e-03f, -1.68082695e-02f, -5.43243699e-02f, 4.51831780e-02f, -4.12297212e-02f },
      { -5.40537685e-02f, -2.52428595e-02f, 1.04439380e-02f, -3.75183560e-02f, -1.16335182e-02f },
      { 2.61036754e-02f, -6.62542135e-02f, -6.38149753e-02f, -2.76327003e-02f, 1.12188235e-02f },
    },
    {
      { 2.33497079e-02f, 3.62171307e-02f, -2.11607832e-02f, -6.67574853e-02f, -3.03183086e-02f },
      { 1.40867913e-02f, 3.81671041e-02f, 1.81270689e-02f, 3.42466757e-02f, -2.76847966e-02f },
      { -3.33468691e-02f, 1.50797935e-02f, -4.19888236e-02f, 1.88218653e-02f, -4.96672392e-02f },
      { -3.97193544e-02f, 2.76921000e-02f, 1.15821436e-02f, -2.40624063e-02f, -8.84911604e-03f },
      { -2.04916410e-02f, 2.18660128e-03f, -5.43813892e-02f, -6.25808984e-02f, 5.02191857e-03f },
    },
    {
      { -2.80260425e-02f, -2.16657342e-03f, -5.83417108e-03f, -3.09017356e-02f, -3.25656720e-02f },
      { 1.86387263e-02f, -2.50765160e-02f, 1.99197605e-02f, -2.59292349e-02f, -6.06926531e-02f },
      { -5.40208556e-02f, -6.86762854e-02f, -5.84861636e-03f, -8.10906105e-03f, 3.56862471e-02f },
      { 1.88400373e-02f, 1.96984094e-02f, -2.69164685e-02f, 3.02130997e-04f, -1.61785427e-02f },
      { 1.56183848e-02f, -3.48724127e-02f, 2.69091874e-03f, -2.05330197e-02f, 3.75915579e-02f },
    },
    {
      { 2.67009549e-02f, -2.46940441e-02f, 7.75965815e-03f, 2.11241213e-03f, 4.66286764e-02f },
      { -5.89457043e-02f, -4.37525995e-02f, -7.35432580e-02f, -6.08298071e-02f, 3.31455655e-02f },
      { -3.90396565e-02f, 2.68805753e-02f, 5.11617213e-02f, 4.47543599e-02f, -5.59597462e-02f },
      { -5.03418520e-02f, -1.85301639e-02f, -4.29088669e-03f, -3.35572064e-02f, -6.55952021e-02f },
      { -2.62889732e-02f, 2.29615029e-02f, -5.76972403e-02f, -4.34630103e-02f, 7.95401819e-03f },
    },
    {
      { -4.09974623e-03f, -2.47376766e-02f, 1.35506215e-02f, 4.64391112e-02f, 3.76694314e-02f },
      { -5.73339090e-02f, 3.38497162e-02f, -2.30403780e-03f, -3.53450142e-02f, 6.81601185e-03f },
      { 2.50510704e-02f, 2.02365313e-03f, 2.66539324e-02f, -4.35833149e-02f, -6.08534329e-02f },
      { -4.62649129e-02f, -4.10460606e-02f, 3.06419879e-02f, -5.36801070e-02f, -3.18374112e-02f },
      { 8.20973236e-03f, 2.21481752e-02f, -4.15100232e-02f, 1.78704765e-02f, 3.18100378e-02f },
    },
    {
      { -5.92486933e-04f, -1.74622536e-02f, -4.96951602e-02f, -1.83630213e-02f, 4.25959006e-02f },
      { -5.89434057e-04f, 3.68411504e-02f, -5.53677976e-03f, -2.35747918e-02f, -2.47275978e-02f },
      { 3.90706919e-02f, -4.04097065e-02f, -2.26731598e-02f, 5.46969660e-02f, -4.21907604e-02f },
      { -1.56766064e-02f, -1.86849833e-02f, -4.72441204e-02f, -2.13004611e-02f, -3.06542888e-02f },
      { 2.96572037e-02f, -1.61354654e-02f, -1.15334969e-02f, 2.44193035e-03f, 4.68413867e-02f },
    },
    {
      { 1.71114057e-02f, -5.54873087e-02f, 1.28790010e-02f, 3.57897207e-02f, -1.60016865e-02f },
      { -3.04868515e-03f, 4.75855395e-02f, -4.53924946e-02f, -4.54199612e-02f, -4.75579174e-03f },
      { -4.18714806e-03f, -6.34855181e-02f, -1.35129993e-03f, 4.70407233e-02f, 4.68327627e-02f },
      { 4.96226512e-02f, -1.83054246e-02f, 4.55804579e-02f, -6.40831292e-02f, -2.05854084e-02f },
      { -4.62028980e-02f, -3.31702195e-02f, -4.48145978e-02f, -5.43956161e-02f, -1.17820567e-02f },
    },
    {
      { -5.79536147e-02f, -5.98533601e-02f, -4.81298752e-02f, -4.12832424e-02f, -5.59924124e-03f },
      { -2.25490108e-02f, -3.23942937e-02f, -5.30466810e-02f, 4.09568883e-02f, -9.17345006e-03f },
      { 1.79933608e-02f, -2.09770910e-02f, 3.22305448e-02f, -2.61788815e-03f, -7.73705868e-03f },
      { 2.78012604e-02f, -1.98219270e-02f, -1.89764574e-02f, 1.40052820e-02f, -1.06586497e-02f },
      { 1.40788546e-02f, 3.57032567e-02f, 4.87736985e-03f, 4.49702563e-03f, -2.19000150e-02f },
    },
  },
  {
    {
      { -1.27288282e-01f, -1.90944418e-01f, 9.58972424e-02f, 1.61912784e-01f, 5.83432987e-02f },
      { -2.01900862e-02f, -2.97508687e-01f, -1.05166085e-01f, 2.14573503e-01f, 2.30277583e-01f },
      { 3.43431085e-01f, 3.62436593e-01f, -1.43277377e-01f, -1.49691552e-01f, -1.04960479e-01f },
      { 1.33647010e-01f, 5.64151943e-01f, 2.67401218e-01f, 2.35430568e-01f, -5.32417074e-02f },
      { 1.61486790e-01f, 2.75972098e-01f, 2.11184509e-02f, 1.13715373e-01f, 1.98623046e-01f },
    },
    {
      { 3.17918696e-02f, 3.79821472e-02f, 1.53091876e-03f, 1.06108531e-01f, -5.90398982e-02f },
      { -3.44341919e-02f, -2.54428297e-01f, 1.03851007e-02f, 3.23096842e-01f, 1.15428306e-01f },
      { 3.21930125e-02f, -1.21698700e-01f, -1.36720076e-01f, 6.87472243e-03f, -7.69967139e-02f },
      { -4.08416316e-02f, 1.10640176e-01f, 1.90597773e-01f, 2.76275635e-01f, -1.95007101e-02f },
      { -2.22926304e-01f, -8.93762559e-02f, -1.95020482e-01f, -3.18337861e-03f, -1.86370686e-01f },
    },
    {
      { 8.59707966e-02f, 1.53215736e-01f, 2.11290628e-01f, 2.01943904e-01f, -1.02339499e-01f },
      { 3.56966630e-02f, -3.04589588e-02f, 1.77723039e-02f, 1.13551877e-01f, -2.67856494e-02f },
      { -7.16812536e-02f, 3.63439657e-02f, 3.02271277e-01f, 2.31259227e-01f, 6.42321184e-02f },
      { -3.88600528e-01f, -2.71428883e-01f, 5.37491553e-02f, 2.64775574e-01f, 1.82829648e-01f },
      { -4.48368609e-01f, -1.38790876e-01f, -2.29129549e-02f, -1.84310570e-01f, -2.08919764e-01f },
    },
    {
      { -1.11199329e-02f, -1.22340769e-01f, -6.00888468e-02f, -1.94095701e-01f, -8.66420716e-02f },
      { -9.70283076e-02f, 7.55027607e-02f, 6.55178130e-02f, -2.35093206e-01f, -7.75300339e-02f },
      { -1.31204590e-01f, -3.52461934e-02f, -1.26046777e-01f, -2.54832476e-01f, -2.78056599e-02f },
      { 3.48904096e-02f, 5.19799888e-02f, -9.88311023e-02f, -3.55369836e-01f, -8.32989365e-02f },
      { 2.38926470e-01f, -5.82112046e-03f, -2.50258029e-01f, -2.58092761e-01f, 7.96127915e-02f },
    },
    {
      { -5.40174991e-02f, -2.75702804e-01f, -1.73243269e-01f, -1.13734089e-01f, 4.70740721e-02f },
      { -8.00362751e-02f, -2.91260481e-02f, -3.73520739e-02f, -2.42053509e-01f, 1.99818406e-02f },
      { 2.10941080e-02f, 2.00433910e-01f, 1.20729499e-01f, 1.25054251e-02f, 8.28387290e-02f },
      { -1.04987521e-04f, -5.60726505e-04f, -8.63018930e-02f, -4.62287590e-02f, 1.43907517e-01f },
      { 8.21996853e-02f, -6.47198781e-02f, -2.73864698e-02f, -1.93728805e-01f, -4.12324965e-02f },
    },
    {
      { 3.30579765e-02f, -9.77965146e-02f, -1.19773701e-01f, 8.84189382e-02f, 1.95285752e-01f },
      { -3.93943861e-02f, 7.46167749e-02f, 1.22078702e-01f, 3.59905548e-02f, 8.28285962e-02f },
      { -1.13686383e-01f, 1.41609073e-01f, 1.84897721e-01f, 1.17457427e-01f, 2.23025203e-01f },
      { -4.56742793e-01f, -5.19968271e-01f, -4.15999740e-01f, -3.91021699e-01f, -1.19860053e-01f },
      { -1.16383530e-01f, -2.38206342e-01f, -2.78948575e-01f, -3.78723532e-01f, -1.43789425e-01f },
    },
    {
      { 1.59752622e-01f, 3.18599761e-01f, -3.08808833e-01f, 8.18223059e-02f, 9.66204107e-02f },
      { 1.15130395e-01f, -2.14270502e-01f, -3.16706479e-01f, 8.54110047e-02f, -5.67487581e-03f },
      { -2.73356646e-01f, -7.32559860e-01f, -4.60415393e-01f, -5.66244945e-02f, 7.01767802e-02f },
      { -3.15418869e-01f, -4.30308193e-01f, -5.07110119e-01f, -1.55315042e-01f, -1.41651392e-01f },
      { -2.38069102e-01f, -1.08875267e-01f, -2.16022953e-01f, 3.89087833e-02f, -5.70949018e-02f },
    },
    {
      { 5.45237288e-02f, 8.05781484e-02f, -1.68860152e-01f, 2.55061798e-02f, -1.42967105e-01f },
      { 5.87342866e-02f, -1.00198142e-01f, -1.03654012e-01f, 5.68321832e-02f, -7.75718689e-02f },
      { -3.23519781e-02f, -2.62688607e-01f, 1.66631723e-03f, 1.09322503e-01f, 5.49130375e-04f },
      { -2.24704832e-01f, -5.01632094e-01f, -3.11815917e-01f, -9.63237956e-02f, -1.46869287e-01f },
      { -2.69956052e-01f, -6.38742447e-02f, -1.49826449e-03f, 7.05829710e-02f, -9.02546719e-02f },
    },
    {
      { 1.10376507e-01f, -1.15579769e-01f, 7.22916275e-02f, 1.73389748e-01f, 1.35307029e-01f },
      { 1.72613606e-01f, -2.18471885e-01f, -1.80037215e-01f, 1.41439214e-01f, 2.14709103e-01f },
      { 2.74993330e-01f, -1.88958913e-01f, -3.72381717e-01f, -3.70506257e-01f, -1.05439141e-01f },
      { 1.28084170e-02f, 2.94974476e-01f, 3.31966728e-01f, 3.18320096e-01f, 2.13297494e-02f },
      { -1.74913913e-01f, 1.50810927e-01f, -1.04585057e-02f, -6.83449656e-02f, -2.43872423e-02f },
    },
    {
      { -5.16680256e-03f, -4.36816774e-02f, 1.38775380e-02f, -7.94411749e-02f, -2.35849936e-02f },
      { -8.26323628e-02f, 3.15770544e-02f, 1.08342327e-01f, -5.53090982e-02f, 1.15721956e-01f },
      { -1.83669254e-01f, -1.04959786e-01f, -2.65022237e-02f, -6.42825514e-02f, 4.48318534e-02f },
      { -8.53341147e-02f, -5.66077605e-02f, -1.92276821e-01f, -2.50082135e-01f, -6.72397017e-02f },
      { 1.63810924e-01f, -7.30035827e-02f, -2.00667486e-01f, -1.50861561e-01f, -8.33300278e-02f },
    },
    {
      { 3.01686060e-02f, -8.05273801e-02f, -1.25410065e-01f, -1.53498292e-01f, -5.15158586e-02f },
      { -4.50378954e-02f, 2.30226642e-03f, -2.54245917e-03f, -9.02277511e-03f, -8.70368853e-02f },
      { 2.04765033e-02f, 8.36929902e-02f, 2.38183469e-01f, 1.61200672e-01f, 1.20183796e-01f },
      { -1.15714550e-01f, -3.19843978e-01f, -2.11472332e-01f, -2.45154351e-01f, -4.03284244e-02f },
      { -1.31707862e-01f, -2.02259272e-01f, -2.93895490e-02f, -9.47076306e-02f, -2.59179980e-01f },
    },
    {
      { -6.77910075e-02f, 1.20190017e-01f, 2.51721948e-01f, 1.14808649e-01f, -4.83953580e-03f },
      { 3.10427640e-02f, 1.28240600e-01f, 2.03896478e-01f, 1.50097132e-01f, 9.95900929e-02f },
      { -8.88120160e-02f, -7.42493942e-02f, -8.82623121e-02f, -2.60671638e-02f, 2.45713536e-03f },
      { 6.03374802e-02f, 1.50629282e-01f, 1.92985713e-01f, 1.55108079e-01f, 3.13102044e-02f },
      { 4.94599044e-02f, -8.17080960e-03f, -6.09733798e-02f, -1.67658553e-02f, -1.11559235e-01f },
    },
    {
      { -4.00858931e-02f, -1.81337877e-03f, 1.99325278e-01f, 2.14666203e-01f, 2.83668563e-03f },
      { -4.23520692e-02f, -9.25002843e-02f, 1.21488757e-01f, 2.55733281e-01f, 4.45550159e-02f },
      { -3.65527347e-02f, -1.96532518e-01f, -1.26268432e-01f, 6.82334835e-03f, 1.52559364e-02f },
      { -1.57227814e-01f, -2.43171658e-02f, 6.56038672e-02f, 1.33597985e-01f, -4.14833836e-02f },
      { -5.69241568e-02f, 1.20560601e-01f, 6.83024339e-03f, -5.20946011e-02f, 4.24387082e-02f },
    },
    {
      { 9.75028612e-03f, 9.25870240e-02f, -6.78290427e-02f, 6.13654554e-02f, -6.02581985e-02f },
      { 1.12552799e-01f, -1.70186505e-01f, 5.20137399e-02f, 2.95235217e-01f, 1.58850670e-01f },
      { 4.44233641e-02f, -3.00269693e-01f, -2.10948855e-01f, -1.87372603e-02f, -2.18056757e-02f },
      { 1.19814619e-01f, 1.79454759e-01f, 1.24613039e-01f, 2.16814131e-01f, -7.99127948e-03f },
      { -2.13637188e-01f, -1.35123031e-02f, -1.06756389e-01f, -1.81322433e-02f, -1.09512478e-01f },
    },
    {
      { 2.47140825e-02f, 1.88172013e-02f, -4.63915393e-02f, 2.12763492e-02f, 4.17214632e-02f },
      { 1.18708294e-02f, 6.58171671e-03f, 5.28226383e-02f, -3.09733637e-02f, 4.05681394e-02f },
      { 1.93042047e-02f, 4.01529074e-02f, -4.97442000e-02f, 1.71689056e-02f, -4.34285328e-02f },
      { 3.75362709e-02f, -3.57856452e-02f, -5.79264872e-02f, -5.50323315e-02f, 4.77581248e-02f },
      { -5.85231334e-02f, 8.42499023e-04f, 5.28105684e-02f, -3.91160585e-02f, 4.48425412e-02f },
    },
    {
      { -2.79844254e-02f, 6.28569722e-02f, -4.74915802e-02f, 3.75234932e-02f, 1.10315895e-02f },
      { 7.32368827e-02f, -6.54883757e-02f, -1.03378082e-02f, -3.23489076e-03f, 8.61813687e-03f },
      { -1.13403983e-02f, -9.83974785e-02f, 3.51227894e-02f, -6.82389885e-02f, -8.83422792e-03f },
      { -4.21430580e-02f, -4.66309264e-02f, 6.57833219e-02f, 4.30345349e-02f, -2.98142601e-02f },
      { 5.14235385e-02f, -1.40208593e-02f, -1.00307465e-02f, 2.64578182e-02f, -1.73920505e-02f },
    },
    {
      { -3.09788696e-02f, 4.53988574e-02f, -1.19149603e-01f, -1.51296929e-01f, 1.82107016e-02f },
      { 9.47460085e-02f, -1.88809615e-02f, -1.07247330e-01f, -1.23505048e-01f, -1.57713503e-01f },
      { 1.57905534e-01f, 6.98554516e-02f, 1.11240325e-02f, -1.22760877e-01f, -8.16766992e-02f },
      { 1.28134027e-01f, 2.22279050e-04f, 3.21613587e-02f, 1.02344118e-02f, -7.82116596e-03f },
      { 1.03219353e-01f, 3.07675526e-02f, 1.17717691e-01f, 1.07643776e-01f, 1.05268389e-01f },
    },
    {
      { -3.10516637e-02f, -2.30074730e-02f, -1.38289675e-01f, -6.03802092e-02f, -1.79932937e-02f },
      { -1.69585757e-02f, -8.34795460e-02f, -4.34795842e-02f, -8.71959999e-02f, 3.14001879e-03f },
      { -1.57271519e-01f, 1.95661951e-02f, 1.70292646e-01f, 1.44041762e-01f, 1.35549277e-01f },
      { -1.55339926e-01f, -1.97006464e-01f, -1.26414314e-01f, -5.29484190e-02f, -1.07042640e-01f },
      { -6.52462542e-02f, 1.41781708e-02f, 6.92575797e-02f, -6.08201465e-03f, -1.04846418e-01f },
    },
    {
      { -5.66744208e-02f, -1.39553711e-01f, -2.96329111e-01f, -1.94903076e-01f, 2.69037802e-02f },
      { 4.03971523e-02f, 3.32909785e-02f, -1.28410163e-03f, -3.06846481e-02f, -9.04079601e-02f },
      { 1.11764304e-01f, 1.21674590e-01f, 2.30296165e-01f, 2.48461157e-01f, 2.82693923e-01f },
      { -7.23476186e-02f, -2.84787774e-01f, -3.46723974e-01f, -2.73582131e-01f, -5.61780445e-02f },
      { -1.44787624e-01f, -2.37418711e-01f, -9.09704491e-02f, 5.57440370e-02f, -5.06120063e-02f },
    },
    {
      { 5.03027327e-02f, -3.21391076e-02f, -4.64730635e-02f, -7.21885413e-02f, 5.56780137e-02f },
      { -3.01128230e-03f, 1.65134557e-02f, 1.61612462e-02f, -3.74785438e-02f, 1.12532958e-01f },
      { 1.00910574e-01f, 2.57877111e-02f, -5.31445853e-02f, -4.99002300e-02f, -1.33797437e-01f },
      { 1.56595647e-01f, 7.50856400e-02f, 6.56383336e-02f, 6.55324757e-02f, -3.90342623e-02f },
      { 1.17716901e-01f, 7.55226910e-02f, -8.56472626e-02f, -9.89799947e-02f, 2.73671579e-02f },
    },
    {
      { -6.59999847e-02f, 7.34836012e-02f, 1.96156204e-01f, 1.51933819e-01f, 7.55572245e-02f },
      { -1.26238942e-01f, 1.05366603e-01f, 9.33297202e-02f, 2.74093226e-02f, -1.47331813e-02f },
      { -1.77903637e-01f, -1.38737395e-01f, -1.36836320e-01f, -8.35577026e-02f, -9.41978991e-02f },
      { 7.19824880e-02f, 1.73096597e-01f, 1.79729283e-01f, -9.98487324e-03f, -2.68636402e-02f },
      { 1.28843382e-01f, 1.33429602e-01f, 2.61297598e-02f, -6.14276752e-02f, -5.10161445e-02f },
    },
    {
      { 1.47188425e-01f, 1.48583263e-01f, -1.40753444e-02f, -1.21568479e-01f, -1.65738016e-01f },
      { 2.12262765e-01f, -4.93688472e-02f, -1.52065888e-01f, -1.17963821e-01f, -1.85252845e-01f },
      { 8.41581225e-02f, -2.86660582e-01f, -2.78080314e-01f, -9.85466987e-02f, -1.43775001e-01f },
      { -3.52226228e-01f, -4.82134134e-01f, -3.97534847e-01f, -4.64262664e-01f, -3.18090528e-01f },
      { -4.97494578e-01f, -5.00695765e-01f, -3.48156184e-01f, -3.09450954e-01f, -2.15934351e-01f },
    },
    {
      { 6.96536973e-02f, 9.84470025e-02f, 2.59789705e-01f, 1.72857821e-01f, 1.91160932e-01f },
      { 1.29555583e-01f, 9.86697674e-02f, 1.41058326e-01f, 7.67500028e-02f, 2.23271355e-01f },
      { 1.87322963e-02f, -2.77654566e-02f, 6.61342815e-02f, 1.74103051e-01f, 1.78542227e-01f },
      { -1.77888334e-01f, -9.75334942e-02f, 1.42707955e-02f, 1.07875526e-01f, 8.78121480e-02f },
      { -1.25436589e-01f, -8.11175164e-03f, 3.10456082e-02f, -2.97425147e-02f, -7.69136250e-02f },
    },
    {
      { 2.85500269e-02f, 5.45192063e-02f, -1.45372469e-03f, -2.18680557e-02f, -3.25434655e-02f },
      { 3.07193305e-02f, -9.43158865e-02f, 1.05390754e-02f, 9.98368710e-02f, -6.58756495e-02f },
      { -1.11841805e-01f, -9.60472748e-02f, -8.97555798e-02f, 5.03126532e-02f, -4.33893055e-02f },
      { -9.86855403e-02f, -9.78233740e-02f, 1.84108075e-02f, 8.28085840e-02f, -2.60215215e-02f },
      { 2.95649078e-02f, 4.60367976e-03f, -3.06117442e-02f, 7.42692687e-03f, -5.31108975e-02f },
    },
    {
      { 8.94805193e-02f, -5.53307645e-02f, -7.69309178e-02f, 1.97877977e-02f, -4.53043804e-02f },
      { -1.71702988e-02f, -4.30023186e-02f, 1.58435944e-02f, -1.16528226e-02f, -4.64493148e-02f },
      { 4.66995174e-03f, 1.47572085e-01f, 2.94913232e-01f, 2.41137266e-01f, 2.17959940e-01f },
      { -1.19746387e-01f, -3.25158566e-01f, -1.71255589e-01f, -1.54046372e-01f, 7.21235294e-04f },
      { -2.10963786e-01f, -2.48709440e-01f, -6.38528094e-02f, 3.37529108e-02f, -1.98707610e-01f },
    },
    {
      { 1.89920843e-01f, 1.44150183e-01f, -1.49653092e-01f, 1.48066267e-01f, 9.16669611e-03f },
      { 1.14201680e-01f, 3.90488282e-02f, 1.62951007e-01f, 1.29799768e-01f, -1.82424113e-01f },
      { 9.33411866e-02f, -9.78183933e-03f, 2.37579226e-01f, 3.17060202e-01f, 1.56206071e-01f },
      { -2.18233839e-01f, -2.22026691e-01f, -2.53760099e-01f, -4.90355790e-02f, 1.35334218e-02f },
      { -3.36051464e-01f, -1.56085849e-01f, 6.67658374e-02f, 1.57469630e-01f, 8.31032544e-02f },
    },
    {
      { -4.11582226e-03f, -1.02345705e-01f, -1.27398133e-01f, -1.44810304e-01f, 8.20850022e-03f },
      { -1.40251126e-03f, -1.41507899e-02f, 2.81920191e-02f, -5.40346168e-02f, -7.78944865e-02f },
      { 7.66628385e-02f, 1.01380460e-01f, 1.55850664e-01f, -2.12771408e-02f, 2.85718823e-03f },
      { 1.26145810e-01f, 4.85692248e-02f, -2.24711597e-02f, -7.94672519e-02f, 1.42740831e-02f },
      { 7.07808957e-02f, -1.67674944e-02f, 1.77605730e-02f, 1.26127720e-01f, 1.20631956e-01f },
    },
    {
      { 7.06542134e-02f, 5.00672730e-03f, 1.36228099e-01f, 1.33043006e-01f, 1.24914855e-01f },
      { -1.31510086e-02f, 4.07826081e-02f, 4.96829674e-02f, 1.10503063e-01f, 1.47512794e-01f },
      { -1.31765142e-01f, -7.54151344e-02f, 3.95150064e-03f, -3.61591466e-02f, 1.43591732e-01f },
      { -2.14768305e-01f, -1.04541942e-01f, -1.05981670e-01f, -1.31343290e-01f, -3.49880382e-02f },
      { -7.94018283e-02f, -1.01780094e-01f, -2.03017354e-01f, -3.32204819e-01f, -2.03812376e-01f },
    },
    {
      { -1.03099607e-01f, 7.14210868e-02f, 2.52507001e-01f, 1.56143650e-01f, 4.35173092e-03f },
      { -1.35464489e-01f, -1.20051846e-01f, 1.19471096e-01f, 7.17412233e-02f, 9.20980871e-02f },
      { -2.99452599e-02f, -1.43522426e-01f, -2.84618676e-01f, -7.84943849e-02f, -1.77674457e-01f },
      { 2.08755881e-01f, 4.08155352e-01f, 4.13205773e-01f, 2.05686271e-01f, -1.49984658e-01f },
      { 6.99658394e-02f, 9.59394947e-02f, 5.86289540e-02f, -7.58587718e-02f, -6.39757365e-02f },
    },
    {
      { 4.39784937e-02f, 9.50038154e-03f, -4.32091765e-02f, -9.37223062e-03f, 5.83010912e-02f },
      { 1.56797878e-02f, 3.74239590e-03f, -1.60921216e-02f, 2.29878910e-02f, 2.72048265e-02f },
      { -5.16305864e-02f, -2.49262638e-02f, 1.18666878e-02f, -3.22568603e-02f, 2.54015718e-02f },
      { 1.22708511e-02f, -3.80424364e-03f, 2.78715380e-02f, -6.31236061e-02f, -1.66326035e-02f },
      { 1.93698681e-03f, 5.07760793e-02f, -4.15179804e-02f, -6.59652650e-02f, 5.60251400e-02f },
    },
    {
      { -6.52024075e-02f, 1.14260517e-01f, 7.92072192e-02f, 1.34998828e-01f, 4.69666012e-02f },
      { -8.90064053e-03f, -9.63747129e-02f, 3.17629687e-02f, 2.84464359e-01f, 1.41142860e-01f },
      { 6.57776222e-02f, -5.05675636e-02f, -2.20864654e-01f, -1.10097006e-01f, -7.57351369e-02f },
      { 2.47839555e-01f, 4.07676101e-01f, 2.82808125e-01f, 1.95253477e-01f, -3.82642262e-02f },
      { -6.84725866e-02f, 2.57090479e-02f, -2.35032663e-01f, -4.65291440e-02f, -2.10993081e-01f },
    },
    {
      { 8.84651095e-02f, 1.00359015e-01f, -2.08485737e-01f, 2.22252728e-03f, -4.89339009e-02f },
      { 1.81890458e-01f, -1.73243672e-01f, -3.92693490e-01f, -7.99525976e-02f, -1.26426846e-01f },
      { 1.10806741e-01f, -3.18717122e-01f, -3.46194148e-01f, -1.17178597e-01f, -3.64646991e-03f },
      { 1.14814371e-01f, -2.59392560e-01f, -4.63281721e-01f, -1.90765828e-01f, -5.19075543e-02f },
      { -2.55415767e-01f, -1.83231831e-01f, -6.63157031e-02f, 8.08334798e-02f, 1.61082819e-02f },
    },
  },
  {
    {
      { 1.31352782e-01f, 8.47359896e-02f, 3.45938474e-01f, 2.91209340e-01f, 8.41515362e-02f },
      { -1.95383996e-01f, -8.10099021e-02f, 2.06822723e-01f, 2.72516280e-01f, 1.40909016e-01f },
      { -3.69344205e-01f, -3.27553570e-01f, -3.38749401e-02f, 2.76265830e-01f, 2.62017727e-01f },
      { -7.21903071e-02f, -4.24482673e-01f, -1.35930434e-01f, 1.77081376e-02f, 1.92004785e-01f },
      { 7.85322338e-02f, -2.12638110e-01f, -3.04064989e-01f, 8.88738781e-02f, 1.41539305e-01f },
    },
    {
      { 2.50485361e-01f, 6.78433776e-02f, 7.35923126e-02f, -9.13900807e-02f, -3.04212213e-01f },
      { 6.92855194e-02f, -9.14331153e-02f, 8.64778608e-02f, -6.17391877e-02f, -2.67141700e-01f },
      { -1.77132159e-01f, -1.10233113e-01f, 1.07930049e-01f, 1.05501294e-01f, -8.63494053e-02f },
      { 7.88828805e-02f, -1.68932006e-01f, 1.10760279e-01f, -6.47325143e-02f, -2.04215548e-03f },
      { 6.90080132e-03f, -1.13628156e-01f, -6.41674027e-02f, 2.56170449e-03f, -6.14460185e-02f },
    },
    {
      { -6.37403727e-02f, -2.71455348e-01f, -7.06741288e-02f, -1.64208338e-01f, -1.90864429e-01f },
      { -2.40625978e-01f, -3.26054871e-01f, -2.41219252e-01f, -1.81717575e-01f, -2.36270517e-01f },
      { -3.52831222e-02f, -2.04427242e-01f, -6.38240054e-02f, -8.95425528e-02f, -1.80733845e-01f },
      { -5.82187111e-03f, 2.47876113e-03f, 5.94250597e-02f, 1.72393341e-02f, -1.23411231e-01f },
      { 2.01560259e-01f, 2.62549430e-01f, 3.66578847e-01f, 3.48962426e-01f, 9.08997282e-03f },
    },
    {
      { 8.36758092e-02f, 3.39102745e-02f, -7.88662583e-02f, 4.81170565e-02f, 2.93609232e-01f },
      { 1.39121398e-01f, 2.04720214e-01f, -1.44519463e-01f, -1.48526922e-01f, 2.77282178e-01f },
      { 1.42427981e-01f, 1.70467198e-01f, -1.38594672e-01f, -1.75411463e-01f, -1.31433923e-02f },
      { 1.51971534e-01f, 1.16028115e-01f, -1.12956807e-01f, -3.49415988e-01f, -4.43221107e-02f },
      { 2.59186532e-02f, 5.20847067e-02f, -1.66015118e-01f, -2.37725183e-01f, 9.25472304e-02f },
    },
    {
      { -4.49675545e-02f, -8.23448971e-02f, 6.76079616e-02f, 2.97572851e-01f, 2.92799115e-01f },
      { -1.02829359e-01f, -7.67164156e-02f, -2.97428936e-01f, -4.60998975e-02f, 3.60376209e-01f },
      { 9.54973996e-02f, 1.74621567e-02f, -2.31955752e-01f, -3.37524533e-01f, 1.80059657e-01f },
      { -5.70838079e-02f, -1.07001744e-01f, -1.63198352e-01f, -3.12048137e-01f, -2.05862839e-02f },
      { 9.77109894e-02f, 6.93388507e-02f, -6.72302023e-02f, -7.16862977e-02f, -4.69025411e-03f },
    },
    {
      { -2.80976444e-01f, -2.55520582e-01f, -3.37151617e-01f, -4.67841234e-03f, 8.23893696e-02f },
      { -8.65385979e-02f, -1.93874195e-01f, -4.64220643e-01f, -3.53384495e-01f, 1.41998336e-01f },
      { 2.50276029e-01f, 1.03129029e-01f, -1.86332926e-01f, -3.41805488e-01f, -3.20433726e-04f },
      { 2.00266182e-01f, 2.46533200e-01f, 9.16951373e-02f, -6.98847920e-02f, -1.16141565e-01f },
      { 2.91378558e-01f, 4.57345575e-01f, 2.07167119e-01f, -1.36575392e-02f, 4.50975709e-02f },
    },
    {
      { 2.99255550e-01f, 1.55020866e-03f, 4.26682718e-02f, -1.36641279e-01f, 4.42757383e-02f },
      { 2.53814906e-01f, -6.33562729e-02f, 9.65119973e-02f, -1.74631238e-01f, 3.67394388e-02f },
      { 9.55413878e-02f, -1.42699286e-01f, -1.25703067e-02f, -1.28016442e-01f, 2.31597312e-02f },
      { -1.94535911e-01f, -1.65536761e-01f, -1.72886878e-01f, 1.17093503e-01f, 3.07050552e-02f },
      { -1.88226059e-01f, -5.92907429e-01f, -2.42434159e-01f, -4.03115489e-02f, 2.51024105e-02f },
    },
    {
      { 1.52855799e-01f, -2.68659443e-01f, -1.65223330e-01f, -2.14494213e-01f, -1.71904966e-01f },
      { 1.14025578e-01f, -1.50153175e-01f, 6.88297376e-02f, -3.56568694e-02f, -1.23827316e-01f },
      { -7.12988526e-02f, -1.95902586e-02f, 5.19898683e-02f, 3.00999787e-02f, 1.22326771e-02f },
      { -1.32189199e-01f, -1.36381984e-01f, 7.22304508e-02f, 1.49774224e-01f, 9.19609517e-02f },
      { -3.62050645e-02f, -1.33056879e-01f, 2.11320058e-01f, 2.58031696e-01f, 4.14013937e-02f },
    },
    {
      { 1.52982265e-01f, 4.12528999e-02f, 2.11718291e-01f, 1.65260449e-01f, -2.55906321e-02f },
      { -4.17051697e-03f, -7.83994421e-02f, 8.11704621e-02f, 2.79077381e-01f, 3.36810946e-03f },
      { -3.85505319e-01f, -4.40433741e-01f, -8.11419934e-02f, 1.53320879e-01f, 1.76036447e-01f },
      { 1.13222517e-01f, -3.55803162e-01f, -7.64729232e-02f, 4.05993834e-02f, 1.81596935e-01f },
      { 2.62212038e-01f, -1.42005026e-01f, -2.57767111e-01f, -4.46921121e-03f, 1.38447183e-04f },
    },
    {
      { 5.54689616e-02f, -1.37633206e-02f, -1.59892812e-01f, -1.77302971e-01f, 3.95435542e-02f },
      { 1.67376101e-01f, 1.32193670e-01f, -1.02958888e-01f, -1.71961248e-01f, -4.14657407e-02f },
      { 2.21540228e-01f, 1.42746225e-01f, 2.31988002e-02f, -1.57446474e-01f, -1.43025368e-01f },
      { 7.19169304e-02f, 2.23504156e-01f, 3.18522714e-02f, -1.91654950e-01f, -8.26383010e-02f },
      { 1.93176959e-02f, 1.73296079e-01f, 9.52243581e-02f, -2.27321452e-03f, 8.94199237e-02f },
    },
    {
      { -2.19393387e-01f, -3.93989861e-01f, -2.35009059e-01f, -3.34239528e-02f, 8.40213969e-02f },
      { -7.95726925e-02f, -3.66093487e-01f, -4.32781905e-01f, -3.37998837e-01f, 3.44021320e-02f },
      { 7.65652657e-02f, -1.99854486e-02f, -2.26578489e-01f, -2.89740771e-01f, -1.67263567e-01f },
      { -7.32229427e-02f, 1.55870188e-02f, 5.94455227e-02f, -7.35226274e-02f, -8.26709941e-02f },
      { 8.04237947e-02f, 3.30178171e-01f, 2.70431876e-01f, 1.51656657e-01f, 2.56921239e-02f },
    },
    {
      { 1.08521707e-01f, 1.22626625e-01f, 6.33741170e-02f, -9.42437500e-02f, -1.64730757e-01f },
      { 1.08138390e-01f, 1.96742147e-01f, -1.61141939e-02f, -4.98559028e-02f, -5.98882698e-02f },
      { -6.78739175e-02f, 7.55861476e-02f, 1.06968887e-01f, 1.13294013e-01f, -6.19495213e-02f },
      { -1.00781797e-02f, -2.32942775e-02f, 1.27096310e-01f, 2.57633645e-02f, -3.43039110e-02f },
      { 4.32290435e-02f, 7.45479390e-02f, -2.93334145e-02f, -2.46486533e-02f, 5.49319647e-02f },
    },
    {
      { 1.05616622e-01f, 6.16442077e-02f, 1.07988656e-01f, -9.73649696e-02f, -1.57016218e-01f },
      { 1.03476129e-01f, -2.91617936e-04f, 2.43582726e-01f, 2.62054764e-02f, -1.02910131e-01f },
      { -8.86912420e-02f, 1.77438185e-02f, 1.48096502e-01f, 1.67703748e-01f, -3.51137929e-02f },
      { 9.73622799e-02f, -4.64139059e-02f, 4.78312280e-03f, 8.56039897e-02f, -9.36433375e-02f },
      { -6.09671639e-04f, -2.96883639e-02f, 7.96172097e-02f, -2.55802069e-02f, -1.53789580e-01f },
    },
    {
      { 1.55242652e-01f, 8.95892754e-02f, 1.34938538e-01f, -5.06986119e-02f, -1.29203171e-01f },
      { 4.24207933e-02f, -2.26250868e-02f, 2.14378610e-01f, 1.30807251e-01f, -1.28577381e-01f },
      { -2.49136955e-01f, -1.25450090e-01f, 1.11604370e-01f, 1.43284455e-01f, 3.15408520e-02f },
      { -1.20200418e-01f, -1.87715411e-01f, 1.51371032e-01f, 1.19957723e-01f, 1.12279337e-02f },
      { 9.38061029e-02f, -3.32117766e-01f, -1.47899970e-01f, -1.42175704e-02f, -2.72684079e-03f },
    },
    {
      { -5.75809600e-03f, -5.44637777e-02f, 3.37495748e-03f, -6.04587011e-02f, -1.96402222e-02f },
      { 7.96730223e-04f, -2.80707085e-04f, 4.75586727e-02f, 1.92050319e-02f, -1.20847495e-02f },
      { -2.62066703e-02f, -4.04011831e-02f, -1.16964690e-02f, -7.59293046e-03f, 4.43018414e-02f },
      { 3.73309031e-02f, 3.41785736e-02f, -3.25706787e-02f, 3.88452709e-02f, -4.02838439e-02f },
      { 3.54532748e-02f, 4.10962962e-02f, -4.53970544e-02f, 5.68401963e-02f, -1.57769173e-02f },
    },
    {
      { 3.56882550e-02f, -6.67504519e-02f, 1.36418222e-02f, -5.07597774e-02f, -6.85401335e-02f },
      { -6.29533082e-02f, 2.70130821e-02f, 9.58566740e-02f, -3.48581653e-03f, -7.33322278e-02f },
      { -5.06591611e-02f, 8.71267393e-02f, 1.24527663e-01f, 2.58812159e-02f, -2.54491214e-02f },
      { 7.30989315e-03f, 2.23960448e-02f, 5.22325784e-02f, 8.65765959e-02f, 3.01376954e-02f },
      { 4.73102694e-03f, -2.05437932e-02f, 8.41188617e-03f, -9.37075261e-03f, -3.34718116e-02f },
    },
    {
      { 1.01682395e-01f, -4.94238213e-02f, 6.92388937e-02f, 4.77744587e-04f, 2.95622945e-02f },
      { 6.55851560e-04f, -7.16966838e-02f, -4.30262834e-02f, -4.47764583e-02f, 3.28515321e-02f },
      { -1.22157075e-01f, -6.03786185e-02f, -3.96275707e-02f, -7.94116110e-02f, 1.54924884e-01f },
      { -7.28803128e-02f, -1.62464991e-01f, -1.48256540e-01f, 8.66633467e-03f, 1.33629948e-01f },
      { 3.84630449e-02f, -2.57399306e-02f, -4.27380763e-02f, 8.88148621e-02f, 3.96153666e-02f },
    },
    {
      { -5.62556013e-02f, -2.16339901e-01f, -1.91333488e-01f, -1.89464360e-01f, -1.28690958e-01f },
      { -6.63517267e-02f, -1.36932716e-01f, -1.59905419e-01f, -1.99506953e-01f, -9.38534513e-02f },
      { 6.16302118e-02f, -7.10524945e-03f, -3.96958105e-02f, -1.84954271e-01f, -4.97432165e-02f },
      { -4.90509309e-02f, 7.28884339e-02f, 9.33945552e-02f, 5.73597476e-02f, -1.74943525e-02f },
      { 2.59155105e-03f, 1.80066794e-01f, 2.11621240e-01f, 1.28007427e-01f, -1.83239840e-02f },
    },
    {
      { -6.04917631e-02f, -1.84111595e-01f, -1.54512122e-01f, 3.15864235e-02f, 1.91003621e-01f },
      { -5.20845428e-02f, -2.38253087e-01f, -4.32231009e-01f, -2.80634999e-01f, 2.11672653e-02f },
      { -2.71843653e-02f, -1.55205742e-01f, -2.73134500e-01f, -2.83149600e-01f, -1.65830299e-01f },
      { -7.84592628e-02f, -5.24776876e-02f, -1.03523105e-01f, -2.80336924e-02f, -4.66620363e-02f },
      { 1.12867184e-01f, 1.64070413e-01f, 2.27518335e-01f, 1.32152483e-01f, 1.62784189e-01f },
    },
    {
      { 8.35033059e-02f, 2.93634390e-03f, 6.87844902e-02f, 3.22929136e-02f, 6.32512569e-02f },
      { -1.74348764e-02f, 5.25264181e-02f, -4.36195843e-02f, 4.91664037e-02f, 5.16599715e-02f },
      { -4.89438465e-03f, -1.02373622e-01f, -8.88512731e-02f, 1.12346321e-01f, 1.19775563e-01f },
      { -6.55603856e-02f, -1.43409088e-01f, -1.31623641e-01f, 1.72146392e-05f, 1.55075684e-01f },
      { -1.12313787e-02f, -2.10799232e-01f, -1.70774043e-01f, -1.55577198e-01f, 1.51873693e-01f },
    },
    {
      { 1.22226007e-01f, 1.02688953e-01f, 1.00905471e-01f, -1.54445171e-01f, -3.68519723e-02f },
      { 9.77272838e-02f, 1.19325563e-01f, 1.41350791e-01f, -5.63757755e-02f, -8.71505514e-02f },
      { -5.29361935e-03f, -6.87058037e-03f, 1.32893339e-01f, -1.27631230e-02f, -1.90437362e-01f },
      { 4.76774164e-02f, 1.22718908e-01f, 1.33736238e-01f, 9.76408049e-02f, -3.61721888e-02f },
      { -3.59923728e-02f, 5.82919398e-04f, -3.40079814e-02f, -7.86724221e-03f, -1.27833132e-02f },
    },
    {
      { -2.65758544e-01f, -2.44497597e-01f, -2.95861632e-01f, -2.66753584e-01f, -1.53786242e-01f },
      { -2.12015480e-01f, -4.09588188e-01f, -3.20522785e-01f, -1.94581226e-01f, -1.24639452e-01f },
      { -4.38660294e-01f, -3.97552788e-01f, -1.45868853e-01f, -1.07824989e-01f, 2.01757960e-02f },
      { -3.79443616e-01f, -2.35689014e-01f, -8.73693153e-02f, 1.30820815e-02f, 2.65650779e-01f },
      { -9.40184742e-02f, -5.32587878e-02f, 2.24056870e-01f, 3.51229936e-01f, 4.20183092e-01f },
    },
    {
      { 1.43607616e-01f, 6.64082617e-02f, -6.40206039e-02f, -1.26520485e-01f, -1.16957098e-01f },
      { 6.18731715e-02f, 9.97374021e-03f, -7.10495636e-02f, -4.30020504e-02f, -1.18839264e-01f },
      { 1.17750876e-01f, 1.41557261e-01f, 1.29036242e-02f, 4.03919481e-02f, 7.42530636e-03f },
      { 2.15265751e-01f, 2.02131838e-01f, 1.17785141e-01f, 1.39486268e-01f, 3.30301151e-02f },
      { 1.64723694e-01f, 1.85953513e-01f, 2.58365214e-01f, 1.68789387e-01f, 7.12594166e-02f },
    },
    {
      { -9.52375960e-03f, 2.77184993e-02f, -4.23055850e-02f, -1.31423518e-01f, -1.46548241e-01f },
      { -2.53996942e-02f, 2.85478290e-02f, 6.43047318e-02f, 2.54674964e-02f, -9.31515917e-02f },
      { 2.58405488e-02f, 9.83201712e-02f, 1.11575693e-01f, 7.96458945e-02f, -4.41685058e-02f },
      { -5.07119158e-03f, 1.94727127e-02f, 5.48556335e-02f, 9.27051678e-02f, 3.99618559e-02f },
      { -4.47678603e-02f, -1.13440230e-01f, 5.15803359e-02f, -1.03799468e-02f, -4.80876975e-02f },
    },
    {
      { -3.88978831e-02f, -2.59342700e-01f, -2.34312400e-01f, -4.19078395e-02f, -5.93842827e-02f },
      { -1.30769104e-01f, -1.93446755e-01f, -1.73541278e-01f, -2.95363069e-01f, -1.18179977e-01f },
      { 4.72034104e-02f, 5.56237586e-02f, -2.89001781e-02f, -2.36919656e-01f, -1.45027012e-01f },
      { -8.78413543e-02f, 8.67397785e-02f, 1.14474662e-01f, 2.54796986e-02f, -4.06535938e-02f },
      { 1.77772120e-01f, 2.70946831e-01f, 2.04747275e-01f, 1.30904302e-01f, -2.61281594e-03f },
    },
    {
      { 8.81127417e-02f, -2.13278420e-02f, -5.46545237e-02f, -2.75453199e-02f, -3.27285267e-02f },
      { -2.53722910e-03f, -1.35203600e-01f, -3.95880640e-02f, -8.28654543e-02f, -1.40197888e-01f },
      { 8.34043548e-02f, -1.16089307e-01f, 3.23752053e-02f, -7.78679699e-02f, -3.28457355e-02f },
      { 1.23715581e-05f, -7.80353770e-02f, 1.12839714e-01f, 2.21239880e-01f, 1.71554223e-01f },
      { 2.30448306e-01f, 1.87224239e-01f, 9.27593485e-02f, 1.08217619e-01f, 4.55142930e-03f },
    },
    {
      { -6.20611012e-02f, -6.51071966e-02f, 3.34292985e-02f, 6.27161935e-02f, 1.26571327e-01f },
      { -3.99353057e-02f, -3.16516571e-02f, -1.27801806e-01f, -5.51536940e-02f, 1.21858537e-01f },
      { -2.87218839e-02f, 8.51030182e-03f, -1.46361142e-01f, -1.71594650e-01f, -5.98212443e-02f },
      { -1.40686616e-01f, -1.18024908e-01f, -8.96653086e-02f, -7.45604485e-02f, 3.55888195e-02f },
      { -1.89177953e-02f, 4.42711413e-02f, 7.18081184e-03f, 9.79017243e-02f, 1.02634057e-01f },
    },
    {
      { 4.72664163e-02f, -4.15824866e-03f, -4.69905287e-02f, -1.00902051e-01f, -2.17792857e-02f },
      { 4.73144650e-02f, 6.24619015e-02f, -6.28039241e-02f, -1.88463226e-01f, -6.40840903e-02f },
      { 1.26490220e-01f, 2.37097323e-01f, 3.40900123e-02f, -1.76496387e-01f, -1.30453065e-01f },
      { 2.11091280e-01f, 2.83442497e-01f, 8.62315670e-02f, -1.15625955e-01f, -1.79965302e-01f },
      { 1.13903806e-01f, 2.46365860e-01f, 1.84474513e-01f, -1.03073135e-01f, 8.03894084e-03f },
    },
    {
      { 1.38778701e-01f, 2.97656178e-01f, 2.40621999e-01f, 2.87393294e-02f, -1.87766571e-02f },
      { 4.55872603e-02f, 2.04047918e-01f, 1.70886204e-01f, 1.55212209e-02f, -6.44403175e-02f },
      { -2.65024841e-01f, -6.35572374e-02f, 6.84388578e-02f, 1.45849511e-01f, -3.13678496e-02f },
      { -1.49617270e-01f, -1.99166443e-02f, 1.17889807e-01f, 1.28234789e-01f, 1.95561815e-02f },
      { -4.06598412e-02f, -1.26565054e-01f, -1.41014671e-02f, -1.33830786e-01f, 3.09293531e-03f },
    },
    {
      { 1.67723354e-02f, -1.36225531e-02f, 1.21044805e-02f, 3.99330854e-02f, -9.86611098e-03f },
      { 1.23808607e-02f, -2.01330651e-02f, 4.28324305e-02f, 3.07391491e-03f, 1.65326465e-02f },
      { 1.49592813e-02f, -2.95093674e-02f, 1.39807649e-02f, 3.30468640e-03f, 6.57219440e-02f },
      { -5.28529622e-02f, -4.66377325e-02f, 3.08864266e-02f, -7.22530205e-03f, 4.82936688e-02f },
      { -1.32242776e-02f, 4.02475297e-02f, -2.54258071e-03f, -5.79432733e-02f, -1.45423273e-02f },
    },
    {
      { 9.66122821e-02f, 1.44462213e-01f, 9.49445367e-02f, -6.16508489e-03f, -6.30842447e-02f },
      { 6.69494495e-02f, -1.35487974e-01f, 1.77813098e-01f, 1.13396093e-01f, -1.47209138e-01f },
      { -3.16411585e-01f, -2.05057681e-01f, 1.58431500e-01f, 2.70608485e-01f, 3.27763297e-02f },
      { -1.30978450e-02f, -1.25806928e-01f, -4.95322514e-03f, 8.98377597e-02f, 9.67555866e-03f },
      { 4.30826592e-04f, -2.74734586e-01f, -9.26537886e-02f, -1.23168476e-01f, 1.15548074e-01f },
    },
    {
      { 2.56185174e-01f, 4.67938446e-02f, 8.16846788e-02f, 1.05885854e-02f, -6.50271699e-02f },
      { 1.46307632e-01f, -3.99256162e-02f, 3.86339314e-02f, 5.85292131e-02f, -2.23052219e-01f },
      { -5.47336154e-02f, -1.70615062e-01f, -2.50247456e-02f, -5.08376285e-02f, -4.80670407e-02f },
      { -2.68798321e-01f, -3.96181494e-01f, -2.05062807e-01f, -9.48631689e-02f, 1.43807322e-01f },
      { -8.24135989e-02f, -5.33085048e-01f, -3.24015260e-01f, 1.29856365e-02f, 1.00980274e-01f },
    },
  },
  {
    {
      { -9.11803395e-02f, 2.53220256e-02f, 2.93633014e-01f, 2.72077709e-01f, 3.50531824e-02f },
      { -1.60087511e-01f, -1.38757572e-01f, -1.15165561e-01f, -1.22624673e-01f, -6.89525530e-02f },
      { -1.26409456e-02f, -1.96991742e-01f, -2.09366933e-01f, -1.81816593e-01f, -1.87892795e-01f },
      { 2.58938018e-02f, -2.56573290e-01f, -3.82603645e-01f, 3.29218321e-02f, 4.64783199e-02f },
      { 2.09468659e-02f, -4.40820791e-02f, -1.70230225e-01f, 6.36824369e-02f, 9.92242396e-02f },
    },
    {
      { -1.02021486e-01f, -2.75223665e-02f, -2.49754153e-02f, 9.89688188e-02f, 1.90776493e-02f },
      { 4.49924134e-02f, -2.46744305e-01f, 3.78566459e-02f, 9.99909043e-02f, -5.52901402e-02f },
      { 1.29997626e-01f, -3.06871295e-01f, 1.67102233e-01f, 1.06294632e-01f, -1.17323078e-01f },
      { -8.90870765e-03f, -3.69846910e-01f, 2.00116545e-01f, -8.99009779e-03f, 5.85511588e-02f },
      { -4.31737900e-02f, -5.48542030e-02f, 6.31957874e-02f, 4.98390570e-02f, -7.21588507e-02f },
    },
    {
      { 6.43236861e-02f, -1.59054488e-01f, 6.66435051e-04f, 7.50078410e-02f, 1.31130785e-01f },
      { -1.27089890e-02f, -1.71606258e-01f, 2.28031546e-01f, 2.39895716e-01f, 1.02386378e-01f },
      { -1.67143270e-01f, -1.77153274e-01f, 1.45917043e-01f, 1.81665897e-01f, 1.55217201e-01f },
      { -3.03429514e-01f, -1.20131649e-01f, 6.78404868e-02f, -1.93782616e-02f, 1.76193099e-02f },
      { -1.09897517e-01f, 9.19444188e-02f, 1.22233063e-01f, 8.29087198e-02f, -8.09133202e-02f },
    },
    {
      { 3.56590375e-02f, 1.82443962e-01f, 8.32549110e-02f, -9.12361965e-02f, -1.14775233e-01f },
      { 8.38682875e-02f, 2.60817438e-01f, 5.88456132e-02f, -1.61248431e-01f, -1.14582621e-01f },
      { 2.00861543e-01f, 3.05067360e-01f, -1.01062767e-01f, -2.23706767e-01f, 1.72988884e-02f },
      { 1.56767204e-01f, 1.42936975e-01f, -1.88705236e-01f, -5.86317154e-03f, 6.67882785e-02f },
      { 8.27147290e-02f, -9.21667889e-02f, -1.92185834e-01f, -5.76738566e-02f, 6.09460846e-02f },
    },
    {
      { -2.50303950e-02f, 4.88881804e-02f, 4.23823018e-03f, 4.61151376e-02f, 2.37516716e-01f },
      { -2.83127595e-02f, 5.48785813e-02f, -6.78191185e-02f, -1.48788720e-01f, 3.01853288e-03f },
      { 1.07035086e-01f, 1.47243857e-01f, -1.18337713e-01f, -3.16850454e-01f, -6.92226738e-02f },
      { 1.08295135e-01f, 1.11529723e-01f, -1.62684560e-01f, -1.92147508e-01f, -6.15205839e-02f },
      { 1.04875863e-01f, 1.31174386e-01f, -2.03063935e-02f, -8.50349441e-02f, 1.08399287e-01f },
    },
    {
      { -1.64479479e-01f, -2.83768922e-02f, 4.60530911e-03f, -1.23343125e-01f, 1.69202015e-01f },
      { -1.78341508e-01f, 7.36971498e-02f, -6.15632646e-02f, -7.99965486e-02f, 9.00282264e-02f },
      { -1.60972983e-01f, 7.34971166e-02f, -1.04752071e-01f, -1.41879097e-01f, -5.97273223e-02f },
      { 5.15141115e-02f, 1.85865745e-01f, 4.58435446e-04f, -5.56537434e-02f, 8.04876313e-02f },
      { 1.54004872e-01f, 5.42542487e-02f, -1.00010425e-01f, -7.85432663e-03f, 7.09878653e-02f },
    },
    {
      { 2.81085018e-02f, -9.48211998e-02f, -5.95062524e-02f, -1.04199285e-02f, -4.44344655e-02f },
      { 1.86369359e-01f, -1.53687477e-01f, 2.07581833e-01f, 1.23563066e-01f, 7.89297931e-03f },
      { 1.85405612e-01f, -3.01461160e-01f, 2.44040474e-01f, 1.94461625e-02f, 2.92250756e-02f },
      { -4.65363933e-04f, -3.09974521e-01f, 3.02591950e-01f, -1.43704768e-02f, 2.76267044e-02f },
      { -2.32967958e-01f, -3.75465572e-01f, -9.32271630e-02f, -2.00394064e-01f, -4.32716571e-02f },
    },
    {
      { 6.79912567e-02f, -1.15859941e-01f, -1.19818062e-01f, 3.05700358e-02f, 7.23274201e-02f },
      { -1.22846076e-02f, -1.72391385e-01f, 1.26911581e-01f, 1.36119813e-01f, 6.19186461e-02f },
      { -9.58774537e-02f, -2.72138774e-01f, 1.13946192e-01f, 1.15108289e-01f, 1.25470164e-03f },
      { -1.07678354e-01f, -1.72083899e-01f, 1.69046625e-01f, 6.82637766e-02f, -4.77141514e-02f },
      { -1.52018622e-01f, -1.26294285e-01f, 8.22522789e-02f, -2.20427383e-02f, -6.89799041e-02f },
    },
    {
      { -2.69622415e-01f, -3.68842185e-02f, 9.26550999e-02f, 2.90373415e-01f, 1.63655490e-01f },
      { -7.04321936e-02f, -2.28657484e-01f, -8.35265219e-02f, 1.65695280e-01f, -4.42295261e-02f },
      { 1.98436126e-01f, -2.31620967e-01f, -2.26971537e-01f, -6.48463592e-02f, -2.42132083e-01f },
      { 2.13140562e-01f, -1.46505699e-01f, -3.36838663e-01f, -8.98872912e-02f, -1.53223902e-01f },
      { 9.79280323e-02f, 1.15630932e-01f, -1.30211338e-01f, 2.39199102e-02f, -2.26726770e-01f },
    },
    {
      { -1.49152935e-01f, 1.03422016e-01f, 4.74244617e-02f, -1.20386459e-01f, -5.29391132e-02f },
      { -2.55161785e-02f, 1.85058579e-01f, 2.60123629e-02f, -1.41962871e-01f, 6.47230744e-02f },
      { -5.63753955e-03f, 1.66727394e-01f, 2.08086073e-02f, -1.28694862e-01f, 3.96295674e-02f },
      { 3.24277617e-02f, 6.90025240e-02f, -5.95091842e-04f, 5.14712967e-02f, 7.38212690e-02f },
      { 4.48183604e-02f, -3.93508002e-02f, -1.08255967e-01f, 1.16943503e-02f, 9.56092253e-02f },
    },
    {
      { -4.23753029e-03f, -7.35459775e-02f, -1.31321624e-01f, -1.11774363e-01f, 1.26419634e-01f },
      { -5.00041917e-02f, -1.34136364e-01f, -1.91555813e-01f, -7.46723339e-02f, 8.53004605e-02f },
      { -1.27896160e-01f, -5.59369177e-02f, -1.54246956e-01f, -2.96112537e-01f, -1.10042579e-01f },
      { -5.63695207e-02f, 9.72790718e-02f, 1.69838853e-02f, -6.64797649e-02f, -1.44568130e-01f },
      { 9.90829021e-02f, 5.51278926e-02f, 6.28591776e-02f, 9.05424822e-03f, 3.61934118e-02f },
    },
    {
      { -9.86183286e-02f, 8.06300789e-02f, 1.42214626e-01f, 8.46369788e-02f, -5.37624769e-02f },
      { -1.14670351e-01f, 1.03513099e-01f, 9.16619785e-03f, -6.27946062e-03f, 2.51230132e-02f },
      { -3.31603289e-02f, 2.08705589e-01f, -6.92692995e-02f, -8.87328386e-02f, 4.42422442e-02f },
      { 2.35322751e-02f, -7.66310422e-03f, -7.84363672e-02f, -1.61484871e-02f, 1.23259395e-01f },
      { 1.87961068e-02f, 3.76916640e-02f, -7.17856809e-02f, 1.10962614e-02f, 1.24211624e-01f },
    },
    {
      { -1.59367904e-01f, -9.05873924e-02f, 5.43283299e-02f, -1.48131382e-02f, 1.34433461e-02f },
      { -8.21526870e-02f, -8.70678872e-02f, 1.11704193e-01f, 1.01454277e-02f, 1.44857354e-02f },
      { -4.07035314e-02f, -2.50091217e-02f, 2.36024678e-01f, -7.18748011e-03f, -5.06508984e-02f },
      { 1.42995883e-02f, -2.25384217e-02f, 1.99325755e-01f, 5.16082123e-02f, 1.16260946e-02f },
      { -5.04524224e-02f, -1.37103088e-02f, -5.90968840e-02f, -6.15668558e-02f, -1.25667259e-01f },
    },
    {
      { -9.55087245e-02f, 9.57960635e-02f, 3.47924083e-02f, 4.30180840e-02f, -1.48341935e-02f },
      { -4.27973680e-02f, -2.16491729e-01f, 1.38458982e-01f, 1.70371696e-01f, -9.06524714e-03f },
      { 5.51278405e-02f, -2.60281414e-01f, 1.86097607e-01f, 1.83719710e-01f, -3.93263251e-02f },
      { -4.11699042e-02f, -3.10542822e-01f, 1.74053296e-01f, 7.15461895e-02f, -1.80797260e-02f },
      { 8.61301497e-02f, -1.00766413e-01f, 1.08645678e-01f, -5.29702343e-02f, -5.83301112e-02f },
    },
    {
      { 5.30056208e-02f, 4.69217002e-02f, 7.55561236e-03f, 1.83277559e-02f, -1.63916666e-02f },
      { 1.16468016e-02f, -4.05028053e-02f, -2.11632699e-02f, -5.53062521e-02f, -3.96111906e-02f },
      { -5.93816042e-02f, 4.80403304e-02f, 4.69710194e-02f, -3.01644229e-03f, -5.12578152e-02f },
      { -1.24067906e-02f, -6.49470044e-03f, -1.46812052e-02f, 3.69075499e-02f, -5.25556244e-02f },
      { 1.12062953e-02f, 4.08001244e-02f, 2.58232784e-02f, -8.17884598e-03f, -2.20829416e-02f },
    },
    {
      { 6.38141334e-02f, 4.75990251e-02f, -1.63286738e-02f, 7.04577416e-02f, -5.84415458e-02f },
      { 5.01628825e-03f, -6.73959181e-02f, 1.40482783e-01f, 1.44216605e-02f, 2.74107442e-03f },
      { 2.28315685e-02f, 3.14973928e-02f, 9.70639288e-02f, 1.73251703e-02f, 4.79014702e-02f },
      { -4.60545868e-02f, 6.76289052e-02f, 1.03425294e-01f, 7.71562615e-03f, -1.11473473e-02f },
      { -6.52614459e-02f, -3.44581902e-02f, -2.80545540e-02f, 3.94484811e-02f, -8.43866449e-03f },
    },
    {
      { 2.88971569e-02f, 1.56653821e-02f, -3.97513881e-02f, -7.05166999e-03f, 9.23479199e-02f },
      { -3.09629366e-02f, -9.73631814e-02f, -4.87426333e-02f, -2.17980836e-02f, -6.95348457e-02f },
      { -2.69487798e-02f, -9.23958197e-02f, 7.08828727e-03f, -3.66190150e-02f, -8.52247700e-02f },
      { -2.27603763e-02f, -1.07928179e-02f, 3.04155499e-02f, 3.21557820e-02f, -5.11351824e-02f },
      { 1.68795381e-02f, -1.42669380e-02f, 3.18591930e-02f, 7.59244785e-02f, 8.45107436e-02f },
    },
    {
      { -1.04187774e-02f, -3.97901535e-02f, -2.95874234e-02f, 4.09198776e-02f, 1.26213074e-01f },
      { -1.66753799e-01f, -1.62262693e-01f, -2.94165388e-02f, 3.14189047e-02f, 9.15770829e-02f },
      { -1.85070470e-01f, -3.31090507e-03f, 9.69800949e-02f, -1.04567356e-01f, -5.11832424e-02f },
      { 2.01402605e-02f, 1.13516830e-01f, 8.83818418e-02f, 3.21023464e-02f, -8.28459635e-02f },
      { -6.21786155e-02f, 6.45647496e-02f, 4.46713194e-02f, -2.81075649e-02f, -6.70896377e-03f },
    },
    {
      { 1.69284269e-01f, 4.15888056e-02f, -5.42436056e-02f, -1.12086385e-01f, 5.11708334e-02f },
      { -3.81991081e-02f, -1.72353506e-01f, -3.19411457e-01f, -2.55186081e-01f, -6.77820891e-02f },
      { -4.17475216e-03f, -2.04155535e-01f, -3.18644732e-01f, -2.34762803e-01f, -2.08338141e-01f },
      { 1.33196086e-01f, 1.41307488e-01f, 1.24617536e-02f, 3.08097787e-02f, -4.92391214e-02f },
      { 8.41937736e-02f, 2.18783636e-02f, -3.65529885e-03f, 3.21271643e-02f, -1.50298970e-02f },
    },
    {
      { 1.15520256e-02f, 8.51726010e-02f, 7.90777355e-02f, 5.82279265e-02f, 4.63695489e-02f },
      { 5.60931899e-02f, -1.33859264e-02f, 4.66038436e-02f, -7.51465634e-02f, -5.55214239e-03f },
      { 1.12832300e-02f, 2.52425149e-02f, -1.10286102e-01f, -1.85599953e-01f, -1.89717054e-01f },
      { 1.35494456e-01f, -7.41932765e-02f, -1.43933892e-01f, -7.17705935e-02f, -2.05228552e-01f },
      { 6.58878163e-02f, 8.14624205e-02f, 3.19200829e-02f, 7.19135106e-02f, -3.61971743e-02f },
    },
    {
      { -4.29813266e-02f, 2.80871037e-02f, 8.59170184e-02f, 9.76919755e-02f, -6.50275499e-02f },
      { -5.74742258e-02f, 9.54139531e-02f, 1.05657615e-01f, -1.11767440e-05f, -9.64018106e-02f },
      { 4.90837730e-02f, 1.85958415e-01f, 3.84266898e-02f, -1.93157494e-01f, 1.57126449e-02f },
      { 6.79611266e-02f, 2.31400318e-03f, -2.15318590e-01f, -8.59925002e-02f, -6.62028417e-03f },
      { -7.43204355e-02f, -8.97574425e-02f, -1.26387805e-01f, -2.42528506e-02f, 7.11995363e-02f },
    },
    {
      { -2.37932056e-01f, -1.11207142e-01f, -1.66371584e-01f, -2.45117009e-01f, -4.14229780e-01f },
      { -1.89809188e-01f, -8.42750967e-02f, -1.49832010e-01f, -4.89183478e-02f, 1.36579156e-01f },
      { -2.06956685e-01f, -2.55213708e-01f, -2.97630578e-01f, -2.08211720e-01f, -1.19150229e-01f },
      { -5.20301908e-02f, -1.17626585e-01f, -3.86254378e-02f, -5.46328500e-02f, -9.51750651e-02f },
      { 7.38320276e-02f, -2.71266084e-02f, -9.51512977e-02f, -5.11936098e-02f, -2.39557922e-02f },
    },
    {
      { 7.25131929e-02f, -1.63224675e-02f, 3.81529182e-02f, 4.41727042e-02f, 7.33287334e-02f },
      { -8.47380236e-02f, 3.69196851e-03f, 8.09549838e-02f, 1.40918434e-01f, 8.43342468e-02f },
      { -3.96902859e-02f, 9.38729569e-02f, 1.36029109e-01f, 1.39501035e-01f, 1.57741398e-01f },
      { -3.12576443e-02f, 3.04682367e-02f, 9.63736847e-02f, 1.52044922e-01f, 1.89533100e-01f },
      { 3.44557539e-02f, 7.97774196e-02f, 1.64591938e-01f, 2.18685642e-01f, 9.89758298e-02f },
    },
    {
      { -4.34431136e-02f, -6.92258775e-02f, -3.73307690e-02f, -5.56263104e-02f, -1.06038518e-01f },
      { 2.79663801e-02f, -1.20027877e-01f, 1.53027311e-01f, 4.29680152e-03f, 1.75049659e-02f },
      { 2.26762444e-02f, -3.07541173e-02f, 2.33186424e-01f, 7.24630728e-02f, 4.40475605e-02f },
      { -7.63980970e-02f, -6.72530457e-02f, 1.95497751e-01f, 4.57226597e-02f, 7.79904425e-02f },
      { -1.06710710e-01f, -4.35300916e-03f, 5.80790034e-03f, -5.59860133e-02f, -7.43943593e-03f },
    },
    {
      { 5.93051985e-02f, 4.22921069e-02f, -8.54865164e-02f, -4.18928862e-02f, 1.00577101e-02f },
      { -3.38294357e-02f, -2.24385951e-02f, -9.12916288e-02f, -5.44171967e-02f, 5.44111915e-02f },
      { -3.35460827e-02f, -1.12908967e-01f, -1.30352825e-01f, -1.10811502e-01f, -9.13290977e-02f },
      { -3.34801786e-02f, 4.02442664e-02f, 1.39832973e-01f, 3.19576561e-02f, -6.43467903e-02f },
      { 7.63830543e-02f, 6.75542727e-02f, 5.65843955e-02f, 7.84732029e-02f, 5.11338115e-02f },
    },
    {
      { 2.36463785e-01f, 9.17727500e-02f, -1.11457683e-01f, -1.26921786e-02f, 5.93492649e-02f },
      { 1.81678280e-01f, -1.31567627e-01f, 2.70562642e-03f, 1.25118300e-01f, 4.09845039e-02f },
      { -1.62121933e-02f, -1.37221143e-01f, 1.33969396e-01f, 9.83492136e-02f, 4.66186320e-03f },
      { -2.06692610e-02f, 8.04422721e-02f, 2.82035410e-01f, 1.56138405e-01f, 4.87775393e-02f },
      { -5.14471643e-02f, 2.93411631e-02f, 1.87553018e-01f, -8.72722548e-03f, 9.05642211e-02f },
    },
    {
      { 8.27779323e-02f, 5.08582965e-02f, -3.22291814e-02f, 3.62794660e-03f, 4.20802645e-02f },
      { -2.79945079e-02f, -8.58790800e-02f, -1.27306387e-01f, -8.81346241e-02f, -5.97115681e-02f },
      { -5.59905693e-02f, 1.21293245e-02f, -1.61960036e-01f, -6.34214357e-02f, -6.89639226e-02f },
      { 3.81912775e-02f, 1.20257571e-01f, 1.59213766e-02f, -6.95413500e-02f, 4.47021984e-02f },
      { 5.82191423e-02f, -8.57728999e-03f, -2.02775411e-02f, 7.50638768e-02f, -8.53594299e-03f },
    },
    {
      { -1.29298210e-01f, 1.16218124e-02f, 8.64891112e-02f, -1.35700461e-02f, 5.93052693e-02f },
      { -2.39799954e-02f, 1.31486133e-01f, 1.91045895e-01f, 1.18848324e-01f, 9.13346931e-02f },
      { 5.14263250e-02f, 2.39544645e-01f, 1.81743160e-01f, 1.12580456e-01f, 1.94335133e-01f },
      { 2.14108098e-02f, 1.40770748e-01f, 1.13087997e-01f, -1.54489605e-02f, 9.01469290e-02f },
      { 7.30620176e-02f, 1.63707137e-01f, -2.82263421e-02f, -2.54604742e-02f, 1.52118742e-01f },
    },
    {
      { -4.38203923e-02f, 1.30326137e-01f, 2.69897163e-01f, 1.51894197e-01f, 7.07918853e-02f },
      { -7.79430121e-02f, 1.51895881e-01f, 4.22837175e-02f, -1.00515358e-01f, 8.95528961e-03f },
      { 2.82538626e-02f, 7.43834823e-02f, -2.12362751e-01f, -3.01421851e-01f, -2.20131785e-01f },
      { 7.24238390e-03f, -1.87237188e-01f, -3.48270059e-01f, -3.03181767e-01f, -1.16155028e-01f },
      { -3.15072350e-02f, -7.89535232e-03f, -1.31120026e-01f, -1.00420071e-02f, -5.96310683e-02f },
    },
    {
      { 3.31064351e-02f, -2.77755391e-02f, -3.09286430e-03f, 1.33031458e-02f, -3.47017758e-02f },
      { -2.52373349e-02f, -1.38833113e-02f, -1.38662439e-02f, -5.03658317e-02f, 1.38798542e-02f },
      { 3.50751616e-02f, 3.08159292e-02f, 3.79501283e-02f, 3.53545137e-02f, -8.90964991e-04f },
      { -2.56855246e-02f, 6.14151657e-02f, -1.59131624e-02f, -1.65942907e-02f, 2.74245068e-02f },
      { 5.04281484e-02f, 4.72862944e-02f, -4.03365269e-02f, -9.19190049e-03f, 9.54577699e-03f },
    },
    {
      { -9.15971473e-02f, 1.92002505e-01f, 1.38688594e-01f, 1.13691784e-01f, -7.75475940e-03f },
      { -7.40646804e-03f, -1.15059637e-01f, 4.76335250e-02f, 4.21515247e-03f, 7.80653283e-02f },
      { 7.82417282e-02f, -3.13497335e-01f, -1.55018941e-01f, -1.15308791e-01f, -1.43691838e-01f },
      { -1.86884683e-02f, -2.56725311e-01f, -1.33327678e-01f, -5.03550693e-02f, -4.55287099e-02f },
      { 2.45790347e-01f, 1.39641061e-01f, 9.13739949e-02f, -4.64505479e-02f, 8.64545256e-02f },
    },
    {
      { 1.31653652e-01f, 1.62995402e-02f, -2.49208197e-01f, 4.09068540e-02f, -6.72777742e-02f },
      { 1.45116791e-01f, -4.50013205e-02f, -4.90698032e-02f, 1.43529892e-01f, -4.24853191e-02f },
      { 2.17370063e-01f, -3.48964781e-01f, 6.16775677e-02f, 1.11404292e-01f, -1.06699057e-01f },
      { 1.57509923e-01f, -4.42961633e-01f, 1.49836719e-01f, 2.72217821e-02f, -8.67550150e-02f },
      { -2.13236827e-02f, -4.43185538e-01f, -3.32512148e-02f, -5.18990122e-02f, -1.25235051e-01f },
    },
  },
  {
    {
      { 2.42595062e-01f, 2.51999527e-01f, 2.36889318e-01f, 1.14242688e-01f, 1.37661681e-01f },
      { 1.76384836e-01f, 1.15693800e-01f, 1.37672707e-01f, 1.26241446e-01f, 1.95209265e-01f },
      { 3.41693103e-01f, 2.82156974e-01f, 2.36993760e-01f, 2.38679394e-01f, 2.45882004e-01f },
      { 2.51915976e-02f, 5.81767447e-02f, 2.54181810e-02f, 3.40305865e-02f, 1.09559029e-01f },
      { -1.05455972e-01f, 1.96361095e-02f, 9.34707671e-02f, 1.03572950e-01f, 1.69801503e-01f },
    },
    {
      { 1.21004200e-02f, -2.49981042e-02f, -1.76135525e-02f, -1.56979978e-01f, -2.27034971e-01f },
      { -4.87836497e-03f, -6.83855787e-02f, 2.20721383e-02f, 4.96394793e-03f, -4.12288494e-02f },
      { 2.41156071e-01f, 6.12543076e-02f, 2.49489695e-02f, 3.29714492e-02f, -8.82167295e-02f },
      { 8.92312080e-03f, -9.67583880e-02f, -8.10365379e-02f, -6.86026290e-02f, -1.40316546e-01f },
      { -7.67761618e-02f, -1.83016926e-01f, -1.19832836e-01f, -7.46715218e-02f, -1.42936960e-01f },
    },
    {
      { -1.04961731e-02f, -9.56317186e-02f, -1.93474710e-01f, -2.09527314e-01f, -1.66948855e-01f },
      { -1.38921395e-01f, -3.38123918e-01f, -1.57370389e-01f, -7.26313666e-02f, -6.01247922e-02f },
      { -1.32082447e-01f, -2.60398626e-01f, -1.77583277e-01f, -6.74625635e-02f, 3.46664712e-02f },
      { 8.00166577e-02f, -1.07880510e-01f, -2.87976395e-02f, 2.43757013e-02f, -9.20637622e-02f },
      { 1.02165319e-01f, 2.89644338e-02f, 1.01305760e-01f, -4.68804576e-02f, -1.52502999e-01f },
    },
    {
      { -5.74260093e-02f, -2.40549043e-01f, -3.70026648e-01f, -2.59727478e-01f, -3.81680846e-01f },
      { 7.50268847e-02f, 2.26991344e-02f, -1.98011562e-01f, -1.71248525e-01f, -1.55781001e-01f },
      { 3.60625722e-02f, -1.25584686e-02f, -9.93717462e-02f, -1.88210353e-01f, -2.27082342e-01f },
      { 5.49013726e-03f, 7.60720894e-02f, -1.49161428e-01f, -1.71842754e-01f, -4.87012938e-02f },
      { -9.97082517e-02f, 5.80252185e-02f, 2.78449226e-02f, 9.05994698e-02f, -8.42348635e-02f },
    },
    {
      { -1.29320547e-01f, -1.13027588e-01f, -1.22162305e-01f, -1.62883878e-01f, -1.90562606e-01f },
      { -5.37865125e-02f, -4.87617813e-02f, -6.22644722e-02f, -4.23072241e-02f, -6.00956269e-02f },
      { 1.45810074e-03f, 9.01357550e-03f, 8.50420818e-03f, -3.51034477e-02f, -1.32195532e-01f },
      { 1.98775694e-01f, 1.35410413e-01f, 1.78262711e-01f, 5.27336337e-02f, 6.07799515e-02f },
      { 1.33190140e-01f, 2.46895105e-01f, 1.11748554e-01f, 7.33377635e-02f, -1.86087321e-02f },
    },
    {
      { -1.27099648e-01f, -3.24853472e-02f, -1.67264774e-01f, -8.93760324e-02f, -2.22551882e-01f },
      { -2.06537619e-01f, -1.28725007e-01f, -3.46567035e-01f, -1.38441384e-01f, -8.89998600e-02f },
      { -1.27596840e-01f, -1.03340194e-01f, -1.97889745e-01f, -3.46762002e-01f, -1.75064951e-01f },
      { 1.96853995e-01f, 1.84482440e-01f, -9.40524936e-02f, -5.89902550e-02f, -1.18040733e-01f },
      { 3.28963771e-02f, 8.93647820e-02f, -9.35562402e-02f, -8.02868456e-02f, -1.45399481e-01f },
    },
    {
      { -1.46880388e-01f, -2.04721928e-01f, -2.51487374e-01f, -4.52984005e-01f, -1.35932282e-01f },
      { -1.01529527e-02f, -1.59553632e-01f, -8.60503688e-02f, -2.47393399e-01f, -1.03334039e-01f },
      { 1.95225909e-01f, 1.81608973e-03f, 7.79860616e-02f, 2.18820032e-02f, -8.45315382e-02f },
      { 2.68879205e-01f, 5.69034182e-02f, 1.75314963e-01f, 1.34980842e-01f, -9.84483957e-02f },
      { 1.04641981e-01f, 4.54546846e-02f, 1.42911509e-01f, -1.64367035e-02f, 1.69269778e-02f },
    },
    {
      { -8.29260498e-02f, -2.67025143e-01f, -2.93773264e-01f, -3.95946175e-01f, -2.53859997e-01f },
      { 1.03714028e-02f, -2.16530249e-01f, -1.24967612e-01f, -1.90350488e-01f, -1.32106915e-01f },
      { 7.51881674e-02f, -8.36841017e-02f, 4.01581414e-02f, -1.33576514e-02f, -7.47478232e-02f },
      { 1.93896130e-01f, 7.46668503e-02f, 1.51717708e-01f, 5.89749357e-03f, -1.02643423e-01f },
      { 1.54617652e-01f, 4.87114266e-02f, 2.78130658e-02f, 5.34963198e-02f, -1.15198717e-01f },
    },
    {
      { 4.13911790e-02f, -2.46475060e-02f, -3.49829649e-03f, -5.98752052e-02f, -1.96066290e-01f },
      { 1.16035379e-01f, 1.84235517e-02f, 3.25939842e-02f, 2.97744758e-02f, -8.58633518e-02f },
      { 2.80742377e-01f, 1.40520170e-01f, -2.29912493e-02f, 1.79345049e-02f, -2.62531321e-02f },
      { 9.68304798e-02f, 9.72536951e-02f, -5.65570667e-02f, 4.75270499e-04f, -1.06018223e-01f },
      { 3.16845812e-02f, -1.16570890e-01f, -2.81748604e-02f, -1.26969993e-01f, -1.29163995e-01f },
    },
    {
      { -7.21921921e-02f, -7.04752281e-02f, -1.83230281e-01f, -1.02566794e-01f, -2.78144509e-01f },
      { -1.21647090e-01f, 7.48071149e-02f, -1.15489215e-01f, -2.52331406e-01f, -2.17868477e-01f },
      { -6.51644319e-02f, 6.16389997e-02f, -5.09439819e-02f, -2.96955705e-01f, -2.44275302e-01f },
      { -3.22923772e-02f, -1.15562771e-02f, -1.70132667e-01f, -3.15675974e-01f, -2.59594887e-01f },
      { -9.69912261e-02f, -3.95718440e-02f, -2.79790014e-01f, -2.85066903e-01f, -2.51703352e-01f },
    },
    {
      { -2.69900888e-01f, -1.67827085e-01f, -2.93178111e-01f, -3.03237557e-01f, -3.19096088e-01f },
      { -3.63452643e-01f, -2.96332836e-01f, -3.17894131e-01f, -2.71155000e-01f, -1.26649365e-01f },
      { -1.24763481e-01f, -2.77773231e-01f, -1.25332996e-01f, -1.38923988e-01f, -1.60795629e-01f },
      { 3.37997496e-01f, 1.71727762e-01f, 7.59929866e-02f, -1.54313026e-02f, -3.14498581e-02f },
      { 1.73486173e-01f, 2.32970938e-01f, 7.78628215e-02f, -5.22944033e-02f, -7.88647830e-02f },
    },
    {
      { -1.13499112e-01f, -3.26446816e-02f, -3.51657830e-02f, -1.05499655e-01f, -1.33119673e-01f },
      { 3.91096547e-02f, 7.12205321e-02f, 5.12086004e-02f, -2.70575527e-02f, -1.17815413e-01f },
      { 1.08876690e-01f, 1.35757968e-01f, -1.46159809e-02f, 1.98172107e-02f, -1.13704830e-01f },
      { -4.60699871e-02f, -8.30272958e-02f, -2.14318350e-01f, -2.59857386e-01f, -2.11099833e-01f },
      { -2.29781151e-01f, -1.71930939e-01f, -2.07830966e-01f, -2.49255791e-01f, -2.61466503e-01f },
    },
    {
      { -6.96074800e-04f, -6.38335422e-02f, 3.08805853e-02f, -5.99314421e-02f, -8.51844624e-02f },
      { 9.54827014e-03f, 1.50547726e-02f, 6.94513395e-02f, 5.02400734e-02f, -1.07369311e-01f },
      { 1.66778430e-01f, 5.63865863e-02f, 1.23997880e-02f, -2.46250592e-02f, -3.70919108e-02f },
      { 7.14630261e-02f, 4.23129369e-03f, -1.39465049e-01f, -7.00968802e-02f, -1.73999652e-01f },
      { -3.00632026e-02f, -1.53476641e-01f, -1.37415916e-01f, -1.61327630e-01f, -1.90801844e-01f },
    },
    {
      { 4.26769406e-02f, -2.59215999e-02f, -1.46878719e-01f, -2.19861239e-01f, -2.23636642e-01f },
      { -8.21168255e-03f, -4.86504193e-03f, 5.37568331e-02f, 2.64619868e-02f, -1.17019758e-01f },
      { 2.28498891e-01f, 1.36442296e-02f, 6.82725664e-03f, 1.04149163e-01f, -3.79359312e-02f },
      { 1.59491956e-01f, -3.57211381e-02f, -6.86580613e-02f, -1.59370806e-02f, -1.55475184e-01f },
      { -3.19909975e-02f, -4.29706201e-02f, -6.65654987e-02f, -1.17488071e-01f, -1.85910612e-01f },
    },
    {
      { 5.85976392e-02f, 2.08386742e-02f, 2.11226605e-02f, -1.95579827e-02f, 4.92143370e-02f },
      { -2.58289836e-02f, 3.06589641e-02f, 5.40313609e-02f, 5.37871011e-03f, 4.82351966e-02f },
      { -2.03313790e-02f, -4.17676792e-02f, -4.61967662e-03f, 4.60166819e-02f, 3.19177993e-02f },
      { 4.21851352e-02f, -5.58918691e-04f, 2.88012647e-03f, 3.82202026e-03f, 3.81136313e-02f },
      { 1.49967158e-02f, -2.19860170e-02f, -1.49529297e-02f, -8.15664977e-03f, -3.54175419e-02f },
    },
    {
      { -5.59568852e-02f, -1.08542062e-01f, -7.96425194e-02f, -1.89775184e-01f, -9.30340737e-02f },
      { 2.57891119e-02f, -4.50512953e-02f, -5.85726323e-03f, -1.56595290e-01f, -1.51317418e-01f },
      { 7.29366541e-02f, 1.06144473e-02f, -1.94711387e-02f, -2.03854684e-02f, -1.12603262e-01f },
      { 1.03891067e-01f, 3.09729856e-02f, -1.73137039e-02f, 7.93104246e-03f, -1.03323713e-01f },
      { -2.76486631e-02f, -2.66179033e-02f, -1.02658004e-01f, -3.54607627e-02f, -1.29353210e-01f },
    },
    {
      { -5.02642728e-02f, -9.95175838e-02f, -1.81454509e-01f, -1.98557600e-01f, -2.67006904e-01f },
      { 4.46733013e-02f, 2.04489548e-02f, -5.09590954e-02f, -4.60394695e-02f, -1.55419812e-01f },
      { 4.92912941e-02f, 7.74078146e-02f, 7.15776011e-02f, 1.08116277e-01f, -4.01700195e-03f },
      { 2.07424477e-01f, 1.51206389e-01f, 3.52075063e-02f, 1.43094242e-01f, -1.48274945e-02f },
      { 1.67415082e-01f, 3.29929627e-02f, 3.56919654e-02f, -2.48692054e-02f, -5.95285147e-02f },
    },
    {
      { -2.47226879e-01f, -3.12425554e-01f, -3.13618690e-01f, -4.17540014e-01f, -2.82715648e-01f },
      { -1.73811719e-01f, -2.31146261e-01f, -2.23383978e-01f, -3.25647831e-01f, -2.42647633e-01f },
      { -6.30004182e-02f, -4.40995060e-02f, -7.67850429e-02f, -1.82448238e-01f, -2.48496905e-01f },
      { 1.42610684e-01f, 6.62209317e-02f, -1.07688382e-02f, -6.87425733e-02f, -2.41844893e-01f },
      { 1.07542515e-01f, -2.89852340e-02f, 3.43376957e-02f, -5.40072843e-02f, -2.47408450e-01f },
    },
    {
      { -2.00947791e-01f, -1.91225946e-01f, -3.53990585e-01f, -2.46866405e-01f, -2.36178845e-01f },
      { -1.19345941e-01f, -1.86245307e-01f, -2.32489616e-01f, -9.15490091e-02f, -2.22208992e-01f },
      { -1.22815058e-01f, -4.62945066e-02f, -3.89134511e-04f, -3.78985070e-02f, -1.64211869e-01f },
      { 3.20810199e-01f, 3.16131711e-01f, 1.72836721e-01f, 1.82062119e-01f, 5.95697295e-03f },
      { 1.06112428e-01f, 1.45480022e-01f, 1.05286986e-01f, 1.38744190e-01f, -7.06417114e-02f },
    },
    {
      { -5.29346578e-02f, -9.90639254e-02f, -1.38263479e-01f, -8.46637264e-02f, -2.52179712e-01f },
      { 3.49948299e-03f, 3.32457498e-02f, -1.70805547e-02f, -3.99437100e-02f, -1.39676258e-01f },
      { 1.27789140e-01f, 8.51524770e-02f, 6.06994890e-02f, 9.26138982e-02f, -5.69073334e-02f },
      { 5.19113466e-02f, 1.47780448e-01f, 2.58299168e-02f, -1.00325057e-02f, -3.38347480e-02f },
      { 5.73010854e-02f, 8.59117135e-02f, 4.05830890e-02f, 7.62051856e-03f, 9.79389413e-04f },
    },
    {
      { -1.06807724e-01f, -1.01023696e-01f, -7.15504587e-02f, -8.87718499e-02f, -1.67701274e-01f },
      { -4.60191630e-03f, -6.13358105e-03f, -8.81179178e-04f, -1.49025798e-01f, -9.56349522e-02f },
      { 1.76157311e-01f, 6.11015782e-02f, -3.79633866e-02f, -9.66918617e-02f, -1.07204966e-01f },
      { 9.36757028e-02f, -7.42599461e-03f, -5.59736639e-02f, -1.86409891e-01f, -2.58412778e-01f },
      { -2.55093962e-01f, -8.59416202e-02f, -1.48252845e-01f, -1.60405666e-01f, -8.89804140e-02f },
    },
    {
      { 1.61766991e-01f, 9.72969010e-02f, -4.42030579e-02f, 1.99885778e-02f, 8.23773891e-02f },
      { 2.55861372e-01f, 1.95687220e-01f, 5.88164814e-02f, 1.21206306e-01f, 2.01485813e-01f },
      { 4.30270657e-02f, 1.14202179e-01f, 1.27864465e-01f, 6.10438548e-02f, 1.23289391e-01f },
      { -1.41035989e-01f, 4.61264625e-02f, -4.44867089e-02f, -2.25552209e-02f, -9.78299081e-02f },
      { 5.77003323e-02f, 3.28508392e-02f, -4.77764346e-02f, -9.36490074e-02f, 5.60477488e-02f },
    },
    {
      { 3.83751094e-02f, 1.15307078e-01f, 2.21231189e-02f, 1.08733758e-01f, 2.64465045e-02f },
      { 5.88527359e-02f, 8.93515795e-02f, 7.44699091e-02f, 1.31793795e-02f, 2.04942040e-02f },
      { -2.00181771e-02f, -1.90313328e-02f, 2.62548141e-02f, 6.41645864e-02f, 3.44554335e-02f },
      { 1.09471805e-01f, -5.82969189e-02f, -7.59498328e-02f, -3.65571342e-02f, 6.84401393e-02f },
      { 6.89639375e-02f, -8.09077621e-02f, -8.02347958e-02f, -1.41314873e-02f, 4.16197777e-02f },
    },
    {
      { -8.26232359e-02f, -1.08064339e-01f, -1.91275597e-01f, -2.52604872e-01f, -1.18058212e-01f },
      { -1.52916312e-02f, -4.75451760e-02f, -3.79620232e-02f, -6.49889708e-02f, -1.76042780e-01f },
      { 5.40100783e-02f, -3.35906297e-02f, 2.45729592e-02f, 3.51147056e-02f, -9.30021405e-02f },
      { 1.46300465e-01f, -5.06381355e-02f, -3.64263318e-02f, -6.56346530e-02f, -7.83829391e-02f },
      { -5.33788577e-02f, -1.26105621e-01f, -5.52287586e-02f, -1.50709614e-01f, -1.81602940e-01f },
    },
    {
      { -1.09208502e-01f, -1.96566686e-01f, -2.41747558e-01f, -2.32578620e-01f, -2.43801072e-01f },
      { -2.02682450e-01f, -2.20854267e-01f, -2.92992204e-01f, -2.29848579e-01f, -3.00438404e-02f },
      { -1.33451700e-01f, -2.85879016e-01f, -1.25541180e-01f, -1.19571231e-01f, -1.53259590e-01f },
      { 3.38921189e-01f, 2.07560107e-01f, 1.49399517e-02f, 8.16328451e-02f, 9.64002777e-03f },
      { 1.06713697e-01f, 1.60802945e-01f, 3.87501679e-02f, -4.93639447e-02f, -5.03489934e-02f },
    },
    {
      { 5.49844205e-02f, 1.52819222e-02f, -8.79189558e-03f, 3.35554779e-02f, 9.52149704e-02f },
      { 9.50354710e-02f, -4.76003811e-02f, 6.99447244e-02f, 2.85244565e-02f, 5.15732504e-02f },
      { 1.20012509e-02f, 4.92120534e-02f, 7.57564232e-02f, 1.23904139e-01f, 1.01256527e-01f },
      { 3.33365649e-01f, 1.33744106e-01f, 1.24484286e-01f, 2.11857140e-01f, 1.37527332e-01f },
      { 1.16410717e-01f, 9.47850496e-02f, 1.60260096e-01f, 8.57047364e-02f, 7.77067104e-03f },
    },
    {
      { -1.97292000e-01f, -2.26409927e-01f, -2.90486753e-01f, -2.39556149e-01f, -3.28502625e-01f },
      { -2.25065090e-02f, -1.00345887e-01f, -1.57325059e-01f, -1.93795353e-01f, -2.19369888e-01f },
      { -5.44934459e-02f, -2.83250324e-02f, 1.67031921e-02f, -6.47835732e-02f, -9.35030282e-02f },
      { 2.37685263e-01f, 2.07705393e-01f, 1.15259491e-01f, 1.12037197e-01f, -5.29374518e-02f },
      { 1.72029600e-01f, 8.28870684e-02f, 1.06280990e-01f, 6.55178260e-03f, -4.81397808e-02f },
    },
    {
      { -8.69058892e-02f, -7.77604803e-02f, -1.56073302e-01f, -1.66460037e-01f, -2.09246159e-01f },
      { -1.71095908e-01f, -6.93695694e-02f, -6.71637803e-02f, -1.97175369e-01f, -1.89318985e-01f },
      { -1.14797272e-01f, -4.39302111e-03f, -2.46566296e-01f, -2.33563215e-01f, -1.91541478e-01f },
      { -3.06461472e-02f, -1.42306805e-01f, -1.88073426e-01f, -2.89282054e-01f, -2.76722908e-01f },
      { -9.25733000e-02f, -3.93483378e-02f, -1.53426170e-01f, -2.40882710e-01f, -2.36181632e-01f },
    },
    {
      { -4.56744395e-02f, 4.79118489e-02f, -4.25405204e-02f, -5.06796055e-02f, -6.33063689e-02f },
      { 1.11977533e-01f, 7.49892294e-02f, 1.92798320e-02f, 5.14242351e-02f, -5.99035062e-02f },
      { 2.18808770e-01f, 7.33368397e-02f, 1.14811078e-01f, 5.95300421e-02f, -3.40904817e-02f },
      { 3.40653062e-02f, 8.30108859e-03f, 6.13361970e-03f, -1.17500499e-01f, -1.09896384e-01f },
      { -1.75292611e-01f, -1.36014313e-01f, -8.67468044e-02f, -5.15192226e-02f, -7.30004683e-02f },
    },
    {
      { 4.39509116e-02f, -1.11288596e-02f, -1.93434358e-02f, 1.52267627e-02f, 2.66510732e-02f },
      { -4.52163108e-02f, 5.82964756e-02f, 5.29233925e-02f, 2.39652600e-02f, -1.67369656e-02f },
      { -2.36290451e-02f, 1.31451972e-02f, -2.08600499e-02f, -5.48518561e-02f, 2.29537245e-02f },
      { -1.75278969e-02f, 5.55656701e-02f, 2.24052183e-02f, 5.90315051e-02f, 3.92961763e-02f },
      { -1.15222828e-02f, 6.04891330e-02f, -4.82866801e-02f, 6.04626164e-03f, 3.16756256e-02f },
    },
    {
      { -7.58730993e-02f, -8.73935223e-02f, -1.97749808e-02f, -1.40901968e-01f, -1.74054563e-01f },
      { 5.67451231e-02f, 1.84249580e-02f, 6.00825660e-02f, 3.58532183e-02f, -1.40008345e-01f },
      { 2.22136751e-01f, 1.16487071e-01f, 3.07254493e-02f, 7.11548030e-02f, -1.65212136e-02f },
      { 6.27445057e-02f, 5.40229529e-02f, -6.52084276e-02f, -4.61685620e-02f, -1.47507027e-01f },
      { -6.33413270e-02f, -7.82048553e-02f, -8.69940743e-02f, -2.19178554e-02f, -8.69880617e-02f },
    },
    {
      { -1.83363128e-02f, -5.69687076e-02f, -1.19714707e-01f, -2.65522510e-01f, -2.41933629e-01f },
      { 9.93181914e-02f, -4.56667654e-02f, -1.56015449e-03f, 4.33075316e-02f, -5.23469895e-02f },
      { 1.97644606e-01f, 1.15665421e-01f, 1.55845404e-01f, 1.60318032e-01f, -4.03173529e-02f },
      { 3.22469860e-01f, 1.81652769e-01f, 1.16537713e-01f, 1.91990346e-01f, -5.20584945e-05f },
      { 2.71396607e-01f, 1.01147167e-01f, 1.70435131e-01f, 1.28513575e-01f, 3.53159243e-03f },
    },
  },
  {
    {
      { 1.71801331e-03f, -5.89605309e-02f, -5.18465526e-02f, 1.53681943e-02f, 4.07633575e-04f },
      { 3.83576378e-02f, -6.25259653e-02f, 2.91286837e-02f, -1.70913097e-02f, 5.71715413e-03f },
      { 4.65894528e-02f, -3.98782417e-02f, 1.19455820e-02f, 7.36004533e-03f, 2.30057482e-02f },
      { 3.29473317e-02f, 4.69293408e-02f, -6.04621805e-02f, 1.97509117e-02f, -6.13154098e-02f },
      { 1.57170892e-02f, -7.40905777e-02f, -4.55212332e-02f, -1.48937395e-02f, 1.50265805e-02f },
    },
    {
      { -6.16973899e-02f, -1.24434074e-02f, -1.53229786e-02f, -2.63282433e-02f, -2.40575559e-02f },
      { -4.46302677e-03f, 3.44364233e-02f, -5.52432202e-02f, 2.54883096e-02f, -3.44777629e-02f },
      { 3.72668207e-02f, -7.31670409e-02f, 2.72203572e-02f, 8.78594909e-03f, -5.41957794e-03f },
      { -1.22936355e-04f, 3.51151302e-02f, -9.37510841e-03f, 3.87749411e-02f, 1.28726130e-02f },
      { -6.18872978e-02f, -4.27312702e-02f, 3.84421200e-02f, 2.77285613e-02f, -6.02284223e-02f },
    },
    {
      { 3.13463360e-02f, 4.22527827e-03f, -1.61505695e-02f, -4.07507867e-02f, 1.50235845e-02f },
      { 9.54952464e-03f, 3.15403789e-02f, -6.77225739e-02f, 5.97256273e-02f, 3.12279481e-02f },
      { -9.07173101e-03f, -6.57526180e-02f, -8.27065036e-02f, -3.20284888e-02f, -4.63975146e-02f },
      { -4.01517050e-03f, -2.95629147e-02f, 9.82217770e-03f, -5.42741008e-02f, 3.10989134e-02f },
      { -7.60554671e-02f, 3.41314934e-02f, -6.97609130e-03f, -5.23800589e-02f, 2.45046057e-02f },
    },
    {
      { -5.29902354e-02f, 4.92374897e-02f, 1.01178093e-02f, 2.53944960e-03f, -3.52629460e-03f },
      { -1.80759728e-02f, 3.65190543e-02f, 4.27745059e-02f, -2.42439304e-02f, 4.72910553e-02f },
      { 1.59078818e-02f, -1.22939693e-02f, -6.05618507e-02f, 2.55395900e-02f, -2.62948237e-02f },
      { -2.68336907e-02f, 3.17313634e-02f, 3.75105217e-02f, -3.07821650e-02f, 5.47663867e-03f },
      { 1.55214509e-02f, -2.97535323e-02f, -2.31862310e-02f, 5.23375981e-02f, -2.06576893e-03f },
    },
    {
      { 1.65083576e-02f, -3.98528762e-02f, -4.71244939e-02f, 4.73977029e-02f, -4.86465469e-02f },
      { 5.97179960e-03f, -5.10321781e-02f, 3.08788437e-02f, -2.20275577e-02f, -6.77358806e-02f },
      { -2.34424751e-02f, -4.39154729e-02f, -1.99252944e-02f, -5.22023328e-02f, -1.92073733e-02f },
      { 3.47231850e-02f, 2.04442311e-02f, 1.62255336e-02f, -4.46806438e-02f, -5.97467348e-02f },
      { -5.53537719e-03f, 6.22451566e-02f, -2.68307254e-02f, 4.74244058e-02f, 5.21599017e-02f },
    },
    {
      { 1.74904894e-02f, 4.45435680e-02f, -3.14810649e-02f, -5.68506531e-02f, 2.94688661e-02f },
      { -1.03388180e-03f, 2.14050128e-03f, -4.32026982e-02f, -6.63042814e-02f, -6.64725527e-03f },
      { 6.21244917e-03f, 6.55877753e-04f, 2.72827186e-02f, 1.12802135e-02f, -2.82772239e-02f },
      { -1.34025076e-02f, 6.08318374e-02f, -3.43500241e-03f, 1.55862486e-02f, -4.23344895e-02f },
      { 6.47032931e-02f, 3.65644023e-02f, 5.29995859e-02f, -5.94615750e-02f, 3.84597965e-02f },
    },
    {
      { 2.82093231e-02f, 3.45258936e-02f, -6.14855550e-02f, -7.93748163e-03f, -3.67803685e-02f },
      { -3.90362628e-02f, -1.16448989e-02f, -4.01877128e-02f, -6.08805530e-02f, 4.56084833e-02f },
      { 2.63804980e-02f, -3.47602591e-02f, 6.55085817e-02f, 3.39209400e-02f, -1.28431097e-02f },
      { -5.19093983e-02f, 2.32874509e-02f, -5.10301965e-04f, -1.43216942e-02f, -3.09778154e-02f },
      { 3.78599949e-02f, 2.28794403e-02f, -5.73171116e-02f, 3.20640765e-02f, 2.69063599e-02f },
    },
    {
      { -2.09866874e-02f, -4.70945612e-02f, -2.62676217e-02f, -3.67262214e-02f, -2.73213424e-02f },
      { -6.04129173e-02f, 3.09473313e-02f, 3.62165235e-02f, -6.44781515e-02f, -7.56227737e-03f },
      { 3.98900509e-02f, -3.32483314e-02f, -6.06019399e-04f, -4.06934656e-02f, -3.08425575e-02f },
      { 1.58975702e-02f, 1.77585874e-02f, -5.51004484e-02f, -4.99711111e-02f, 2.05698237e-02f },
      { -1.89980529e-02f, -1.59827806e-02f, 4.53510433e-02f, 3.08907516e-02f, 5.41658094e-03f },
    },
    {
      { 1.23949759e-02f, 6.74114097e-03f, -5.88497408e-02f, -2.51137540e-02f, -6.54407069e-02f },
      { 2.23050680e-04f, -1.43910246e-03f, -4.31584790e-02f, -8.53709057e-02f, -6.37396798e-02f },
      { 1.90468924e-03f, -4.34833467e-02f, -7.07736462e-02f, -4.40347120e-02f, -3.84582914e-02f },
      { 3.90091129e-02f, -3.93065810e-02f, 2.39853896e-02f, -5.99563979e-02f, 3.97928543e-02f },
      { -2.75257733e-02f, -7.51667768e-02f, -1.82230826e-02f, 3.18026431e-02f, -2.32838672e-02f },
    },
    {
      { 5.02054021e-03f, -3.08290347e-02f, 1.90516617e-02f, 3.61132808e-03f, -2.19185520e-02f },
      { 2.31484864e-02f, 1.39028663e-02f, -1.01908054e-02f, -6.05070079e-03f, 3.71400602e-02f },
      { 2.29239371e-02f, 1.73986275e-02f, -2.79227216e-02f, -6.68789595e-02f, 1.80159342e-02f },
      { -6.85498193e-02f, -4.89299446e-02f, 4.11702320e-02f, -5.68563677e-02f, 4.92232405e-02f },
      { 3.16887386e-02f, -2.87028234e-02f, -1.20797800e-02f, 4.42872047e-02f, -5.28866835e-02f },
    },
    {
      { -4.00466360e-02f, -5.35440594e-02f, 1.29546197e-02f, -3.66809107e-02f, 4.59712259e-02f },
      { -2.68596224e-02f, -5.42730466e-03f, -2.32012887e-02f, 2.67473385e-02f, 4.16354537e-02f },
      { 3.38913240e-02f, 1.09549873e-02f, -8.07458069e-04f, -5.99988401e-02f, 3.84875908e-02f },
      { -8.61306954e-03f, 1.07043339e-02f, -4.78048623e-02f, 1.00804253e-04f, 3.14896218e-02f },
      { -2.90229358e-03f, 5.67728095e-02f, -1.44908698e-02f, 1.53574254e-02f, -2.62315311e-02f },
    },
    {
      { -6.43010512e-02f, -1.34185432e-02f, -1.60579812e-02f, 7.76556408e-05f, -5.14112376e-02f },
      { 3.98381911e-02f, -4.68642637e-02f, 9.58874635e-03f, -6.55039772e-02f, -6.34050220e-02f },
      { -2.66098548e-02f, -3.92644219e-02f, -2.39730459e-02f, -5.18074520e-02f, 3.01770656e-03f },
      { -6.87979860e-03f, 9.92734823e-03f, -3.84036787e-02f, -5.31479008e-02f, -4.96567301e-02f },
      { 2.23108381e-02f, 1.56650320e-02f, 2.88588144e-02f, -5.79605289e-02f, 2.88192350e-02f },
    },
    {
      { 4.96426001e-02f, 4.34054919e-02f, -1.29371509e-03f, 2.95072757e-02f, 2.95552872e-02f },
      { 1.35824201e-03f, 3.41551416e-02f, 1.33179752e-02f, -4.18568552e-02f, -6.34292737e-02f },
      { -1.79132801e-02f, 2.36013625e-02f, 1.89464651e-02f, -6.58868253e-02f, -6.05615266e-02f },
      { 3.22812274e-02f, -4.51981984e-02f, -3.65715027e-02f, -5.11946157e-02f, -2.93535320e-03f },
      { 4.62201200e-02f, 2.96242703e-02f, 6.26715180e-03f, -2.39888262e-02f, -4.52078730e-02f },
    },
    {
      { -4.62824702e-02f, 1.87371671e-02f, 2.41812561e-02f, 3.72034013e-02f, 1.65114980e-02f },
      { -1.06850518e-02f, 4.63825986e-02f, 2.97174696e-02f, -1.79209113e-02f, -4.08088304e-02f },
      { -1.11827888e-02f, 4.38764952e-02f, -8.66471883e-03f, -4.30388860e-02f, -2.66143512e-02f },
      { 2.53598839e-02f, 1.82605460e-02f, -9.31885466e-03f, 1.75082386e-02f, 6.26474898e-03f },
      { 1.39354561e-02f, 4.12184093e-03f, -6.82296902e-02f, 5.03699854e-02f, -1.61674693e-02f },
    },
    {
      { -2.72174664e-02f, 1.08980248e-02f, -2.18015127e-02f, 1.59244332e-02f, 3.07042208e-02f },
      { -2.84369979e-02f, -3.21621187e-02f, -9.77926329e-03f, 2.39037368e-02f, -6.12895451e-02f },
      { 2.81027779e-02f, 2.40185428e-02f, 5.51726818e-02f, -1.33377304e-02f, 1.87028721e-02f },
      { 3.99419367e-02f, -3.75217199e-02f, 3.37269418e-02f, -5.19891120e-02f, 3.39410007e-02f },
      { -4.59280163e-02f, 6.65961280e-02f, 5.72628081e-02f, 4.72734496e-02f, -5.23684770e-02f },
    },
    {
      { 7.13436864e-03f, -3.48964408e-02f, -8.35828390e-03f, -4.78429422e-02f, -3.06970775e-02f },
      { -1.51009187e-02f, 4.19426300e-02f, -3.03602014e-02f, -3.16148438e-02f, -5.19943871e-02f },
      { -5.52549697e-02f, 3.09527125e-02f, 2.04895679e-02f, 3.13156191e-03f, -1.11301979e-02f },
      { 3.04723643e-02f, -2.67847348e-02f, -5.45660891e-02f, 1.27718435e-03f, 1.65375639e-02f },
      { -6.44732788e-02f, -1.41310198e-02f, 3.98204513e-02f, -5.54718412e-02f, 3.10535803e-02f },
    },
    {
      { -1.56735163e-02f, 3.56748886e-02f, 3.40183713e-02f, 2.19652746e-02f, -4.45937254e-02f },
      { -3.48323099e-02f, -4.70655896e-02f, -3.41113694e-02f, -1.97295174e-02f, 2.75175236e-02f },
      { -4.97977287e-02f, 2.46923491e-02f, -4.30389261e-03f, -3.65539193e-02f, 2.32920349e-02f },
      { 4.97864410e-02f, 2.19327845e-02f, 1.05517162e-02f, -2.17127297e-02f, 1.68321673e-02f },
      { -6.23252429e-02f, -2.08404791e-02f, -4.01867516e-02f, -5.18761352e-02f, -3.44920717e-02f },
    },
    {
      { -2.48328615e-02f, 8.94973148e-03f, 5.87787293e-03f, 1.66990273e-02f, 1.77825484e-02f },
      { -5.41621037e-02f, 3.05634756e-02f, -5.06038442e-02f, 3.52893071e-03f, -4.36949097e-02f },
      { -5.73533215e-02f, -5.15540540e-02f, 1.53037822e-02f, -6.08746260e-02f, -3.31157558e-02f },
      { -1.11726001e-02f, 4.34829062e-03f, -6.73555583e-03f, -6.69842679e-03f, -5.66629730e-02f },
      { 2.25523561e-02f, -4.40808106e-03f, -5.66213466e-02f, 4.26255614e-02f, 2.44073905e-02f },
    },
    {
      { 2.48060543e-02f, -6.67713583e-02f, -4.63973440e-04f, 1.49387633e-02f, 4.47276421e-03f },
      { 3.87955531e-02f, 1.62736177e-02f, -2.12664176e-02f, -3.65422629e-02f, -5.25892153e-03f },
      { 5.57633042e-02f, 1.88099276e-02f, -1.56997498e-02f, 3.26664522e-02f, 4.24682721e-03f },
      { -7.68504851e-03f, -4.63012867e-02f, 4.73135337e-02f, 2.63627688e-03f, 2.55978405e-02f },
      { 4.08574305e-02f, -5.21216132e-02f, 1.07212625e-02f, 4.52164188e-02f, -2.19848640e-02f },
    },
    {
      { 3.77761275e-02f, 2.85211597e-02f, 1.80099290e-02f, 1.32206352e-02f, 3.54700089e-02f },
      { 6.99283043e-03f, -1.71712844e-03f, -5.74738272e-02f, 1.49200642e-02f, 2.81802006e-02f },
      { -5.25161587e-02f, -4.98413108e-02f, -3.25524509e-02f, -3.45227830e-02f, 2.88312938e-02f },
      { -4.58392501e-02f, 1.62052065e-02f, -6.86967149e-02f, 4.49668095e-02f, -1.22782486e-02f },
      { 4.01877463e-02f, -6.65682256e-02f, 3.05768475e-02f, 1.72728263e-02f, -2.12318357e-02f },
    },
    {
      { 3.36213782e-03f, -2.02415977e-02f, -1.03384191e-02f, 3.90827768e-02f, 4.43647206e-02f },
      { -5.66304699e-02f, 3.19736414e-02f, -5.89630231e-02f, 3.42141986e-02f, -6.95782974e-02f },
      { -6.26503155e-02f, -1.47942277e-02f, -2.66282223e-02f, -7.26832892e-04f, -1.21966506e-04f },
      { 2.43720189e-02f, -1.88084936e-03f, 3.83884017e-03f, -4.48699072e-02f, -3.69987935e-02f },
      { 2.13152133e-02f, 4.69526974e-03f, -5.14355376e-02f, -5.35036139e-02f, 5.11261187e-02f },
    },
    {
      { -1.08468076e-02f, -4.95116785e-02f, 6.23035105e-03f, 4.04999293e-02f, -8.49369261e-03f },
      { -2.54211482e-02f, -2.80665681e-02f, -6.48110727e-05f, -2.52258924e-05f, 4.00645845e-02f },
      { -5.01114465e-02f, -3.47553566e-02f, 6.08830974e-02f, -3.79195623e-02f, -1.22691260e-03f },
      { 4.87814993e-02f, 4.47044410e-02f, -4.63050008e-02f, -8.40813108e-03f, -5.71580678e-02f },
      { -3.51893567e-02f, 6.17415756e-02f, -7.56793306e-05f, 3.12155895e-02f, 2.71313693e-02f },
    },
    {
      { 5.16055785e-02f, 2.31463742e-02f, 4.31751981e-02f, -5.58806816e-04f, 1.99799128e-02f },
      { 4.18828726e-02f, 5.56811057e-02f, -2.43650340e-02f, -4.88521010e-02f, 3.05941962e-02f },
      { -4.64123487e-03f, -5.44576943e-02f, 4.34444435e-02f, -3.15036438e-02f, -4.65518869e-02f },
      { 4.45555151e-02f, 2.31126063e-02f, -5.99019841e-05f, -3.57710421e-02f, -4.62701581e-02f },
      { -6.40488556e-03f, -2.46698819e-02f, 3.78786549e-02f, -5.45949154e-02f, 1.28662921e-02f },
    },
    {
      { -1.60616990e-02f, 1.05730193e-02f, -6.36736974e-02f, 5.87094203e-03f, 2.47962866e-02f },
      { 2.93501969e-02f, 2.05927268e-02f, 4.47161235e-02f, -6.66186363e-02f, -7.25238100e-02f },
      { 2.42347573e-03f, 4.11604568e-02f, -6.06665574e-02f, 2.62487028e-02f, -5.95773235e-02f },
      { -6.45342097e-02f, 3.54138650e-02f, -6.36411235e-02f, -6.89510554e-02f, -2.21845564e-02f },
      { -6.66163042e-02f, 8.38550553e-03f, -2.68156938e-02f, -3.71379405e-02f, 4.84653041e-02f },
    },
    {
      { -2.66853105e-02f, -5.24040163e-02f, -4.15014476e-02f, 3.83412242e-02f, -3.03252619e-02f },
      { -1.34054304e-03f, 4.84547913e-02f, 1.76800303e-02f, -3.05090634e-05f, -5.45130894e-02f },
      { 1.93978865e-02f, 4.83856052e-02f, -3.98117006e-02f, 1.60844240e-03f, 8.84253439e-03f },
      { -2.24481262e-02f, -6.50314912e-02f, -6.88975826e-02f, 1.31184077e-02f, 4.21349667e-02f },
      { 3.71594578e-02f, 1.10260583e-02f, -5.60107231e-02f, 3.19941714e-02f, -4.16386500e-02f },
    },
    {
      { -1.45567209e-03f, 1.97802149e-02f, -2.25144885e-02f, -2.71439496e-02f, -4.60258983e-02f },
      { 3.85059640e-02f, -1.24802683e-02f, -2.55287308e-02f, -1.78985428e-02f, 1.44782253e-02f },
      { -9.03123617e-02f, 2.85801850e-02f, 1.03433533e-02f, -6.38616756e-02f, -7.61146694e-02f },
      { -1.85754541e-02f, -8.14812258e-02f, 4.28491756e-02f, -2.20094919e-02f, 2.06869300e-02f },
      { 3.76774301e-03f, -2.29403209e-02f, 5.90908155e-03f, 2.91830655e-02f, 7.58839399e-03f },
    },
    {
      { -4.32916693e-02f, -5.78177646e-02f, -5.24897054e-02f, 1.70378406e-02f, 1.09066013e-02f },
      { 3.01612187e-02f, -3.70582975e-02f, -5.69948480e-02f, -5.33636808e-02f, -2.22437605e-02f },
      { 5.31940954e-03f, -2.94452049e-02f, -5.81645183e-02f, -1.75873246e-02f, 4.14248481e-02f },
      { 1.78589765e-02f, -2.91201808e-02f, -6.00400846e-03f, 2.99226474e-02f, -1.92252807e-02f },
      { -3.42255794e-02f, -3.52657735e-02f, 2.25489009e-02f, -6.09228201e-02f, -2.29402147e-02f },
    },
    {
      { 3.29766572e-02f, 4.83213216e-02f, -5.92923313e-02f, -3.77613977e-02f, 3.22766267e-02f },
      { 1.66826621e-02f, 2.98110135e-02f, 4.75405306e-02f, -3.89689989e-02f, -3.83778326e-02f },
      { 3.52421962e-02f, -5.80911189e-02f, 1.25156213e-02f, -6.25004694e-02f, -2.39750892e-02f },
      { -7.82980304e-03f, -4.12707217e-02f, 3.85919400e-02f, -2.11412739e-02f, -5.96883008e-03f },
      { 1.66291334e-02f, -5.87309264e-02f, 1.70370024e-02f, 1.94466079e-03f, -5.16083427e-02f },
    },
    {
      { -6.68945163e-02f, -6.93353564e-02f, -6.10981956e-02f, -8.00887868e-02f, 1.81452110e-02f },
      { 3.22586508e-03f, -2.97582056e-02f, -7.20208734e-02f, -3.83795649e-02f, -4.37215418e-02f },
      { 1.38962613e-02f, -1.77821319e-03f, -1.90228410e-02f, -2.56677344e-02f, -6.10069893e-02f },
      { 9.51697677e-03f, -1.20774435e-04f, 1.75726451e-02f, -6.81169182e-02f, -4.67286780e-02f },
      { -6.14364445e-02f, -5.56664094e-02f, -6.51327670e-02f, -6.15733536e-03f, 3.24901417e-02f },
    },
    {
      { 1.44129375e-03f, 3.23642232e-02f, 5.62200323e-02f, 5.89239262e-02f, 3.24812792e-02f },
      { -4.38264683e-02f, 3.32185277e-03f, 1.82554368e-02f, -5.13172671e-02f, 1.82647258e-02f },
      { -3.82240936e-02f, -3.44437063e-02f, -4.03638706e-02f, -4.32326123e-02f, 5.08478731e-02f },
      { 2.83623505e-02f, 2.49032378e-02f, 3.08263991e-02f, 1.01096891e-02f, -2.26434600e-02f },
      { 1.08666532e-02f, -5.60217835e-02f, -2.53133546e-03f, -3.71149331e-02f, -1.89132262e-02f },
    },
    {
      { -2.86577418e-02f, 2.09692512e-02f, 3.15164030e-02f, -1.49793187e-02f, 2.93099396e-02f },
      { 5.01973405e-02f, -4.22754046e-03f, -1.06957462e-02f, 6.50660992e-02f, -4.16054353e-02f },
      { -2.40646279e-03f, 1.52235152e-02f, -2.03007534e-02f, -3.67196165e-02f, -6.08892255e-02f },
      { -5.35208359e-03f, 3.95046771e-02f, -2.31129886e-03f, 5.00855073e-02f, -4.93522733e-02f },
      { 8.52704793e-03f, 4.15893272e-03f, -4.33780216e-02f, -1.61427986e-02f, 4.88884598e-02f },
    },
    {
      { -3.05258334e-02f, 1.40718427e-02f, -6.34040833e-02f, 5.44365321e-04f, -3.52928340e-02f },
      { -5.65725565e-02f, -6.32683411e-02f, 3.33145559e-02f, -2.90305726e-02f, -2.03593564e-03f },
      { -2.58693490e-02f, 3.48301753e-02f, -6.16921149e-02f, 2.29751114e-02f, -5.02831675e-02f },
      { -3.99983525e-02f, -2.42788028e-02f, 8.17537960e-03f, 2.05693264e-02f, -3.29228006e-02f },
      { -2.52462067e-02f, -4.50036265e-02f, 2.86038406e-02f, -6.94456249e-02f, -1.83896888e-02f },
    },
  },
  {
    {
      { -1.30030410e-02f, -1.35736838e-01f, -1.72289133e-01f, -1.31357878e-01f, -2.37283573e-01f },
      { 1.10965334e-01f, 3.43984440e-02f, 1.08072393e-01f, 2.57706165e-01f, 6.23934567e-02f },
      { 1.70097426e-01f, -1.26254663e-01f, -2.97858745e-01f, -2.25334376e-01f, -1.76589504e-01f },
      { 9.73033160e-02f, 2.60317504e-01f, -5.54612316e-02f, -2.19413921e-01f, -6.35029972e-02f },
      { -2.23438084e-01f, -1.35144843e-02f, 3.18693928e-02f, -7.66124874e-02f, 5.79645708e-02f },
    },
    {
      { -1.09956190e-01f, -4.38337438e-02f, 1.85012035e-02f, -3.55482996e-02f, -1.82996899e-01f },
      { 3.07075698e-02f, 1.33904889e-01f, 2.70365357e-01f, 2.19228193e-01f, 1.86021537e-01f },
      { -7.79224336e-02f, -1.14302211e-01f, -2.19835475e-01f, -8.18721652e-02f, -3.27307805e-02f },
      { -6.96102381e-02f, 1.40855223e-01f, 2.82574613e-02f, 5.42862006e-02f, -2.74041574e-03f },
      { -2.46094048e-01f, -3.21425349e-02f, -1.41579714e-02f, -4.29066308e-02f, -1.24865606e-01f },
    },
    {
      { -2.17527479e-01f, -1.95689555e-02f, 9.27473754e-02f, 1.46259606e-01f, 5.36853261e-02f },
      { -1.07951760e-01f, -2.30108306e-01f, -8.64846036e-02f, 1.25762954e-01f, 4.09767419e-01f },
      { -1.40190899e-01f, -1.82433993e-01f, -9.66070667e-02f, 5.51420934e-02f, 1.47086814e-01f },
      { -2.95383602e-01f, -3.42835933e-02f, 1.17561340e-01f, 1.71186417e-01f, 1.40052870e-01f },
      { -1.86131716e-01f, -8.32018554e-02f, -1.08659379e-02f, 4.51679453e-02f, 6.15555122e-02f },
    },
    {
      { 1.23108521e-01f, 1.87262386e-01f, 6.42905757e-02f, 3.39631997e-02f, -7.35681802e-02f },
      { 1.62759587e-01f, 1.76726624e-01f, 2.49660481e-02f, -9.60459188e-02f, -2.73684174e-01f },
      { 1.08506583e-01f, 1.02928735e-01f, 1.99327603e-01f, -1.11684799e-01f, -2.57575750e-01f },
      { 2.33585969e-01f, 3.30248848e-02f, 2.56672166e-02f, -1.94132075e-01f, -1.45350143e-01f },
      { 2.07282811e-01f, 5.46542481e-02f, -3.29067148e-02f, -1.80319548e-01f, -1.05093509e-01f },
    },
    {
      { 2.29301691e-01f, 1.86945900e-01f, 2.69760471e-02f, 2.07793317e-03f, 1.29596189e-01f },
      { 2.48055473e-01f, 2.19813019e-01f, 9.92628112e-02f, -2.37112609e-03f, -5.42513579e-02f },
      { 1.23690225e-01f, 2.03996763e-01f, 1.79122582e-01f, -3.89291793e-02f, -2.31190085e-01f },
      { 3.25478613e-02f, 4.24338728e-02f, 1.66184738e-01f, 8.66865814e-02f, -8.90813321e-02f },
      { 2.01165244e-01f, 5.93147017e-02f, -5.62177598e-02f, 1.49282087e-02f, 3.31157744e-02f },
    },
    {
      { -3.13132368e-02f, -1.66060589e-02f, 4.02746350e-02f, 1.84392020e-01f, 1.62040532e-01f },
      { -1.15776718e-01f, 5.10498025e-02f, -2.07936227e-01f, -2.09066644e-01f, -2.56836206e-01f },
      { 1.03091151e-02f, 3.61096896e-02f, 1.92311499e-02f, 1.89449359e-02f, -1.69041842e-01f },
      { -1.93657979e-01f, -1.14777081e-01f, -3.40593457e-02f, -1.77820828e-02f, -1.07167318e-01f },
      { 1.27097100e-01f, 1.02699161e-01f, -2.19551730e-03f, -1.48177996e-01f, -9.02535692e-02f },
    },
    {
      { -2.27431044e-01f, -5.88638894e-02f, -1.02869861e-01f, -1.71618924e-01f, 6.53205439e-02f },
      { 1.72013941e-03f, 1.31023213e-01f, -3.46857752e-03f, -3.53966027e-01f, -1.33325905e-01f },
      { 1.10297978e-01f, -1.39498245e-02f, 3.62568237e-02f, -8.29155892e-02f, -3.77837569e-02f },
      { 1.65092543e-01f, 3.65995876e-02f, -1.67176560e-01f, -1.27040923e-01f, -1.14051312e-01f },
      { 1.41622722e-01f, 2.13890895e-01f, 8.19238462e-03f, -6.42049983e-02f, -1.16044752e-01f },
    },
    {
      { -1.26862481e-01f, 3.35469060e-02f, 5.14682196e-02f, 7.26560131e-02f, 1.37288421e-01f },
      { -5.23798056e-02f, -1.49800226e-01f, -8.25406983e-02f, -3.04812163e-01f, 2.23701857e-02f },
      { 3.02227214e-02f, -1.03808261e-01f, 1.48120942e-02f, 1.04266264e-01f, 1.06965989e-01f },
      { -8.97556245e-02f, -1.08466826e-01f, -6.16610013e-02f, -1.63885113e-02f, -8.22836980e-02f },
      { -8.96143988e-02f, 8.71105418e-02f, 8.73647630e-02f, -2.24133097e-02f, -1.23542450e-01f },
    },
    {
      { -2.01284420e-03f, -1.86135784e-01f, -6.79129809e-02f, -2.06256807e-01f, -3.38755876e-01f },
      { 7.80580565e-02f, 6.10897653e-02f, 2.17864782e-01f, 3.76292884e-01f, 2.29472235e-01f },
      { 2.81968769e-02f, 9.00424421e-02f, -1.97957858e-01f, 5.65188415e-02f, -7.12008029e-02f },
      { -5.05371168e-02f, 3.33184838e-01f, 9.30619463e-02f, 3.28537002e-02f, -1.03089564e-01f },
      { -2.03023851e-01f, 1.12070516e-01f, 3.81344520e-02f, 1.08725898e-01f, -4.34773462e-03f },
    },
    {
      { 6.69348687e-02f, 7.14614838e-02f, -3.13843675e-02f, 5.24981618e-02f, 8.04692507e-03f },
      { -1.90878361e-02f, 1.95170846e-02f, 3.02471351e-02f, -1.15354188e-01f, -1.21698156e-01f },
      { -6.78533614e-02f, -2.97190603e-02f, 5.23740202e-02f, -1.38102815e-01f, -8.05630609e-02f },
      { 1.01207003e-01f, -4.03257133e-03f, 5.22219576e-02f, -3.57441604e-02f, -5.06197959e-02f },
      { 2.34950669e-02f, 5.72098903e-02f, -4.27683592e-02f, -4.18749228e-02f, 1.54802352e-02f },
    },
    {
      { -9.76719521e-03f, 9.73212123e-02f, 1.16173811e-01f, 1.86124280e-01f, 1.91820428e-01f },
      { -1.06590264e-01f, 3.32769528e-02f, -1.27764894e-02f, -2.39135310e-01f, -1.30436301e-01f },
      { -5.91866150e-02f, 5.15879691e-02f, 1.08719192e-01f, -9.67633724e-03f, 1.20747676e-02f },
      { -5.14665581e-02f, -1.85861677e-01f, -2.34416332e-02f, 4.05061692e-02f, -3.89456078e-02f },
      { 9.81238037e-02f, 2.95803975e-02f, -7.03807622e-02f, -4.68304716e-02f, -6.34200051e-02f },
    },
    {
      { -4.58393507e-02f, 3.21220867e-02f, -8.58563036e-02f, -6.52549341e-02f, -9.93504450e-02f },
      { -1.09145204e-02f, 1.65736470e-02f, 4.62220013e-02f, 2.16344684e-01f, 1.84064209e-01f },
      { -1.69200391e-01f, -1.18825927e-01f, 3.19809988e-02f, -3.89416404e-02f, 1.44518008e-02f },
      { -9.48889703e-02f, -3.52172330e-02f, 2.59300638e-02f, -8.26814771e-02f, 4.17123362e-02f },
      { -1.30052343e-02f, -1.69185232e-02f, 2.01442186e-02f, -1.01518482e-01f, -4.40935828e-02f },
    },
    {
      { -7.76617900e-02f, -1.08016439e-01f, -4.33653258e-02f, -1.03131615e-01f, -1.50628900e-02f },
      { -4.53158282e-02f, -1.25162631e-01f, 2.04014895e-03f, -2.21269182e-03f, 1.92457605e-02f },
      { -9.95067954e-02f, -1.03663653e-01f, -8.53458941e-02f, 2.19142511e-02f, 7.79662728e-02f },
      { -1.53244957e-01f, 6.59981743e-02f, 3.94809283e-02f, -2.37917174e-02f, 1.65321417e-02f },
      { -1.31743580e-01f, 8.45218748e-02f, 2.25478504e-02f, -6.57747220e-03f, 2.81209941e-06f },
    },
    {
      { -5.53076230e-02f, -4.70763780e-02f, -2.63863429e-02f, -1.52157903e-01f, -1.26591653e-01f },
      { -1.03752101e-02f, 8.10491964e-02f, 3.01100522e-01f, 2.27919027e-01f, 1.72487959e-01f },
      { -2.60813441e-02f, -8.25593099e-02f, -1.67205289e-01f, -9.04064626e-02f, -2.18633469e-03f },
      { -1.48484260e-02f, 1.36728629e-01f, -4.26993035e-02f, -1.80187263e-02f, 3.90454084e-02f },
      { -2.44313851e-01f, 4.03932557e-02f, 7.92815443e-03f, -6.05868641e-04f, -1.81143805e-01f },
    },
    {
      { 3.63401733e-02f, 2.00143754e-02f, -1.96871348e-02f, -3.55209932e-02f, 2.13599522e-02f },
      { -3.11869960e-02f, -2.44972613e-02f, 3.70886736e-03f, 1.42390318e-02f, 2.42358372e-02f },
      { 3.28599736e-02f, -5.32404073e-02f, -1.63598657e-02f, -1.74498316e-02f, -5.59399128e-02f },
      { -2.84864716e-02f, -2.77498178e-02f, -6.13679104e-02f, -2.12791823e-02f, -4.75988127e-02f },
      { 2.99477261e-02f, 4.48276848e-02f, -4.08624709e-02f, 6.13718107e-02f, -1.96929239e-02f },
    },
    {
      { 9.26723983e-03f, -5.34945317e-02f, 7.34858066e-02f, 7.93078691e-02f, 7.98632577e-02f },
      { 8.72252434e-02f, 8.54323246e-03f, 4.14448902e-02f, -1.10851964e-02f, -2.21630558e-02f },
      { 1.25143221e-02f, -5.20501100e-03f, -5.03610186e-02f, 3.63942049e-02f, -3.25688608e-02f },
      { 4.36405838e-02f, -1.65728405e-02f, 2.19395719e-02f, -5.24945669e-02f, 4.79486138e-02f },
      { -9.23858304e-03f, 5.32244658e-03f, 4.59525511e-02f, -4.18178849e-02f, -1.19503131e-02f },
    },
    {
      { 8.53896961e-02f, 1.12515070e-01f, 2.56463811e-02f, -1.96570884e-02f, -6.70160428e-02f },
      { 4.49317954e-02f, 6.71562776e-02f, -4.48337756e-03f, -2.68833712e-03f, -5.06431460e-02f },
      { 1.08069383e-01f, 1.02019146e-01f, 1.23397328e-01f, 6.87843487e-02f, 1.01895824e-01f },
      { -5.56323939e-05f, -2.03695404e-03f, -4.59412411e-02f, 1.04565069e-01f, 1.89268067e-02f },
      { -6.59474581e-02f, 3.93450819e-02f, 5.97259812e-02f, -1.98814715e-03f, -1.00295013e-02f },
    },
    {
      { -8.62115398e-02f, -5.31961359e-02f, 1.28796130e-01f, 1.34949952e-01f, 6.26662821e-02f },
      { -2.31403857e-02f, 3.58023122e-02f, 7.50327064e-03f, -8.51873234e-02f, -8.20340142e-02f },
      { 2.91717909e-02f, -1.50913512e-02f, 1.34728432e-01f, 1.55551180e-01f, 4.81593907e-02f },
      { -1.42487600e-01f, -1.18846089e-01f, 4.79961298e-02f, 4.39689681e-02f, -5.05137183e-02f },
      { 4.49670060e-03f, 6.88040182e-02f, 3.18432599e-02f, -5.93249016e-02f, -9.69331637e-02f },
    },
    {
      { 1.42472878e-01f, 1.62779912e-01f, 1.26185715e-01f, 2.96048969e-01f, 2.45355740e-01f },
      { 8.31199288e-02f, 6.37922138e-02f, -2.41569038e-02f, -1.63408190e-01f, -2.92279005e-01f },
      { 5.03193811e-02f, 4.30391803e-02f, 6.39934987e-02f, 7.16716424e-02f, -5.61759695e-02f },
      { -1.93243790e-02f, -1.96870521e-01f, -4.37180661e-02f, 7.30865523e-02f, -2.99803019e-02f },
      { 4.30659018e-02f, -6.14490546e-03f, -1.71160787e-01f, -1.02500632e-01f, 3.54029350e-02f },
    },
    {
      { 1.66275933e-01f, 3.76534127e-02f, -1.15734376e-01f, -2.96153892e-02f, -5.43752983e-02f },
      { 7.30785653e-02f, 1.14361487e-01f, 7.89650306e-02f, 9.71119180e-02f, 5.68050481e-02f },
      { 2.79437732e-02f, 7.66623989e-02f, 5.79026602e-02f, 2.92191785e-02f, -5.92201427e-02f },
      { 3.87373520e-03f, 8.59091505e-02f, 1.93020981e-02f, 3.64715955e-03f, -7.39008114e-02f },
      { 4.48577963e-02f, -6.27367850e-03f, -3.69664580e-02f, 3.13423425e-02f, 1.03535568e-02f },
    },
    {
      { -8.23434722e-03f, -8.31210986e-03f, -3.32370959e-02f, -9.43040699e-02f, -5.26409298e-02f },
      { -2.88458671e-02f, -3.00365556e-02f, 1.04359865e-01f, 9.34828222e-02f, 1.79274175e-02f },
      { -8.36236030e-02f, -2.46478878e-02f, 1.18193030e-01f, 1.25199214e-01f, -2.87663229e-02f },
      { 5.96008152e-02f, -6.27006292e-02f, -9.38722864e-02f, -1.57538548e-01f, -1.19229652e-01f },
      { 1.46375537e-01f, 1.30409658e-01f, 1.41662201e-02f, -7.18321502e-02f, -2.70656664e-02f },
    },
    {
      { 1.38460428e-01f, -6.28453791e-02f, 3.98628414e-02f, -2.93298699e-02f, -2.06779987e-01f },
      { -9.32859108e-02f, -2.88694978e-01f, -1.81216240e-01f, -2.87526876e-01f, -2.83414155e-01f },
      { -4.12014574e-01f, -2.93429077e-01f, -1.41658440e-01f, -1.93457618e-01f, 2.95372792e-02f },
      { -1.37006789e-01f, -2.26863205e-01f, -2.63599336e-01f, -1.22990333e-01f, 1.11864842e-01f },
      { 8.30447301e-02f, -2.87743695e-02f, -7.69566223e-02f, -2.61204839e-01f, 9.85461520e-04f },
    },
    {
      { -9.86183714e-03f, 6.32406399e-02f, 5.43958787e-03f, 1.24451090e-02f, 5.97779639e-02f },
      { -4.22883928e-02f, -5.40253669e-02f, 3.63503471e-02f, 4.46101688e-02f, 3.29278335e-02f },
      { -6.85011521e-02f, -4.48136181e-02f, 4.45229858e-02f, 3.73451225e-02f, -2.03994829e-02f },
      { -2.37321220e-02f, 2.96635721e-02f, 1.16678745e-01f, 6.82700202e-02f, 9.05781016e-02f },
      { 3.41505297e-02f, 9.47173871e-03f, 7.15823397e-02f, 1.45149678e-01f, 5.90280555e-02f },
    },
    {
      { -6.38811514e-02f, 5.33708222e-02f, -4.50173218e-04f, 1.81294826e-03f, 5.76337241e-02f },
      { 6.04286529e-02f, 1.61814671e-02f, 1.26537438e-02f, -7.43351281e-02f, 6.66133091e-02f },
      { 1.43097248e-02f, -1.35847449e-01f, -3.52108292e-02f, -5.04250303e-02f, 3.11201960e-02f },
      { -2.72038598e-02f, -3.81569453e-02f, 2.22830311e-03f, -1.43194497e-02f, -4.96776551e-02f },
      { -1.74957886e-03f, 5.28283864e-02f, 6.90739751e-02f, -4.57705520e-02f, 2.15823054e-02f },
    },
    {
      { -2.55720504e-02f, -4.99521829e-02f, 6.09155744e-02f, 1.68669760e-01f, 1.60496637e-01f },
      { -6.47138581e-02f, -8.59361365e-02f, -8.05397928e-02f, -1.56134546e-01f, -1.45944685e-01f },
      { -2.68301629e-02f, -2.68378537e-02f, 9.85382963e-03f, 2.42315643e-02f, 6.68993816e-02f },
      { -8.09707940e-02f, -2.34135062e-01f, -1.23113714e-01f, 3.50363902e-04f, -5.01706377e-02f },
      { 3.02984770e-02f, 9.34219509e-02f, -7.26499408e-02f, -2.74269395e-02f, 2.03154627e-02f },
    },
    {
      { 2.68628467e-02f, 2.41191871e-02f, 2.05306008e-01f, 2.06120566e-01f, 2.45708480e-01f },
      { 2.72251777e-02f, -1.36789605e-02f, -4.72071432e-02f, -9.48811769e-02f, 7.78131112e-02f },
      { 1.10789515e-01f, 5.70136048e-02f, 2.20127422e-02f, 1.27682358e-01f, 2.29145393e-01f },
      { -4.85113114e-02f, -2.26606369e-01f, -1.24842830e-01f, 6.73659965e-02f, -3.96962464e-03f },
      { 2.21740399e-02f, 1.67138115e-01f, 5.29868267e-02f, -2.98377406e-02f, 1.31249493e-02f },
    },
    {
      { 6.70522749e-02f, 1.45675689e-01f, 8.63724574e-02f, 1.47881091e-01f, 7.50856474e-02f },
      { 4.77111079e-02f, 1.17991768e-01f, 1.19687326e-01f, 2.64825318e-02f, -9.23525393e-02f },
      { 5.54197244e-02f, 1.03623241e-01f, 1.84611194e-02f, 3.72809172e-02f, 2.92781834e-02f },
      { 2.52607130e-02f, -2.68155951e-02f, 1.66215803e-02f, -2.40055867e-03f, 1.83932688e-02f },
      { 1.02567501e-01f, 1.57606080e-02f, 1.38029782e-02f, 2.91900802e-02f, 3.00806165e-02f },
    },
    {
      { 5.17190136e-02f, -4.14935239e-02f, -2.33361199e-02f, -1.36421239e-02f, -3.28280404e-02f },
      { 2.79877707e-03f, -6.06110729e-02f, -8.17729160e-02f, -6.18234202e-02f, 2.34932750e-02f },
      { -6.75770938e-02f, -3.94751839e-02f, 4.30871360e-02f, -8.31999555e-02f, -8.77479240e-02f },
      { -1.42612979e-02f, 8.71675983e-02f, 2.97271907e-02f, -3.47498506e-02f, 7.42646530e-02f },
      { -3.56988870e-02f, 4.97194827e-02f, 2.82704663e-02f, -8.50411598e-03f, -4.33445908e-02f },
    },
    {
      { -1.12774834e-01f, -1.16838172e-01f, -1.16884746e-01f, -1.78632453e-01f, -2.14482173e-01f },
      { -1.07468357e-02f, -5.71982190e-02f, 2.10994780e-01f, 3.42449248e-01f, 1.74262762e-01f },
      { 6.32019415e-02f, -8.97723660e-02f, -3.70334946e-02f, 1.28619075e-01f, -8.28853250e-02f },
      { 6.19623028e-02f, -1.86414216e-02f, -1.78189829e-01f, -2.32203320e-01f, -1.84370041e-01f },
      { -3.92985443e-04f, 2.39291345e-03f, 1.35263102e-02f, -1.02472790e-01f, -1.19329385e-01f },
    },
    {
      { 1.12816067e-02f, 6.31552236e-03f, 3.91038768e-02f, -4.57140096e-02f, 4.56173196e-02f },
      { -9.54949763e-03f, 6.27774969e-02f, 2.53106728e-02f, -4.57056686e-02f, 5.55396974e-02f },
      { -9.48964525e-03f, 2.63242424e-02f, 5.59540950e-02f, -6.07640259e-02f, -1.61405969e-02f },
      { 4.95486036e-02f, 3.57666612e-02f, 4.48751748e-02f, 2.57740095e-02f, -2.42320355e-02f },
      { -3.37571800e-02f, -2.26593707e-02f, 1.52087035e-02f, -3.45691544e-04f, -4.52257227e-03f },
    },
    {
      { 3.17586847e-02f, -7.45044649e-02f, -2.46339962e-02f, -1.53028756e-01f, -1.18403278e-01f },
      { 1.08907856e-01f, 1.63007513e-01f, 4.00081694e-01f, 3.18844199e-01f, 1.15203902e-01f },
      { 1.02603160e-01f, -3.35643031e-02f, -1.78869694e-01f, -1.00581124e-01f, -1.75681725e-01f },
      { 9.45091993e-02f, 1.61296129e-01f, -8.20534155e-02f, -7.94549882e-02f, -5.66224903e-02f },
      { -1.77016288e-01f, -5.73901040e-03f, -5.91653362e-02f, 2.31656991e-02f, -1.78559378e-01f },
    },
    {
      { 3.13313156e-02f, -1.33268729e-01f, 5.58379591e-02f, -1.39734745e-01f, -9.25720036e-02f },
      { 1.51959985e-01f, 1.05047775e-02f, 8.10025111e-02f, -2.15644658e-01f, -2.65686542e-01f },
      { 1.22829460e-01f, 8.79448280e-02f, 5.40772732e-03f, -2.60526817e-02f, -1.51621029e-02f },
      { 9.72594470e-02f, 2.56760214e-02f, -5.92086315e-02f, -6.92084208e-02f, -1.10473379e-01f },
      { -7.69903362e-02f, 6.90883100e-02f, -1.54441092e-02f, -3.78201641e-02f, -1.44684881e-01f },
    },
  },
  {
    {
      { 6.75798146e-05f, 3.62867825e-02f, 5.67665882e-02f, 6.16645962e-02f, 3.55956964e-02f },
      { 2.14776699e-03f, 3.55355418e-03f, -7.58819608e-03f, 6.20607398e-02f, 5.33121405e-03f },
      { 8.62557441e-03f, -4.14660498e-02f, 3.36142071e-02f, 6.07796386e-02f, 2.08241772e-02f },
      { 2.53899824e-02f, -5.92236221e-02f, -5.77525571e-02f, 7.70835802e-02f, 7.10483780e-03f },
      { 5.27252480e-02f, 2.87899431e-02f, 8.73891730e-03f, -3.93491238e-02f, -3.60118151e-02f },
    },
    {
      { 2.50229482e-02f, -1.36491628e-02f, -7.09248800e-03f, -7.72500411e-02f, -5.93514517e-02f },
      { -6.48996234e-02f, -2.22162027e-02f, -5.16276211e-02f, 4.01074253e-02f, 1.40064834e-02f },
      { -2.13646647e-02f, -4.34596986e-02f, -7.05755576e-02f, 8.43367260e-03f, -5.82672879e-02f },
      { -6.30240440e-02f, 1.33149931e-02f, -7.81398118e-02f, -3.84708196e-02f, 2.30478775e-02f },
      { 2.16224082e-02f, -7.10589513e-02f, -1.54333487e-02f, 3.57287824e-02f, -3.67230922e-02f },
    },
    {
      { -4.64450009e-02f, 3.89474519e-02f, -1.71804591e-03f, -2.67464351e-02f, 1.79959945e-02f },
      { -4.98887561e-02f, -4.77780774e-02f, -4.31560166e-02f, -1.67515744e-02f, 5.60242683e-03f },
      { -7.82093555e-02f, 4.89437440e-03f, -7.06131384e-02f, 3.65501046e-02f, -2.33675949e-02f },
      { -1.60501450e-02f, -5.21475673e-02f, -6.48019090e-02f, -3.81583832e-02f, -1.65925007e-02f },
      { 3.51698697e-02f, -6.20227233e-02f, -6.67227209e-02f, -1.19225811e-02f, -8.53195339e-02f },
    },
    {
      { 3.77500169e-02f, 2.33188905e-02f, -3.13214287e-02f, -4.29789200e-02f, -7.42196515e-02f },
      { 2.25884877e-02f, 1.59855490e-03f, 3.31429802e-02f, -5.43960184e-02f, -7.37474263e-02f },
      { 5.93224764e-02f, 3.35248001e-02f, 3.24042886e-02f, -7.42415264e-02f, -4.25018072e-02f },
      { -9.84389149e-03f, -2.86399405e-02f, 4.44616340e-02f, -1.27015053e-03f, -6.99693784e-02f },
      { -1.79959834e-02f, 1.49853928e-02f, 1.10744489e-02f, -4.10980321e-02f, 8.51660222e-03f },
    },
    {
      { 5.39546870e-02f, -4.20194305e-02f, 1.75742507e-02f, -1.30524505e-02f, 4.23064940e-02f },
      { 4.31342982e-02f, -2.71232482e-02f, -2.66417470e-02f, -2.11459007e-02f, 2.90130954e-02f },
      { 3.23287360e-02f, 6.00335468e-03f, 8.88644438e-03f, -4.11706381e-02f, -2.75845844e-02f },
      { 1.64965149e-02f, 3.14394496e-02f, -1.39317885e-02f, -7.21473545e-02f, 3.42428684e-02f },
      { 4.55715209e-02f, 4.49874997e-02f, -5.26209660e-02f, -2.58433744e-02f, 2.26429738e-02f },
    },
    {
      { -4.25943919e-02f, 2.27110507e-03f, -7.27987587e-02f, -6.22700639e-02f, 2.20255982e-02f },
      { 1.65188480e-02f, -9.37288348e-03f, -6.80364843e-04f, 4.09118179e-03f, -7.23097473e-03f },
      { 4.75705862e-02f, -2.05457713e-02f, -9.57782753e-03f, -6.57410845e-02f, 4.12237085e-02f },
      { 7.56429881e-03f, 4.70082611e-02f, -3.56416851e-02f, 6.23978814e-03f, 3.79942060e-02f },
      { 3.42826475e-03f, -2.44516617e-04f, -6.82118759e-02f, -7.24898726e-02f, -1.54405599e-02f },
    },
    {
      { 1.07419053e-02f, -5.74843325e-02f, -2.27162801e-02f, -5.52797019e-02f, -2.00663526e-02f },
      { 2.14571152e-02f, -3.95799018e-02f, 5.11878543e-02f, 3.34835686e-02f, 4.56741080e-02f },
      { 1.49027482e-02f, 4.93091829e-02f, -5.13329320e-02f, 3.77837010e-02f, 3.83907929e-02f },
      { -4.36748471e-03f, 3.64880711e-02f, -9.58245620e-03f, 5.29914834e-02f, -3.07910386e-02f },
      { 2.92907842e-02f, 1.17762275e-02f, -8.45132768e-03f, 3.70689039e-03f, 1.19759301e-02f },
    },
    {
      { -4.88391295e-02f, -4.92959470e-02f, -4.65571210e-02f, -5.30080944e-02f, 2.23320089e-02f },
      { 2.27053054e-02f, -2.59048045e-02f, -1.00370543e-02f, -1.69540793e-02f, -2.40649097e-02f },
      { 4.83844131e-02f, -2.05248944e-03f, 6.70270696e-02f, 2.62987223e-02f, 3.25103775e-02f },
      { -2.06330586e-02f, -2.32727583e-02f, -6.91376207e-03f, -7.01250285e-02f, -7.65048712e-02f },
      { 5.09484345e-03f, -1.89032964e-02f, 3.78230698e-02f, -6.75410852e-02f, -7.78638124e-02f },
    },
    {
      { 6.04385361e-02f, -4.66312170e-02f, -5.23811728e-02f, 5.34307808e-02f, 6.84476048e-02f },
      { -3.57022770e-02f, 5.97031275e-03f, 6.09262288e-03f, 1.94407057e-03f, 3.06287408e-02f },
      { -2.86122989e-02f, 1.55319460e-02f, 6.78180084e-02f, 8.41889977e-02f, 6.04424030e-02f },
      { 1.68563481e-02f, -1.21207116e-02f, 3.07226069e-02f, -3.25223021e-02f, 6.37197867e-02f },
      { 2.70485394e-02f, -4.65156026e-02f, 7.05355126e-03f, -4.29162011e-02f, 3.16027589e-02f },
    },
    {
      { -2.96254568e-02f, -9.43038762e-02f, -2.53168549e-02f, 5.48763247e-03f, -6.51967153e-02f },
      { -5.59730120e-02f, -1.86124817e-02f, -2.71985400e-02f, 2.45038327e-02f, -7.22772703e-02f },
      { -2.08206335e-03f, -1.69305969e-02f, -2.41088253e-02f, -6.62153736e-02f, -9.02830288e-02f },
      { -3.97519767e-02f, 5.16880564e-02f, -4.96783070e-02f, 8.27394018e-04f, -6.24700934e-02f },
      { -3.47491615e-02f, -1.50870699e-02f, -2.29792073e-02f, -6.64816946e-02f, -5.14002442e-02f },
    },
    {
      { 3.47311748e-03f, 3.56020853e-02f, 4.22616638e-02f, -1.31326467e-02f, -7.26846233e-02f },
      { 3.00379265e-02f, 5.10782516e-03f, -6.83903992e-02f, -2.24916730e-02f, -5.39591117e-03f },
      { -1.82790437e-03f, -8.25424585e-03f, 1.85732525e-02f, -3.20348144e-02f, 9.88296792e-03f },
      { -1.79923866e-02f, 1.36367287e-02f, 2.41933782e-02f, -3.26361433e-02f, -6.56702071e-02f },
      { -2.88503338e-02f, -7.05687702e-02f, -6.42556325e-03f, 2.48383991e-02f, -5.86928129e-02f },
    },
    {
      { 3.05016823e-02f, -6.25861138e-02f, -2.84780227e-02f, -3.28883678e-02f, -7.80071914e-02f },
      { -3.39899957e-02f, -9.25811101e-03f, -5.27161621e-02f, -4.73222248e-02f, 2.67304722e-02f },
      { 1.36392135e-02f, 7.99799804e-03f, 1.85288079e-02f, 3.72352935e-02f, -4.92597446e-02f },
      { -3.66768092e-02f, -7.88732320e-02f, -6.04240373e-02f, -1.36480741e-02f, 5.24088787e-03f },
      { -4.52978909e-03f, -6.51608855e-02f, -3.34135816e-02f, -5.65172844e-02f, -8.68173130e-03f },
    },
    {
      { -5.51252812e-02f, -7.19346330e-02f, -3.25406604e-02f, -6.09489530e-02f, -1.02214152e-02f },
      { -4.23236890e-03f, -3.01134549e-02f, 1.29436180e-02f, 1.57274562e-03f, -3.71739082e-02f },
      { -7.93416705e-03f, -5.70720732e-02f, -2.28986330e-02f, -5.07671759e-02f, -6.36969134e-02f },
      { -1.65568467e-03f, 1.41832512e-02f, 1.20041911e-02f, -4.13580239e-02f, 7.16997264e-03f },
      { -2.19732728e-02f, -7.01087434e-03f, -6.67368025e-02f, -5.56410179e-02f, -1.33047542e-02f },
    },
    {
      { -1.67810824e-02f, -4.22057658e-02f, 1.90283358e-02f, -3.83951142e-02f, -2.36630682e-02f },
      { 1.53128356e-02f, 4.92899455e-02f, -1.28906146e-02f, 4.92264666e-02f, -2.35297978e-02f },
      { -8.10843632e-02f, 5.16371056e-03f, -4.00026627e-02f, -6.05542697e-02f, -1.50170708e-02f },
      { -4.99981381e-02f, -2.08186805e-02f, -4.33336347e-02f, 2.76748296e-02f, -5.90543896e-02f },
      { -1.87859908e-02f, -2.23343279e-02f, -5.61439544e-02f, -2.41853949e-02f, -5.08614741e-02f },
    },
    {
      { -1.40807098e-02f, -2.87585519e-02f, -2.90197041e-02f, 5.12524955e-02f, -2.70504002e-02f },
      { -4.59152833e-02f, -2.34535504e-02f, -1.64326970e-02f, 4.39709350e-02f, 4.79775853e-02f },
      { -3.55978794e-02f, 4.50300723e-02f, -9.19017103e-03f, -1.16627594e-03f, 5.31552844e-02f },
      { 1.83630420e-03f, -3.00271381e-02f, 3.69720124e-02f, 3.96641158e-02f, 2.70795580e-02f },
      { -5.33788390e-02f, 3.22781578e-02f, 2.63418444e-02f, -5.41857779e-02f, 3.64117064e-02f },
    },
    {
      { 2.25769877e-02f, 3.21198702e-02f, -2.36632163e-03f, -5.32879867e-02f, -5.67621849e-02f },
      { 4.44314331e-02f, -5.12396172e-02f, -3.86933945e-02f, -4.32896130e-02f, -4.61845472e-02f },
      { 2.33631078e-02f, 4.56645936e-02f, 4.55716178e-02f, -5.02322912e-02f, -7.89597481e-02f },
      { 1.49087571e-02f, -8.04911032e-02f, -1.90100670e-02f, 6.89737732e-03f, -4.41094954e-03f },
      { -6.23158086e-03f, -4.13336642e-02f, 3.54021378e-02f, -4.94263992e-02f, -4.38542068e-02f },
    },
    {
      { 2.09699459e-02f, -2.02259552e-02f, 1.57528073e-02f, -4.08246629e-02f, 1.36475414e-02f },
      { 5.19463383e-02f, -5.41503131e-02f, -6.89802170e-02f, -1.02984775e-02f, 9.59866494e-03f },
      { 2.98473332e-02f, -1.68939084e-02f, -5.24952002e-02f, -6.75537661e-02f, 2.09828746e-02f },
      { -3.29200514e-02f, 1.33146839e-02f, 1.77104864e-02f, -1.89311095e-02f, 2.67517902e-02f },
      { -2.76368652e-02f, 4.10045981e-02f, -6.41463846e-02f, -5.07393898e-03f, -1.71638876e-02f },
    },
    {
      { -5.62998168e-02f, 2.57451143e-02f, -2.18578149e-02f, 1.90503467e-02f, -2.95522027e-02f },
      { -4.50080857e-02f, 4.41653887e-03f, -3.86000313e-02f, 3.34273092e-02f, 1.89683884e-02f },
      { 5.09409681e-02f, 1.98120549e-02f, 5.55971079e-03f, 2.74633095e-02f, 1.20964190e-02f },
      { -1.14891259e-02f, 3.01223863e-02f, -3.56818326e-02f, -5.75427972e-02f, -5.56316562e-02f },
      { -5.47680221e-02f, -6.08259700e-02f, -6.66057616e-02f, 3.18500325e-02f, -6.07852973e-02f },
    },
    {
      { -6.20871447e-02f, -8.38370528e-03f, -2.46934290e-03f, -4.27986197e-02f, 4.12973762e-02f },
      { 2.77859289e-02f, 7.21298996e-03f, 2.50832848e-02f, -2.48030219e-02f, -6.74561560e-02f },
      { 2.92587858e-02f, 5.79811214e-03f, 3.28068957e-02f, -3.84714939e-02f, -7.37450197e-02f },
      { 1.53520713e-02f, -4.40906323e-02f, -5.51909134e-02f, -3.58784012e-02f, -7.22783208e-02f },
      { -3.20164301e-02f, -2.82859411e-02f, -7.19979256e-02f, -3.02503426e-02f, 3.71415764e-02f },
    },
    {
      { -4.57628742e-02f, -4.73001823e-02f, 1.62585843e-02f, 2.23403033e-02f, -7.41101569e-04f },
      { 6.37285970e-03f, -2.30612103e-02f, -3.65749449e-02f, 3.25346291e-02f, -1.12661417e-03f },
      { 1.50750307e-02f, -2.59067472e-02f, -6.84366152e-02f, -6.51033372e-02f, -2.01929789e-02f },
      { -3.68151702e-02f, -6.88848272e-02f, -6.47328645e-02f, -1.45187257e-02f, 2.99375672e-02f },
      { -4.24813554e-02f, 2.11218884e-03f, 3.13921861e-04f, -2.66534672e-03f, -3.78354900e-02f },
    },
    {
      { -5.30976243e-02f, -4.83562984e-02f, -7.96832982e-03f, -7.62464181e-02f, -3.24984081e-02f },
      { -5.82940169e-02f, -2.30448861e-02f, -5.27730733e-02f, -1.04525076e-04f, 6.21544709e-03f },
      { -4.34036888e-02f, 2.59979498e-02f, 1.51027518e-03f, -6.45639598e-02f, 1.24338567e-02f },
      { 4.08084691e-03f, -6.82113692e-02f, 1.28668146e-02f, 2.28500832e-02f, 3.17668617e-02f },
      { -1.82283223e-02f, -9.22385696e-03f, -1.04699032e-02f, 3.58142667e-02f, -1.06402440e-02f },
    },
    {
      { 3.77756823e-03f, -4.38913815e-02f, 1.63100008e-02f, -1.31710712e-02f, -7.22034601e-03f },
      { 3.70784849e-02f, 3.79123092e-02f, 1.87863689e-02f, -2.79703410e-04f, 5.34018129e-02f },
      { -1.36682997e-02f, -4.76543792e-02f, -3.22048329e-02f, 4.38226946e-03f, 2.45255753e-02f },
      { 3.59287076e-02f, -5.17113395e-02f, 4.96043563e-02f, -4.71674502e-02f, -5.83856106e-02f },
      { 1.39573205e-03f, -2.92134248e-02f, -6.74726367e-02f, -5.37645556e-02f, 5.69356186e-03f },
    },
    {
      { -3.43997292e-02f, -3.68487835e-02f, -3.98618728e-02f, 8.37265747e-04f, -4.32580225e-02f },
      { 1.67402513e-02f, -1.50659662e-02f, -8.75819623e-02f, -4.16118157e-04f, -4.61132005e-02f },
      { -3.40684950e-02f, -5.61321452e-02f, -9.27739516e-02f, 3.47857922e-02f, 3.36605087e-02f },
      { -1.60886273e-02f, -2.51757596e-02f, -1.49053591e-03f, -2.83914581e-02f, 4.83265799e-03f },
      { -6.54650405e-02f, -2.11194456e-02f, -1.55665772e-03f, -1.87532604e-02f, -1.32996670e-03f },
    },
    {
      { -5.11363987e-03f, 2.30866540e-02f, -2.48460118e-02f, -3.09895948e-02f, 3.31396945e-02f },
      { -4.94729914e-02f, 1.53586473e-02f, -2.20603459e-02f, -9.97482706e-03f, 4.31893654e-02f },
      { -5.94208064e-03f, -3.98022160e-02f, -6.25916123e-02f, 4.42156233e-02f, -3.80741246e-02f },
      { -2.50340123e-02f, 8.40605050e-03f, -1.98765453e-02f, -4.01047803e-02f, 4.77816537e-03f },
      { -2.57376172e-02f, -5.09368954e-03f, -5.71102053e-02f, -5.58345690e-02f, -8.60549882e-03f },
    },
    {
      { -1.49412835e-02f, -2.12025438e-02f, -3.44801880e-02f, -6.03322834e-02f, -1.04454318e-02f },
      { 2.80567687e-02f, -3.07214409e-02f, -3.59703377e-02f, -5.27122840e-02f, -6.85618818e-02f },
      { -4.21882421e-02f, -3.65710668e-02f, 3.57074253e-02f, 4.08076718e-02f, -2.69396212e-02f },
      { -1.91947743e-02f, 1.27286115e-03f, 1.13472873e-02f, 2.97520286e-03f, 3.98816280e-02f },
      { -5.04758433e-02f, 6.44375617e-03f, -2.74459217e-02f, 2.88043395e-02f, -6.24046884e-02f },
    },
    {
      { 3.84183489e-02f, 3.50487679e-02f, 7.36366725e-03f, 1.53146004e-02f, -4.40471619e-02f },
      { -8.66511546e-04f, 2.35586315e-02f, 6.48712069e-02f, 2.94484440e-02f, -4.76141423e-02f },
      { 6.12448417e-02f, 6.07720390e-02f, 8.34709127e-03f, 1.44642014e-02f, 1.10962968e-02f },
      { -4.81639355e-02f, -5.74865844e-03f, -3.58086228e-02f, -5.68173006e-02f, 5.91980964e-02f },
      { -3.86416763e-02f, -4.26737498e-03f, -4.91969660e-02f, 2.50911061e-02f, -3.35152410e-02f },
    },
    {
      { 2.93836873e-02f, -1.45210074e-02f, -2.27265898e-02f, -5.04612848e-02f, -7.19700307e-02f },
      { -5.34531251e-02f, 4.08631973e-02f, -5.69914766e-02f, -2.26992797e-02f, -1.71540130e-03f },
      { -4.04021181e-02f, -3.49645354e-02f, 3.93875269e-03f, 7.58698676e-03f, -1.88075134e-03f },
      { 8.36154539e-03f, -5.89884492e-03f, 1.28849428e-02f, -6.53209537e-02f, -1.99015047e-02f },
      { -6.97478801e-02f, 3.75163229e-03f, 4.40143086e-02f, -3.92544195e-02f, -2.79269796e-02f },
    },
    {
      { -8.68269056e-02f, -5.47394417e-02f, -8.70722979e-02f, -3.18088271e-02f, -7.61022791e-02f },
      { -6.20337240e-02f, -2.24766992e-02f, -7.71202520e-02f, -6.21661879e-02f, 9.50394943e-03f },
      { -8.89145285e-02f, -9.23631787e-02f, 1.44238202e-02f, 9.66132525e-03f, -4.99084890e-02f },
      { -8.03010464e-02f, 1.50263421e-02f, 6.07254216e-04f, -6.34862781e-02f, -1.59098897e-02f },
      { -9.86705646e-02f, -1.00343242e-01f, -2.25252304e-02f, 3.71500179e-02f, 2.70214621e-02f },
    },
    {
      { -6.41355198e-03f, 6.53629005e-02f, 4.98429015e-02f, -2.17778347e-02f, -2.53621768e-02f },
      { 6.55863108e-03f, 3.74078713e-02f, 1.31294439e-02f, -5.11605367e-02f, 2.46881302e-02f },
      { 2.24887747e-02f, 1.66199207e-02f, 1.83220804e-02f, -4.82851975e-02f, 9.92360245e-03f },
      { -1.15283420e-02f, -8.13286472e-03f, -6.01100177e-02f, 1.37883695e-02f, 3.83666977e-02f },
      { 2.66173612e-02f, -5.59755452e-02f, -7.06952736e-02f, -3.57023999e-02f, -4.17247191e-02f },
    },
    {
      { -3.77374254e-02f, -2.43391506e-02f, 2.94158980e-02f, -4.65339758e-02f, -1.40469559e-02f },
      { -3.69962975e-02f, 1.44038359e-02f, -5.07491343e-02f, -3.23957466e-02f, 6.86500408e-03f },
      { 4.86056171e-02f, -2.83564702e-02f, -1.74466372e-02f, 1.35244643e-02f, -4.96340580e-02f },
      { -3.74014340e-02f, 4.02055867e-02f, 2.21004840e-02f, -4.08853106e-02f, 7.28423984e-05f },
      { 4.63579930e-02f, -4.78714630e-02f, -7.07474817e-03f, 2.41252948e-02f, -1.25495216e-03f },
    },
    {
      { -5.89856692e-03f, 1.45986816e-02f, -3.51766199e-02f, -5.71928211e-02f, 1.11476695e-02f },
      { 5.89985065e-02f, 1.30660152e-02f, -3.32378559e-02f, -1.71957780e-02f, -5.50220460e-02f },
      { 3.67022902e-02f, -4.30726036e-02f, 5.73492795e-02f, 9.18580592e-03f, 4.00746167e-02f },
      { -3.61145064e-02f, -5.95046245e-02f, -2.08501071e-02f, -2.18897257e-02f, -3.33083607e-02f },
      { 4.75168042e-03f, -3.30336876e-02f, 4.72824015e-02f, 4.22889329e-02f, 4.09663245e-02f },
    },
    {
      { -4.36367802e-02f, 7.72334635e-02f, 2.40622293e-02f, 5.07206395e-02f, -3.29322442e-02f },
      { 2.45344564e-02f, -2.25239526e-02f, -1.85050294e-02f, -3.04070339e-02f, -7.77853793e-03f },
      { -1.29461968e-02f, -2.66095605e-02f, -2.04094336e-03f, -1.30733699e-02f, 1.58102587e-02f },
      { -4.13293093e-02f, 2.88039800e-02f, -8.75012483e-03f, -3.89835760e-02f, 8.19303170e-02f },
      { -7.01540709e-02f, 1.10542988e-02f, -5.95071912e-02f, -3.27090919e-02f, -3.34099308e-02f },
    },
  },
  {
    {
      { 1.55814350e-01f, -2.24310741e-01f, -9.62645635e-02f, 1.60606764e-02f, 1.29188329e-01f },
      { 3.81625503e-01f, 2.63812929e-01f, -4.49538603e-03f, 5.84497452e-02f, 1.62766397e-01f },
      { 9.06752422e-02f, 2.43437544e-01f, 2.46093169e-01f, 2.46122014e-02f, 2.39979193e-01f },
      { -1.75945256e-02f, -7.37308189e-02f, -1.43380076e-01f, -4.17772800e-01f, -2.48806894e-01f },
      { 1.23405978e-01f, 1.36580288e-01f, 6.70991689e-02f, -4.74896394e-02f, 2.63596326e-02f },
    },
    {
      { -1.18398950e-01f, -2.53021538e-01f, -1.38776004e-01f, 2.92169861e-03f, -3.51442471e-02f },
      { 1.08097814e-01f, 9.90134850e-02f, -1.79607496e-01f, -8.70478675e-02f, 2.09351704e-01f },
      { 2.45819259e-02f, 1.95833251e-01f, -6.21717758e-02f, -1.06457151e-01f, 1.56814829e-01f },
      { 5.58228791e-02f, -5.94825037e-02f, -2.20648631e-01f, -2.64810771e-01f, 1.00721508e-01f },
      { -1.50295319e-02f, -3.75349857e-02f, -9.20237452e-02f, -1.97326958e-01f, -9.88146141e-02f },
    },
    {
      { -9.24705938e-02f, -7.23037273e-02f, -1.82916507e-01f, -9.13992375e-02f, -7.54824877e-02f },
      { 1.92956880e-01f, 3.96986753e-01f, 2.58208305e-01f, 1.21021211e-01f, 1.76408291e-01f },
      { -1.40599102e-01f, -1.49069920e-01f, -2.54895210e-01f, -2.07138479e-01f, -1.06179819e-01f },
      { 8.55303258e-02f, -1.44237325e-01f, -1.85476467e-01f, -9.45268571e-02f, -2.81491950e-02f },
      { -5.05553186e-02f, -2.08459124e-01f, -9.07479227e-02f, -6.54294668e-03f, -5.02056740e-02f },
    },
    {
      { 1.68624753e-03f, 2.22880960e-01f, -2.23312192e-02f, -2.83479333e-01f, -1.50111511e-01f },
      { -1.27944902e-01f, -2.54850924e-01f, -2.55966578e-02f, -1.35379300e-01f, -2.86009222e-01f },
      { -9.80128124e-02f, -1.66628912e-01f, 8.85344222e-02f, 8.13510343e-02f, -3.32222104e-01f },
      { 8.25266168e-02f, -6.51105959e-03f, 1.77567512e-01f, 6.22397363e-02f, -1.38215959e-01f },
      { 2.10107844e-02f, -8.18970054e-02f, -1.31121017e-02f, 3.98171768e-02f, -9.71801877e-02f },
    },
    {
      { -1.05598077e-01f, 9.83625650e-02f, -4.56946269e-02f, -1.69391379e-01f, -7.85516724e-02f },
      { 2.72280863e-03f, 1.83465838e-01f, 1.83779031e-01f, -1.28884807e-01f, -1.25428021e-01f },
      { -1.41695112e-01f, -2.47307926e-01f, -1.11428117e-02f, -6.66521415e-02f, -2.84621328e-01f },
      { 6.88916370e-02f, 3.40762362e-02f, 2.11624116e-01f, 1.36104748e-01f, -1.31653920e-01f },
      { -4.93618548e-02f, 1.55342917e-03f, 4.98299189e-02f, 2.15921834e-01f, -1.10984273e-01f },
    },
    {
      { 3.80306644e-03f, 1.66186765e-01f, 2.48944312e-01f, 7.01930970e-02f, 9.47190672e-02f },
      { -1.92164093e-01f, 1.70602113e-01f, 3.41425091e-01f, 7.53200948e-02f, -1.22992106e-01f },
      { -1.61066979e-01f, -3.49636376e-01f, -1.54161468e-01f, -6.14034161e-02f, -2.93279439e-01f },
      { -8.80082026e-02f, -1.39543176e-01f, 1.72402384e-03f, 4.92303111e-02f, -1.47475794e-01f },
      { 1.39758334e-01f, -4.94289584e-02f, -1.39883719e-02f, 1.02307700e-01f, -4.50633541e-02f },
    },
    {
      { 6.70958906e-02f, -8.31712857e-02f, 5.70146590e-02f, 2.15541542e-01f, -1.79823607e-01f },
      { 6.16697548e-03f, -3.51996958e-01f, -4.10553873e-01f, -1.34782732e-01f, -2.46785998e-01f },
      { 2.08327845e-01f, 1.54720411e-01f, -8.13427627e-01f, 8.83832499e-02f, 2.57910371e-01f },
      { -1.42329196e-02f, 2.49086261e-01f, -4.01677102e-01f, 2.65797108e-01f, 4.55609262e-01f },
      { -3.38822231e-02f, 1.31693762e-02f, -5.75210191e-02f, -4.35956344e-02f, 1.37113124e-01f },
    },
    {
      { 5.49500398e-02f, -6.85097044e-03f, 4.02956270e-02f, 2.65056431e-01f, 1.15574449e-02f },
      { 5.07658236e-02f, 1.52291777e-02f, -8.85322224e-03f, 1.76391192e-02f, -2.86964271e-02f },
      { 3.19705904e-02f, 5.33900224e-03f, -4.62595016e-01f, -8.51402134e-02f, -4.02274309e-03f },
      { 5.94576113e-02f, -9.90766380e-03f, -6.70391172e-02f, 1.07483298e-01f, 1.30489111e-01f },
      { -4.93572950e-02f, -8.39314684e-02f, -4.08007316e-02f, -1.10156335e-01f, -3.10953688e-02f },
    },
    {
      { 7.20341504e-02f, -1.58963740e-01f, -2.13204160e-01f, 1.58025175e-01f, 1.07598282e-01f },
      { 1.43573746e-01f, 1.29576296e-01f, -1.61380857e-01f, -2.52240688e-01f, 2.29938865e-01f },
      { -9.43016633e-03f, 1.62082896e-01f, 4.18883532e-01f, 2.39963662e-02f, 3.07227135e-01f },
      { -1.56078130e-01f, -1.06604457e-01f, 1.56839043e-01f, -1.99637368e-01f, -5.78686185e-02f },
      { -3.82807963e-02f, 8.47001448e-02f, 5.80989681e-02f, -3.22695784e-02f, -1.11517899e-01f },
    },
    {
      { -6.02053432e-03f, 8.78736824e-02f, 2.72345860e-02f, 1.78796351e-02f, -1.32596150e-01f },
      { -1.85559437e-01f, -2.33627900e-01f, 1.32908627e-01f, 1.35293856e-01f, -5.93790039e-02f },
      { -1.10530503e-01f, -1.73919827e-01f, 2.56143995e-02f, 6.94579259e-02f, -1.91520452e-01f },
      { 5.60592255e-03f, 1.03150740e-01f, -1.88529007e-02f, -8.16039667e-02f, -5.32412082e-02f },
      { 6.55029621e-03f, -2.17526667e-02f, -3.71031798e-02f, -9.83568802e-02f, 6.06052345e-04f },
    },
    {
      { -5.16193397e-02f, 2.25136392e-02f, 1.43720299e-01f, 4.04809266e-02f, -8.59931484e-02f },
      { -1.46789074e-01f, 1.23713359e-01f, 4.03803855e-01f, 1.31720930e-01f, -1.96789533e-01f },
      { -3.50001715e-02f, -2.04846770e-01f, -1.79920554e-01f, -2.35345945e-01f, -1.73341721e-01f },
      { -8.61877054e-02f, -1.44505277e-01f, -3.07555143e-02f, 9.52003673e-02f, 2.31445711e-02f },
      { -6.87828287e-02f, -9.66866016e-02f, 7.95055106e-02f, 1.49109945e-01f, 1.02519445e-01f },
    },
    {
      { 5.94481602e-02f, 3.60754430e-02f, 7.15776682e-02f, 3.76695357e-02f, -6.23017289e-02f },
      { -5.98299270e-03f, -9.27634090e-02f, -1.50989667e-01f, 3.36468816e-02f, 7.21254721e-02f },
      { -4.33428809e-02f, 1.22300856e-01f, 2.12606564e-01f, 2.78303623e-01f, 1.24074876e-01f },
      { -1.09127857e-01f, 2.23033559e-02f, 7.68573806e-02f, -5.44534959e-02f, -1.71564996e-01f },
      { 4.83470224e-02f, -2.25938465e-02f, -2.51819611e-01f, -2.47521117e-01f, -8.84814709e-02f },
    },
    {
      { -3.32623236e-02f, -7.65052363e-02f, 1.53628383e-02f, 1.47497952e-01f, -5.26946224e-02f },
      { 1.08752504e-01f, 5.43679558e-02f, -3.04300994e-01f, 1.68607244e-03f, 8.77548680e-02f },
      { 6.83666393e-02f, 9.00163897e-04f, -5.56424744e-02f, 7.50722140e-02f, 1.60709441e-01f },
      { 2.92915292e-02f, -6.12017922e-02f, -1.08128265e-02f, 4.70205443e-03f, 3.73442806e-02f },
      { 2.70347111e-03f, 1.93148982e-02f, -5.72478101e-02f, -2.46824384e-01f, -9.34000090e-02f },
    },
    {
      { -1.59563508e-03f, -1.83887705e-01f, -7.72248134e-02f, 9.79007706e-02f, 5.36866747e-02f },
      { 1.73592195e-01f, 4.56989072e-02f, -3.91294479e-01f, -3.95423472e-02f, 1.23813353e-01f },
      { 3.16144079e-02f, 1.14193328e-01f, -1.00570314e-01f, -5.35148717e-02f, 1.76676050e-01f },
      { 4.56947787e-03f, 7.48691931e-02f, -9.72227380e-02f, -1.77767143e-01f, 9.21351016e-02f },
      { 5.36505766e-02f, 2.70410907e-02f, 2.02037487e-02f, -2.40478769e-01f, -7.31280595e-02f },
    },
    {
      { 2.02488154e-02f, -1.85387619e-02f, 3.76758166e-02f, -2.20656265e-02f, 2.62125395e-02f },
      { 5.55013446e-03f, -3.41911204e-02f, 5.94459055e-03f, 4.22224998e-02f, 5.15841655e-02f },
      { 4.80948649e-02f, -4.58677076e-02f, 1.81675665e-02f, -3.13367806e-02f, 5.32267354e-02f },
      { 5.22817485e-02f, -3.85873839e-02f, -1.30874328e-02f, -4.51912694e-02f, 3.18225473e-02f },
      { -1.61974430e-02f, -1.98946204e-02f, -5.36515713e-02f, -6.72651753e-02f, 6.33889204e-03f },
    },
    {
      { -4.62028757e-02f, -1.07820004e-01f, -5.56332693e-02f, 6.15267865e-02f, -3.45239192e-02f },
      { -5.53875230e-02f, -2.95719188e-02f, -4.37793247e-02f, -1.75564233e-02f, 9.37980320e-03f },
      { 5.08317128e-02f, 4.47879992e-02f, -1.13714129e-01f, 8.66511613e-02f, 6.91217706e-02f },
      { -3.78756076e-02f, -5.57877831e-02f, -1.71400756e-02f, 1.18593022e-01f, 5.26828058e-02f },
      { 4.42385348e-03f, 2.26083081e-02f, -3.36890407e-02f, -1.87317003e-02f, -2.39467621e-02f },
    },
    {
      { -5.76275177e-02f, -9.05741230e-02f, -4.69150357e-02f, -2.53325794e-02f, -2.54952591e-02f },
      { -3.03512048e-02f, -5.60824806e-03f, -5.35754301e-02f, -8.11260417e-02f, -6.65780082e-02f },
      { -6.02628551e-02f, 7.73975765e-03f, -4.80837049e-03f, -1.25065111e-02f, -6.99035972e-02f },
      { -4.15795371e-02f, -1.78319346e-02f, 3.20529900e-02f, 9.57575887e-02f, 3.24744023e-02f },
      { -1.35283917e-01f, -1.70425475e-02f, 7.49058574e-02f, -5.73021686e-03f, 2.54870653e-02f },
    },
    {
      { -1.29722850e-02f, 4.67610061e-02f, 1.18069790e-01f, 8.30263346e-02f, -1.04984120e-01f },
      { 2.59040911e-02f, 4.82348837e-02f, 3.28860097e-02f, 7.40249231e-02f, -1.76623493e-01f },
      { -3.13235447e-02f, -1.63702622e-01f, -2.83319384e-01f, -9.33283567e-02f, -8.22355002e-02f },
      { -6.88707009e-02f, -6.16006628e-02f, 1.13661252e-02f, 1.76347010e-02f, -1.36933206e-02f },
      { -2.56913472e-02f, -4.73651178e-02f, 3.19638364e-02f, -3.31870653e-02f, -3.39734964e-02f },
    },
    {
      { -6.86195269e-02f, -4.14863182e-03f, 1.32542774e-01f, 1.05686463e-01f, 7.52059668e-02f },
      { -1.99380502e-01f, 6.55501857e-02f, 2.21685767e-01f, 1.25144184e-01f, -1.53129950e-01f },
      { -3.48997861e-02f, -9.52246413e-02f, -1.22412920e-01f, -1.37918785e-01f, -1.33537769e-01f },
      { -1.07840136e-01f, 2.66866703e-02f, 1.35287747e-01f, 1.14342220e-01f, -1.09109329e-02f },
      { -5.60570098e-02f, -1.25870109e-01f, 3.70591469e-02f, 1.70448497e-02f, 9.16701034e-02f },
    },
    {
      { 1.62383934e-04f, 2.00239550e-02f, -7.66492635e-02f, -8.77270103e-02f, -6.03545830e-03f },
      { -8.11473951e-02f, -1.08826319e-02f, -1.73384398e-01f, -1.52853802e-01f, -3.48814204e-03f },
      { -1.00969858e-01f, -7.34074116e-02f, 1.89311523e-02f, 3.07338256e-02f, -4.34475690e-02f },
      { -2.91112810e-02f, 2.61458643e-02f, 1.24012589e-01f, 1.29096890e-02f, -7.74189888e-04f },
      { 4.83715273e-02f, 7.16775358e-02f, 1.16440475e-01f, 8.70404691e-02f, -8.97233491e-04f },
    },
    {
      { -4.08195052e-03f, 7.16590881e-02f, 1.57605156e-01f, 5.76126613e-02f, -6.00539260e-02f },
      { -4.29722434e-03f, -2.49763101e-01f, -2.36226097e-01f, -1.52454644e-01f, -8.02801698e-02f },
      { 6.10180125e-02f, 3.71512435e-02f, 2.20158160e-01f, 2.81997114e-01f, 7.80668557e-02f },
      { -8.32747519e-02f, 3.85659225e-02f, 7.19204023e-02f, 6.29077628e-02f, -1.84149027e-01f },
      { 8.46764818e-03f, 1.69470743e-03f, -1.37024492e-01f, -2.17036784e-01f, -7.13332519e-02f },
    },
    {
      { 8.37968290e-03f, -8.31527784e-02f, -1.17771946e-01f, -1.91193089e-01f, -2.34361783e-01f },
      { -3.42491478e-01f, -3.69570822e-01f, -2.73503244e-01f, -1.65282175e-01f, -9.90122706e-02f },
      { -2.96668917e-01f, -8.07777494e-02f, -1.59192637e-01f, -1.89192906e-01f, -7.90350288e-02f },
      { -1.58812791e-01f, 1.00933500e-02f, 4.21716906e-02f, -1.20621398e-02f, -2.24271581e-01f },
      { -2.17280269e-01f, -1.74715891e-01f, 1.14163838e-01f, 1.12646833e-01f, 4.43873778e-02f },
    },
    {
      { 4.71692979e-02f, 3.19190286e-02f, 4.31795232e-02f, 3.88234891e-02f, 7.59280771e-02f },
      { 1.38837263e-01f, 9.79634002e-02f, 1.10857844e-01f, 7.58603960e-02f, 1.58460245e-01f },
      { 2.92040855e-02f, -4.76409793e-02f, 2.48090737e-02f, 1.10461496e-01f, 4.03739624e-02f },
      { 2.82469206e-02f, 1.02840647e-01f, 4.29711444e-03f, -1.02850348e-01f, -8.49289671e-02f },
      { 5.74816465e-02f, 2.83315387e-02f, -4.52247299e-02f, -1.61960378e-01f, -3.45445238e-02f },
    },
    {
      { -1.39024910e-02f, -7.15522692e-02f, 4.95444462e-02f, -4.41368446e-02f, -6.79779500e-02f },
      { -1.06922779e-02f, -3.30499150e-02f, -1.52041361e-01f, -4.89182770e-02f, -5.39810769e-02f },
      { 3.12081203e-02f, 1.01097226e-01f, -1.47068441e-01f, 3.94272096e-02f, 9.62130651e-02f },
      { 7.90140126e-03f, 2.44413372e-02f, -1.76204536e-02f, 1.52737647e-01f, -2.10377679e-04f },
      { 6.53746165e-03f, 2.81935111e-02f, -3.57933678e-02f, -8.95076469e-02f, 1.03361672e-02f },
    },
    {
      { -4.79052104e-02f, 2.21222341e-02f, 1.10528544e-01f, 8.78573582e-02f, -6.69355243e-02f },
      { -1.02852710e-01f, 9.36498418e-02f, 3.61581981e-01f, 1.39236465e-01f, -1.28568187e-01f },
      { -1.06122941e-01f, -1.82532355e-01f, -1.54711798e-01f, -1.43659621e-01f, -1.37439162e-01f },
      { 2.55512390e-02f, -3.05519868e-02f, 8.07141606e-03f, -1.50294714e-02f, -1.15193790e-02f },
      { -6.81105405e-02f, -2.34573577e-02f, 1.71203669e-02f, 4.69685495e-02f, 7.83672705e-02f },
    },
    {
      { 7.78061897e-02f, 1.16720706e-01f, 2.30412707e-01f, 3.62566292e-01f, 1.25965208e-01f },
      { 7.48162791e-02f, 6.99120164e-02f, 2.33390406e-01f, 5.94887398e-02f, -5.56994155e-02f },
      { 1.96798757e-01f, 1.30785406e-01f, -3.46580446e-01f, -1.28652424e-01f, 5.69379777e-02f },
      { 5.71924336e-02f, 2.12901682e-02f, -3.57385096e-03f, 2.62617350e-01f, 1.89161211e-01f },
      { -4.45879847e-02f, -1.38014808e-01f, -1.08271576e-01f, -1.61015596e-02f, -4.67645191e-02f },
    },
    {
      { -1.78860635e-01f, -8.21368769e-02f, 1.83105320e-02f, 5.08852163e-03f, -1.34498760e-01f },
      { -1.12980485e-01f, -2.69756131e-02f, 1.11502357e-01f, -3.19953100e-03f, -7.96536207e-02f },
      { 2.44751032e-02f, 4.78368776e-04f, -3.78740057e-02f, 9.28218104e-03f, -6.59885630e-02f },
      { -6.07146509e-02f, -3.75522021e-03f, 1.46190822e-01f, 1.47648513e-01f, 2.27996316e-02f },
      { -1.03885219e-01f, -5.54992235e-04f, -4.35094396e-03f, 2.24377122e-03f, -3.99192609e-02f },
    },
    {
      { -1.56523380e-02f, 1.34434586e-03f, 5.66484034e-02f, -4.81884703e-02f, -6.07937202e-02f },
      { 8.70010108e-02f, 3.16808112e-02f, 7.40846470e-02f, 4.08745594e-02f, 4.41344902e-02f },
      { -7.18992874e-02f, -1.92421198e-01f, 7.58641027e-03f, 5.80382184e-04f, -1.06156431e-01f },
      { -4.66692075e-02f, -1.69586420e-01f, -1.77931026e-01f, -9.41647068e-02f, -1.32773653e-01f },
      { 2.51264889e-02f, -6.58839801e-03f, -1.50009140e-01f, -8.88843238e-02f, -1.82278320e-01f },
    },
    {
      { 1.51122967e-02f, -2.76495726e-03f, 9.96068344e-02f, 7.81239644e-02f, 5.03089931e-03f },
      { 4.06526066e-02f, -2.58964479e-01f, -2.45078459e-01f, -7.37846494e-02f, 7.41579086e-02f },
      { 4.83238734e-02f, 2.18163073e-01f, 2.44947627e-01f, 2.58103579e-01f, 1.55078113e-01f },
      { -1.40826315e-01f, 8.67988989e-02f, 6.72349185e-02f, -3.60865407e-02f, -2.24077031e-01f },
      { 1.10050207e-02f, -1.55595848e-02f, -1.68129534e-01f, -1.65290475e-01f, -7.44298548e-02f },
    },
    {
      { -9.70012625e-04f, -1.88173726e-02f, -4.11042608e-02f, 2.54898760e-02f, -1.72365475e-02f },
      { 1.64130852e-02f, 4.19847742e-02f, -6.50651455e-02f, 2.70976499e-02f, -4.49691042e-02f },
      { 1.75532978e-03f, -5.28694876e-02f, 4.77258563e-02f, -5.46729285e-03f, -5.46798185e-02f },
      { 4.72120345e-02f, -4.28843275e-02f, 1.10257883e-02f, -4.48535569e-02f, 2.56026555e-02f },
      { -2.67414600e-02f, 5.51196523e-02f, 2.19090769e-04f, -4.07671109e-02f, -1.68510750e-02f },
    },
    {
      { -1.14787752e-02f, -2.00933456e-01f, -2.29255874e-02f, 9.70596895e-02f, 5.99567145e-02f },
      { 1.99546203e-01f, 5.29437605e-03f, -2.13127553e-01f, 5.40312827e-02f, 1.99296281e-01f },
      { -2.55827159e-02f, 2.08543912e-01f, 2.41182715e-01f, -3.84437554e-02f, 2.41274126e-02f },
      { -1.52364448e-01f, -8.01010989e-03f, -2.04105545e-02f, -4.25008625e-01f, -2.02513114e-01f },
      { -6.13393597e-02f, -1.61837798e-03f, 1.05057349e-02f, -1.61086679e-01f, 7.93107003e-02f },
    },
    {
      { 4.57155108e-02f, 3.99554409e-02f, -1.04937933e-01f, 1.77630693e-01f, -4.61311452e-02f },
      { 5.17819487e-02f, -2.25501023e-02f, -2.16368064e-01f, -2.01974973e-01f, -4.07652780e-02f },
      { 1.83146745e-01f, 1.41478539e-01f, -2.32830569e-01f, -3.11353207e-01f, 1.33704454e-01f },
      { 1.84889243e-04f, 7.77570978e-02f, -1.42444670e-02f, -1.90966636e-01f, 2.65280604e-01f },
      { 2.69756410e-02f, -4.35328484e-02f, 1.13720633e-02f, -1.14112966e-01f, 4.76630740e-02f },
    },
  },
  {
    {
      { 2.89143361e-02f, 5.35674579e-02f, -2.86377966e-03f, -3.04049198e-02f, -4.69082110e-02f },
      { 1.81039907e-02f, -5.94880432e-04f, -4.63187322e-02f, -2.42672004e-02f, -5.88539504e-02f },
      { -4.37285304e-02f, -1.26655102e-02f, -7.24582374e-03f, -1.45425424e-02f, 3.17670219e-02f },
      { -3.64112109e-02f, -1.91088095e-02f, -1.67886540e-03f, 2.06209980e-02f, -2.70646811e-02f },
      { -2.62688287e-02f, -5.47013618e-02f, -2.41971053e-02f, 7.82518461e-03f, 2.69061215e-02f },
    },
    {
      { -2.99642105e-02f, -3.83352339e-02f, 3.47532257e-02f, -3.17946374e-02f, 2.82208491e-02f },
      { -6.62618876e-02f, -3.41604277e-02f, -2.88789161e-02f, -3.60610150e-02f, -6.29936950e-03f },
      { 5.26298694e-02f, -3.58817764e-02f, -2.72598676e-03f, -2.78020632e-02f, -2.39013471e-02f },
      { -4.11512218e-02f, 1.69602409e-02f, -5.19370809e-02f, 2.28524115e-02f, 5.15030399e-02f },
      { -5.78942746e-02f, 4.39680293e-02f, 3.84064158e-03f, -6.48155957e-02f, 3.45155746e-02f },
    },
    {
      { -6.22238256e-02f, -5.13515510e-02f, -4.47938852e-02f, 3.36446014e-04f, -6.22206926e-02f },
      { -1.89504921e-02f, 1.76215842e-02f, 1.46263465e-02f, 2.70970501e-02f, 2.54840381e-03f },
      { -1.61427688e-02f, -4.82407734e-02f, -3.31168901e-03f, -1.05460761e-02f, -3.42218988e-02f },
      { -3.10295820e-02f, 1.57979317e-02f, -4.62572277e-03f, -3.22868600e-02f, 4.45789583e-02f },
      { 9.76166595e-03f, -1.21294260e-02f, -5.64271435e-02f, -6.11355789e-02f, 5.16107045e-02f },
    },
    {
      { 1.99614894e-02f, 4.56727669e-02f, 1.33582857e-03f, -5.12589924e-02f, 2.29867380e-02f },
      { -5.08778580e-02f, -2.77522504e-02f, -9.28042363e-03f, 5.53170368e-02f, -2.13947222e-02f },
      { 1.55042671e-02f, -3.65769789e-02f, 1.26178665e-02f, -4.60254699e-02f, 3.80154997e-02f },
      { 5.61130978e-02f, 5.31714596e-02f, -4.29878831e-02f, -6.17629029e-02f, -5.40916212e-02f },
      { 1.23018371e-02f, -3.38587575e-02f, 5.79270236e-02f, 4.14898060e-02f, -4.66670133e-02f },
    },
    {
      { -9.64996777e-03f, 1.85573157e-02f, -3.29630040e-02f, 6.81197178e-03f, 1.99163165e-02f },
      { -3.38525102e-02f, -1.32812355e-02f, 4.08574045e-02f, -2.29314137e-02f, -1.97258443e-02f },
      { -5.66631444e-02f, -2.16440242e-02f, 3.97279076e-02f, 2.69212853e-02f, 2.93009989e-02f },
      { 4.79041226e-02f, -2.58013662e-02f, -1.67370960e-02f, -5.15453890e-02f, -2.15452705e-02f },
      { -2.38796398e-02f, -4.53940779e-02f, -2.76478822e-03f, -4.52811718e-02f, 2.61512422e-03f },
    },
    {
      { 4.90147881e-02f, 1.30087025e-02f, -4.38239053e-02f, -5.22548221e-02f, 1.46474913e-02f },
      { -4.49090637e-02f, -4.14044298e-02f, 1.82612259e-02f, -6.76425993e-02f, 2.39572930e-03f },
      { -7.16590509e-03f, -1.80866700e-02f, 3.13085616e-02f, -2.05453951e-02f, 1.71726663e-02f },
      { 3.87377217e-02f, -3.68850268e-02f, -2.59169880e-02f, 4.66862582e-02f, -4.71539274e-02f },
      { -4.09992188e-02f, -4.78090756e-02f, -3.56400050e-02f, 2.26626862e-02f, -5.29301260e-03f },
    },
    {
      { -1.77988037e-02f, -3.08132693e-02f, 2.91716643e-02f, -2.48834267e-02f, -1.67547204e-02f },
      { 3.40162851e-02f, 3.72090563e-03f, 2.72809826e-02f, -3.27580161e-02f, 4.79006656e-02f },
      { 2.38659419e-02f, 3.89395095e-02f, -3.02009564e-02f, -3.99405807e-02f, 2.45769732e-02f },
      { -5.92396706e-02f, -1.27626285e-02f, 4.39439379e-02f, 7.64890388e-03f, -5.69163449e-02f },
      { -5.22603728e-02f, 3.92352007e-02f, 2.02122442e-02f, 1.91719122e-02f, 1.61713846e-02f },
    },
    {
      { 4.71500158e-02f, 7.54842348e-03f, 3.36599797e-02f, 2.85240100e-03f, -4.71295118e-02f },
      { -2.95560341e-02f, 4.01413850e-02f, -4.18443084e-02f, 1.26111591e-02f, 2.08299118e-03f },
      { -2.54513137e-02f, -3.90592068e-02f, -3.88587825e-02f, -5.21800853e-02f, 2.29121856e-02f },
      { 3.82525520e-03f, -5.48064038e-02f, -2.30852682e-02f, -6.24740981e-02f, -2.16542557e-02f },
      { 7.11744186e-03f, 1.98264769e-03f, -4.29339446e-02f, -3.32471989e-02f, 4.76198196e-02f },
    },
    {
      { 2.49093436e-02f, 4.92937528e-02f, -1.69592537e-02f, 2.90301479e-02f, -4.93467487e-02f },
      { 5.57193570e-02f, 2.63875686e-02f, 3.09784673e-02f, -4.47541699e-02f, 1.93787627e-02f },
      { -1.21541843e-02f, -2.50743069e-02f, 3.33054326e-02f, -3.41254473e-02f, -4.04124670e-02f },
      { -5.22968136e-02f, 3.78400944e-02f, -3.58809754e-02f, -3.38805914e-02f, 2.30915882e-02f },
      { -2.89731473e-03f, 6.79760054e-03f, -1.95413455e-03f, 1.00362673e-03f, 3.33287381e-02f },
    },
    {
      { -3.20170783e-02f, -2.95327753e-02f, -5.82990088e-02f, -1.07358070e-02f, 2.07870174e-02f },
      { 1.62256621e-02f, -1.65177304e-02f, 8.25224444e-03f, -5.69501556e-02f, 1.62850637e-02f },
      { -1.19591213e-03f, -1.06922938e-02f, 2.31871512e-02f, 1.17675159e-02f, 6.15078211e-03f },
      { 3.35416794e-02f, -5.30620217e-02f, 4.20724116e-02f, -1.46381054e-02f, -1.89954638e-02f },
      { 4.47518844e-03f, 2.36955527e-02f, -4.23161946e-02f, -5.12101389e-02f, -4.50545689e-03f },
    },
    {
      { -2.91860979e-02f, -1.73672233e-02f, -6.46582469e-02f, 4.82480228e-02f, -6.42886013e-02f },
      { 2.54070591e-02f, -5.37267029e-02f, -6.72171116e-02f, -6.49944767e-02f, 4.63174842e-02f },
      { -5.45814373e-02f, -3.12599577e-02f, 3.29412892e-02f, -4.43110950e-02f, 2.73875445e-02f },
      { -3.01925968e-02f, 1.30214375e-02f, -4.44695260e-03f, 4.40702513e-02f, -3.70615534e-02f },
      { -4.22477238e-02f, -4.85107787e-02f, 2.99642533e-02f, -1.06913988e-02f, -2.57057622e-02f },
    },
    {
      { -5.27734272e-02f, -6.18898012e-02f, -2.57258657e-02f, 1.35533409e-02f, -9.10765864e-03f },
      { 4.33887206e-02f, -4.91991118e-02f, -5.28989732e-02f, -5.85793927e-02f, 1.68497618e-02f },
      { -6.73185214e-02f, -1.69217773e-02f, -5.35085462e-02f, -3.36348861e-02f, -4.75316308e-02f },
      { -2.20812429e-02f, -4.62622382e-02f, -8.33998621e-03f, 3.44154686e-02f, 2.11507604e-02f },
      { -2.97357664e-02f, -4.26827408e-02f, 3.59804779e-02f, 2.86953431e-02f, -1.63033661e-02f },
    },
    {
      { 4.04149294e-02f, -5.53925149e-02f, -5.39283566e-02f, -2.45715305e-02f, -4.90828529e-02f },
      { -5.44628017e-02f, -4.31054644e-02f, -9.09747742e-03f, -2.53134631e-02f, -5.34102954e-02f },
      { 2.93178763e-02f, -1.12791108e-02f, -1.06541608e-02f, 5.68280136e-03f, 5.27990004e-03f },
      { -3.10560782e-02f, 4.22913842e-02f, -5.65090925e-02f, -3.06226350e-02f, 3.30459476e-02f },
      { -3.75322253e-02f, 7.31089385e-03f, -3.41939144e-02f, -2.57199351e-02f, -5.78279085e-02f },
    },
    {
      { -6.38041645e-02f, -6.14125766e-02f, -4.55705412e-02f, -6.61176518e-02f, 4.27309014e-02f },
      { 3.87360752e-02f, 1.54943969e-02f, -5.41317463e-02f, -4.93074246e-02f, 6.29925728e-02f },
      { -2.12154780e-02f, -4.32298183e-02f, 1.74370932e-03f, 1.11051248e-02f, -4.80529480e-02f },
      { 1.91211049e-02f, -1.08193224e-02f, -4.96811569e-02f, -1.02324942e-02f, -5.32096364e-02f },
      { -5.15435589e-04f, 4.74181324e-02f, -6.03289120e-02f, -4.73303758e-02f, -9.50286258e-03f },
    },
    {
      { -4.90484983e-02f, 2.55777799e-02f, 1.03528239e-02f, -5.21780290e-02f, 4.63307016e-02f },
      { -2.10922472e-02f, -1.95940733e-02f, 2.89008059e-02f, 3.64771150e-02f, -6.08074293e-02f },
      { -5.43005764e-02f, -5.81982173e-02f, 3.51681896e-02f, 1.28241517e-02f, -1.94997564e-02f },
      { 5.47274388e-02f, 2.81259008e-02f, -2.63472758e-02f, -2.32402012e-02f, -1.31099224e-02f },
      { -2.47438215e-02f, -1.37607232e-02f, 6.73315302e-03f, 5.67405708e-02f, 3.78091373e-02f },
    },
    {
      { 9.29638371e-03f, 3.35480063e-03f, 3.54961678e-02f, -5.22352336e-03f, 2.05522031e-02f },
      { 1.92849990e-02f, 4.18837033e-02f, -2.56098993e-02f, -4.57324311e-02f, -2.99257897e-02f },
      { -5.46474308e-02f, 5.28517878e-04f, 2.67914981e-02f, -1.51012195e-02f, -1.92060228e-02f },
      { -3.03069316e-02f, -1.28663536e-02f, -4.61799651e-02f, 7.02971872e-03f, 9.33797657e-03f },
      { 7.99934007e-03f, -5.34280203e-02f, 3.39440033e-02f, -7.10697053e-03f, -5.69414832e-02f },
    },
    {
      { 4.84771803e-02f, 1.52551867e-02f, 5.23130931e-02f, -5.02403602e-02f, 1.94212347e-02f },
      { -6.13630973e-02f, -3.14733982e-02f, -2.39332151e-02f, -2.99854688e-02f, -6.45361170e-02f },
      { 1.17288847e-02f, -5.61931878e-02f, 2.51981220e-03f, -4.60891724e-02f, 1.78985354e-02f },
      { -2.54920088e-02f, -3.20808813e-02f, -3.66659686e-02f, 8.35476536e-03f, 2.61156671e-02f },
      { -3.71929072e-03f, -1.72493700e-02f, -2.52806488e-02f, -1.99593659e-02f, -1.54813360e-02f },
    },
    {
      { 6.29749987e-03f, 2.81290598e-02f, 3.12451180e-02f, -3.86650339e-02f, -5.26394323e-02f },
      { 5.18122651e-02f, 2.80810129e-02f, -6.20382354e-02f, -1.74252298e-02f, -2.65481346e-03f },
      { 4.63751629e-02f, 1.79343261e-02f, 5.13328947e-02f, -3.06483954e-02f, 1.82395186e-02f },
      { -2.87956223e-02f, -3.72805633e-02f, 4.23712395e-02f, 3.81749496e-02f, 4.71589714e-02f },
      { -4.53797765e-02f, -6.53820857e-02f, -4.14859736e-03f, -2.24467237e-02f, -4.95860912e-02f },
    },
    {
      { -3.94719280e-02f, 1.25022344e-02f, -2.85671186e-02f, 1.86262354e-02f, -5.56058139e-02f },
      { 2.58617867e-02f, 1.14469579e-03f, 3.51283848e-02f, -2.56920531e-02f, -2.31564101e-02f },
      { -3.27493809e-02f, -3.16101648e-02f, -2.36137733e-02f, -3.47607434e-02f, -1.73525717e-02f },
      { 4.33859602e-02f, -4.02088985e-02f, -3.51043828e-02f, -3.83571498e-02f, 2.65828650e-02f },
      { -3.65881510e-02f, -6.04517646e-02f, 1.64057966e-02f, -4.64422330e-02f, -1.66171119e-02f },
    },
    {
      { -6.64934888e-02f, -5.03264479e-02f, -5.52928448e-02f, -1.55893341e-02f, -3.80789153e-02f },
      { -2.09539197e-02f, 4.31543328e-02f, 9.47257597e-03f, -6.53664768e-02f, -4.41697016e-02f },
      { -8.88122991e-03f, -4.15158123e-02f, 9.80375428e-03f, 4.62019145e-02f, 3.40983924e-03f },
      { 5.40730245e-02f, 4.28918302e-02f, -4.91185859e-02f, 4.94837947e-02f, -2.51655299e-02f },
      { -3.30230501e-03f, -2.83596795e-02f, 2.92861811e-03f, -2.29775198e-02f, 5.74437575e-03f },
    },
    {
      { -5.82817383e-02f, -5.60447946e-02f, -3.06922067e-02f, -5.87611422e-02f, -5.07381074e-02f },
      { 3.21336798e-02f, 1.02610793e-02f, 2.28856131e-02f, -1.65998414e-02f, 3.00764274e-02f },
      { 1.20176766e-02f, 3.04991137e-02f, 5.03150485e-02f, 3.25141847e-02f, 2.42977124e-02f },
      { -4.21134010e-02f, 2.87900176e-02f, 2.90187709e-02f, 3.90995182e-02f, -2.88673192e-02f },
      { -3.28533985e-02f, 5.23790568e-02f, -6.03051484e-02f, 1.04872296e-02f, -1.82091333e-02f },
    },
    {
      { 3.50206234e-02f, 1.84070282e-02f, 2.60274000e-02f, 9.43067297e-03f, -2.21936665e-02f },
      { -9.18567926e-03f, 2.23914199e-02f, 2.85287574e-03f, 4.74174209e-02f, 3.93786617e-02f },
      { 4.16971333e-02f, -1.33221336e-02f, 2.70514078e-02f, -1.92150101e-02f, -1.65271759e-03f },
      { 4.45654206e-02f, -1.61521286e-02f, -3.91037874e-02f, 3.54142152e-02f, 4.73599508e-03f },
      { 2.42893361e-02f, -3.22129056e-02f, -4.83878441e-02f, -4.73008379e-02f, 2.91761197e-02f },
    },
    {
      { -2.34777499e-02f, -2.45747603e-02f, 4.63426448e-02f, 5.16142659e-02f, -4.81263585e-02f },
      { -3.65014225e-02f, 8.08771607e-03f, -2.90790386e-02f, -3.30013856e-02f, -2.28071976e-02f },
      { 4.15857136e-02f, 2.81363204e-02f, 1.70575641e-02f, 4.87704650e-02f, 1.72814708e-02f },
      { 3.83024141e-02f, -5.94778322e-02f, 1.71687510e-02f, 1.67822056e-02f, -3.31703909e-02f },
      { -3.30908149e-02f, 2.71673035e-02f, 4.00103405e-02f, 2.27650423e-02f, 4.82469983e-02f },
    },
    {
      { 9.08052828e-03f, -1.29528781e-02f, 4.41470556e-02f, -1.69852134e-02f, 4.39901836e-02f },
      { 3.81357856e-02f, 4.79437001e-02f, 1.79748945e-02f, -4.62298058e-02f, -1.17135327e-02f },
      { 2.40351502e-02f, -2.80707385e-02f, -5.45467772e-02f, -5.19849770e-02f, -5.42662181e-02f },
      { 2.94484403e-02f, -1.20812850e-02f, -1.30699826e-02f, 2.00498104e-02f, 4.12737951e-02f },
      { 1.17813759e-02f, 2.65512746e-02f, 4.27685156e-02f, -4.55483086e-02f, 3.27607207e-02f },
    },
    {
      { -3.23366933e-02f, 3.17510180e-02f, -6.31275922e-02f, 5.36622070e-02f, 2.41585057e-02f },
      { -1.71007775e-02f, 2.24332158e-02f, -2.45533716e-02f, -3.13199088e-02f, -2.00867802e-02f },
      { -4.60859463e-02f, 8.70458782e-03f, -1.35455448e-02f, 3.90531011e-02f, -3.24725658e-02f },
      { -3.19399312e-02f, 7.08320644e-03f, -2.70212423e-02f, 2.98803160e-03f, 7.40678143e-03f },
      { 2.54637040e-02f, -5.00493720e-02f, -2.89341528e-02f, -4.99945171e-02f, 5.28508238e-02f },
    },
    {
      { 4.88833003e-02f, -3.85963917e-02f, 5.10031991e-02f, -5.09613380e-03f, 2.27844752e-02f },
      { -3.60448211e-02f, 4.47105281e-02f, 2.89466046e-02f, -5.11740521e-02f, 2.84326039e-02f },
      { -1.13820024e-02f, 5.38586713e-02f, 3.45984437e-02f, -4.60517779e-03f, -4.90702540e-02f },
      { 1.53401867e-03f, -5.65537512e-02f, 3.68250050e-02f, 4.88624610e-02f, -2.11760215e-02f },
      { -1.25535950e-03f, 2.79275738e-02f, -8.35401565e-03f, 2.87845396e-02f, -2.12685578e-02f },
    },
    {
      { -3.07394248e-02f, -3.29086073e-02f, -5.11533134e-02f, -4.81944755e-02f, -3.87504809e-02f },
      { -4.16223966e-02f, -4.49307933e-02f, -8.80404655e-03f, -4.18563224e-02f, -2.95022167e-02f },
      { -2.49647051e-02f, -4.66474444e-02f, -5.24994545e-02f, 5.02171926e-02f, -7.68628810e-03f },
      { 2.85787769e-02f, 4.56047989e-02f, -5.44783426e-03f, 4.10975479e-02f, -3.11993863e-02f },
      { 5.49865328e-02f, -5.47744110e-02f, -5.88567406e-02f, -1.75184663e-02f, 3.32394987e-02f },
    },
    {
      { 3.09861768e-02f, -4.80476767e-02f, 2.64408439e-02f, -1.66154150e-02f, 2.71147173e-02f },
      { 7.67534692e-03f, 3.55677158e-02f, -4.01686244e-02f, -2.27855686e-02f, 4.02062237e-02f },
      { -7.15637999e-03f, -2.19784230e-02f, 5.07917181e-02f, 1.92696750e-02f, -4.69317399e-02f },
      { -2.69090608e-02f, -1.74780134e-02f, 5.09552807e-02f, 5.44606745e-02f, 1.35167856e-02f },
      { -3.88568826e-02f, 2.74384022e-02f, 9.17712040e-03f, -6.70643337e-03f, -7.31298234e-03f },
    },
    {
      { -7.71458587e-03f, 1.98222417e-02f, -6.07972741e-02f, -9.64461267e-03f, 1.45993726e-02f },
      { -3.56038101e-02f, -2.98710112e-02f, -3.78628299e-02f, -3.86295579e-02f, 2.47756741e-03f },
      { -2.42079934e-03f, 3.57950069e-02f, -4.15111659e-03f, -2.06430000e-03f, 3.81550677e-02f },
      { -1.63670927e-02f, -4.15529385e-02f, 3.22195105e-02f, -4.16142903e-02f, -6.45637661e-02f },
      { -5.28602786e-02f, 1.09538957e-02f, -5.60590904e-03f, 4.07506749e-02f, -2.06184275e-02f },
    },
    {
      { 4.14204262e-02f, -1.68960653e-02f, 1.30887665e-02f, -1.12666599e-02f, 1.74377672e-02f },
      { 1.58409439e-02f, 1.96660347e-02f, 7.92126730e-03f, -1.92144141e-02f, 4.96326797e-02f },
      { 3.09546255e-02f, 2.45968960e-02f, -3.02787125e-03f, -9.09829885e-03f, -1.60568953e-02f },
      { 5.21365069e-02f, 1.27426870e-02f, -1.66001916e-02f, -4.07333337e-02f, 9.86985490e-03f },
      { 2.56949849e-02f, 4.22741808e-02f, 7.07974657e-03f, 1.55976303e-02f, 7.52530992e-04f },
    },
    {
      { -1.35093518e-02f, -9.46972519e-03f, -4.65054661e-02f, 8.51317123e-03f, -6.11601956e-02f },
      { -1.66893415e-02f, -2.03316137e-02f, 3.99191566e-02f, -5.89350834e-02f, -1.93068758e-03f },
      { -2.98137330e-02f, -1.07884780e-02f, 5.30724190e-02f, -1.23194866e-02f, 2.34582834e-02f },
      { -6.03403151e-02f, -4.16979790e-02f, 2.07373388e-02f, 1.52360229e-02f, -4.22608107e-02f },
      { -5.16799465e-03f, 4.25374843e-02f, -3.71792465e-02f, -1.44133903e-02f, -3.79115418e-02f },
    },
    {
      { -4.88798805e-02f, 2.68635415e-02f, 8.94984603e-03f, -5.03686816e-02f, 9.80787631e-03f },
      { 4.98867445e-02f, -5.99976070e-02f, -3.56079713e-02f, -2.33499110e-02f, -5.26279733e-02f },
      { 1.05608106e-02f, -2.82822270e-02f, 1.72205977e-02f, -2.91170590e-02f, 5.91434389e-02f },
      { -3.48399803e-02f, 4.50180694e-02f, -3.10517251e-02f, 3.86912636e-02f, 2.87583210e-02f },
      { -6.24254867e-02f, 3.52279209e-02f, 2.83790454e-02f, 1.87560879e-02f, -3.40620964e-03f },
    },
  },
  {
    {
      { 1.42698124e-01f, 8.98092985e-02f, 8.79629925e-02f, 6.41287416e-02f, 5.18056005e-02f },
      { 8.00425336e-02f, 6.31295070e-02f, 1.66419119e-01f, 2.05510408e-01f, -9.81014222e-02f },
      { -3.60620409e-01f, -5.17967582e-01f, -3.08945298e-01f, 3.75228189e-02f, 4.89789583e-02f },
      { -2.58927234e-03f, -9.07962117e-03f, -1.92958921e-01f, -9.58226249e-02f, -4.62957770e-02f },
      { 1.28219560e-01f, 5.07875644e-02f, 3.77085477e-01f, 1.09502248e-01f, 1.39447615e-01f },
    },
    {
      { 1.02587059e-01f, -9.16859135e-03f, -5.84820062e-02f, -4.83607054e-02f, -6.16810024e-02f },
      { 1.80737928e-01f, 1.30452529e-01f, 2.17245102e-01f, 3.65745366e-01f, -1.97495390e-02f },
      { -2.40411937e-01f, -3.80862176e-01f, -1.51187867e-01f, 1.33223951e-01f, -2.74607003e-01f },
      { 4.42323014e-02f, 1.05345689e-01f, -7.32957721e-02f, -1.02252498e-01f, -1.56139448e-01f },
      { -5.12829311e-02f, -6.27981797e-02f, -9.11789387e-02f, -1.18106231e-01f, -1.23803401e-02f },
    },
    {
      { -3.17958966e-02f, 2.01505899e-01f, 2.58768618e-01f, 1.67615235e-01f, -5.85260391e-02f },
      { -3.65475714e-01f, -1.79322258e-01f, 2.73309369e-02f, 2.44091183e-01f, 1.89822376e-01f },
      { 3.20299678e-02f, 2.16348857e-01f, 1.18463024e-01f, 2.98719350e-02f, -1.51411891e-01f },
      { 8.05433914e-02f, 2.66415179e-01f, 3.80093217e-01f, 2.14403853e-01f, 8.19946006e-02f },
      { -6.09744601e-02f, -2.16933072e-01f, -8.27253312e-02f, -1.67136956e-02f, -1.98126808e-01f },
    },
    {
      { 6.98272511e-02f, -1.60628988e-04f, -1.77717045e-01f, -1.73720837e-01f, -4.06477377e-02f },
      { -2.76657511e-02f, 1.80908181e-02f, -2.07387716e-01f, -5.45305431e-01f, -7.23782554e-02f },
      { 4.75392342e-02f, 3.04866079e-02f, -2.72014234e-02f, -3.47399503e-01f, -9.49911401e-02f },
      { 1.67052805e-01f, -7.25869685e-02f, -1.20223373e-01f, -1.99338675e-01f, 2.99766939e-03f },
      { 1.34706602e-01f, -2.86727082e-02f, -2.05447346e-01f, -6.08663596e-02f, -7.41906092e-02f },
    },
    {
      { -2.11583041e-02f, 6.60628155e-02f, 2.17084348e-01f, 7.79751837e-02f, 3.91595140e-02f },
      { -1.08810356e-02f, -1.36066660e-01f, -2.22036943e-01f, -2.20428243e-01f, 1.12215683e-01f },
      { 1.50864407e-01f, 3.63796763e-02f, 1.96674969e-02f, -4.41362888e-01f, -6.97553232e-02f },
      { 1.42709970e-01f, 1.76555682e-02f, 4.90703806e-02f, -9.27593559e-02f, -8.79034176e-02f },
      { 2.01078027e-01f, 1.94123629e-02f, -7.78134912e-02f, -9.74074230e-02f, 6.45603240e-02f },
    },
    {
      { -2.11700439e-01f, -2.06678316e-01f, 1.86753243e-01f, 2.39470944e-01f, 1.90979600e-01f },
      { -3.05633932e-01f, -2.64357239e-01f, -3.94099385e-01f, -1.37920752e-01f, 2.80803502e-01f },
      { -2.18729693e-02f, 1.88671559e-01f, 2.09304944e-01f, 6.99213967e-02f, 2.07274422e-01f },
      { -1.07359119e-01f, -4.83805425e-02f, 8.87624323e-02f, 1.51695773e-01f, 1.86659276e-01f },
      { -3.95645276e-02f, -1.92141652e-01f, -7.79119274e-03f, -8.75074565e-02f, -3.02428026e-02f },
    },
    {
      { -3.66154052e-02f, -1.09403804e-01f, -2.89337754e-01f, 1.20786682e-01f, 2.97821850e-01f },
      { -2.18813300e-01f, -2.52606362e-01f, -1.89117372e-01f, -7.84640536e-02f, -1.00189671e-01f },
      { -1.83066890e-01f, -3.37710440e-01f, -1.11298159e-01f, 1.79572806e-01f, -4.27810043e-01f },
      { 6.11731149e-02f, -2.70551831e-01f, -1.72617272e-01f, 4.61849980e-02f, -2.61875689e-01f },
      { 3.05980414e-01f, -1.24080546e-01f, -3.43068153e-01f, -1.74537912e-01f, -9.76765528e-02f },
    },
    {
      { -1.15279645e-01f, -1.74116120e-01f, -5.17319664e-02f, -3.48014235e-02f, 3.35959680e-02f },
      { -1.80772722e-01f, -3.06610048e-01f, -1.60707310e-01f, -1.51752057e-02f, -2.08279684e-01f },
      { 1.80952743e-01f, 8.96120667e-02f, 1.83773890e-01f, 2.62840986e-01f, -2.47754619e-01f },
      { 1.26123786e-01f, 2.24488731e-02f, 1.96244214e-02f, 5.31947911e-02f, -1.48974389e-01f },
      { 1.26193494e-01f, 4.18982320e-02f, -1.53543591e-01f, -1.55965492e-01f, -8.41863975e-02f },
    },
    {
      { 5.59754036e-02f, -1.00334652e-01f, -7.58457277e-03f, -2.16265060e-02f, 7.76075944e-02f },
      { 2.23107308e-01f, 1.12164058e-01f, 2.25864455e-01f, 4.19864833e-01f, 1.15385890e-01f },
      { -4.05601919e-01f, -3.14081848e-01f, -4.77846950e-01f, -5.56762591e-02f, 1.06663622e-01f },
      { -2.40311682e-01f, 2.85692140e-02f, -2.41551042e-01f, -3.07987928e-01f, -6.26230389e-02f },
      { 3.53142945e-03f, 9.42766741e-02f, 5.64444810e-03f, -1.46909982e-01f, -2.19715014e-01f },
    },
    {
      { 2.93810316e-03f, -9.24139395e-02f, -1.41887411e-01f, 2.39367187e-02f, 1.84861198e-01f },
      { -6.87806830e-02f, -8.78265724e-02f, -1.39778152e-01f, -2.28687823e-01f, 9.63705033e-02f },
      { 1.30152125e-02f, -4.16052602e-02f, 6.46180585e-02f, 2.77498905e-02f, 9.07348990e-02f },
      { -1.79174095e-02f, -6.22762740e-02f, 7.16064572e-02f, 1.55624241e-01f, 1.31513178e-01f },
      { -3.61856371e-02f, -3.13264802e-02f, -1.08990155e-01f, 4.99776714e-02f, 9.39432457e-02f },
    },
    {
      { -1.57698423e-01f, 3.54539379e-02f, 1.33760124e-01f, 2.25361362e-01f, 1.29059851e-01f },
      { -1.78779140e-01f, -2.61028796e-01f, -4.02807087e-01f, -3.01173359e-01f, 4.14821282e-02f },
      { 2.10794151e-01f, 1.36670962e-01f, 2.13443980e-01f, 6.46302104e-03f, -1.21785194e-01f },
      { 1.87058449e-01f, 1.07524969e-01f, 1.71102718e-01f, 6.08648546e-02f, -5.17745363e-03f },
      { 1.69666275e-01f, -2.91037243e-02f, -2.56269351e-02f, -1.07213303e-01f, -7.32572898e-02f },
    },
    {
      { 2.19860859e-02f, -1.99849233e-02f, -3.27118486e-02f, -1.81540295e-01f, -7.19133317e-02f },
      { 1.47335231e-01f, 1.77988783e-01f, 2.25371718e-01f, 1.42023817e-01f, 9.08812433e-02f },
      { -2.31335551e-01f, -1.83734164e-01f, -1.17183618e-01f, 1.85659528e-02f, 8.99708346e-02f },
      { -1.83342874e-01f, -1.33235484e-01f, 3.33278552e-02f, 1.08597592e-01f, 8.40975717e-02f },
      { -2.11438373e-01f, -5.02727740e-03f, 7.80203342e-02f, 4.71632928e-02f, 8.24690163e-02f },
    },
    {
      { -1.46529614e-03f, -4.69000526e-02f, 1.34743340e-02f, 8.72654346e-06f, -7.53040686e-02f },
      { 3.51435468e-02f, 2.60220841e-02f, 2.14503154e-01f, 2.27068886e-01f, -1.47615209e-01f },
      { -1.57708034e-01f, -5.65858744e-02f, -2.45013777e-02f, 1.75038606e-01f, -1.53349871e-02f },
      { 5.82800880e-02f, -3.93351121e-03f, -3.66499051e-02f, -4.68916930e-02f, 9.07593817e-02f },
      { 5.75932600e-02f, -1.14935925e-02f, 1.76862366e-02f, -7.07258582e-02f, 3.40825133e-02f },
    },
    {
      { 6.43546879e-02f, 1.75997540e-02f, -7.86507353e-02f, 2.95645967e-02f, -5.78156412e-02f },
      { 1.44990399e-01f, 1.61751732e-01f, 3.23981076e-01f, 2.72472233e-01f, -1.94397658e-01f },
      { -2.59604037e-01f, -2.59220272e-01f, -2.53726065e-01f, 1.10976420e-01f, -2.92605668e-01f },
      { 9.08158943e-02f, 7.75883272e-02f, -1.27316922e-01f, 3.77012454e-02f, -1.57979503e-01f },
      { -6.47990257e-02f, -2.13199556e-02f, -5.36232032e-02f, -2.02002257e-01f, 2.88888235e-02f },
    },
    {
      { 4.26624380e-02f, -1.71778612e-02f, -1.38105871e-02f, 8.46074778e-04f, 3.78009491e-02f },
      { -4.68779728e-02f, -4.05152254e-02f, -5.98788671e-02f, -3.38201597e-02f, -3.59270647e-02f },
      { -5.08729070e-02f, -4.30436432e-02f, 9.10351146e-03f, -8.94131232e-03f, 6.28976524e-02f },
      { 1.71312112e-02f, 5.62898889e-02f, 1.86554994e-02f, -1.62114911e-02f, -6.33240491e-02f },
      { -4.88929972e-02f, -1.58402547e-02f, -3.21248062e-02f, -5.12224063e-02f, 3.89328673e-02f },
    },
    {
      { 3.45025142e-03f, 1.20285545e-02f, -1.36804208e-02f, 3.30968201e-02f, 2.53546163e-02f },
      { 1.06988557e-01f, -1.01785921e-02f, 9.13959593e-02f, -2.14926396e-02f, -7.95673132e-02f },
      { 9.36015230e-03f, -3.52628566e-02f, 8.29935372e-02f, -5.25973178e-03f, -1.20588757e-01f },
      { 1.86806116e-02f, 6.24796550e-04f, -2.77360808e-02f, -1.71712656e-02f, -4.52097692e-02f },
      { -4.77244630e-02f, -2.79128756e-02f, -1.05162719e-02f, -6.19181395e-02f, 2.70496849e-02f },
    },
    {
      { 8.75731930e-02f, -9.29447298e-04f, -4.80516814e-03f, -7.41866082e-02f, -1.08994864e-01f },
      { 4.92452644e-02f, 2.31694449e-02f, -8.78777057e-02f, -9.86746103e-02f, -1.55445665e-01f },
      { 1.20038539e-01f, 1.00162916e-01f, 9.92225111e-03f, -2.72838660e-02f, -9.90438610e-02f },
      { 7.03659281e-02f, 1.85964499e-02f, -1.33363530e-01f, -1.09269597e-01f, -7.24953115e-02f },
      { 4.44726869e-02f, 8.99872649e-03f, 4.67469543e-02f, -8.03402513e-02f, 3.01286159e-03f },
    },
    {
      { -1.15054347e-01f, -9.32580754e-02f, -2.98825298e-02f, 5.08677363e-02f, 4.69560586e-02f },
      { -5.58743067e-02f, -9.90978479e-02f, -4.58901227e-02f, -1.13475673e-01f, 1.19495569e-02f },
      { 1.58016235e-01f, 1.10211991e-01f, 8.81924778e-02f, 8.81715491e-03f, 4.09751572e-03f },
      { 2.53914874e-02f, -6.94778934e-02f, 6.50851578e-02f, 2.79932264e-02f, -9.87064987e-02f },
      { -3.39226797e-02f, -1.16910905e-01f, -1.25225127e-01f, -1.17675155e-01f, 5.42824529e-03f },
    },
    {
      { 2.10264325e-02f, -3.17972689e-03f, 1.61845788e-01f, 2.10484758e-01f, 6.06700629e-02f },
      { -1.98623841e-03f, -1.63544446e-01f, -3.93826544e-01f, -2.82345384e-01f, -1.80615291e-01f },
      { 1.37239754e-01f, 1.88148335e-01f, 2.22754121e-01f, -3.07716541e-02f, -1.59944758e-01f },
      { 2.06555594e-02f, -1.04260698e-01f, 2.55075619e-02f, -2.96870377e-02f, -1.34197682e-01f },
      { 9.96889248e-02f, -5.84476292e-02f, -3.85467289e-03f, -1.31832585e-01f, -2.24064570e-02f },
    },
    {
      { 4.46631685e-02f, 3.81822581e-04f, 1.08561963e-01f, 5.94599098e-02f, -6.38349131e-02f },
      { 1.62142694e-01f, 1.10243171e-01f, 5.12902923e-02f, 5.91634922e-02f, -8.86080936e-02f },
      { -1.12585369e-02f, 3.58856879e-02f, -1.86748475e-01f, -1.97949752e-01f, -1.72512546e-01f },
      { 5.17736413e-02f, 6.97274357e-02f, -7.01649636e-02f, -1.78196415e-01f, -3.92371081e-02f },
      { 6.07865825e-02f, -6.53986484e-02f, 2.98849344e-02f, -2.22255033e-03f, -3.69202010e-02f },
    },
    {
      { 3.54070403e-02f, 2.28647105e-02f, -4.98787053e-02f, -1.01533681e-01f, 3.09259873e-02f },
      { 2.00504065e-01f, 3.03520650e-01f, 2.40123674e-01f, 1.84315201e-02f, -1.45112619e-01f },
      { 4.25482281e-02f, -4.91974428e-02f, 6.08623065e-02f, -3.59027945e-02f, 5.75942919e-02f },
      { -1.35997236e-01f, -1.61545470e-01f, -1.30836770e-01f, -6.39253631e-02f, -3.86735052e-02f },
      { -1.17109865e-01f, -7.08803236e-02f, -3.28161828e-02f, 2.58192457e-02f, 8.39991611e-04f },
    },
    {
      { -1.49836555e-01f, -3.47483158e-01f, -2.57272184e-01f, -2.16084555e-01f, -2.27322221e-01f },
      { -4.68771875e-01f, -3.54901135e-01f, -3.58886629e-01f, -5.50385416e-01f, -3.59221578e-01f },
      { -2.44196579e-01f, 1.51113227e-01f, 2.84931045e-02f, -1.33602187e-01f, -7.85530433e-02f },
      { 1.64157182e-01f, 2.99475938e-01f, 3.51660028e-02f, -1.53469115e-01f, -3.59681039e-03f },
      { 2.22520515e-01f, 9.44032148e-02f, -4.74103242e-02f, -1.66966170e-01f, -2.11341485e-01f },
    },
    {
      { 8.88815150e-02f, 7.26769352e-03f, -2.23433543e-02f, 3.39861773e-02f, 1.27610743e-01f },
      { -2.34350506e-02f, -2.85426248e-02f, -9.53465048e-03f, 1.19927198e-01f, 2.84145504e-01f },
      { -1.06731832e-01f, 1.48897432e-03f, 7.04127327e-02f, 1.46032825e-01f, 2.91654170e-01f },
      { -9.14737135e-02f, 5.17627113e-02f, 1.08361810e-01f, 1.76987201e-01f, 1.97593734e-01f },
      { -2.08079200e-02f, 6.91092163e-02f, 1.56608865e-01f, 1.98292285e-01f, 1.26756623e-01f },
    },
    {
      { -9.44793373e-02f, 2.91560423e-02f, -4.29482665e-03f, 4.35032658e-02f, 5.86426184e-02f },
      { 7.62103647e-02f, -7.46119320e-02f, 4.66773212e-02f, 9.87271518e-02f, -1.40728191e-01f },
      { -4.96008508e-02f, -1.48012742e-01f, 6.60212636e-02f, -1.35138091e-02f, -1.97122931e-01f },
      { 2.07694154e-02f, 8.74687452e-03f, 3.89426691e-03f, 9.11051258e-02f, -9.63938534e-02f },
      { 1.42033910e-02f, -2.65543647e-02f, -1.24188252e-02f, -1.43139213e-02f, 1.06085101e-02f },
    },
    {
      { -5.30878417e-02f, -4.33702767e-02f, 1.28191471e-01f, 5.61634116e-02f, 9.87848788e-02f },
      { -1.33294716e-01f, -1.56965479e-01f, -2.40063503e-01f, -1.52393848e-01f, 2.59321388e-02f },
      { 1.40925646e-01f, 1.71954900e-01f, 2.72666186e-01f, 1.18386559e-01f, -5.71006872e-02f },
      { 6.47311732e-02f, 5.08803874e-02f, 1.95447952e-01f, 1.33399859e-01f, 4.55573760e-02f },
      { 2.37336964e-03f, 6.20269626e-02f, -4.96834666e-02f, -7.63845146e-02f, -7.74133056e-02f },
    },
    {
      { 5.81076518e-02f, 6.64984137e-02f, 1.02961510e-01f, 6.31059557e-02f, 1.03683576e-01f },
      { -3.64278560e-04f, 1.54506834e-02f, -3.80236395e-02f, 6.57072514e-02f, -6.86905533e-02f },
      { 2.25626573e-01f, 1.51953891e-01f, 3.25491756e-01f, 2.79971451e-01f, -5.24317883e-02f },
      { 3.82050015e-02f, -9.54544824e-03f, 2.05558981e-03f, 9.96722877e-02f, -2.30582710e-02f },
      { 2.31539726e-01f, 3.62410806e-02f, -7.13065937e-02f, 6.94980670e-04f, 2.92191692e-02f },
    },
    {
      { -1.92356184e-02f, 1.04375808e-02f, 2.42814030e-02f, -2.86746472e-02f, -2.55530085e-02f },
      { 8.89329612e-03f, -3.81484069e-03f, -1.78437427e-01f, -2.10909113e-01f, 8.42516869e-03f },
      { 8.25582258e-03f, 1.07174270e-01f, 2.23339237e-02f, -8.03593174e-02f, -7.37260878e-02f },
      { 1.60117391e-02f, -6.31201863e-02f, 2.78542358e-02f, -6.39148355e-02f, 5.84224379e-03f },
      { 6.11781739e-02f, -1.89451203e-02f, 4.47460376e-02f, -1.31293666e-02f, 2.09695753e-02f },
    },
    {
      { -1.35464687e-02f, 4.09347638e-02f, -1.69706512e-02f, 2.35195961e-02f, 1.32319883e-01f },
      { -2.02736795e-01f, -5.49120791e-02f, 5.74735133e-03f, 1.77859306e-01f, 2.43931189e-01f },
      { -8.68518353e-02f, -4.72701937e-02f, -1.49126258e-02f, -3.09036691e-02f, 1.04250744e-01f },
      { -5.91931604e-02f, -3.23087834e-02f, 9.06602666e-02f, 2.87961289e-02f, 7.13903382e-02f },
      { -7.53301084e-02f, -5.85373342e-02f, -4.36085351e-02f, -4.12990227e-02f, 5.14372326e-02f },
    },
    {
      { 1.18488304e-01f, 9.64399129e-02f, 6.66566342e-02f, -6.47061616e-02f, -1.08712614e-01f },
      { 2.95267552e-01f, 4.20470387e-01f, 4.45428908e-01f, 2.53809243e-01f, -5.21022156e-02f },
      { -9.44745466e-02f, -1.34943575e-01f, 8.03212076e-03f, -2.10073814e-02f, -9.34471041e-02f },
      { -1.91020384e-01f, -1.28657609e-01f, -1.53664529e-01f, -7.14193508e-02f, -1.40748426e-01f },
      { -8.93796906e-02f, 1.18426029e-02f, 6.71806261e-02f, 2.11010184e-02f, -2.52723228e-02f },
    },
    {
      { -3.04136053e-03f, 2.24767048e-02f, -2.90300809e-02f, 5.01569211e-02f, 4.83236276e-02f },
      { -5.36408760e-02f, -5.18877134e-02f, -5.38265929e-02f, -6.10008873e-02f, 1.02879340e-02f },
      { -3.54203247e-02f, 2.20805947e-02f, 3.13518606e-02f, -2.32150406e-02f, -4.33385447e-02f },
      { 2.04542316e-02f, -5.82987666e-02f, -1.21186720e-02f, 1.59923397e-02f, 4.80693094e-02f },
      { 2.09097285e-02f, 4.12033312e-02f, -4.96102646e-02f, 4.88962084e-02f, 3.76250148e-02f },
    },
    {
      { 1.13344029e-01f, 8.68731216e-02f, 3.78300212e-02f, -4.34476584e-02f, -4.37787734e-03f },
      { 1.38485089e-01f, 2.18701556e-01f, 3.88994724e-01f, 1.81682631e-01f, -1.28162876e-01f },
      { -2.42942050e-01f, -4.14186418e-01f, -3.85425657e-01f, 3.20629054e-03f, -3.03011954e-01f },
      { 1.44814521e-01f, 1.44607782e-01f, -1.59903586e-01f, -1.84542775e-01f, -1.67338222e-01f },
      { -1.11512050e-01f, 3.13336588e-02f, 5.76498471e-02f, -6.54608160e-02f, 3.86840627e-02f },
    },
    {
      { 1.64810121e-01f, 1.75305568e-02f, -3.42050970e-01f, -1.71684071e-01f, -1.48060605e-01f },
      { -9.89716593e-03f, -2.32270017e-01f, -3.08803558e-01f, -2.01860026e-01f, -4.45932359e-01f },
      { 9.18092653e-02f, -2.15630084e-01f, -2.61365741e-01f, 5.72268032e-02f, -3.59516531e-01f },
      { 1.45052239e-01f, 5.46011422e-03f, -2.23262697e-01f, -1.63006261e-02f, -2.90887713e-01f },
      { 1.35784268e-01f, 1.01042002e-01f, -3.38210851e-01f, -1.96668446e-01f, -7.11410940e-02f },
    },
  },
  {
    {
      { 5.28079346e-02f, -4.63325605e-02f, 1.03641767e-02f, 2.24118605e-02f, -3.72996219e-02f },
      { 4.90743816e-02f, 3.86574119e-02f, -2.77175345e-02f, 6.59416243e-03f, 1.11302258e-02f },
      { 4.22960930e-02f, -7.45268464e-02f, 6.21859403e-03f, -2.23127496e-03f, 3.56036499e-02f },
      { 1.34691980e-03f, -2.15690359e-02f, -3.67131867e-02f, 2.79166121e-02f, -8.32552761e-02f },
      { -8.28289464e-02f, 2.09090039e-02f, -3.89728472e-02f, -8.44044685e-02f, -6.09204769e-02f },
    },
    {
      { -3.40035073e-02f, -7.35229626e-02f, -3.38135101e-02f, -2.08819527e-02f, -2.78339889e-02f },
      { -4.42975722e-02f, -2.97396723e-02f, -6.62336424e-02f, -1.08695368e-03f, -2.87691578e-02f },
      { -6.05638605e-03f, 4.94509041e-02f, -5.08147255e-02f, 1.72606407e-04f, -4.19437177e-02f },
      { -3.42963859e-02f, -6.35949075e-02f, -6.32087365e-02f, 2.63230428e-02f, -7.44029209e-02f },
      { -4.43822406e-02f, 2.85098087e-02f, -5.61565869e-02f, -7.02026784e-02f, -5.54946810e-02f },
    },
    {
      { 3.02301999e-02f, -1.83852594e-02f, 2.31629685e-02f, -4.66318615e-02f, 2.04947609e-02f },
      { -6.92561492e-02f, -5.77316992e-02f, 1.30002352e-03f, -2.72881668e-02f, 2.31632404e-02f },
      { 1.11272763e-02f, -3.06311785e-03f, -6.70680031e-02f, -4.04929882e-03f, -7.24263536e-03f },
      { -4.44992483e-02f, -4.66618910e-02f, -2.73111882e-03f, 1.56736542e-02f, 3.17817181e-02f },
      { -4.70691510e-02f, 2.14368794e-02f, -6.57017305e-02f, -4.18667980e-02f, 1.81090757e-02f },
    },
    {
      { -5.08489124e-02f, -4.29574810e-02f, 2.35758256e-02f, -6.43501505e-02f, -4.49147262e-02f },
      { 1.74799412e-02f, 2.81752856e-03f, -5.85348457e-02f, -2.70381533e-02f, 3.55338654e-03f },
      { -8.62072594e-03f, -5.11367284e-02f, 1.97060555e-02f, 7.78071815e-03f, -5.61188310e-02f },
      { -7.07920408e-03f, -6.46525295e-03f, 1.14860861e-02f, 5.32699842e-03f, -1.90772675e-02f },
      { -8.81820396e-02f, -8.56985301e-02f, -3.39074358e-02f, -7.65892640e-02f, -5.18891737e-02f },
    },
    {
      { -3.10750194e-02f, 2.06107330e-02f, -3.80333886e-02f, -4.94055524e-02f, 7.92029127e-03f },
      { -5.44112641e-03f, -7.74693638e-02f, -1.89557895e-02f, 3.25451791e-02f, -8.69906396e-02f },
      { 2.64215842e-03f, -5.20914607e-02f, -7.19518587e-02f, -2.13825796e-03f, -6.40521646e-02f },
      { -4.93807010e-02f, -5.94751909e-02f, -1.37201035e-02f, 2.08566636e-02f, -6.61133304e-02f },
      { 4.45893779e-03f, 2.49028206e-02f, -7.52067715e-02f, 2.10365141e-03f, -8.36416483e-02f },
    },
    {
      { -7.36083165e-02f, -4.84675951e-02f, -6.09130971e-02f, 6.30363123e-03f, 9.78501234e-03f },
      { 1.87750943e-02f, -7.59186894e-02f, 1.39590409e-02f, -7.54053295e-02f, 2.97281868e-03f },
      { -1.29480064e-02f, 8.41550180e-04f, 1.31836710e-02f, -6.69877529e-02f, -7.72298053e-02f },
      { -2.10997276e-02f, -6.05580434e-02f, -3.69146205e-02f, -8.09543356e-02f, 5.55697735e-03f },
      { -6.19299263e-02f, 2.75956653e-02f, 1.26554044e-02f, -7.36128837e-02f, -1.25389760e-02f },
    },
    {
      { -2.44419817e-02f, 2.50096433e-02f, -4.49226871e-02f, -4.24155481e-02f, -4.00120579e-02f },
      { -8.24635774e-02f, 2.87695844e-02f, -1.86362416e-02f, -4.13828269e-02f, 3.66719700e-02f },
      { -6.49881409e-03f, -3.67925875e-02f, -7.79064596e-02f, -2.52053025e-03f, 2.15155594e-02f },
      { 1.98618472e-02f, 2.02848986e-02f, 1.69043597e-02f, -3.99528928e-02f, -6.32000109e-03f },
      { 1.04751792e-02f, -4.31056656e-02f, 9.36074299e-04f, -7.24484771e-02f, -4.46625575e-02f },
    },
    {
      { -1.45169152e-02f, -1.60553642e-02f, -2.88169160e-02f, 3.01664174e-02f, -1.59654282e-02f },
      { -7.51096532e-02f, -4.71274108e-02f, -8.10800791e-02f, 3.13218869e-03f, -5.85981756e-02f },
      { -6.14401624e-02f, -7.58190779e-03f, -5.19282278e-03f, 1.52981272e-02f, -7.50899538e-02f },
      { -8.59970003e-02f, -6.80277497e-02f, -2.98301801e-02f, -7.78057128e-02f, -2.53467001e-02f },
      { 1.96451247e-02f, -5.93003929e-02f, -8.14041570e-02f, 1.07327905e-02f, -7.11446628e-02f },
    },
    {
      { 3.39051336e-02f, 3.26294452e-02f, -4.19629216e-02f, 1.72984973e-02f, 3.65506671e-02f },
      { -8.26018024e-03f, -3.31011713e-02f, 4.94273752e-02f, 4.06168513e-02f, -6.04654402e-02f },
      { -1.12399850e-02f, 4.04600799e-02f, -9.33247805e-03f, 3.21010523e-03f, -5.26245758e-02f },
      { 5.97619778e-03f, -2.50437595e-02f, -4.19839770e-02f, 8.25203781e-04f, 3.69529892e-03f },
      { 1.33955004e-02f, -6.03423119e-02f, -4.68261242e-02f, -4.94252630e-02f, -7.17410520e-02f },
    },
    {
      { 2.73230616e-02f, -6.53521344e-02f, 1.21230204e-02f, -2.91516688e-02f, 2.13604588e-02f },
      { -2.80239526e-02f, 1.66630689e-02f, 3.05057988e-02f, -7.79625475e-02f, 8.16848502e-03f },
      { -6.08728677e-02f, -5.53009734e-02f, -9.25074425e-03f, 7.67207425e-03f, -4.22406159e-02f },
      { -1.35821765e-02f, -3.89728174e-02f, -7.88291171e-02f, -1.65840611e-02f, -8.39053169e-02f },
      { -7.40098581e-02f, -7.72561654e-02f, -6.82722256e-02f, -7.13471398e-02f, -2.35167202e-02f },
    },
    {
      { -7.82902390e-02f, -8.89739916e-02f, -5.98767847e-02f, 1.04261758e-02f, -5.12715057e-02f },
      { 3.74575052e-03f, 8.91578291e-03f, -5.11428118e-02f, 1.57238860e-02f, -8.65337253e-02f },
      { 2.09288225e-02f, -7.80443028e-02f, 3.30311880e-02f, -6.55852705e-02f, -7.65103325e-02f },
      { -1.35133248e-02f, 1.71173550e-02f, -9.06789303e-02f, -1.35248080e-02f, -3.64121050e-02f },
      { 1.32410247e-02f, -5.22294566e-02f, 1.65333916e-02f, -4.04608771e-02f, -6.39087800e-03f },
    },
    {
      { -4.55577224e-02f, -5.21896295e-02f, -2.86796447e-02f, 3.39559577e-02f, 6.57586232e-02f },
      { -6.10658750e-02f, -6.65530469e-03f, -2.34648157e-02f, 4.02132571e-02f, -2.61121579e-02f },
      { 1.14742564e-02f, 6.13594502e-02f, -3.91470119e-02f, -3.56606208e-02f, -5.80117591e-02f },
      { -2.10395791e-02f, -3.10315453e-02f, -6.11070767e-02f, -3.94283123e-02f, -6.38096593e-03f },
      { -1.81775168e-02f, 3.30308825e-02f, 7.72452727e-03f, -8.76289830e-02f, -1.35138687e-02f },
    },
    {
      { -3.27373785e-03f, -2.07470246e-02f, -4.92309593e-02f, -2.96079051e-02f, -5.39295897e-02f },
      { 5.29721491e-02f, -4.81296368e-02f, -3.34076770e-02f, -3.15930950e-03f, -2.65060961e-02f },
      { -1.32298367e-02f, -1.24655559e-03f, -7.24503258e-03f, 1.51262786e-02f, 1.86897237e-02f },
      { -3.70238675e-03f, -2.44553834e-02f, -6.26054108e-02f, 3.09295468e-02f, -4.27656397e-02f },
      { -2.49169134e-02f, -4.49548438e-02f, -7.46959001e-02f, 9.27275978e-03f, -2.67696381e-02f },
    },
    {
      { -7.12072151e-03f, -7.75248334e-02f, -2.97146067e-02f, 1.39437364e-02f, -6.38110563e-02f },
      { 2.33089011e-02f, -3.98515724e-02f, 2.01001428e-02f, -7.65695889e-03f, 1.29270423e-02f },
      { -6.65471032e-02f, 3.10017020e-02f, 5.19509753e-03f, 2.12073768e-03f, -3.45188044e-02f },
      { -4.00703177e-02f, -5.47115579e-02f, -8.20528995e-03f, 3.46658453e-02f, 3.51784192e-02f },
      { -6.25942647e-02f, -5.50201908e-02f, -6.05466478e-02f, -3.72682735e-02f, 2.91386209e-02f },
    },
    {
      { -4.05376032e-02f, 8.00454989e-03f, 4.82707210e-02f, 4.39410843e-02f, 4.35583815e-02f },
      { 1.31587051e-02f, -4.54133675e-02f, -5.43303899e-02f, -4.69604060e-02f, 2.92161610e-02f },
      { 2.15341188e-02f, 5.63783906e-02f, -6.08207732e-02f, -1.12371258e-02f, 1.99647881e-02f },
      { 5.63373752e-02f, -2.04918198e-02f, 1.71547942e-02f, -3.48297581e-02f, 2.35896371e-02f },
      { 5.98086677e-02f, -6.11450151e-02f, -2.84995176e-02f, -5.04074171e-02f, -2.76889950e-02f },
    },
    {
      { -7.52532668e-03f, -7.01295212e-02f, -3.17249307e-03f, -6.71898713e-04f, 1.60364583e-02f },
      { -4.23058644e-02f, -8.08013454e-02f, -5.91298938e-02f, -1.02305664e-02f, 1.32205589e-02f },
      { 1.41968997e-02f, -7.33522279e-03f, 1.08630611e-02f, 6.86189206e-03f, -7.31051266e-02f },
      { 2.58918945e-02f, -3.20947543e-02f, -5.16655073e-02f, -7.00337738e-02f, -7.18496740e-02f },
      { -7.27702230e-02f, 2.75487304e-02f, 1.52278896e-02f, -7.90638402e-02f, 1.15366175e-03f },
    },
    {
      { 1.23849446e-02f, -8.92524421e-02f, 7.77544454e-04f, -2.06073956e-03f, 1.51278377e-02f },
      { 2.58789659e-02f, 2.39024609e-02f, -7.65422583e-02f, -2.23236606e-02f, -5.27072214e-02f },
      { -7.04489872e-02f, -5.38296178e-02f, -6.90052472e-03f, -1.54868783e-02f, -6.15660250e-02f },
      { 4.08519991e-03f, -4.66222912e-02f, -6.96816668e-02f, -5.29822079e-04f, -8.76017734e-02f },
      { -6.62626624e-02f, -7.92389214e-02f, -8.46030638e-02f, 3.14319991e-02f, -5.07043935e-02f },
    },
    {
      { 1.50428880e-02f, 2.69428585e-02f, -4.47178558e-02f, -8.71560536e-03f, -7.64577091e-02f },
      { -8.56028870e-02f, -6.34723678e-02f, -2.69607492e-02f, -5.44295348e-02f, -4.48634103e-02f },
      { -3.19772325e-02f, -3.58196199e-02f, -8.15082043e-02f, -3.28197628e-02f, -6.49397150e-02f },
      { -6.50336295e-02f, -7.41394833e-02f, -8.20508897e-02f, -1.11118611e-02f, -4.65722568e-02f },
      { -5.23605645e-02f, -4.62652557e-02f, -1.19273253e-02f, -5.89863323e-02f, 3.41052562e-02f },
    },
    {
      { -4.35563475e-02f, -7.05485940e-02f, -7.47029716e-03f, -9.07722339e-02f, -5.58966063e-02f },
      { -6.42037615e-02f, -8.62244591e-02f, -5.06343022e-02f, 2.76018679e-02f, 6.64340006e-03f },
      { -8.17951486e-02f, -8.28292966e-02f, -4.38347124e-02f, -2.40875538e-02f, -7.27302581e-02f },
      { 2.27485728e-02f, -1.55734038e-03f, -1.31058237e-02f, 2.49388218e-02f, -1.56720113e-02f },
      { -9.11182389e-02f, 2.57101394e-02f, 3.03707980e-02f, -6.19817786e-02f, -1.56247960e-02f },
    },
    {
      { 4.64461232e-03f, -3.80886346e-02f, 2.25246139e-02f, -4.80462722e-02f, -2.44235583e-02f },
      { -3.64068896e-02f, 2.48777196e-02f, -5.25413938e-02f, 3.23474072e-02f, -3.87111716e-02f },
      { -2.53889803e-03f, -7.98985213e-02f, 2.32314412e-02f, -2.66010594e-02f, -5.24220020e-02f },
      { -5.74717559e-02f, -6.50925115e-02f, -8.75648186e-02f, -8.20545629e-02f, -5.89620583e-02f },
      { 1.34524014e-02f, -5.93120418e-02f, -7.63741806e-02f, -4.89361398e-02f, -2.86578853e-02f },
    },
    {
      { -1.37123521e-02f, -2.77488567e-02f, -5.50128557e-02f, 5.57091041e-03f, 4.81171869e-02f },
      { -1.22751296e-03f, -2.63805781e-03f, -3.02219838e-02f, 3.63216065e-02f, -2.77268905e-02f },
      { -3.42516191e-02f, 2.58570593e-02f, -1.23490961e-02f, 4.99605387e-02f, -5.96471056e-02f },
      { -3.27742733e-02f, -5.17222583e-02f, 5.47664240e-02f, -6.56040898e-03f, -1.14009308e-03f },
      { 8.44446570e-03f, -6.56944662e-02f, 2.96033639e-02f, 2.68646963e-02f, -8.23877230e-02f },
    },
    {
      { 1.98588483e-02f, 5.95259331e-02f, 1.22082494e-02f, 3.32907774e-02f, -2.83073224e-02f },
      { -2.72467434e-02f, 3.97027656e-03f, -4.67483327e-03f, 4.71624248e-02f, -5.33005558e-02f },
      { -5.09222224e-03f, 1.55085586e-02f, 5.72644211e-02f, -3.75196636e-02f, 2.71950774e-02f },
      { 5.40611483e-02f, 6.08599000e-02f, -2.56210230e-02f, 1.64891891e-02f, -2.99257748e-02f },
      { 2.48249657e-02f, -4.50788476e-02f, -5.29250875e-02f, 3.83889638e-02f, 4.10535000e-02f },
    },
    {
      { 4.50178236e-03f, -5.50654233e-02f, -3.95182148e-02f, -1.50713529e-02f, -1.44772734e-02f },
      { 1.67716239e-02f, -4.30279151e-02f, -7.84866214e-02f, -1.44493319e-02f, -8.31214562e-02f },
      { -6.98474869e-02f, -3.30900750e-03f, -6.72594905e-02f, -1.97814144e-02f, 1.64071023e-02f },
      { -8.22073966e-02f, -6.44474849e-02f, 2.43653040e-02f, -6.95301592e-02f, -2.69992184e-02f },
      { -7.11951703e-02f, -3.71063389e-02f, -6.15702337e-03f, -1.19662343e-03f, -2.53408831e-02f },
    },
    {
      { -1.49247078e-02f, -5.24541885e-02f, -5.24421083e-03f, -8.64954889e-02f, -1.33662522e-02f },
      { 1.00652967e-02f, -3.36050987e-02f, 3.32295778e-03f, 2.32288055e-02f, 1.89188938e-03f },
      { 1.72631778e-02f, -8.88380706e-02f, -2.89898943e-02f, -6.98092878e-02f, -4.46975343e-02f },
      { 6.94399653e-03f, -6.41333535e-02f, 1.46189509e-02f, -7.57529587e-03f, -7.89190363e-03f },
      { -4.43879180e-02f, -8.10510889e-02f, -8.56509209e-02f, 2.62798984e-02f, -4.45884988e-02f },
    },
    {
      { 1.02590732e-02f, -8.32309797e-02f, -5.46222553e-02f, 2.72446983e-02f, 1.75292883e-02f },
      { -7.46596828e-02f, -4.55659255e-02f, 1.59377810e-02f, -7.31575675e-03f, -2.64913402e-02f },
      { -6.31023720e-02f, -6.28156215e-02f, -2.92111300e-02f, -6.16231151e-02f, -2.03902740e-02f },
      { -2.93981228e-02f, -6.00199727e-03f, -8.92706309e-03f, 1.29890116e-02f, -8.07160065e-02f },
      { -6.34424984e-02f, -5.32807261e-02f, -2.49064881e-02f, -7.61770234e-02f, -4.05616537e-02f },
    },
    {
      { 1.99739374e-02f, 3.52044106e-02f, -1.17031382e-02f, -4.55329977e-02f, -1.13566630e-02f },
      { 7.03919213e-03f, -6.41773567e-02f, 9.88269318e-03f, 1.79932988e-03f, -3.47119309e-02f },
      { 2.43624114e-03f, -8.08545649e-02f, -7.42160827e-02f, -4.44718098e-05f, 2.55109742e-02f },
      { 9.42182634e-03f, -8.08836743e-02f, -7.70535991e-02f, -4.55972962e-02f, -3.43994498e-02f },
      { -5.30589931e-02f, 3.49059626e-02f, -9.61380824e-03f, -5.32548726e-02f, 8.20872281e-03f },
    },
    {
      { -8.71546846e-03f, -6.32706657e-02f, 2.02288162e-02f, -6.59094006e-02f, -7.21049756e-02f },
      { -7.66470134e-02f, -9.83886234e-03f, -4.13250923e-02f, -4.27050143e-02f, -6.04312792e-02f },
      { -3.40076499e-02f, -3.10535561e-02f, -7.20282048e-02f, 4.39063972e-03f, -2.94918697e-02f },
      { -4.70687710e-02f, 6.80912146e-03f, 6.22831145e-03f, -5.70050962e-02f, -6.17337823e-02f },
      { -3.35754417e-02f, -6.65778592e-02f, 1.31788310e-02f, -1.38146542e-02f, -3.51657383e-02f },
    },
    {
      { 2.66929027e-02f, -8.22787210e-02f, -4.72649075e-02f, -5.90697713e-02f, 8.60449392e-03f },
      { 3.62825021e-02f, -2.01420709e-02f, -6.52151704e-02f, 7.28212856e-03f, -8.40593651e-02f },
      { 5.16498927e-03f, 1.61404386e-02f, 1.64841246e-02f, -4.27628756e-02f, -3.98946144e-02f },
      { -4.69873808e-02f, 8.85372143e-03f, -3.34420428e-02f, -6.14113268e-03f, 2.15684436e-02f },
      { -2.80692820e-02f, -2.30037849e-02f, 3.45948264e-02f, -7.13007664e-03f, -6.10512942e-02f },
    },
    {
      { -4.88785580e-02f, -4.00107075e-03f, 3.55465896e-02f, 2.17578330e-04f, 3.51969600e-02f },
      { -1.39448754e-02f, 6.78579435e-02f, 4.79946584e-02f, 2.37940550e-02f, 8.13960563e-03f },
      { 5.75639606e-02f, 1.59581378e-02f, 6.49926141e-02f, -2.21568104e-02f, -5.42782620e-02f },
      { 3.89372651e-03f, 5.73813505e-02f, 2.19660476e-02f, 3.18707339e-02f, -7.97483250e-02f },
      { -6.70095831e-02f, -3.25485878e-02f, 8.12303089e-03f, -6.15053028e-02f, -3.45934071e-02f },
    },
    {
      { 5.27998321e-02f, -6.09552562e-02f, -3.02397627e-02f, -2.05533579e-02f, -6.00793362e-02f },
      { 2.56677456e-02f, 1.34265386e-02f, 2.06854604e-02f, -5.86580038e-02f, -1.85378157e-02f },
      { 1.01851858e-02f, -3.86792757e-02f, 1.06445514e-02f, 5.95110320e-02f, 5.59385307e-02f },
      { -3.25598791e-02f, 5.20235710e-02f, 2.63119452e-02f, -3.74888703e-02f, 1.60707943e-02f },
      { 3.35502215e-02f, 3.20406444e-02f, 2.60509551e-04f, 5.59414960e-02f, -5.50181270e-02f },
    },
    {
      { 3.21617499e-02f, -4.00238410e-02f, 5.13410233e-02f, 2.91197412e-02f, 3.86496074e-02f },
      { 4.88201901e-02f, -5.39015047e-02f, 3.93622415e-03f, -4.84807650e-03f, 1.22037278e-02f },
      { -6.75315037e-02f, 2.45799087e-02f, 4.29542596e-03f, -2.87370142e-02f, -4.26681936e-02f },
      { 1.24891978e-02f, -3.32838483e-02f, -5.60302250e-02f, 3.86602469e-02f, -8.37950855e-02f },
      { -5.69478273e-02f, 3.38283777e-02f, -7.53842071e-02f, 2.90585794e-02f, -1.51908565e-02f },
    },
    {
      { -4.30762358e-02f, 2.24454626e-02f, 1.09878350e-02f, -7.22893700e-02f, 1.35498438e-02f },
      { -3.40909660e-02f, -6.35406449e-02f, 2.91908048e-02f, -8.86242837e-03f, 2.84243990e-02f },
      { -3.08921915e-02f, -3.40466038e-03f, -8.35830942e-02f, -2.24684868e-02f, -7.62071013e-02f },
      { -6.96337223e-02f, -8.15102383e-02f, -6.72347173e-02f, 2.80599948e-02f, 3.05026900e-02f },
      { -8.37602243e-02f, 8.50142073e-03f, -2.06443127e-02f, -6.55492721e-03f, -6.03036210e-03f },
    },
  },
  {
    {
      { 2.12833092e-01f, 4.81917486e-02f, 9.80072189e-03f, 1.06437176e-01f, 1.54247507e-01f },
      { 2.21220061e-01f, 1.28455922e-01f, 1.44448383e-02f, 6.67572320e-02f, 1.94820836e-01f },
      { 2.81740397e-01f, 3.15135747e-01f, 1.97554260e-01f, 5.75201772e-02f, 6.37652203e-02f },
      { 9.68040898e-02f, 2.02408686e-01f, 2.96048999e-01f, 2.85381794e-01f, 1.88274831e-01f },
      { 1.47553444e-01f, 1.61527976e-01f, 3.28290641e-01f, 2.71970063e-01f, 9.38130263e-03f },
    },
    {
      { -6.52442947e-02f, -2.56676108e-01f, -1.34679049e-01f, 7.43088573e-02f, 1.01194521e-02f },
      { -3.94142419e-02f, -9.19262171e-02f, -1.98342398e-01f, 3.63052189e-02f, 4.82377447e-02f },
      { 3.02932058e-02f, -2.54048724e-02f, -4.47431989e-02f, -3.34559232e-01f, -1.87648281e-01f },
      { -3.94131020e-02f, -1.05717085e-01f, -5.03761619e-02f, -1.11093618e-01f, -2.01258212e-02f },
      { -2.94503476e-02f, 5.22479117e-02f, 1.63960680e-01f, 7.90046081e-02f, -9.01517421e-02f },
    },
    {
      { -1.01770990e-01f, -6.15957528e-02f, -2.70727705e-02f, 9.69496816e-02f, 4.49086912e-02f },
      { -1.06382169e-01f, -1.31028563e-01f, -1.20419353e-01f, -1.22405089e-01f, -7.12718442e-02f },
      { -9.97791514e-02f, -1.82730719e-01f, -8.05104524e-02f, -1.07219435e-01f, 8.03559050e-02f },
      { -8.97857174e-02f, -2.56525427e-01f, -3.32200378e-01f, -1.80990458e-01f, 1.87034845e-01f },
      { 1.53027680e-02f, -1.86469048e-01f, -2.92061359e-01f, 9.30635445e-03f, 2.21219003e-01f },
    },
    {
      { 3.39917615e-02f, 1.90331534e-01f, 2.76440252e-02f, -1.33138344e-01f, 4.93855178e-02f },
      { -3.08817867e-02f, 2.83321906e-02f, 3.52459066e-02f, 3.28518152e-02f, 1.23809613e-01f },
      { 2.74758856e-03f, -8.29296038e-02f, 1.11908905e-01f, 2.11768851e-01f, 1.22269243e-01f },
      { -6.87490553e-02f, -1.00403838e-01f, 6.09353278e-03f, 1.41613081e-01f, 3.49422768e-02f },
      { -3.47430818e-02f, -6.72357008e-02f, -5.58798462e-02f, -2.20148396e-02f, 2.37533972e-02f },
    },
    {
      { 3.24781463e-02f, 1.15720704e-01f, 5.52493893e-02f, -8.47766325e-02f, -1.94915291e-02f },
      { 6.32803813e-02f, 2.29448020e-01f, 2.36645818e-01f, 8.23632777e-02f, -1.03652468e-02f },
      { -1.44220099e-01f, 1.84894666e-01f, 3.17514151e-01f, 2.98858345e-01f, 1.66828319e-01f },
      { 6.47495920e-03f, 1.02068288e-02f, 1.13825545e-01f, 2.40266249e-01f, 2.85995714e-02f },
      { 6.73379526e-02f, 3.67479920e-02f, 1.01309434e-01f, 9.43194032e-02f, 1.50832999e-02f },
    },
    {
      { -8.45394656e-02f, -7.41742477e-02f, -9.53445435e-02f, -1.03500649e-01f, 3.90547477e-02f },
      { -2.52761632e-01f, -4.75405306e-02f, -8.36706012e-02f, -1.09762125e-01f, 4.76466082e-02f },
      { -2.98006505e-01f, -3.77210796e-01f, -1.70854434e-01f, 7.80221298e-02f, 8.34301412e-02f },
      { 2.01654322e-02f, -4.17629689e-01f, -3.48086506e-01f, -4.03749235e-02f, 2.68602520e-02f },
      { 9.60525647e-02f, -1.26180694e-01f, -2.96254486e-01f, -1.05338186e-01f, -4.62405682e-02f },
    },
    {
      { 7.13775456e-02f, -2.10629627e-01f, -1.72042549e-01f, -5.56632411e-04f, -1.29716590e-01f },
      { 5.27915061e-02f, -2.18000025e-01f, -1.17398836e-01f, 2.21718233e-02f, -1.53778493e-01f },
      { 6.96792975e-02f, -6.32106513e-02f, -8.13515708e-02f, -4.66294028e-02f, -4.28461619e-02f },
      { 4.99998219e-02f, 2.39195317e-01f, 7.91245550e-02f, -2.90680956e-03f, -4.96593071e-03f },
      { -1.73238605e-01f, 8.15841705e-02f, 1.71138421e-01f, -7.00891614e-02f, 4.06680889e-02f },
    },
    {
      { 5.45061454e-02f, -1.75857261e-01f, -1.36222571e-01f, -4.68981713e-02f, -3.20677049e-02f },
      { -5.19335344e-02f, -4.20415290e-02f, -1.04983248e-01f, -1.13007233e-01f, -2.13635221e-01f },
      { -4.52666031e-03f, -5.57928067e-03f, -8.40553194e-02f, -1.00990348e-01f, 5.88008277e-02f },
      { 1.27564475e-01f, 1.05017945e-01f, -3.41183357e-02f, -1.59067124e-01f, 5.78523129e-02f },
      { 6.49691671e-02f, 2.78522540e-02f, -5.30538000e-02f, -1.69632316e-01f, -3.61854844e-02f },
    },
    {
      { 5.11197932e-02f, -1.53643653e-01f, -2.03265712e-01f, 7.31247803e-03f, 3.13916653e-02f },
      { 3.02852020e-02f, -1.07608460e-01f, -4.13844645e-01f, -2.90668547e-01f, 1.52667239e-01f },
      { -7.71636292e-02f, 4.16903495e-05f, -6.36385381e-03f, -2.11262211e-01f, -2.59699047e-01f },
      { -6.97113052e-02f, -1.06864981e-01f, 4.67506424e-02f, 3.42699625e-02f, -9.91800502e-02f },
      { -3.98539193e-02f, 2.30418649e-02f, 2.09568396e-01f, 2.31817603e-01f, 2.67485119e-02f },
    },
    {
      { -6.23430423e-02f, 7.30005428e-02f, 8.71581957e-03f, -6.14214167e-02f, 6.23458736e-02f },
      { 1.74480621e-02f, -4.21157442e-02f, -1.62649937e-02f, -6.05215579e-02f, 7.36445561e-02f },
      { -2.47991853e-03f, -2.06168562e-01f, -1.79967701e-01f, -8.79307985e-02f, 1.78299211e-02f },
      { 3.89326923e-02f, -1.99042290e-01f, -3.15308481e-01f, -6.75422922e-02f, -5.87560013e-02f },
      { 2.00189352e-02f, -1.00992091e-01f, -2.31734887e-01f, -1.26408517e-01f, 4.04266566e-02f },
    },
    {
      { -1.50616303e-01f, -1.53733790e-03f, -5.01113907e-02f, -5.31002730e-02f, 9.50080603e-02f },
      { -1.95511490e-01f, -1.53791877e-02f, 1.46089211e-01f, 2.18882393e-02f, -7.32238442e-02f },
      { -1.28419384e-01f, -1.65475845e-01f, 3.72737758e-02f, 1.23838603e-01f, 1.89271197e-01f },
      { 1.24771051e-01f, -1.21299230e-01f, -1.27796859e-01f, 3.83663476e-02f, 9.56683606e-02f },
      { 1.56972632e-01f, 1.95910502e-02f, -1.37617990e-01f, -1.55650824e-01f, -3.99030186e-02f },
    },
    {
      { 1.41274305e-02f, -7.17879180e-03f, 7.86577351e-03f, -3.39706168e-02f, 2.03680806e-02f },
      { 8.91694352e-02f, -8.35033953e-02f, -1.98219672e-01f, -1.38275689e-02f, 6.89042136e-02f },
      { 1.22856215e-01f, -7.84497708e-02f, -1.87405661e-01f, -2.30258942e-01f, -1.07097588e-01f },
      { -7.94230551e-02f, -9.44928452e-02f, -2.79793233e-01f, -1.19075865e-01f, 3.22957560e-02f },
      { -1.02063142e-01f, -4.86923568e-02f, -2.82621682e-02f, -4.22072746e-02f, 5.20804897e-02f },
    },
    {
      { 5.92474788e-02f, -2.90566683e-02f, -5.70773296e-02f, 1.76048517e-01f, 4.18644845e-02f },
      { 8.17473680e-02f, -4.05113213e-02f, -1.70999169e-01f, -7.45513886e-02f, 1.07363082e-01f },
      { 5.13686500e-02f, -5.43852858e-02f, -1.51625827e-01f, -2.88666010e-01f, -6.54570907e-02f },
      { -6.16153814e-02f, -8.58363584e-02f, -1.48529708e-01f, -2.64394343e-01f, -7.19783530e-02f },
      { -8.29204991e-02f, -1.01137169e-01f, -9.83241498e-02f, -7.01619536e-02f, 2.21394608e-03f },
    },
    {
      { -1.93069894e-02f, -2.24985123e-01f, -8.57869387e-02f, 1.90948583e-02f, 2.94169504e-02f },
      { 1.03315912e-01f, -1.17221363e-01f, -1.09827377e-01f, 1.13437928e-01f, 5.31623363e-02f },
      { 8.88893381e-02f, 5.42138629e-02f, 2.21356787e-02f, -1.34116128e-01f, -1.75270647e-01f },
      { -2.45434493e-02f, -4.89639938e-02f, 6.40501874e-03f, -1.17275104e-01f, -3.97441313e-02f },
      { 2.57464107e-02f, -1.75241381e-02f, 8.29096660e-02f, -9.65206549e-02f, -1.29983962e-01f },
    },
    {
      { -6.17928244e-02f, 4.51695696e-02f, 4.14197333e-02f, 3.26679870e-02f, -4.89911065e-02f },
      { -4.68910150e-02f, 1.66537017e-02f, -1.77218392e-02f, -3.18184160e-02f, -1.33747533e-02f },
      { 2.42348779e-02f, -4.94951233e-02f, -6.92849606e-03f, -1.95751637e-02f, -1.96349975e-02f },
      { -2.14541890e-03f, -4.45181802e-02f, 2.46766917e-02f, 4.45414670e-02f, -1.71344895e-02f },
      { 1.22319281e-04f, 1.68690383e-02f, -6.23337552e-02f, 5.24022356e-02f, 1.57687385e-02f },
    },
    {
      { 4.72077765e-02f, -2.45612450e-02f, 5.35916351e-02f, 6.26963452e-02f, 1.10172825e-02f },
      { 9.28272605e-02f, 5.26737198e-02f, -3.07007302e-02f, 4.66096327e-02f, -4.15524691e-02f },
      { 4.88570966e-02f, 4.00424004e-02f, -1.04721608e-02f, -5.51582128e-02f, 1.30160246e-02f },
      { 1.10784568e-01f, 6.34886250e-02f, -5.95351905e-02f, -7.75883421e-02f, 3.11473571e-02f },
      { 6.38481230e-02f, 5.40677533e-02f, 1.67305898e-02f, -1.05614811e-01f, 1.04869884e-02f },
    },
    {
      { -4.09652153e-03f, 4.69880812e-02f, 7.10782334e-02f, -3.78064287e-04f, -1.30656689e-01f },
      { 1.28518447e-01f, 8.92859697e-02f, 1.34707749e-01f, 3.19460705e-02f, -1.31433576e-01f },
      { 8.52684900e-02f, 1.78771049e-01f, 1.83409542e-01f, 1.35487795e-01f, 1.67342238e-02f },
      { 3.86920273e-02f, 1.65875703e-01f, 1.76626801e-01f, 3.39986011e-02f, 1.72732898e-03f },
      { 4.20246609e-02f, 8.61051753e-02f, 6.24074377e-02f, 6.36843848e-04f, -8.71129520e-03f },
    },
    {
      { -4.64595892e-02f, -3.91135775e-02f, -9.02132690e-03f, -1.18080489e-01f, -9.88986716e-02f },
      { -7.60628060e-02f, 3.49512622e-02f, 4.30811271e-02f, -6.27004504e-02f, -5.60257323e-02f },
      { 7.20264688e-02f, -1.98647175e-02f, -1.14977740e-01f, -1.52899325e-02f, -6.29936829e-02f },
      { 2.22643420e-01f, 3.38737071e-02f, -2.63995528e-02f, -1.04936130e-01f, -8.86509791e-02f },
      { 1.92710415e-01f, 2.98596956e-02f, -1.33863792e-01f, -9.45662707e-02f, -6.91627115e-02f },
    },
    {
      { -1.67370699e-02f, -3.09964977e-02f, 4.10100035e-02f, -8.58084671e-03f, 5.48308343e-02f },
      { -6.41222298e-02f, 1.36520252e-01f, 2.05839574e-01f, 1.47062853e-01f, 9.58335469e-04f },
      { -1.10496230e-01f, 1.74766909e-02f, 6.24609850e-02f, 2.18068182e-01f, 1.66002676e-01f },
      { 5.11207990e-02f, 9.36985016e-02f, 1.25463217e-01f, 4.60882336e-02f, -8.78905505e-03f },
      { 1.29974112e-01f, -3.79348435e-02f, -4.28818204e-02f, -1.52347744e-01f, 2.19759401e-02f },
    },
    {
      { 4.96811308e-02f, 8.80070999e-02f, -5.63087985e-02f, -5.08576632e-02f, -8.71956572e-02f },
      { 9.05742645e-02f, 8.32019746e-02f, 1.52521804e-02f, -6.54205233e-02f, -2.09971741e-02f },
      { -8.34746473e-03f, 2.69538105e-01f, 2.14992672e-01f, 1.24506116e-01f, -2.23416835e-02f },
      { -3.37529294e-02f, 8.62610787e-02f, 1.32873997e-01f, 1.40607700e-01f, -3.80933061e-02f },
      { -7.33271614e-02f, 1.00485012e-01f, 1.57004282e-01f, 7.86199495e-02f, -1.10699035e-01f },
    },
    {
      { -7.78553169e-03f, -6.48267707e-03f, 3.43279690e-02f, -1.67178828e-02f, 9.15266480e-03f },
      { 3.29624526e-02f, -1.70091003e-01f, -1.65582135e-01f, -3.44207212e-02f, 1.26718029e-01f },
      { 1.13289207e-01f, -1.50180772e-01f, -1.26410872e-01f, -7.08039105e-02f, 1.70579590e-02f },
      { 6.53680712e-02f, -4.95833121e-02f, -1.68073505e-01f, -1.19030856e-01f, -1.05298311e-02f },
      { 4.92537580e-02f, -7.62908980e-02f, 3.36913839e-02f, 3.38672586e-02f, 9.89429057e-02f },
    },
    {
      { 1.65697634e-01f, -3.07312384e-02f, -2.08056808e-01f, -3.75984997e-01f, -1.50480896e-01f },
      { 1.75496876e-01f, -9.08310041e-02f, -1.13281466e-01f, -1.29087463e-01f, -3.90905648e-01f },
      { -2.20745951e-02f, -2.26030290e-01f, 4.04463895e-02f, 2.19479576e-02f, -3.63421589e-01f },
      { -3.20388556e-01f, -3.38558495e-01f, -1.83774233e-02f, 4.72183228e-02f, -1.11731470e-01f },
      { -2.30273977e-01f, -7.79533163e-02f, -5.81853837e-02f, 1.43778035e-02f, 3.50038223e-02f },
    },
    {
      { 1.03663541e-01f, 1.01840347e-01f, 1.35089457e-02f, 1.07465005e-02f, 9.45217088e-02f },
      { 1.83646232e-01f, 1.46554977e-01f, -4.34886403e-02f, -1.79052465e-02f, 6.00526668e-02f },
      { 1.40893236e-01f, 3.54078040e-02f, -9.02326405e-02f, -2.03696281e-01f, -1.54427150e-02f },
      { 1.00348502e-01f, -1.00768037e-01f, -2.04234913e-01f, -2.24022776e-01f, -3.51898745e-02f },
      { 1.22797705e-01f, -4.44642715e-02f, -1.89847767e-01f, -1.41356274e-01f, 1.05275206e-01f },
    },
    {
      { -5.38624115e-02f, -1.73316710e-02f, 3.60628851e-02f, 3.90616469e-02f, -2.29336824e-02f },
      { 4.70832102e-02f, -5.80691919e-02f, -2.51543894e-02f, -1.38077792e-03f, 6.33996725e-02f },
      { 1.06589064e-01f, -2.37435438e-02f, 9.64175444e-03f, -1.04177698e-01f, 1.40948566e-02f },
      { -1.78421158e-02f, 7.40792826e-02f, -3.57206538e-02f, -1.61707088e-01f, -2.32406072e-02f },
      { -1.46484356e-02f, 1.00894272e-02f, 3.83480228e-02f, -4.44305092e-02f, 2.98908260e-02f },
    },
    {
      { -1.13837114e-02f, -5.57451919e-02f, -4.19398397e-02f, -1.72328129e-02f, 1.02394838e-02f },
      { -9.21440497e-02f, -9.09532886e-03f, 3.77551727e-02f, 6.46642298e-02f, 6.19815476e-03f },
      { -1.17333494e-01f, -1.90020055e-01f, -8.15448444e-03f, 8.18268359e-02f, 1.76587060e-01f },
      { 7.10923523e-02f, -7.27960095e-02f, -2.29795635e-01f, -1.65050235e-02f, 1.31043568e-01f },
      { 1.35399729e-01f, 2.37181745e-02f, -7.30945617e-02f, -6.84603900e-02f, 9.53240544e-02f },
    },
    {
      { 4.62580696e-02f, 1.05782799e-01f, 6.91501126e-02f, 1.93214521e-01f, 9.56920162e-02f },
      { 7.27843540e-03f, 1.24882326e-01f, 1.59956768e-01f, 1.55707344e-01f, 6.17243759e-02f },
      { 1.05684593e-01f, 5.75145595e-02f, 6.83880970e-02f, 1.90998718e-01f, 2.83684760e-01f },
      { 1.44949496e-01f, 1.37970984e-01f, 5.69141321e-02f, 5.01022600e-02f, 9.39187035e-02f },
      { 7.57283196e-02f, 3.33141349e-02f, 7.75298709e-03f, -1.61711335e-01f, 1.16612688e-01f },
    },
    {
      { -5.42490557e-02f, 9.09468010e-02f, 4.51907963e-02f, -5.85355680e-04f, -3.07729263e-02f },
      { 5.32031804e-02f, 1.82547182e-01f, 2.31060520e-01f, 6.74541369e-02f, -1.72980949e-02f },
      { 4.71990928e-02f, 7.84640759e-02f, 1.24183521e-01f, 1.71889171e-01f, 2.42694784e-02f },
      { 1.99628416e-02f, 5.46962842e-02f, 1.61202639e-01f, 6.73559606e-02f, 2.41400506e-02f },
      { 1.07870242e-02f, 1.57352258e-02f, -4.33986336e-02f, -6.59547076e-02f, -8.84352475e-02f },
    },
    {
      { 6.11025430e-02f, -4.89745438e-02f, -5.39580621e-02f, -6.90731034e-02f, 2.58602891e-02f },
      { 1.47710759e-02f, -7.75178894e-02f, -1.42763287e-01f, -9.08885300e-02f, 6.67770058e-02f },
      { -1.11653432e-01f, -1.82495058e-01f, -2.62510061e-01f, -1.29397884e-01f, 1.91858336e-02f },
      { 3.93486917e-02f, -2.83779860e-01f, -2.14466542e-01f, -1.49503842e-01f, 4.85634431e-02f },
      { -1.18807079e-02f, -3.30354013e-02f, -1.15848549e-01f, -1.75637286e-02f, 1.21354960e-01f },
    },
    {
      { -5.85258380e-03f, -7.32705742e-02f, -4.20741625e-02f, -5.80280609e-02f, -9.19023587e-04f },
      { 5.76918498e-02f, -1.39446825e-01f, -3.46341372e-01f, -3.12928669e-02f, 7.38263056e-02f },
      { 1.06499054e-01f, -2.10577454e-02f, -1.62934974e-01f, -8.09112862e-02f, -1.26337320e-01f },
      { -2.52530817e-02f, -5.34861051e-02f, -2.13409029e-02f, 2.08551511e-02f, 1.08242467e-01f },
      { -1.27077987e-02f, -5.41539825e-02f, 1.66494846e-01f, 1.29559338e-01f, 1.16174303e-01f },
    },
    {
      { -3.18743587e-02f, -4.80317324e-02f, 5.44878878e-02f, -2.40852982e-02f, 1.05672674e-02f },
      { -5.45532815e-02f, -2.32123267e-02f, 4.98152338e-02f, 5.48262782e-02f, -1.73575096e-02f },
      { -5.39039485e-02f, 4.52404693e-02f, -4.95939441e-02f, 2.70468406e-02f, -3.67486849e-02f },
      { -4.61996496e-02f, 2.47683823e-02f, -2.69592535e-02f, -8.33328813e-03f, 3.02120205e-02f },
      { 1.45909861e-02f, -4.26954105e-02f, 3.64367105e-03f, -3.49428644e-03f, 2.83755511e-02f },
    },
    {
      { -2.63576247e-02f, -2.78722048e-01f, -1.47022933e-01f, -2.06376426e-02f, 1.05977558e-01f },
      { 1.31722510e-01f, -1.21461943e-01f, -1.77021131e-01f, 9.38075855e-02f, 6.21111803e-02f },
      { 1.88346267e-01f, 2.31233045e-01f, 1.10292017e-01f, -1.51183173e-01f, -1.76883638e-01f },
      { 7.34052621e-03f, 5.71011985e-03f, 6.52292445e-02f, 6.03336915e-02f, 8.40931311e-02f },
      { -4.06947136e-02f, 1.35706261e-01f, 1.65846869e-01f, 8.22621137e-02f, -2.25127593e-01f },
    },
    {
      { 1.83422446e-01f, 1.75506957e-02f, -8.14286843e-02f, -1.61343068e-02f, -1.20346360e-01f },
      { 1.85521632e-01f, 7.87509307e-02f, 9.45484787e-02f, 6.04096390e-02f, -2.45912090e-01f },
      { 1.54611304e-01f, 1.63185373e-01f, 1.81223676e-01f, 1.37913957e-01f, -5.83090484e-02f },
      { 1.19420081e-01f, 3.30562860e-01f, 3.63850325e-01f, 1.01723097e-01f, -1.14245586e-01f },
      { -1.79751627e-02f, 1.22777395e-01f, 2.39987537e-01f, 6.02325089e-02f, -1.24003865e-01f },
    },
  },
  {
    {
      { -9.17842239e-03f, -2.23996975e-02f, -5.99752553e-02f, -4.62808907e-02f, -3.61346155e-02f },
      { 1.96930096e-02f, -1.79051030e-02f, -8.48132297e-02f, -2.82707606e-02f, 1.00487759e-02f },
      { -4.39623296e-02f, -2.05672048e-02f, -2.61615287e-03f, 2.41301395e-02f, -3.48342210e-02f },
      { -3.13333124e-02f, 2.64053494e-02f, -6.92036236e-04f, -4.27077599e-02f, -7.98906386e-02f },
      { 2.33236551e-02f, -4.14167233e-02f, -6.22043721e-02f, 9.85942129e-03f, 2.36431267e-02f },
    },
    {
      { -4.35925536e-02f, -5.97888529e-02f, -2.16400456e-02f, 2.01874375e-02f, -6.96923677e-03f },
      { 5.16170934e-02f, 3.61946821e-02f, 8.72917101e-03f, 2.47032642e-02f, -4.08053733e-02f },
      { -2.71028234e-03f, 4.84061800e-02f, 4.33705235e-03f, -2.45806266e-04f, 1.84644444e-03f },
      { 4.76064384e-02f, -3.78632993e-02f, -1.09211924e-02f, 5.61751053e-03f, -6.31748736e-02f },
      { 2.45947437e-03f, 4.12907377e-02f, -2.29576360e-02f, 3.40399705e-02f, 1.71534959e-02f },
    },
    {
      { -1.49333645e-02f, -8.23265016e-02f, 3.37284580e-02f, 1.64815262e-02f, -8.10801089e-02f },
      { -3.65306772e-02f, 1.47214979e-02f, 2.64021959e-02f, 2.61991564e-02f, 5.82732586e-03f },
      { 2.24364158e-02f, -3.58103886e-02f, 3.16938274e-02f, 3.46595049e-02f, 3.45525183e-02f },
      { -6.01403527e-02f, -5.65369334e-03f, -4.01490517e-02f, 3.01707294e-02f, -4.57552485e-02f },
      { -3.69824097e-02f, 1.97345158e-03f, -1.87063422e-02f, 1.57000907e-02f, -1.96247883e-02f },
    },
    {
      { -4.62760590e-02f, 2.95047443e-02f, 4.58308831e-02f, 1.74214505e-03f, -2.17880551e-02f },
      { 3.31048891e-02f, -4.25648730e-04f, 6.88839098e-03f, -4.66728508e-02f, -4.00737599e-02f },
      { -7.06424704e-03f, -4.30240631e-02f, 2.97782235e-02f, -5.37854098e-02f, -6.49760514e-02f },
      { -5.30617349e-02f, 3.09842527e-02f, -2.65692864e-02f, 2.82346774e-02f, -5.88451885e-02f },
      { 1.73335560e-02f, -6.83871880e-02f, 1.10658668e-02f, -1.80722103e-02f, 1.01274028e-02f },
    },
    {
      { -4.58747819e-02f, -1.49330301e-02f, -5.79883810e-04f, -4.34487797e-02f, -4.84016202e-02f },
      { 2.96118725e-02f, 1.40350237e-02f, 2.61109099e-02f, -4.17118184e-02f, 2.90813297e-02f },
      { 2.71208324e-02f, -2.46842671e-02f, 1.20863868e-02f, -3.16761583e-02f, -4.50140350e-02f },
      { 4.75999601e-02f, 2.05111597e-02f, 2.69569596e-03f, -6.10707030e-02f, -2.11974909e-03f },
      { -6.35969341e-02f, -5.56668900e-02f, -7.01398700e-02f, 1.15410695e-02f, 3.80055606e-02f },
    },
    {
      { -7.22249672e-02f, -2.29549240e-02f, -2.37996001e-02f, 3.12102698e-02f, 2.56084837e-02f },
      { -2.06886865e-02f, -9.66648757e-03f, -7.43359281e-03f, -4.66356426e-02f, -1.27110509e-02f },
      { -8.42035636e-02f, -8.83161351e-02f, -1.97892841e-02f, 1.23674879e-02f, -4.91189696e-02f },
      { -6.51311129e-02f, -7.71700889e-02f, -1.56959966e-02f, -4.94905151e-02f, 1.65447462e-02f },
      { -9.15918723e-02f, -5.16529940e-02f, 1.92032233e-02f, 2.65399646e-02f, 1.70256849e-02f },
    },
    {
      { -7.70414397e-02f, -3.75713110e-02f, -4.90461178e-02f, -5.84308878e-02f, -2.54255068e-02f },
      { -4.06482294e-02f, -1.06680468e-02f, 4.21352312e-03f, -9.08825770e-02f, 6.29919395e-03f },
      { -8.32615942e-02f, -4.20862064e-02f, -6.82692230e-03f, -7.13225454e-02f, -5.47140166e-02f },
      { 2.40116585e-02f, 3.17576788e-02f, -5.97963482e-02f, -7.20295012e-02f, -2.48548388e-02f },
      { 6.10608328e-03f, 2.18951646e-02f, 1.44354207e-02f, 3.97958085e-02f, 4.05588746e-02f },
    },
    {
      { 1.33361425e-02f, -2.96542849e-02f, -8.93345382e-03f, -3.33063900e-02f, -6.52813390e-02f },
      { -1.89201888e-02f, -2.20755823e-02f, -3.98512930e-02f, -3.03036179e-02f, -1.08606331e-02f },
      { -2.84316321e-03f, 1.56121105e-02f, -1.19961901e-02f, -6.18782602e-02f, -5.34918718e-02f },
      { 4.33377065e-02f, 4.07330394e-02f, -6.57709464e-02f, -1.87260453e-02f, 1.43988365e-02f },
      { -4.98456359e-02f, -3.54019590e-02f, 3.92652154e-02f, 2.06810422e-02f, -3.93894501e-02f },
    },
    {
      { -5.80016803e-03f, -5.91397062e-02f, -6.63267747e-02f, 3.13187428e-02f, -3.72789279e-02f },
      { -8.72458518e-03f, -2.73490939e-02f, -8.73567834e-02f, -1.07055381e-02f, -4.02892344e-02f },
      { -5.35578132e-02f, -5.00002913e-02f, 1.87695827e-02f, -5.52000590e-02f, -7.75535684e-03f },
      { 1.62593238e-02f, -6.88938871e-02f, -9.50426888e-03f, -2.81083379e-02f, -5.71647212e-02f },
      { 2.41397154e-02f, 1.84001382e-02f, -4.08074819e-02f, 8.89907870e-03f, -5.83244823e-02f },
    },
    {
      { -4.23312038e-02f, -3.83001864e-02f, -1.81265082e-02f, -6.95265010e-02f, -9.85786691e-03f },
      { -7.23551884e-02f, -1.22679665e-03f, 3.39804031e-02f, -5.26991561e-02f, 4.09820303e-03f },
      { 3.40219471e-04f, -6.30143806e-02f, 2.57912651e-02f, 1.27707953e-02f, -3.68598774e-02f },
      { 1.04277972e-02f, 8.14194698e-03f, -3.80254015e-02f, 3.03419586e-02f, -1.32978745e-02f },
      { -4.86159921e-02f, -5.38226962e-03f, 6.05382491e-03f, 2.40124334e-02f, 2.78504640e-02f },
    },
    {
      { 3.15647013e-03f, -6.12527207e-02f, -6.69805706e-02f, -4.40276787e-03f, 4.03214134e-02f },
      { 4.10833247e-02f, -2.66975481e-02f, 6.18083216e-03f, -5.84272593e-02f, -5.41426465e-02f },
      { -6.62471801e-02f, 2.70392057e-02f, -6.87269792e-02f, -1.72742475e-02f, -3.17827286e-03f },
      { -5.12356162e-02f, -8.27573333e-03f, -4.58619110e-02f, -5.47233075e-02f, 1.06029455e-02f },
      { 3.91231067e-02f, -6.37499522e-03f, -5.51079540e-03f, 3.67633626e-02f, -5.99767081e-03f },
    },
    {
      { 4.02778648e-02f, 4.02332246e-02f, -3.77455354e-02f, 1.24389527e-03f, 2.44252365e-02f },
      { -5.31046689e-02f, -6.18829764e-02f, -2.59586442e-02f, -3.28797884e-02f, 2.48945653e-02f },
      { -2.92221401e-02f, -2.00425228e-03f, -5.35201058e-02f, 4.92681190e-02f, -3.18449065e-02f },
      { -4.28167880e-02f, -5.93914688e-02f, 3.01888473e-02f, -3.75457145e-02f, 4.65744026e-02f },
      { -1.46286609e-02f, 3.26656289e-02f, -4.61477973e-02f, -5.69786206e-02f, -4.36540358e-02f },
    },
    {
      { 5.08328713e-02f, -3.46570909e-02f, -3.73576023e-02f, 2.31995713e-02f, -6.22236617e-02f },
      { 1.90726109e-02f, 1.82070676e-02f, -4.96325940e-02f, -1.62567422e-02f, -2.43383553e-03f },
      { -3.56781222e-02f, 4.57286388e-02f, -5.56379929e-03f, -5.06702960e-02f, -5.26113771e-02f },
      { -3.58092450e-02f, -3.69040482e-02f, -4.51979823e-02f, -3.60823832e-02f, 3.21634971e-02f },
      { 3.28434110e-02f, 3.51413414e-02f, 1.03512015e-02f, -3.06012947e-02f, 9.58792493e-03f },
    },
    {
      { -4.91369478e-02f, 2.89365388e-02f, -8.42032023e-03f, -6.17620386e-02f, -4.71382551e-02f },
      { -5.94636165e-02f, -4.01489553e-04f, 5.14051467e-02f, -2.13935897e-02f, 1.35243265e-02f },
      { -3.52309421e-02f, -2.85226963e-02f, -5.16095832e-02f, 7.84813799e-03f, -8.63121822e-03f },
      { -2.27824226e-02f, -8.46804306e-03f, -5.23999035e-02f, -6.79316819e-02f, 5.25948368e-02f },
      { -4.02253754e-02f, -4.35173810e-02f, -1.72681622e-02f, 3.42226215e-02f, -1.56766400e-02f },
    },
    {
      { -4.99988459e-02f, 2.92495675e-02f, -4.59903013e-03f, 5.64569198e-02f, 4.99790302e-03f },
      { 3.26951407e-02f, -2.83758212e-02f, 3.07292398e-02f, 8.70276988e-03f, -6.20087981e-03f },
      { -1.32281100e-02f, 2.78567267e-03f, 5.59654534e-02f, -4.26946543e-02f, 5.20612448e-02f },
      { -4.87078950e-02f, 5.56715615e-02f, -1.85227375e-02f, -1.10106440e-02f, -4.73137498e-02f },
      { -5.10654263e-02f, 5.79125062e-02f, -3.90656330e-02f, 4.76456434e-02f, 1.25483535e-02f },
    },
    {
      { -7.13553280e-02f, 7.75244739e-03f, 4.14680764e-02f, 3.55338189e-03f, 2.18040845e-03f },
      { -3.97739783e-02f, 7.07459543e-03f, -6.39051944e-02f, -5.35240322e-02f, -2.97668856e-02f },
      { -6.26605302e-02f, 4.67063114e-02f, -2.02848986e-02f, -4.97984104e-02f, -2.16154009e-02f },
      { 1.52713452e-02f, -3.46286334e-02f, -3.15209925e-02f, 3.32976989e-02f, -5.73573671e-02f },
      { 5.00199459e-02f, -1.67943595e-03f, 4.35449928e-02f, 3.12142279e-02f, -6.62036762e-02f },
    },
    {
      { 2.58256309e-02f, 3.58478096e-03f, 1.42087489e-02f, 5.10454439e-02f, 4.45420519e-02f },
      { 1.34514440e-02f, -3.04646585e-02f, -1.26938801e-02f, -6.63766190e-02f, -6.73066229e-02f },
      { -3.76968645e-02f, 1.03528332e-02f, -2.29312829e-03f, 4.82677184e-02f, -2.57469434e-02f },
      { 1.72132086e-02f, -6.87556565e-02f, 1.58577356e-02f, -1.08678704e-02f, -3.78782749e-02f },
      { 2.82015782e-02f, -4.51312438e-02f, -3.96881439e-03f, -1.49361277e-02f, 1.49869872e-02f },
    },
    {
      { 7.88065605e-03f, -6.65472448e-02f, 3.64938229e-02f, 1.19437985e-02f, -2.45620473e-03f },
      { -3.59858572e-02f, 4.64793853e-02f, 1.21946642e-02f, 2.67509688e-02f, 2.77051399e-03f },
      { -9.44979675e-03f, -3.03623620e-02f, -2.60530487e-02f, 1.88345034e-02f, -4.12048176e-02f },
      { 3.76580469e-02f, 3.24005745e-02f, 6.55694166e-03f, 1.68572795e-02f, 2.68474519e-02f },
      { -3.18358429e-02f, -4.90859291e-03f, -1.63899995e-02f, 4.42389958e-02f, -1.63364951e-02f },
    },
    {
      { -4.72043641e-02f, -1.85666326e-02f, -1.89051428e-03f, -3.07299607e-02f, -2.80891433e-02f },
      { -1.51892789e-02f, 4.27708812e-02f, -4.79777716e-02f, -4.45390120e-02f, -3.58164646e-02f },
      { 9.56358481e-03f, -6.42932504e-02f, -1.54637955e-02f, -3.93886976e-02f, 5.23918644e-02f },
      { 1.68235023e-02f, -5.74151464e-02f, -4.97139134e-02f, 3.11135463e-02f, 9.76499356e-03f },
      { 5.00150248e-02f, -1.52451564e-02f, -3.22358906e-02f, -1.75709780e-02f, 4.69296016e-02f },
    },
    {
      { -4.06010188e-02f, -4.14710268e-02f, 1.99189093e-02f, -6.28135204e-02f, 9.23135900e-04f },
      { 2.58537978e-02f, -6.24683648e-02f, 3.65160480e-02f, 1.11057404e-02f, 1.40810516e-02f },
      { -1.72638930e-02f, -3.49613205e-02f, -6.13182709e-02f, -5.42224199e-02f, 4.54519913e-02f },
      { -5.48367798e-02f, 5.26292473e-02f, 1.55285401e-02f, -5.53045608e-02f, -3.23368274e-02f },
      { 3.51338424e-02f, 5.25691621e-02f, -4.98790704e-02f, -1.72751322e-02f, -2.68065464e-02f },
    },
    {
      { -2.30977274e-02f, -1.32752704e-02f, 3.78285125e-02f, 1.10487603e-02f, -4.23133150e-02f },
      { -2.48429310e-02f, -1.57428067e-02f, -6.93591833e-02f, -5.08015184e-03f, -1.53105902e-02f },
      { 2.71218196e-02f, -1.09495167e-02f, -2.73707733e-02f, -3.25126573e-03f, -4.21109386e-02f },
      { -4.38871048e-02f, -2.71144696e-02f, -2.10856344e-03f, 5.16367257e-02f, -3.21653322e-03f },
      { 3.19925835e-03f, 4.23829183e-02f, 2.91634873e-02f, 1.06198527e-02f, 2.88688336e-02f },
    },
    {
      { 8.05743877e-03f, -5.03769964e-02f, -9.52201802e-03f, 4.59478423e-02f, 5.15985936e-02f },
      { 2.39298269e-02f, 4.24386375e-02f, 5.51656671e-02f, -6.31929040e-02f, 1.67744029e-02f },
      { -7.47879734e-03f, 4.42606695e-02f, 2.07255725e-02f, -3.35170934e-03f, -6.08026870e-02f },
      { 2.62837429e-02f, -5.88023057e-03f, -6.10156059e-02f, -3.46387960e-02f, -6.88704401e-02f },
      { -4.13861535e-02f, -4.51901406e-02f, 3.64786349e-02f, -2.54846308e-02f, 2.91297622e-02f },
    },
    {
      { -3.47119123e-02f, 2.87969708e-02f, -2.20598653e-02f, -5.91643192e-02f, -2.79957037e-02f },
      { -6.26595318e-02f, -4.38684411e-02f, -6.79505467e-02f, 4.27894713e-03f, -2.21782755e-02f },
      { -8.19618255e-02f, -6.31070584e-02f, -6.01931214e-02f, -2.35340539e-02f, -8.49441662e-02f },
      { -4.60183108e-03f, -3.20963971e-02f, -1.77776646e-02f, -5.11389636e-02f, 2.92755999e-02f },
      { 1.55961690e-02f, -9.36367549e-03f, -2.36266442e-02f, 3.29583548e-02f, 9.56626330e-03f },
    },
    {
      { 3.72643396e-02f, 2.42543723e-02f, 2.94660106e-02f, -4.89153527e-02f, -6.17000647e-02f },
      { -4.27924730e-02f, -5.59329689e-02f, -1.79846007e-02f, 2.54116766e-02f, -2.51725055e-02f },
      { -6.90383688e-02f, 3.28876749e-02f, -1.23565400e-03f, 6.15951794e-05f, -1.03977583e-02f },
      { -6.16701543e-02f, 5.51802746e-04f, -2.02553906e-02f, -6.85982555e-02f, 4.08647470e-02f },
      { -2.79355119e-03f, -4.70198654e-02f, 3.03789973e-02f, -1.53229497e-02f, 3.09990696e-03f },
    },
    {
      { 3.17857526e-02f, -3.35215479e-02f, 4.27852422e-02f, -2.91325897e-02f, -6.77383645e-03f },
      { 2.30348092e-02f, -5.74495085e-02f, -3.07424888e-02f, 3.13306451e-02f, 1.78062748e-02f },
      { 4.16155644e-02f, 2.96875797e-02f, 4.70880754e-02f, 1.29391504e-02f, -6.60133585e-02f },
      { -1.85650028e-02f, -3.86686474e-02f, 4.14184630e-02f, -2.97845751e-02f, -6.43794388e-02f },
      { 4.35818806e-02f, -3.62120494e-02f, -1.95640847e-02f, 3.88870388e-02f, -4.99371886e-02f },
    },
    {
      { -2.88302228e-02f, -7.03809857e-02f, -7.14046806e-02f, -7.48371631e-02f, -5.72248735e-02f },
      { 2.73563508e-02f, -6.42532259e-02f, -5.57119660e-02f, -7.22316876e-02f, -4.07729819e-02f },
      { -8.03581253e-02f, 9.79927368e-03f, -4.82411608e-02f, -1.14003727e-02f, 3.43029909e-02f },
      { 3.73431519e-02f, -6.63043261e-02f, -4.11038995e-02f, -6.17644154e-02f, 2.28192024e-02f },
      { -5.04021421e-02f, 9.80075356e-03f, -4.13731150e-02f, 1.61836650e-02f, -5.01977392e-02f },
    },
    {
      { 1.71313640e-02f, -1.11250365e-02f, -1.77479144e-02f, -4.60086390e-02f, 8.91253725e-03f },
      { 1.63958855e-02f, 2.79729683e-02f, -3.94099094e-02f, 2.95836162e-02f, 4.70721014e-02f },
      { -1.57677922e-02f, -1.49550922e-02f, -5.44714034e-02f, 2.59449836e-02f, -1.45145403e-02f },
      { 3.27667929e-02f, -4.68108058e-02f, 4.35484052e-02f, -5.90541661e-02f, -2.37119179e-02f },
      { -3.65252718e-02f, -6.96780235e-02f, -4.80980538e-02f, -4.30438742e-02f, 3.64948176e-02f },
    },
    {
      { -9.41337366e-03f, -8.74865875e-02f, -6.03641383e-03f, -2.89858673e-02f, -7.67810047e-02f },
      { 3.46119292e-02f, -6.63458109e-02f, -3.51565033e-02f, -1.40504148e-02f, -5.87647222e-02f },
      { 4.58111949e-02f, 2.53163707e-02f, 1.15045505e-02f, -6.38149232e-02f, 3.93096805e-02f },
      { -1.17086768e-02f, 4.07943316e-02f, -6.01306232e-03f, 3.84152308e-02f, 1.67091489e-02f },
      { 2.89367624e-02f, 5.49279712e-03f, -8.53023399e-03f, -6.81706145e-03f, 9.98585019e-03f },
    },
    {
      { -3.97996278e-03f, -7.13462755e-02f, -1.77585948e-02f, -3.92523520e-02f, -6.87015429e-02f },
      { -5.73753789e-02f, 7.34059978e-03f, 4.11459524e-03f, -6.36667460e-02f, -7.83074275e-02f },
      { 2.06432585e-03f, -5.49346656e-02f, -5.12750559e-02f, -1.82146747e-02f, -7.36963674e-02f },
      { -5.95207652e-03f, -7.75645673e-02f, -3.62654068e-02f, -7.17523023e-02f, 4.69847722e-03f },
      { -5.12176007e-02f, -8.71817395e-02f, -7.43446350e-02f, -3.07684857e-02f, 7.61528872e-03f },
    },
    {
      { 3.92380729e-02f, -1.26211122e-02f, 3.60861979e-02f, 1.60123762e-02f, -1.35593601e-02f },
      { 5.90907149e-02f, 4.53737490e-02f, 4.23580073e-02f, -5.67243956e-02f, -3.73369195e-02f },
      { 2.24179812e-02f, 3.23305167e-02f, 1.71321761e-02f, 9.63743962e-03f, -6.01197407e-02f },
      { -3.28454562e-02f, -4.88582179e-02f, 4.43523191e-03f, -9.43498034e-03f, 3.41088362e-02f },
      { -2.03876477e-03f, -2.95338873e-02f, 1.57347769e-02f, -1.34366574e-02f, 5.07312492e-02f },
    },
    {
      { 1.86921358e-02f, 3.68328206e-02f, -9.42445081e-03f, -4.56655696e-02f, 1.65064670e-02f },
      { 1.65208802e-02f, -1.54929364e-03f, 1.46512520e-02f, -4.09006048e-03f, -3.95742878e-02f },
      { -2.19184216e-02f, -2.77503077e-02f, 1.31137138e-02f, -1.67003553e-02f, -5.68744587e-03f },
      { -2.98299976e-02f, -5.95542118e-02f, 1.92952983e-04f, -6.89319521e-02f, 3.50556448e-02f },
      { 8.84128083e-03f, -4.55590263e-02f, 2.51680352e-02f, 3.33589315e-02f, 1.20749800e-02f },
    },
    {
      { 1.50225675e-02f, 2.74432986e-03f, -2.10447870e-02f, -3.12117115e-02f, 3.11963074e-02f },
      { -5.66799827e-02f, 6.39466271e-02f, 3.67846079e-02f, 2.92782094e-02f, -4.65488806e-02f },
      { -5.14810253e-03f, -3.58811915e-02f, -7.12991580e-02f, -5.60329631e-02f, 1.97552759e-02f },
      { -6.52632564e-02f, -2.64766980e-02f, 6.56103622e-03f, 1.19247595e-02f, -1.05048465e-02f },
      { 4.44717072e-02f, -8.00161213e-02f, -7.31151029e-02f, -5.14445715e-02f, 5.74517511e-02f },
    },
  },
  {
    {
      { -1.00649193e-01f, -3.92837375e-02f, -2.29420364e-02f, -1.50728479e-01f, -2.80626386e-01f },
      { -6.96912259e-02f, -2.02724189e-01f, 5.11728376e-02f, 2.72820771e-01f, 6.03392068e-03f },
      { -3.16032499e-01f, -2.25713581e-01f, -7.05343559e-02f, 5.44348538e-01f, 5.21211505e-01f },
      { -2.11610794e-01f, -2.08999485e-01f, -4.99538898e-01f, -5.90215862e-01f, -9.35294759e-03f },
      { -6.31725565e-02f, 7.75857270e-02f, 2.10969791e-01f, 6.03531636e-02f, -4.50008184e-01f },
    },
    {
      { 1.88324638e-02f, -2.62833778e-02f, -1.43872555e-02f, -2.56904811e-01f, -4.05042529e-01f },
      { -1.91352684e-02f, 4.71396605e-03f, 1.66214511e-01f, 2.25388259e-01f, -2.44437799e-01f },
      { -2.25668736e-02f, -3.26771177e-02f, 1.82707787e-01f, 2.72112757e-01f, 1.87639922e-01f },
      { 1.65852793e-02f, -1.50596827e-01f, -2.99817801e-01f, -4.03158188e-01f, -2.92373914e-02f },
      { 4.54221182e-02f, 1.18552014e-01f, 2.71930218e-01f, -2.05730945e-02f, -3.27669114e-01f },
    },
    {
      { -1.60548687e-01f, -4.70757782e-02f, 3.53982821e-02f, 9.09139961e-02f, -1.00010119e-01f },
      { 4.29761782e-02f, -5.35380915e-02f, 1.23346290e-02f, 9.87191424e-02f, 1.06129624e-01f },
      { -2.50636577e-03f, -2.82857209e-01f, -4.68784630e-01f, -4.29866970e-01f, 5.60610835e-03f },
      { -3.12391240e-02f, 1.08407997e-01f, 1.21530890e-01f, 1.36267841e-01f, -1.50500894e-01f },
      { -5.13190664e-02f, 4.35582027e-02f, 2.18256846e-01f, 3.17095697e-01f, 1.54088005e-01f },
    },
    {
      { 6.23175837e-02f, 1.05710812e-02f, -1.37541056e-01f, 1.46857034e-02f, 1.66086122e-01f },
      { 4.14261408e-03f, -1.80527591e-03f, -9.96496975e-02f, -2.83736706e-01f, 2.37619989e-02f },
      { 9.10930559e-02f, -7.27704214e-03f, -6.24447577e-02f, -6.74808547e-02f, -2.46741951e-01f },
      { 3.57333533e-02f, -1.55215636e-01f, -7.10886344e-02f, 5.40366247e-02f, -1.43098816e-01f },
      { -7.71985278e-02f, -1.99004844e-01f, -1.25444889e-01f, -3.18008587e-02f, 8.62132758e-03f },
    },
    {
      { -1.97490286e-02f, 3.48391570e-02f, 3.19360867e-02f, -2.36553513e-03f, 5.71548007e-02f },
      { 5.48736267e-02f, 1.02546774e-01f, -9.09437537e-02f, -1.16150782e-01f, 9.47442576e-02f },
      { -4.13729213e-02f, 2.60334667e-02f, -7.04963207e-02f, -2.40673691e-01f, -1.09344199e-01f },
      { 5.78278750e-02f, 6.20111637e-02f, 1.41922757e-01f, 1.30738422e-01f, -1.38463348e-01f },
      { -1.37784025e-02f, -1.35446459e-01f, 4.68439460e-02f, 2.04994664e-01f, 2.41513118e-01f },
    },
    {
      { -4.13999259e-02f, -7.43693858e-02f, -1.04775898e-01f, 2.45752901e-01f, 1.12589262e-01f },
      { 2.14965958e-02f, 1.76906884e-02f, -3.14670920e-01f, -1.14047185e-01f, 1.53517485e-01f },
      { 6.36882260e-02f, 3.25854235e-05f, -1.03599213e-01f, -3.14089626e-01f, -3.35474640e-01f },
      { 5.28547391e-02f, 4.88213524e-02f, 2.63053238e-01f, 2.69013315e-01f, -4.90210243e-02f },
      { -2.49516387e-02f, -2.18836755e-01f, -2.27712736e-01f, 1.81335807e-02f, -1.83477718e-02f },
    },
    {
      { -2.25729588e-02f, 1.94536313e-01f, 1.41488448e-01f, -2.10838005e-01f, -1.13916583e-01f },
      { -9.42224488e-02f, 1.35094330e-01f, 8.54608044e-02f, -4.53622669e-01f, -4.84404176e-01f },
      { 2.24605738e-03f, -7.81087354e-02f, -1.25234444e-02f, -1.18039720e-01f, -2.25217998e-01f },
      { 3.84330633e-03f, -3.49337548e-01f, -3.21036339e-01f, -5.90812974e-02f, 3.49941961e-02f },
      { 9.73069966e-02f, -1.30639583e-01f, -2.75765628e-01f, -6.24377668e-01f, -3.37276280e-01f },
    },
    {
      { 7.21589178e-02f, 1.25808686e-01f, 1.13706134e-01f, -8.43751281e-02f, -1.62896365e-01f },
      { -1.67756397e-02f, 5.67104444e-02f, -6.06149323e-02f, -3.00022006e-01f, -2.85405040e-01f },
      { -5.96664250e-02f, -2.37900481e-01f, -2.31136277e-01f, -2.76671171e-01f, -1.29354432e-01f },
      { -1.05977990e-01f, 1.06901433e-02f, -2.14515207e-03f, 5.80923259e-02f, 1.66287139e-01f },
      { -6.97433352e-02f, 1.95741914e-02f, -1.30870923e-01f, -9.86673236e-02f, -9.08320956e-03f },
    },
    {
      { -4.39105975e-03f, -1.14757277e-01f, 1.80901587e-01f, -2.34095633e-01f, -4.96024132e-01f },
      { 4.70395759e-02f, -1.96805626e-01f, -2.47871689e-02f, 1.29346386e-01f, -1.22226059e-01f },
      { 3.26150805e-02f, 4.76922207e-02f, 5.60388006e-02f, 3.76662910e-01f, 3.81938905e-01f },
      { -6.53363019e-02f, -2.67885532e-03f, -4.28621680e-01f, -4.51075852e-01f, -3.86645310e-02f },
      { 4.40959958e-03f, 1.89858362e-01f, 3.54636192e-01f, 1.60822704e-01f, -4.29525763e-01f },
    },
    {
      { 8.26233849e-02f, -4.26536277e-02f, -2.16718361e-01f, -3.65586467e-02f, 1.26357511e-01f },
      { -2.95222457e-03f, 4.31321226e-02f, -8.47428292e-02f, -1.18965603e-01f, 2.46350393e-02f },
      { 1.12276532e-01f, -8.62997994e-02f, 3.28838499e-03f, -1.23586580e-01f, -1.70864746e-01f },
      { 1.10468917e-01f, -1.57686844e-01f, -6.95552081e-02f, 1.14579080e-02f, 3.07056289e-02f },
      { 6.87875003e-02f, -1.44359037e-01f, -8.75200257e-02f, -3.73371653e-02f, -5.40043302e-02f },
    },
    {
      { -3.14524695e-02f, -3.47883776e-02f, -1.44162983e-01f, 1.46479547e-01f, 8.95810500e-02f },
      { 4.30390947e-02f, 1.26149431e-01f, -2.35823244e-01f, -1.10915370e-01f, 1.87741965e-01f },
      { -1.10787213e-01f, -1.45951301e-01f, -1.50429338e-01f, -3.50813985e-01f, -3.40420753e-01f },
      { -1.07192412e-01f, 6.11027442e-02f, 3.17211419e-01f, 4.37671542e-01f, 2.15165943e-01f },
      { -4.04079184e-02f, -1.27846703e-01f, -3.93559504e-03f, 6.93416670e-02f, 3.03041399e-01f },
    },
    {
      { 1.28671080e-01f, 3.89747657e-02f, -1.79731429e-01f, -1.46160558e-01f, 4.17728275e-02f },
      { -9.49764438e-03f, -7.04002157e-02f, 1.37759689e-02f, 4.51092944e-02f, -1.15358397e-01f },
      { 5.75388595e-02f, 2.04239935e-01f, 2.50460118e-01f, 3.07633311e-01f, 2.22964853e-01f },
      { 7.06201866e-02f, -6.61219209e-02f, -2.08616391e-01f, 2.32612640e-02f, 9.04191062e-02f },
      { 3.65161151e-03f, 5.11243753e-02f, -2.82092467e-02f, -1.83222871e-02f, -7.17890039e-02f },
    },
    {
      { 2.31123660e-02f, 3.66130471e-02f, 1.12422019e-01f, -1.69845119e-01f, -1.25305355e-01f },
      { -2.62656044e-02f, -1.28735021e-01f, 2.37490404e-02f, 6.03122823e-02f, 3.49906981e-02f },
      { -3.64353433e-02f, -1.22820973e-01f, -8.50091428e-02f, 1.07619561e-01f, 1.82467699e-01f },
      { 6.22277297e-02f, -6.64971361e-04f, -1.70254081e-01f, -1.97395101e-01f, -1.25977192e-02f },
      { 5.30134365e-02f, 7.07643926e-02f, 1.04789361e-01f, 4.56302688e-02f, -2.57568091e-01f },
    },
    {
      { -1.85081400e-02f, 7.93133974e-02f, 1.15318231e-01f, -1.97482228e-01f, -2.89390385e-01f },
      { -1.23312339e-01f, -4.86190543e-02f, 1.36960819e-01f, 5.97876087e-02f, -2.09040284e-01f },
      { -8.31956342e-02f, 2.51140930e-02f, 1.62000865e-01f, 3.04420829e-01f, 2.58845598e-01f },
      { 5.21306396e-02f, -9.08761546e-02f, -2.84238845e-01f, -2.26790220e-01f, 2.84855459e-02f },
      { 7.20112622e-02f, 1.85764223e-01f, 1.92701802e-01f, -1.02023937e-01f, -3.22998911e-01f },
    },
    {
      { -5.85922413e-02f, -6.92951158e-02f, 3.10045481e-02f, 5.25479652e-02f, 3.43311355e-02f },
      { 6.80708839e-03f, -1.71434786e-02f, -6.45290986e-02f, 2.45884694e-02f, -4.98149879e-02f },
      { -1.23404795e-02f, 8.12306069e-03f, -5.99577352e-02f, -1.99770182e-02f, -7.79927801e-03f },
      { -4.84540686e-02f, 2.03333460e-02f, -5.61319515e-02f, 3.31382989e-03f, 7.43445067e-04f },
      { 3.29583250e-02f, 1.74752879e-03f, 4.13456708e-02f, 1.63387898e-02f, 4.45773043e-02f },
    },
    {
      { 3.63741331e-02f, 4.50035632e-02f, -1.09572913e-02f, -2.13359464e-02f, -3.27516273e-02f },
      { -1.31471148e-02f, 5.84571715e-03f, -3.06224879e-02f, 9.43625998e-03f, -3.90137061e-02f },
      { 5.41005880e-02f, 8.74202251e-02f, 3.61684710e-02f, 4.86597270e-02f, 1.01715378e-01f },
      { 6.16498441e-02f, -1.61954537e-02f, -7.32919648e-02f, -1.92627888e-02f, 8.15050900e-02f },
      { 1.15487412e-01f, -3.38888094e-02f, 1.01699959e-02f, -1.32707134e-01f, -5.15862368e-02f },
    },
    {
      { -2.17436589e-02f, 2.84444652e-02f, -1.24840988e-02f, -6.00645505e-02f, -3.68546210e-02f },
      { 5.48503734e-03f, 4.78640087e-02f, -1.80267692e-02f, -8.20131153e-02f, -3.61622982e-02f },
      { 9.51133575e-03f, -1.67565849e-02f, -7.93333445e-03f, 1.59442350e-02f, -4.70284373e-02f },
      { 3.91835421e-02f, 1.03556536e-01f, 1.35228947e-01f, 7.62826055e-02f, 3.05665433e-02f },
      { 1.93004329e-02f, 6.06237985e-02f, -1.60850082e-02f, 5.98897319e-03f, 1.27150863e-01f },
    },
    {
      { 7.50222504e-02f, -9.00272466e-03f, -5.60636483e-02f, 1.71378406e-03f, -6.23784587e-03f },
      { 1.22957259e-01f, 7.18037412e-02f, -1.58804983e-01f, -1.53812930e-01f, -1.72785036e-02f },
      { -5.45012839e-02f, -1.78569295e-02f, -4.25808616e-02f, -9.52652842e-02f, -1.51641607e-01f },
      { 6.83271885e-02f, 1.18623883e-01f, 1.27875268e-01f, 2.02872947e-01f, 1.40612766e-01f },
      { -1.24149583e-02f, 2.93584783e-02f, -5.50613850e-02f, 4.30436656e-02f, 1.05871312e-01f },
    },
    {
      { 3.47150080e-02f, 3.64679620e-02f, -5.02501521e-03f, 1.26691192e-01f, 1.25736684e-01f },
      { 1.01854406e-01f, 1.16263181e-01f, 7.92312901e-03f, -1.70698673e-01f, 7.71719739e-02f },
      { -8.27571228e-02f, -1.89995140e-01f, 1.39503228e-02f, -1.01823814e-01f, -2.43684694e-01f },
      { -1.29154280e-01f, 1.23195060e-01f, 3.54607373e-01f, 3.75703901e-01f, 2.73433834e-01f },
      { 3.40889487e-03f, -4.63102795e-02f, -1.87340647e-01f, 3.00061014e-02f, 2.63761342e-01f },
    },
    {
      { 7.94272050e-02f, 7.13259801e-02f, 3.04844975e-02f, 3.77468318e-02f, -9.80127752e-02f },
      { 6.82986677e-02f, 8.97925720e-02f, 1.30300922e-02f, -8.18797201e-02f, -1.83865856e-02f },
      { -5.37345149e-02f, 8.23061317e-02f, 2.08402406e-02f, -5.54523021e-02f, 1.27230138e-01f },
      { -3.19887549e-02f, -6.88573122e-02f, -4.82971370e-02f, -3.65347043e-02f, 5.77236339e-02f },
      { 1.37523357e-02f, 7.26949871e-02f, 7.36988187e-02f, 1.18578402e-02f, -6.69011623e-02f },
    },
    {
      { 3.27816680e-02f, 6.06705844e-02f, -6.69975765e-03f, -6.57462180e-02f, 7.07597136e-02f },
      { -8.35797414e-02f, -7.77323171e-02f, -3.59492600e-02f, -6.33326126e-04f, -1.53025389e-01f },
      { 1.52575031e-01f, 1.13018401e-01f, 2.38163933e-01f, 2.57560849e-01f, 5.10507636e-02f },
      { -2.18655393e-02f, -1.31837383e-01f, -3.31941172e-02f, 2.96156835e-02f, 2.24434152e-01f },
      { 1.09166875e-01f, 4.09931354e-02f, 1.15038622e-02f, -1.40219301e-01f, -1.77418426e-01f },
    },
    {
      { 1.98072597e-01f, 8.16645622e-02f, 3.39601278e-01f, 5.61765349e-03f, -4.42652777e-02f },
      { 1.41406979e-03f, -3.51587147e-01f, -4.05146092e-01f, -2.61960685e-01f, -2.38263339e-01f },
      { -1.09636642e-01f, -2.84878314e-01f, -4.58071798e-01f, -3.60590667e-01f, -4.01859045e-01f },
      { -1.15293302e-01f, -2.13172764e-01f, -2.09745452e-01f, -9.63890851e-02f, 4.96084914e-02f },
      { 1.04702376e-01f, -2.12019950e-01f, -4.30823974e-02f, 9.22355615e-03f, 3.31601547e-03f },
    },
    {
      { 1.17381416e-01f, -8.81638750e-02f, 2.06205957e-02f, 8.04725438e-02f, 1.22843854e-01f },
      { 6.08199835e-02f, -4.20073718e-02f, -1.05065286e-01f, 1.14356004e-01f, 1.29842192e-01f },
      { 1.73356891e-01f, 1.58798784e-01f, -5.38318567e-02f, -6.61625564e-02f, 1.27209155e-02f },
      { 2.22251430e-01f, 2.19990015e-01f, 3.07883695e-02f, 4.50074002e-02f, 7.48410635e-03f },
      { 1.28498614e-01f, 3.88448462e-02f, -2.45742835e-02f, 1.13076173e-01f, 1.48500890e-01f },
    },
    {
      { 4.89957482e-02f, 2.59666573e-02f, -6.27341541e-03f, -7.46461973e-02f, -6.05926942e-03f },
      { -3.12940814e-02f, -1.57438517e-02f, 6.25596344e-02f, -8.98497552e-02f, -3.64106223e-02f },
      { 7.86408037e-03f, -1.74439186e-03f, 1.61908790e-02f, 8.20993334e-02f, 6.96524382e-02f },
      { -1.05749201e-02f, -5.93009517e-02f, -1.62918538e-01f, -2.38816123e-02f, 9.30974782e-02f },
      { 9.00139511e-02f, 5.65087087e-02f, -4.67751063e-02f, -6.63083270e-02f, -2.56618634e-02f },
    },
    {
      { -1.52254384e-02f, -1.43254176e-01f, -1.10554807e-01f, 4.96392101e-02f, -1.11059379e-02f },
      { 7.49619529e-02f, -2.29976997e-02f, -1.35240808e-01f, -6.36251271e-02f, 8.26296583e-02f },
      { -1.56951427e-01f, -1.55196190e-01f, -7.79729262e-02f, -2.45422080e-01f, -2.10730880e-01f },
      { -5.70383742e-02f, 6.37136027e-02f, 2.64690727e-01f, 3.26880395e-01f, 1.92756832e-01f },
      { 8.99313763e-02f, -1.10200994e-01f, -5.80414720e-02f, 7.77241215e-02f, 2.08356947e-01f },
    },
    {
      { 1.15247920e-01f, 1.37394845e-01f, 1.95163056e-01f, 1.32039875e-01f, 9.69684310e-03f },
      { 5.20012714e-02f, 8.72968212e-02f, 4.74926606e-02f, -9.89135429e-02f, -4.57089543e-02f },
      { -1.08459190e-01f, -8.71382728e-02f, 1.45042259e-02f, -9.52527523e-02f, -7.61660710e-02f },
      { -9.49554145e-02f, -8.94188136e-03f, 1.50269508e-01f, 3.13798040e-01f, 3.03164691e-01f },
      { 1.35137746e-02f, -1.62577882e-01f, -1.89102009e-01f, -2.02041641e-01f, 1.50133044e-01f },
    },
    {
      { 3.60376723e-02f, 4.90529314e-02f, 6.11092569e-03f, -1.40196001e-02f, -2.38347780e-02f },
      { -9.39216930e-03f, 3.25536840e-02f, 3.15966085e-03f, -9.28780288e-02f, 2.04039458e-02f },
      { 2.43198667e-02f, 2.34090723e-02f, 3.25402133e-02f, -1.15400963e-01f, -1.56846762e-01f },
      { -5.41380271e-02f, 1.22453921e-01f, 1.67706683e-01f, 1.95848361e-01f, 3.45713533e-02f },
      { -1.85424853e-02f, -9.40875039e-02f, -5.21884076e-02f, 1.88986566e-02f, 1.79705292e-01f },
    },
    {
      { -5.35476692e-02f, -8.80564153e-02f, -2.32378151e-02f, 1.65836737e-01f, 1.60943404e-01f },
      { 4.16131876e-02f, -5.19351522e-03f, -7.87911192e-02f, 5.13416268e-02f, 1.28222078e-01f },
      { 1.32791877e-01f, -5.69834374e-02f, -9.21452865e-02f, -1.25211775e-01f, -4.13638838e-02f },
      { 1.54940516e-01f, -1.05366506e-01f, -7.08072782e-02f, -8.01507682e-02f, -1.34857163e-01f },
      { 1.20852858e-01f, 2.05726316e-03f, -2.17283815e-02f, 1.94761921e-02f, -7.54281692e-03f },
    },
    {
      { 1.51036005e-03f, 1.36146724e-01f, -1.74923912e-02f, -2.45167345e-01f, -1.83984578e-01f },
      { -2.54302304e-02f, -2.13839579e-03f, 9.58299339e-02f, 1.50253341e-01f, -2.61231244e-01f },
      { -1.73638272e-03f, 1.65932223e-01f, 3.52636874e-01f, 4.56362456e-01f, 3.37765396e-01f },
      { -7.49062076e-02f, -2.91686177e-01f, -3.11736465e-01f, 2.18354855e-02f, 2.79495865e-01f },
      { 6.68564662e-02f, -3.62210535e-02f, 1.08102344e-01f, -9.85919759e-02f, -9.66362134e-02f },
    },
    {
      { -9.12127085e-03f, -4.02453169e-02f, -4.09774594e-02f, 1.98445562e-02f, -6.02324381e-02f },
      { -1.75239798e-02f, 4.44977134e-02f, -3.87966707e-02f, 3.15182619e-02f, -2.01386344e-02f },
      { -5.75504117e-02f, 1.72170009e-02f, -4.27674241e-02f, -4.75524832e-03f, -2.95168236e-02f },
      { 3.59148979e-02f, -2.25912295e-02f, 6.85038697e-03f, 4.69002426e-02f, 5.28549254e-02f },
      { -5.19448482e-02f, 2.27916110e-02f, 4.81098369e-02f, 5.91489747e-02f, 1.26215806e-02f },
    },
    {
      { -9.09973029e-03f, 1.36374190e-01f, 8.52057431e-03f, -3.19182903e-01f, -2.03807354e-01f },
      { -4.86158505e-02f, -3.94851342e-02f, 1.23131946e-01f, 1.16298631e-01f, -3.63133371e-01f },
      { -1.19199455e-02f, 1.07793108e-01f, 2.44099721e-01f, 4.78206307e-01f, 3.34769309e-01f },
      { -5.49348630e-02f, -4.91883084e-02f, -3.68550658e-01f, -9.84328911e-02f, 2.38352880e-01f },
      { 8.91042277e-02f, 1.69671327e-01f, 3.10930043e-01f, -2.97683105e-02f, -2.29820028e-01f },
    },
    {
      { 7.46110678e-02f, 7.61988088e-02f, 1.40151545e-01f, -1.50857210e-01f, -2.76200205e-01f },
      { 7.43432194e-02f, 6.64779842e-02f, 6.26306757e-02f, -1.80726781e-01f, -3.59273911e-01f },
      { -5.47561329e-03f, -1.38639659e-01f, -1.25723228e-01f, -2.84531564e-01f, -2.56263733e-01f },
      { -1.81647807e-01f, -7.41601363e-02f, -3.40831012e-01f, -3.08601111e-01f, -6.61108866e-02f },
      { -1.63358629e-01f, -3.40073332e-02f, -2.29084119e-01f, -3.39525431e-01f, -2.39006609e-01f },
    },
  },
  {
    {
      { -7.74016231e-02f, -1.60355553e-01f, -2.57308837e-02f, 1.36569679e-01f, 2.25311965e-01f },
      { 1.31207049e-01f, 6.54391870e-02f, -8.21935162e-02f, -9.40540880e-02f, -7.55039603e-02f },
      { 1.64621994e-01f, 3.03103954e-01f, 2.46210650e-01f, 2.21398100e-01f, 3.48157622e-02f },
      { 2.65439153e-01f, 2.42578253e-01f, 2.59365976e-01f, 2.30460227e-01f, 1.18372336e-01f },
      { 1.90966457e-01f, 2.52326131e-01f, 3.80423337e-01f, 2.66636223e-01f, 1.34907454e-01f },
    },
    {
      { 7.85532035e-03f, -1.69431359e-01f, -1.81588858e-01f, -5.59608415e-02f, 1.32588342e-01f },
      { 1.15726203e-01f, -1.05045773e-01f, -4.19417918e-01f, -3.60550523e-01f, -8.02566633e-02f },
      { 3.39835286e-02f, 5.34381755e-02f, 7.15735629e-02f, -7.92053193e-02f, -1.20329961e-01f },
      { 6.37463480e-02f, 1.14323884e-01f, 1.24936871e-01f, -1.25459716e-01f, -6.81690872e-02f },
      { -7.18729794e-02f, -1.33249098e-02f, -1.18596509e-01f, -1.53185293e-01f, -1.24047391e-01f },
    },
    {
      { 1.53705955e-01f, -2.27565151e-02f, -1.64736852e-01f, -3.86298567e-01f, -1.71276972e-01f },
      { 2.78804839e-01f, 3.20538402e-01f, 1.41840816e-01f, 1.65592916e-02f, -9.91069302e-02f },
      { 1.13003977e-01f, 1.66702375e-01f, 2.07596928e-01f, 1.66584119e-01f, 6.91372752e-02f },
      { -6.41417354e-02f, 1.73516537e-03f, -5.66384085e-02f, -7.22674951e-02f, 4.83996645e-02f },
      { -1.04687519e-01f, -5.48361987e-02f, -1.49293378e-01f, -4.90757413e-02f, -1.46571090e-02f },
    },
    {
      { -9.82289463e-02f, -4.86378409e-02f, 1.60574391e-02f, 3.59455869e-02f, 1.93361081e-02f },
      { -1.69432834e-01f, -7.95743242e-02f, -2.31865644e-02f, 5.30230515e-02f, 8.18748586e-03f },
      { -6.93469718e-02f, -2.33323097e-01f, -1.34684876e-01f, 9.43446346e-03f, 2.31443346e-02f },
      { 4.14759386e-03f, -7.16007799e-02f, -8.78082588e-02f, 9.56789553e-02f, 7.28391036e-02f },
      { 1.17063724e-01f, -7.14070275e-02f, 3.70753147e-02f, 3.78092425e-03f, 4.72901110e-03f },
    },
    {
      { -8.66014883e-02f, 1.87679064e-02f, 4.42334004e-02f, 4.41660024e-02f, 1.39542788e-01f },
      { -9.31464806e-02f, -1.88239366e-02f, 3.12322043e-02f, 1.24437034e-01f, 1.62985958e-02f },
      { -1.70511588e-01f, -1.12098418e-01f, -9.54147354e-02f, 1.36496201e-01f, 1.40194505e-01f },
      { 3.51091325e-02f, -1.31594464e-01f, -1.88996792e-02f, 2.06593405e-02f, 1.13900602e-01f },
      { 2.22197518e-01f, 1.05891898e-01f, 3.28986160e-02f, 2.14840621e-01f, 2.02973798e-01f },
    },
    {
      { 1.26838207e-01f, 2.46016726e-01f, 1.22937471e-01f, 6.03183545e-02f, 2.64553297e-02f },
      { 4.27977107e-02f, 1.94791809e-01f, 1.77379578e-01f, 1.86865166e-01f, 1.22566536e-01f },
      { -1.06408320e-01f, 1.45927772e-01f, 1.66194156e-01f, 1.41510636e-01f, 1.35370508e-01f },
      { -2.27791682e-01f, -2.65909493e-01f, 2.88637765e-02f, 2.97862440e-02f, -1.06564490e-02f },
      { -3.41048390e-02f, -9.21277925e-02f, -6.81465864e-02f, 1.51366726e-01f, 1.00785224e-02f },
    },
    {
      { -1.30176872e-01f, -1.02021538e-01f, -3.07196323e-02f, -7.82619640e-02f, -1.09534673e-02f },
      { -1.52459875e-01f, -4.74077851e-01f, -5.91670573e-01f, -2.28598803e-01f, -3.09621040e-02f },
      { 6.18780814e-02f, -1.90190703e-01f, -7.61718988e-01f, -5.81057608e-01f, -1.29305184e-01f },
      { 9.15194899e-02f, 3.40261403e-03f, -4.09289151e-01f, -3.26494604e-01f, -9.80208963e-02f },
      { 1.51388958e-01f, 1.74618408e-01f, -2.68967569e-01f, -2.64838427e-01f, -2.28504706e-02f },
    },
    {
      { -9.90328193e-03f, 8.33314564e-03f, 1.75848417e-02f, -8.21015313e-02f, 5.46969362e-02f },
      { 4.97781066e-03f, -8.81269425e-02f, -7.77720511e-02f, -1.17420079e-02f, 4.81544137e-02f },
      { 6.01954795e-02f, -9.64264944e-02f, -1.47187740e-01f, -2.71596521e-01f, -3.05223428e-02f },
      { -7.29546249e-02f, -1.22601852e-01f, -2.80312508e-01f, -3.42663288e-01f, -3.94281298e-02f },
      { -2.16476060e-02f, -6.92377910e-02f, -2.47679174e-01f, -2.23800436e-01f, -2.63900217e-03f },
    },
    {
      { -1.60257578e-01f, -4.33113933e-01f, -1.95088997e-01f, 1.25741169e-01f, 2.56148219e-01f },
      { 6.66502491e-02f, -1.71762347e-01f, -4.63067621e-01f, -5.19411087e-01f, -4.61322032e-02f },
      { 2.76116449e-02f, 6.10662661e-02f, -4.37247269e-02f, -2.62411684e-01f, -1.79815844e-01f },
      { 1.36741484e-02f, 2.02249661e-01f, 1.43045425e-01f, 1.64533854e-02f, 3.85391936e-02f },
      { -2.23701037e-02f, -6.06812984e-02f, 1.28916278e-01f, 4.02671620e-02f, 6.23095315e-03f },
    },
    {
      { -9.64155272e-02f, 4.90183085e-02f, 4.03978452e-02f, -2.45703422e-02f, -4.62466143e-02f },
      { -9.59682539e-02f, -3.40936072e-02f, -2.56708134e-02f, 1.33059010e-01f, 1.22367591e-01f },
      { -8.36573765e-02f, 1.73914842e-02f, -5.32010496e-02f, 8.66967887e-02f, 8.41707960e-02f },
      { -9.77304950e-02f, -8.06520730e-02f, -1.24990486e-01f, 1.03540607e-01f, 1.88468844e-02f },
      { -1.37654632e-01f, -1.09173171e-01f, -1.57468766e-01f, -7.08824620e-02f, -5.47573417e-02f },
    },
    {
      { -4.00084257e-03f, 1.11096442e-01f, 4.69253585e-02f, 4.70616445e-02f, 9.53329206e-02f },
      { -1.10553205e-01f, 6.84673525e-03f, 1.11420050e-01f, 1.86670825e-01f, 1.45053372e-01f },
      { -2.05730826e-01f, -3.13437283e-02f, 1.11111872e-01f, 7.54380822e-02f, 6.53018281e-02f },
      { -1.25181571e-01f, -3.27280045e-01f, -1.75914347e-01f, -6.67547360e-02f, -8.95827264e-02f },
      { 2.52878983e-02f, -3.03204693e-02f, 1.52585581e-02f, 1.07456997e-01f, 1.82917491e-01f },
    },
    {
      { -2.11781655e-02f, -5.13561778e-02f, 8.42265040e-02f, 8.08663890e-02f, -1.76802576e-02f },
      { -4.02496606e-02f, -1.46672800e-01f, -1.49696618e-01f, -1.88756511e-01f, -3.56965400e-02f },
      { 4.07029390e-02f, -7.57676922e-03f, 1.47792026e-02f, -2.57957932e-02f, 9.64852143e-03f },
      { 6.04430623e-02f, 9.70067754e-02f, 1.86135337e-01f, 2.05250546e-01f, 1.58039942e-01f },
      { -1.56451017e-02f, -5.95304184e-02f, 6.64316267e-02f, 3.28791188e-03f, 5.79274865e-03f },
    },
    {
      { 2.45531816e-02f, -1.31823584e-01f, -1.35002851e-01f, 2.84552183e-02f, 4.74450067e-02f },
      { 1.30543172e-01f, -2.90864818e-02f, -2.02208892e-01f, -2.17201561e-01f, -1.21493019e-01f },
      { 1.12287633e-01f, 7.25390613e-02f, 4.43958910e-03f, -4.43507433e-02f, -1.89428590e-02f },
      { 9.12246853e-02f, 1.43344298e-01f, 4.27674726e-02f, -3.70549597e-02f, -2.58062184e-02f },
      { -9.62476954e-02f, -5.53538725e-02f, -1.08173586e-01f, -6.88149482e-02f, -6.10214695e-02f },
    },
    {
      { -9.19601321e-02f, -1.96531072e-01f, -1.45407900e-01f, -4.92421836e-02f, 4.10361476e-02f },
      { 2.66754646e-02f, -2.08978191e-01f, -5.44143140e-01f, -4.08093303e-01f, 4.74963300e-02f },
      { 4.54611033e-02f, -1.56088965e-02f, -1.64722592e-01f, -3.10635120e-01f, -7.09796697e-02f },
      { 1.75245687e-01f, 1.53684914e-01f, 1.03430867e-01f, -5.79786152e-02f, -3.75464149e-02f },
      { -2.57294513e-02f, 4.73352149e-03f, -1.66687235e-01f, -2.45487377e-01f, -1.37192681e-01f },
    },
    {
      { 3.82367037e-02f, -6.47552013e-02f, -4.08551889e-03f, 4.72193286e-02f, 3.04476116e-02f },
      { -3.21859010e-02f, 2.55184565e-02f, -5.62423430e-02f, -2.66518071e-02f, 1.49706025e-02f },
      { -5.36559783e-02f, 4.94177155e-02f, -2.06350815e-02f, -4.53795195e-02f, 4.91774231e-02f },
      { -1.78394262e-02f, -4.40647267e-02f, -3.55393402e-02f, 2.91015487e-02f, -2.09778715e-02f },
      { 2.43111681e-02f, -1.21994270e-02f, 2.57828142e-02f, -6.05891040e-03f, -4.72727343e-02f },
    },
    {
      { -6.13878444e-02f, -6.38124272e-02f, -3.29418592e-02f, 6.66082874e-02f, 4.25939485e-02f },
      { -2.84317136e-02f, -8.96062627e-02f, -4.04047370e-02f, 4.27207984e-02f, 5.48673756e-02f },
      { -1.89929195e-02f, 2.82158470e-03f, -1.39405146e-01f, -9.64830965e-02f, -1.16396500e-02f },
      { 6.22649342e-02f, 5.57980761e-02f, -9.28054824e-02f, 6.58525899e-03f, 7.55899251e-02f },
      { -1.47572495e-02f, -1.78606603e-02f, -1.56287327e-02f, 1.41285947e-02f, 6.11155257e-02f },
    },
    {
      { 4.94646654e-03f, -4.47397903e-02f, 6.53189560e-03f, 5.00530936e-02f, 4.58044931e-03f },
      { -1.07089050e-01f, -1.62871942e-01f, -4.87396270e-02f, -5.20449989e-02f, 4.90836091e-02f },
      { -5.57105280e-02f, -1.86308905e-01f, -1.15705147e-01f, -3.70987244e-02f, 3.35437953e-02f },
      { 4.77470160e-02f, 3.26942094e-02f, -2.32189037e-02f, 1.49254045e-02f, 2.21189000e-02f },
      { 1.74030483e-01f, 9.59252194e-02f, 1.39820367e-01f, 7.12508410e-02f, 5.44976294e-02f },
    },
    {
      { -7.62242153e-02f, 8.42893645e-02f, -3.01290676e-03f, -4.94159535e-02f, 2.41378844e-02f },
      { -1.29769757e-01f, 9.71249212e-03f, 1.13326609e-01f, 9.71170515e-02f, 4.16157097e-02f },
      { -1.35889485e-01f, -1.63334310e-01f, -1.40894189e-01f, -7.41700381e-02f, 6.41141310e-02f },
      { -1.38583988e-01f, -2.17736319e-01f, -2.17178449e-01f, -3.31328288e-02f, -3.18174846e-02f },
      { -8.13590810e-02f, -8.94316956e-02f, -1.74474686e-01f, -1.33822327e-02f, 3.91116925e-02f },
    },
    {
      { 1.47017082e-02f, 9.01028290e-02f, 1.09281227e-01f, -6.94367057e-03f, 4.62930799e-02f },
      { -1.08252555e-01f, -1.24790452e-01f, 7.64720961e-02f, 1.90359622e-01f, 9.01085362e-02f },
      { -1.91629395e-01f, -1.06655285e-01f, -4.23469953e-03f, -1.69067457e-02f, 4.90557104e-02f },
      { -4.97804657e-02f, -1.99959725e-01f, -1.54514655e-01f, -8.68979096e-02f, -1.13818897e-02f },
      { 7.97015429e-02f, 1.06551915e-01f, 1.19377933e-01f, 1.46482646e-01f, 2.26827905e-01f },
    },
    {
      { -2.82266140e-02f, 2.55804919e-02f, 2.35004313e-02f, 2.33055845e-01f, 1.61423102e-01f },
      { 1.86929386e-03f, -1.32384360e-01f, -3.48418318e-02f, -9.50219296e-03f, 2.69074999e-02f },
      { -1.24014057e-01f, -1.87745050e-01f, -1.80993706e-01f, -5.04576787e-02f, 5.23156370e-04f },
      { 3.39997709e-02f, -2.79394211e-03f, -3.57803293e-02f, -3.86085026e-02f, 9.22271013e-02f },
      { 1.16269335e-01f, 4.14834591e-03f, 3.44536975e-02f, 3.29781212e-02f, 7.10142106e-02f },
    },
    {
      { -8.47980157e-02f, 1.77735798e-02f, 7.08665028e-02f, 2.16675982e-01f, 5.32617941e-02f },
      { -1.34118676e-01f, -1.28375813e-01f, -8.37997422e-02f, -4.92457151e-02f, -7.69226477e-02f },
      { -1.24681592e-02f, -6.89287111e-02f, -1.31112099e-01f, -9.41620693e-02f, -1.72102227e-05f },
      { 7.73057789e-02f, 6.06954936e-03f, -2.88186260e-02f, 1.35403439e-01f, 5.21307327e-02f },
      { -2.35640886e-03f, 5.11578545e-02f, -1.48560237e-02f, 4.27251831e-02f, -8.43588114e-02f },
    },
    {
      { -1.21945478e-01f, -4.34724949e-02f, -6.02961592e-02f, -2.66620833e-02f, -1.59108669e-01f },
      { 7.81188607e-02f, 5.00332424e-03f, 6.10026121e-02f, -1.86214447e-01f, -1.30065605e-01f },
      { 2.81595141e-01f, 1.08153760e-01f, -6.07329756e-02f, -1.61864787e-01f, 5.22598699e-02f },
      { 1.25606004e-02f, -2.46977136e-02f, -1.31471619e-01f, -4.30931225e-02f, 7.61285871e-02f },
      { -3.95314097e-02f, -1.49271742e-01f, -6.01137727e-02f, 6.54276833e-02f, -6.93541840e-02f },
    },
    {
      { 2.23401472e-01f, 1.15854010e-01f, 1.04165547e-01f, -4.73731644e-02f, -2.43563130e-02f },
      { 2.20021382e-01f, 2.23015174e-01f, 1.81547239e-01f, 6.94099739e-02f, 1.27799615e-01f },
      { 1.84587434e-01f, 2.17771769e-01f, 2.09923670e-01f, 2.45054856e-01f, 2.11222872e-01f },
      { 1.62406474e-01f, 1.79603472e-01f, 2.57425874e-01f, 1.73276633e-01f, 8.92148614e-02f },
      { 3.75572219e-02f, 1.08641304e-01f, 5.09479940e-02f, 1.14791289e-01f, 1.03854962e-01f },
    },
    {
      { -2.33291350e-02f, -1.23752989e-01f, -1.61628856e-03f, 1.92810372e-02f, -5.48279658e-03f },
      { -2.22320072e-02f, -1.14944592e-01f, -1.78195015e-01f, -1.00892922e-03f, 3.03857550e-02f },
      { 4.64185588e-02f, -3.73277180e-02f, -1.26614690e-01f, -1.39838278e-01f, 3.71414199e-02f },
      { 1.14148714e-01f, 7.38425106e-02f, 2.40754616e-03f, -9.63187218e-02f, 6.42384589e-02f },
      { -8.66443571e-03f, 3.67149003e-02f, -4.21575718e-02f, -1.68745667e-02f, -6.20030379e-03f },
    },
    {
      { 7.19740763e-02f, 4.18647528e-02f, 6.86818287e-02f, -7.69826323e-02f, 1.03442022e-03f },
      { -7.04631805e-02f, 6.31664135e-03f, 9.72119123e-02f, 1.13284543e-01f, 7.05018938e-02f },
      { -1.06009908e-01f, -4.32664268e-02f, 6.58682510e-02f, 2.75092162e-02f, 9.20896605e-03f },
      { -1.13665864e-01f, -8.09575394e-02f, -1.45938858e-01f, -1.08213618e-01f, -1.44265428e-01f },
      { 5.93263656e-02f, 3.75116691e-02f, -2.14087646e-02f, 6.99718744e-02f, 1.53335527e-01f },
    },
    {
      { 1.83251381e-01f, 1.61773250e-01f, 2.18258306e-01f, 2.73699649e-02f, 3.79843749e-02f },
      { 6.22892305e-02f, 1.31692113e-02f, 1.75953716e-01f, 1.13304272e-01f, 5.91190569e-02f },
      { 7.99420550e-02f, 8.74085873e-02f, 8.45896080e-02f, 6.65241992e-03f, 3.12676607e-03f },
      { 1.13560125e-01f, 2.14489713e-01f, 3.61520462e-02f, 8.01095068e-02f, 1.38424218e-01f },
      { 1.55903473e-01f, 2.21585527e-01f, 1.69375792e-01f, 9.47019905e-02f, 2.61940747e-01f },
    },
    {
      { -1.07818492e-01f, -7.69955367e-02f, -3.11378166e-02f, 3.80177833e-02f, 4.37255353e-02f },
      { -2.04381615e-01f, -1.35116085e-01f, 4.01724316e-03f, 2.79645585e-02f, 6.82832953e-03f },
      { -1.34539157e-01f, -1.86007828e-01f, -1.30207255e-01f, -7.90362433e-02f, 3.58426161e-02f },
      { 7.24583790e-02f, -6.80583641e-02f, -7.06743822e-02f, 2.76992712e-02f, 2.51697586e-03f },
      { 1.40199959e-01f, 1.25685558e-01f, 1.91160478e-02f, 9.51613039e-02f, 1.19094826e-01f },
    },
    {
      { 1.07893877e-01f, 1.34383962e-01f, -1.08300047e-02f, -8.94989725e-03f, -2.03571469e-02f },
      { 1.82688609e-01f, 2.05247149e-01f, 2.05038294e-01f, 1.36639506e-01f, 8.01160932e-04f },
      { 1.95521507e-02f, 1.30753681e-01f, 2.48501018e-01f, 1.64948344e-01f, 4.74974662e-02f },
      { 4.19623824e-03f, 5.14724888e-02f, 1.40801147e-01f, 1.57215983e-01f, 5.71735390e-02f },
      { -2.28564247e-01f, -1.98452488e-01f, -6.08939305e-02f, 6.07180744e-02f, -7.74058923e-02f },
    },
    {
      { -2.35322222e-01f, -1.13595314e-01f, 6.74099922e-02f, 2.21589774e-01f, 9.98630226e-02f },
      { -2.20182836e-01f, -2.97614902e-01f, -2.21359551e-01f, -2.88204819e-01f, -1.32340357e-01f },
      { 2.92385672e-03f, -4.92858067e-02f, -1.35146856e-01f, -1.18343033e-01f, -3.63134742e-02f },
      { 1.10421710e-01f, 1.27108380e-01f, 1.08430274e-01f, 1.15703315e-01f, 3.29140723e-02f },
      { 3.35312150e-02f, 4.54926975e-02f, 8.85597616e-03f, 3.53561938e-02f, 3.31309214e-02f },
    },
    {
      { 4.11282964e-02f, -4.30846997e-02f, -2.28283592e-02f, 1.40975351e-02f, -3.55683155e-02f },
      { 6.01183362e-02f, 5.41729331e-02f, -4.01542634e-02f, 5.16839400e-02f, 2.23902818e-02f },
      { 1.62957236e-02f, -1.10698184e-02f, -3.65784578e-02f, -3.70853655e-02f, -4.34877165e-02f },
      { -4.28456441e-02f, 3.86403576e-02f, 3.43121067e-02f, 2.11707945e-03f, 1.56334396e-02f },
      { -4.85193394e-02f, 3.37226205e-02f, 4.71459590e-02f, -2.37586945e-02f, -1.16694802e-02f },
    },
    {
      { -1.64097860e-01f, -1.58786416e-01f, 1.00460395e-01f, 1.45429522e-01f, 1.04241416e-01f },
      { -4.44453582e-02f, -1.71631604e-01f, -4.07423109e-01f, -3.33983749e-01f, -2.67624552e-03f },
      { -2.41445936e-02f, -4.25232984e-02f, -6.15298599e-02f, -1.36431798e-01f, -3.83270830e-02f },
      { 5.13444580e-02f, 1.10480838e-01f, 8.26946795e-02f, -4.29679677e-02f, 8.13362524e-02f },
      { -7.89161548e-02f, -6.53017536e-02f, -7.18506873e-02f, -6.72305524e-02f, -6.37307987e-02f },
    },
    {
      { 1.79515928e-02f, -1.54532254e-01f, -8.17213282e-02f, -3.21619287e-02f, 2.42224783e-02f },
      { -2.76193279e-03f, -1.88960314e-01f, -4.20461148e-01f, -3.44867855e-01f, 8.36395323e-02f },
      { 7.06376042e-03f, -1.45235300e-01f, -2.69773304e-01f, -5.13502777e-01f, -1.45118281e-01f },
      { 8.14184844e-02f, 1.34008890e-02f, -1.07943274e-01f, -3.77741098e-01f, -9.99877751e-02f },
      { 1.43362343e-01f, 8.59945789e-02f, -1.06677584e-01f, -2.32062966e-01f, 2.04940457e-02f },
    },
  },
  {
    {
      { 2.08055153e-01f, 1.28754333e-01f, 2.53511131e-01f, 2.40277767e-01f, 2.78882563e-01f },
      { 1.54618472e-01f, -5.38567789e-02f, -1.75081596e-01f, -2.09864527e-01f, -1.85417265e-01f },
      { 1.15508683e-01f, -1.70713425e-01f, -5.50451815e-01f, -4.18558329e-01f, 1.83455762e-03f },
      { 1.45705685e-01f, 7.87510276e-02f, -1.20553076e-01f, -1.06846532e-02f, 1.40405029e-01f },
      { 1.07896693e-01f, -3.06537822e-02f, -1.02908306e-01f, -1.56500265e-01f, -1.53963510e-02f },
    },
    {
      { -8.76819640e-02f, -4.85330354e-03f, -1.20771065e-01f, 8.26417506e-02f, 1.22936584e-01f },
      { 3.55207883e-02f, -1.77995980e-01f, -1.03657030e-01f, 4.23464403e-02f, -7.43686035e-02f },
      { -2.81015169e-02f, -2.98850149e-01f, -3.02482069e-01f, -2.94156391e-02f, 8.59928876e-02f },
      { -9.70200747e-02f, -5.36234751e-02f, -6.43109307e-02f, 5.00869378e-02f, 2.01075748e-01f },
      { 1.79132834e-01f, 1.66217417e-01f, -6.73964471e-02f, 1.36381863e-02f, 4.66519557e-02f },
    },
    {
      { -9.09576267e-02f, -1.87851250e-01f, -3.43726337e-01f, 4.19681408e-02f, 5.32566123e-02f },
      { -2.68806845e-01f, -4.64261264e-01f, -4.33161676e-01f, -1.81442928e-02f, 6.09655492e-02f },
      { -2.63958126e-01f, -1.12139381e-01f, -5.96992858e-02f, -1.58847142e-02f, 8.45601708e-02f },
      { -4.01051007e-02f, 1.50399730e-02f, 1.47916824e-01f, 8.17215368e-02f, -8.08369145e-02f },
      { 5.90866208e-02f, 2.53794879e-01f, 2.84707278e-01f, 2.38443330e-01f, 8.66718143e-02f },
    },
    {
      { 2.35995635e-01f, 1.72420695e-01f, 9.82489139e-02f, -6.93843588e-02f, 4.89956094e-03f },
      { 1.62690803e-01f, 2.87705034e-01f, 1.78171083e-01f, -1.36378020e-01f, -1.16473816e-01f },
      { 8.08273405e-02f, 2.07276464e-01f, 5.32992929e-02f, -1.03772700e-01f, -4.55520935e-02f },
      { 1.29909255e-02f, 9.51358527e-02f, 2.64102947e-02f, 4.57826890e-02f, 4.52995207e-03f },
      { 6.76067099e-02f, -4.92100269e-02f, 4.11436185e-02f, 9.96047184e-02f, 5.45943044e-02f },
    },
    {
      { 3.21612269e-01f, 2.54744828e-01f, 1.01145700e-01f, -1.64451092e-01f, 3.47142667e-02f },
      { 1.87092602e-01f, 1.51789159e-01f, 1.67823266e-02f, -2.61229843e-01f, -1.32247210e-01f },
      { 6.03827909e-02f, 2.64580220e-01f, 1.19403504e-01f, -1.19130388e-01f, -9.39830169e-02f },
      { 1.67105377e-01f, 1.53967202e-01f, -1.23433145e-02f, -5.77697940e-02f, -1.30856022e-01f },
      { 5.25859557e-02f, 4.98791486e-02f, -3.39930318e-02f, -4.96039577e-02f, 1.03119444e-02f },
    },
    {
      { 5.76390289e-02f, -1.69265002e-01f, -2.83569962e-01f, -1.51347294e-01f, -5.28375916e-02f },
      { -1.13719754e-01f, -6.17304444e-02f, -2.04638943e-01f, -2.99032837e-01f, -1.79559201e-01f },
      { -9.65465009e-02f, 1.06145792e-01f, 1.71310291e-01f, -3.22737135e-02f, -1.94024384e-01f },
      { -4.11338769e-02f, 2.44188741e-01f, 2.27978572e-01f, 1.95303053e-01f, -5.79041690e-02f },
      { 4.07744572e-02f, 2.75157597e-02f, 2.31640279e-01f, 2.43823543e-01f, 1.36484593e-01f },
    },
    {
      { 2.17300892e-01f, -9.26394388e-03f, -2.08626345e-01f, -9.75235030e-02f, -4.69759814e-02f },
      { 2.61486441e-01f, -3.09576333e-01f, -3.19039255e-01f, 1.30119212e-02f, 7.91946501e-02f },
      { 2.13196754e-01f, -4.28900510e-01f, -3.97710979e-01f, -2.36592088e-02f, 9.68449190e-02f },
      { 2.39882052e-01f, -1.77190572e-01f, -4.85075802e-01f, -6.59873709e-02f, 2.41238087e-01f },
      { 1.96174577e-01f, -1.02530882e-01f, -5.03753722e-01f, -2.07031801e-01f, 1.56116202e-01f },
    },
    {
      { 1.13785556e-02f, -1.44654661e-01f, -4.40516949e-01f, -1.17759436e-01f, -8.92549604e-02f },
      { -8.87920856e-02f, -3.26966256e-01f, -1.91810638e-01f, 8.76777172e-02f, 9.58160385e-02f },
      { -5.94572984e-02f, -1.57974690e-01f, -9.80213732e-02f, 2.29329407e-01f, 1.38297930e-01f },
      { -1.37826912e-02f, 4.49407920e-02f, -3.47092673e-02f, 5.47636002e-02f, 1.20775752e-01f },
      { -6.06519766e-02f, -5.62835075e-02f, -1.50725484e-01f, 2.21191626e-03f, 1.08723104e-01f },
    },
    {
      { -2.31099561e-01f, -1.31801412e-01f, 1.39298779e-03f, 9.84122157e-02f, 1.67956084e-01f },
      { 9.38747823e-02f, -6.00871183e-02f, -1.04050547e-01f, -7.52986744e-02f, 9.77883935e-02f },
      { 5.43556735e-02f, -6.82742745e-02f, -5.95933318e-01f, -5.20905137e-01f, -7.62825236e-02f },
      { 1.60165206e-01f, 8.93560518e-03f, -2.65063852e-01f, -3.64006013e-01f, 2.07609519e-01f },
      { 2.14148089e-01f, 1.31878868e-01f, -2.36689877e-02f, -9.02532488e-02f, -5.79352751e-02f },
    },
    {
      { -5.11915870e-02f, 2.04894077e-02f, 3.97664681e-02f, -8.08814615e-02f, -3.92237864e-02f },
      { -5.29322587e-02f, 1.05562970e-01f, 1.11181013e-01f, -1.26278132e-01f, -1.41395986e-01f },
      { -9.35823694e-02f, -3.31598669e-02f, 1.04306437e-01f, 7.79410675e-02f, -1.08931206e-01f },
      { -1.25771135e-01f, -3.15912589e-02f, 1.49688929e-01f, 1.55750662e-01f, 6.96853921e-02f },
      { -2.25645620e-02f, 6.37718663e-02f, 5.41158579e-02f, 1.43505484e-01f, 5.90356626e-02f },
    },
    {
      { 1.99284442e-02f, 4.02786024e-02f, -4.58593853e-02f, -2.81756848e-01f, -1.39592588e-01f },
      { -1.66336805e-01f, -1.00628950e-01f, -7.24737346e-02f, -1.96516439e-01f, -9.35760215e-02f },
      { -6.90331906e-02f, 1.20012544e-01f, 1.16757378e-01f, 9.49634314e-02f, -1.14695899e-01f },
      { 4.43247594e-02f, 1.53232530e-01f, 2.35412240e-01f, 1.72463417e-01f, -5.79290316e-02f },
      { 2.64249332e-02f, 5.24174012e-02f, 2.34247781e-02f, 5.55409193e-02f, 4.12009992e-02f },
    },
    {
      { -1.70328110e-01f, -9.17902812e-02f, 7.59788677e-02f, 8.84309709e-02f, 3.59202921e-02f },
      { -1.87689122e-02f, 1.10631287e-01f, 1.71372592e-01f, 7.73422420e-02f, -1.15920477e-01f },
      { -3.78314108e-02f, -4.56876084e-02f, -1.12371534e-01f, -1.69179976e-01f, -1.79412678e-01f },
      { -1.02911472e-01f, -1.74665838e-01f, -1.52750805e-01f, -9.77489352e-03f, 1.04252569e-01f },
      { -1.11425426e-02f, 6.77596033e-02f, 2.33031139e-01f, 2.14698389e-01f, 1.56312928e-01f },
    },
    {
      { -2.19493091e-01f, -2.29343921e-01f, -6.29904494e-02f, 9.30022448e-02f, 6.82609528e-02f },
      { -1.00243151e-01f, -2.02172622e-01f, -4.69696894e-02f, 1.44918710e-01f, 3.28801312e-02f },
      { -4.78309207e-02f, -4.01539542e-02f, -1.60997719e-01f, 3.90329100e-02f, 3.63693759e-02f },
      { -9.51112211e-02f, -5.63310161e-02f, -5.62532283e-02f, -8.46800283e-02f, 1.29659534e-01f },
      { 2.80446522e-02f, 8.41588974e-02f, 7.85541683e-02f, -4.12733713e-03f, 1.27222508e-01f },
    },
    {
      { -8.68135244e-02f, 1.08431587e-02f, -8.57285187e-02f, 6.19843379e-02f, 7.21649826e-02f },
      { 1.52802952e-02f, -1.56594411e-01f, -9.19191912e-02f, 9.69806686e-02f, 7.14392737e-02f },
      { 5.37101459e-03f, -3.46223891e-01f, -2.99501777e-01f, -1.57660432e-02f, 3.97258848e-02f },
      { 2.94236541e-02f, -1.72079265e-01f, -2.64125437e-01f, 4.35752608e-02f, 1.82635680e-01f },
      { 1.36739835e-01f, -6.23094430e-03f, -1.29084945e-01f, -1.22227311e-01f, 1.53499141e-01f },
    },
    {
      { 5.92967086e-02f, 2.25193333e-02f, 5.94352894e-02f, 3.05820256e-02f, 3.68523523e-02f },
      { -2.66911015e-02f, 1.83033943e-02f, -4.02265228e-02f, 1.23792363e-03f, 1.06248306e-02f },
      { 5.65986522e-02f, 5.26102111e-02f, 3.54354270e-03f, 1.09684719e-02f, 4.87362556e-02f },
      { 4.45897505e-02f, -2.01827809e-02f, 3.38720605e-02f, -4.25992608e-02f, 1.92781780e-02f },
      { 5.87337418e-03f, -3.34282070e-02f, -1.41009968e-02f, -1.68000795e-02f, -3.32889259e-02f },
    },
    {
      { -6.58704787e-02f, -1.26844049e-02f, 3.43417674e-02f, 3.35535291e-03f, 4.66995575e-02f },
      { -6.88394392e-03f, -7.99509510e-02f, 5.90794161e-02f, 8.77781585e-02f, 1.63614228e-02f },
      { 3.42208106e-04f, -4.17830274e-02f, 6.81101009e-02f, 3.27701457e-02f, 6.72768205e-02f },
      { -1.00484535e-01f, -1.34668350e-01f, -7.53006414e-02f, 6.07260875e-02f, 1.04196906e-01f },
      { -7.91596323e-02f, -1.15477011e-01f, -6.48396313e-02f, 6.15514740e-02f, 1.40225366e-01f },
    },
    {
      { 9.07992199e-02f, 1.30738690e-01f, 6.63153827e-02f, -5.65959923e-02f, 1.87012311e-02f },
      { 5.32854684e-02f, 1.22576699e-01f, 3.61851417e-02f, -1.65383238e-02f, 4.55470420e-02f },
      { 4.17179801e-02f, 3.32011878e-02f, 5.69325723e-02f, 2.71546487e-02f, 6.89815879e-02f },
      { -3.37365046e-02f, -3.64539325e-02f, -9.31513533e-02f, -4.96120602e-02f, 4.79265116e-02f },
      { 5.01444004e-02f, -1.10952489e-01f, -9.11406800e-02f, -6.36193454e-02f, 7.75792375e-02f },
    },
    {
      { 2.65556499e-02f, -1.34755626e-01f, -1.30231202e-01f, -1.32613704e-01f, -1.44160122e-01f },
      { -4.38606329e-02f, -1.06656358e-01f, -3.21241617e-02f, 2.65344116e-03f, 3.03395800e-02f },
      { 1.64224878e-02f, 4.94997129e-02f, 5.97332753e-02f, 1.73464775e-01f, -4.81242985e-02f },
      { 8.01189244e-02f, 9.35732275e-02f, 4.21845242e-02f, 1.04308270e-01f, 3.45143490e-02f },
      { -7.89301991e-02f, -2.86439154e-02f, -1.50260767e-02f, 1.29312146e-02f, 4.83454131e-02f },
    },
    {
      { 1.25072807e-01f, 6.69019818e-02f, -2.59961132e-02f, -1.99451685e-01f, -2.37856984e-01f },
      { -2.03355625e-02f, -6.58514276e-02f, -1.42808482e-01f, -2.52217740e-01f, -2.14085087e-01f },
      { -4.28130710e-03f, -2.49466002e-02f, 2.83756983e-02f, -2.12985296e-02f, -2.66899616e-02f },
      { 1.37620524e-01f, 1.43392682e-01f, 1.53587878e-01f, 1.25315830e-01f, 4.49698195e-02f },
      { 8.95389356e-03f, -2.66132206e-02f, 2.27783360e-02f, 1.91990789e-02f, -7.71005452e-02f },
    },
    {
      { 1.99122369e-01f, 1.73698470e-01f, 1.50237709e-01f, 2.88233273e-02f, -6.51921704e-02f },
      { 1.31281689e-01f, 1.27195433e-01f, 3.42490226e-02f, -4.59494479e-02f, -1.55270277e-02f },
      { 1.48775741e-01f, 1.35407969e-01f, -1.14356261e-02f, -1.27195910e-01f, -5.36282323e-02f },
      { 1.05270766e-01f, -2.52443478e-02f, -2.05422521e-01f, -1.19402826e-01f, 5.88483512e-02f },
      { 1.49552757e-02f, -6.73781484e-02f, -1.27745807e-01f, -2.05940418e-02f, 1.56812787e-01f },
    },
    {
      { -1.43818289e-01f, -4.92359474e-02f, 1.39090404e-01f, 1.18656136e-01f, -1.89924147e-02f },
      { 6.88457638e-02f, 2.03496918e-01f, 2.44648218e-01f, 1.13331020e-01f, -4.36410122e-02f },
      { 2.21983772e-02f, -1.53532578e-02f, -1.51233992e-03f, -7.88915232e-02f, -2.35139936e-01f },
      { -9.47040990e-02f, -1.28752545e-01f, -7.70662054e-02f, 3.13865282e-02f, 9.30221379e-02f },
      { -1.14029087e-01f, -2.66491901e-02f, 8.67165998e-02f, 2.07938626e-01f, 1.88226417e-01f },
    },
    {
      { -1.95420489e-01f, -3.89094383e-01f, -4.63937938e-01f, -3.20895046e-01f, 2.97196116e-03f },
      { -1.38877273e-01f, -3.30818743e-01f, -2.63774902e-01f, -1.92752063e-01f, 4.65396009e-02f },
      { -2.41278738e-01f, -1.71119913e-01f, -2.18308136e-01f, -1.54726833e-01f, -4.41546850e-02f },
      { -1.25799730e-01f, -2.33180940e-01f, -1.47551283e-01f, -2.21516434e-02f, 2.83175223e-02f },
      { -2.34837249e-01f, -1.38824567e-01f, 1.43125211e-03f, -1.29958197e-01f, -7.55197704e-02f },
    },
    {
      { 6.73137233e-02f, -1.76969022e-01f, -1.10017374e-01f, 3.44030485e-02f, 1.00158472e-02f },
      { 2.93687303e-02f, -9.16361138e-02f, -1.18989781e-01f, -4.13293466e-02f, -8.42454098e-03f },
      { -8.69197175e-02f, -2.28685569e-02f, 2.06045453e-02f, -5.55359386e-02f, -9.53664258e-02f },
      { -4.75728624e-02f, -1.09314829e-01f, 6.76748529e-02f, 7.42390901e-02f, 3.14354971e-02f },
      { 2.10656878e-02f, 1.07381403e-01f, 1.98678672e-01f, 2.15766877e-01f, 1.93480536e-01f },
    },
    {
      { -4.69023995e-02f, -9.09610167e-02f, -8.05486441e-02f, 1.18325152e-01f, 2.81587429e-02f },
      { -5.56211434e-02f, -1.46545440e-01f, 2.44603641e-02f, 8.75172094e-02f, 5.45956567e-02f },
      { 3.72469835e-02f, -1.36272445e-01f, -3.77994180e-02f, 5.42126596e-02f, 1.08133100e-01f },
      { -6.83833435e-02f, -7.82064945e-02f, -6.63141310e-02f, 8.47378671e-02f, 1.32958204e-01f },
      { -3.68863950e-03f, -7.66214356e-02f, -9.21982080e-02f, -2.48788409e-02f, 1.40208200e-01f },
    },
    {
      { 3.34370658e-02f, 5.40204085e-02f, -5.17416596e-02f, -9.53144804e-02f, -1.18173189e-01f },
      { -2.36896291e-01f, -1.20994069e-01f, -1.44465724e-02f, -1.00956127e-01f, 3.66614349e-02f },
      { -1.21447720e-01f, 2.89189816e-03f, 4.78960015e-02f, 7.12346286e-02f, -5.47177680e-02f },
      { 4.84683178e-02f, 5.37869930e-02f, 1.03124224e-01f, 1.53980047e-01f, 6.42131492e-02f },
      { 1.09030746e-01f, 8.14024955e-02f, 3.38127948e-02f, -1.47500932e-02f, 5.14007546e-02f },
    },
    {
      { 1.20016642e-01f, 3.18292971e-03f, -2.02770174e-01f, -2.22923994e-01f, -1.36445507e-01f },
      { 1.31579684e-02f, -1.67532623e-01f, -6.87010214e-02f, -5.20205544e-03f, 1.30724788e-01f },
      { 2.42366828e-02f, -3.26723456e-02f, 3.31491791e-02f, 5.81667349e-02f, 1.55236684e-02f },
      { 5.88248707e-02f, 9.23211277e-02f, 5.68003356e-02f, 5.32631837e-02f, 8.83278996e-02f },
      { 5.92582300e-02f, 1.61569819e-01f, 6.41219169e-02f, 4.60706800e-02f, 1.02216192e-01f },
    },
    {
      { 1.61784828e-01f, 4.91464175e-02f, 2.19597369e-02f, -5.88372424e-02f, -2.09235977e-02f },
      { -5.71548603e-02f, -6.86595635e-03f, 7.77959079e-02f, 2.80517228e-02f, -3.25691067e-02f },
      { 6.02007061e-02f, 1.28466636e-01f, 6.27939776e-02f, 1.24698766e-01f, 7.31795095e-04f },
      { 3.28247510e-02f, -2.65158806e-02f, 4.53464501e-03f, -4.36651073e-02f, 1.68963280e-02f },
      { -7.91865494e-03f, -3.13049071e-02f, -2.50436366e-02f, -6.92246109e-02f, -3.54856299e-03f },
    },
    {
      { -6.86801672e-02f, -1.49802804e-01f, -1.35177568e-01f, -4.79300991e-02f, 6.69521019e-02f },
      { -1.18841618e-01f, -6.86370656e-02f, 2.41289921e-02f, -7.08860606e-02f, -2.55063605e-02f },
      { -5.64192422e-02f, 5.28826229e-02f, 1.19987860e-01f, -1.08076319e-01f, -1.42780945e-01f },
      { 1.70361213e-02f, 6.84701353e-02f, 2.07061514e-01f, 1.10840224e-01f, -7.27570355e-02f },
      { -2.59221382e-02f, 1.87368497e-01f, 2.76258051e-01f, 2.58690178e-01f, 9.97790247e-02f },
    },
    {
      { -9.05104727e-02f, 1.09877042e-01f, 2.79898077e-01f, 1.71417683e-01f, 3.56826521e-02f },
      { 1.53973654e-01f, 2.44541392e-01f, 2.05826148e-01f, 1.54311746e-01f, -6.98331147e-02f },
      { 7.33566657e-02f, -1.35765508e-01f, -2.35909417e-01f, -2.85929769e-01f, -2.87982106e-01f },
      { -6.36934564e-02f, -1.55641213e-01f, -1.62500203e-01f, -5.79503179e-03f, 1.26994178e-01f },
      { -2.60353200e-02f, 1.93794891e-02f, 5.80911562e-02f, 1.23180509e-01f, 1.83847070e-01f },
    },
    {
      { -6.73357695e-02f, 2.62485910e-02f, -1.35746012e-02f, 2.34237015e-02f, -4.18024175e-02f },
      { -2.17447383e-03f, 2.30718739e-02f, 2.22153384e-02f, -5.78186028e-02f, -3.84363681e-02f },
      { 3.48723605e-02f, -1.62558500e-02f, -6.69896975e-02f, 3.47329192e-02f, 2.82554068e-02f },
      { 2.42726039e-02f, -1.34168928e-02f, 4.62162048e-02f, 6.95508323e-04f, 2.52637565e-02f },
      { 4.93496768e-02f, 5.18927760e-02f, 4.48407680e-02f, 4.23400328e-02f, 1.55248819e-02f },
    },
    {
      { 2.78117877e-05f, 1.45193592e-01f, 2.13365033e-01f, 1.21214002e-01f, 1.63811564e-01f },
      { 1.47042379e-01f, 5.86677808e-03f, -5.48227318e-02f, 7.07476363e-02f, -1.61600038e-01f },
      { 2.86557283e-02f, -2.45270908e-01f, -4.32870716e-01f, -3.97407971e-02f, -3.01346388e-02f },
      { 1.38661973e-02f, -2.33271495e-01f, -1.82078972e-01f, 7.73645267e-02f, 1.55918404e-01f },
      { 9.31479186e-02f, 8.41769427e-02f, -6.36001229e-02f, -4.85589951e-02f, 1.28675312e-01f },
    },
    {
      { 1.76639691e-01f, 1.39959544e-01f, -3.11570406e-01f, -1.66780978e-01f, -1.87438712e-01f },
      { 1.19377881e-01f, -2.84506623e-02f, -2.99588144e-01f, -7.71644488e-02f, 5.71874827e-02f },
      { 2.37785190e-01f, -1.98033586e-01f, -2.68836975e-01f, 1.87643077e-02f, 1.70932025e-01f },
      { 1.12231307e-01f, -1.45143434e-01f, -3.70583087e-01f, -1.58703029e-01f, 1.60260513e-01f },
      { 1.13455556e-01f, -1.55198261e-01f, -4.13288563e-01f, -3.11938614e-01f, 1.15817308e-01f },
    },
  },
  {
    {
      { -8.41634274e-02f, -1.70224882e-03f, 3.42525430e-02f, -1.14744276e-01f, -8.08848813e-02f },
      { -2.65837740e-02f, -2.73441374e-02f, 2.48229112e-02f, 6.26653209e-02f, 2.25588959e-02f },
      { 4.71002012e-02f, 4.40757684e-02f, 1.77337416e-02f, -9.80301667e-03f, -4.62143794e-02f },
      { -4.66632545e-02f, -3.92368771e-02f, -5.93292452e-02f, 5.45531176e-02f, -5.54798432e-02f },
      { 6.06752522e-02f, -8.87904316e-03f, 2.35791411e-02f, 4.58210222e-02f, 4.18454893e-02f },
    },
    {
      { -6.24193028e-02f, 1.20582210e-03f, -4.42249328e-02f, -7.27157146e-02f, -6.72297329e-02f },
      { -3.37770768e-02f, -1.53962488e-03f, -3.51241305e-02f, -5.72833791e-02f, -1.10361047e-01f },
      { 2.74297055e-02f, -5.04239239e-02f, -5.64074069e-02f, 4.03477484e-03f, -6.31517842e-02f },
      { -6.01305589e-02f, -1.89086515e-02f, -4.81078215e-02f, -6.33938164e-02f, -4.75529721e-03f },
      { 3.67576778e-02f, 3.45050879e-02f, -5.46271764e-02f, -4.87273606e-03f, -3.34908552e-02f },
    },
    {
      { -6.69179708e-02f, -6.17651902e-02f, -3.76567780e-03f, -1.79538690e-02f, -7.40858167e-02f },
      { -1.32316323e-02f, 1.51656093e-02f, 1.77106503e-02f, -5.67639433e-02f, 2.00713575e-02f },
      { 2.59339791e-02f, -9.19843558e-03f, -6.26252033e-03f, -4.90513705e-02f, -4.27864008e-02f },
      { -8.10303539e-02f, -4.52239923e-02f, -1.00149274e-01f, -7.45079592e-02f, -5.57958782e-02f },
      { -1.08744137e-01f, -9.10298452e-02f, -1.04904026e-01f, -8.15365240e-02f, 8.81325826e-03f },
    },
    {
      { -2.27231923e-02f, -8.65330622e-02f, 3.11012883e-02f, 1.12773832e-02f, -3.97854857e-02f },
      { -2.80989483e-02f, -8.46579969e-02f, -8.46475810e-02f, -2.87539605e-02f, 1.50445746e-02f },
      { -8.63604061e-03f, -7.33947754e-02f, -7.40462691e-02f, -1.60930622e-02f, -5.56717142e-02f },
      { -2.09572986e-02f, -5.60188964e-02f, -4.08245623e-02f, -1.03273973e-01f, 2.61993539e-02f },
      { 4.32019704e-04f, 1.68893989e-02f, -6.06065057e-02f, -7.19628111e-02f, -4.22762111e-02f },
    },
    {
      { -2.60726828e-02f, -1.59690194e-02f, 5.13204606e-03f, -2.19921600e-02f, 5.49510345e-02f },
      { -2.75942567e-03f, -2.54565328e-02f, 3.53543609e-02f, -4.14584316e-02f, -4.79267053e-02f },
      { -9.52076241e-02f, 6.83920644e-03f, -5.61098233e-02f, -9.47069190e-03f, 3.58565710e-03f },
      { -5.31611778e-02f, 4.02822904e-03f, -7.86605328e-02f, -1.70591865e-02f, 3.57862934e-02f },
      { -2.97774654e-02f, -5.63555844e-02f, -8.17820057e-02f, -1.04322419e-01f, -7.61477510e-03f },
    },
    {
      { -6.18165210e-02f, -3.61204520e-02f, -6.46423921e-02f, 1.71787906e-02f, 3.41612995e-02f },
      { -1.18608907e-01f, -1.69618931e-02f, -3.13203856e-02f, 4.22518663e-02f, -1.78672578e-02f },
      { -2.97941361e-02f, -1.06666088e-01f, -2.42072698e-02f, -4.32951003e-02f, 2.61083934e-02f },
      { -7.23078996e-02f, -1.10134311e-01f, -4.74894568e-02f, -3.52174714e-02f, -8.88996050e-02f },
      { -8.34222585e-02f, -6.19909167e-02f, -6.22977829e-03f, -1.24700718e-01f, -3.98331173e-02f },
    },
    {
      { -8.43165517e-02f, 1.09805427e-02f, -2.25451514e-02f, -3.16902734e-02f, -7.49574825e-02f },
      { 5.63318878e-02f, 5.82249351e-02f, -3.51517275e-02f, 4.09163572e-02f, -6.39981106e-02f },
      { -2.79745855e-03f, 6.67415783e-02f, -2.03746464e-02f, 2.38119182e-03f, -1.02272674e-01f },
      { 1.30560808e-02f, -7.10573699e-03f, -4.17073928e-02f, 5.25236242e-02f, -2.61845514e-02f },
      { -1.02518899e-02f, -3.13426964e-02f, 1.78238135e-02f, 2.90428530e-02f, -3.55750099e-02f },
    },
    {
      { -7.59789199e-02f, -2.90755704e-02f, 6.03250042e-02f, 3.00388746e-02f, -6.16293140e-02f },
      { -4.29250449e-02f, -1.81318130e-02f, 1.08420132e-02f, -7.23303556e-02f, -9.01948735e-02f },
      { -6.95124418e-02f, -3.76851149e-02f, -9.10849199e-02f, -1.03040509e-01f, -8.96964744e-02f },
      { -8.19018751e-04f, -6.60988241e-02f, -4.60105622e-03f, -2.35797446e-02f, -8.10507778e-03f },
      { -2.37626377e-02f, -2.49799937e-02f, 1.10984854e-02f, 3.46569121e-02f, -7.07749724e-02f },
    },
    {
      { -6.84588403e-02f, -1.06798727e-02f, -8.23796540e-02f, -3.75494100e-02f, -7.25952685e-02f },
      { 3.61032411e-02f, 3.76295224e-02f, -3.32870074e-02f, 1.94958150e-02f, -9.05388072e-02f },
      { -2.39330083e-02f, 1.25591299e-02f, 3.80705893e-02f, 4.93516363e-02f, -2.62260288e-02f },
      { -3.94686498e-02f, -6.57381788e-02f, -5.57870753e-02f, 2.42821183e-02f, -5.02998456e-02f },
      { 9.66518000e-02f, 9.33416933e-03f, -3.62921767e-02f, -4.52602282e-02f, 2.39624344e-02f },
    },
    {
      { -7.22251832e-02f, 2.23679598e-02f, 1.37636010e-02f, -4.55144309e-02f, -5.66590875e-02f },
      { -3.76674011e-02f, -3.82598378e-02f, -2.78734528e-02f, 4.01977263e-02f, 3.55850756e-02f },
      { -3.67978401e-02f, -1.01883776e-01f, -6.51738346e-02f, 1.43360160e-02f, 3.44525687e-02f },
      { -4.49967422e-02f, 1.50806541e-02f, -2.67884042e-03f, -7.80517161e-02f, -4.19919007e-02f },
      { -4.92388867e-02f, -3.29340212e-02f, -3.12291249e-03f, -2.95856334e-02f, -9.10522342e-02f },
    },
    {
      { -6.36116117e-02f, 4.27329540e-03f, -7.04345256e-02f, 2.98617203e-02f, 2.38071419e-02f },
      { -6.79099932e-02f, -5.35171852e-02f, -2.63696886e-03f, -3.49065214e-02f, 4.96492721e-02f },
      { -5.77982739e-02f, -2.51350254e-02f, -8.50767568e-02f, -8.20327848e-02f, 6.65535731e-03f },
      { -5.15162088e-02f, -6.52047545e-02f, -1.31196648e-01f, -8.61386433e-02f, -2.39478052e-02f },
      { -8.37972388e-02f, -7.52712116e-02f, -6.95967153e-02f, -6.97500035e-02f, -3.85397971e-02f },
    },
    {
      { -5.97078726e-03f, 7.27152126e-03f, -2.63524298e-02f, -7.48746172e-02f, 3.40174721e-03f },
      { -2.74473261e-02f, -3.89435440e-02f, -1.04508244e-01f, -3.34950797e-02f, -7.32679740e-02f },
      { -2.47229245e-02f, 2.36770064e-02f, -7.81577379e-02f, -6.69130385e-02f, -2.02792846e-02f },
      { -9.12739858e-02f, -9.02015790e-02f, 1.27196191e-02f, -3.65717374e-02f, -4.88318130e-02f },
      { 1.17799835e-02f, -6.09601885e-02f, -5.01596481e-02f, 1.42177250e-02f, -1.24944979e-02f },
    },
    {
      { 2.00799778e-02f, -1.01214193e-01f, 6.56418130e-03f, -3.87695022e-02f, -6.88541681e-02f },
      { 3.50194722e-02f, 1.35621354e-02f, -6.40634969e-02f, -3.07560456e-03f, -1.16472341e-01f },
      { -7.93157890e-02f, -4.05132324e-02f, 2.70286202e-02f, -9.35914367e-02f, -1.73689537e-02f },
      { -1.76320504e-02f, -6.34281663e-03f, 2.50964775e-03f, -2.49649063e-02f, -7.96098262e-02f },
      { -7.02931881e-02f, 1.85466185e-02f, -6.40336648e-02f, -9.27017443e-03f, 1.61974709e-02f },
    },
    {
      { 2.24410873e-02f, -8.53522273e-04f, -6.01096936e-02f, -5.22277243e-02f, -2.20444109e-02f },
      { -4.55117486e-02f, 3.47873243e-03f, -8.94192159e-02f, -9.22036767e-02f, -1.14961438e-01f },
      { 3.60687636e-02f, -5.20766228e-02f, 2.02900693e-02f, 2.92930938e-02f, -9.68015492e-02f },
      { 2.65653189e-02f, 2.42144372e-02f, 2.70412546e-02f, -1.45244855e-03f, -8.65970254e-02f },
      { 4.31675836e-02f, 1.20045841e-02f, 3.58730778e-02f, -5.97992279e-02f, 3.03277448e-02f },
    },
    {
      { -6.23366311e-02f, 6.29520640e-02f, -4.83749360e-02f, -2.11706422e-02f, 1.61116067e-02f },
      { -2.80204881e-02f, -3.47794848e-04f, -2.24192254e-02f, 6.44946024e-02f, -3.91500071e-02f },
      { -4.16084267e-02f, 4.86793229e-04f, -3.58965993e-02f, 2.15584598e-02f, -1.34509942e-02f },
      { 8.66155326e-03f, 5.36584817e-02f, 1.29385646e-02f, -1.09327203e-02f, -5.98357692e-02f },
      { -9.83033609e-03f, 3.11747589e-03f, 6.21546283e-02f, -1.76649354e-02f, 2.38831826e-02f },
    },
    {
      { -1.66793726e-02f, -1.01467103e-01f, -3.96411680e-02f, -5.12554236e-02f, -2.27436349e-02f },
      { 1.48716439e-02f, 1.63470525e-02f, 9.64303315e-03f, -1.71858519e-02f, -8.61155689e-02f },
      { -9.74366535e-03f, 1.62446424e-02f, 5.02220541e-03f, -1.44493133e-02f, -6.20708428e-02f },
      { -7.10975528e-02f, 1.64263435e-02f, -5.72108403e-02f, -9.95944440e-02f, -1.13645338e-01f },
      { -4.00331542e-02f, -8.33349302e-02f, -3.84699777e-02f, 2.84990743e-02f, -8.30836892e-02f },
    },
    {
      { -6.25456274e-02f, -7.64882714e-02f, -3.36266533e-02f, -5.17174639e-02f, -4.07363139e-02f },
      { -2.25322377e-02f, -4.35569882e-03f, 1.23191411e-02f, -6.03876077e-03f, 2.52168402e-02f },
      { 4.66438904e-02f, -2.24115865e-04f, 3.36861275e-02f, -3.56237106e-02f, -5.65665588e-03f },
      { -6.34193346e-02f, -4.93924730e-02f, 3.99950688e-04f, -5.34834005e-02f, 2.13532988e-02f },
      { -3.84414964e-03f, -2.35392824e-02f, -4.83417958e-02f, -4.57335860e-02f, -7.27663785e-02f },
    },
    {
      { -7.85721280e-03f, -2.78561898e-02f, -2.90659955e-03f, 3.06286365e-02f, -3.61068025e-02f },
      { -3.92166749e-02f, 1.92737018e-04f, 4.42252979e-02f, 1.91463828e-02f, -1.89987049e-02f },
      { -9.12488699e-02f, -2.85347160e-02f, -8.16204175e-02f, -2.44660359e-02f, 4.07398939e-02f },
      { 1.22673865e-02f, -5.82610182e-02f, -3.79988886e-02f, -9.81208980e-02f, -8.86756461e-03f },
      { -6.69159070e-02f, -2.63823550e-02f, -8.01829994e-03f, -1.16716241e-02f, -8.07752162e-02f },
    },
    {
      { -3.85280028e-02f, -5.99288307e-02f, 1.54525628e-02f, 4.71794866e-02f, 1.73604824e-02f },
      { -7.34419450e-02f, -6.10422902e-02f, -9.60371643e-03f, 4.39756513e-02f, -6.35728016e-02f },
      { -2.20596176e-02f, -1.47165908e-02f, -4.30935435e-03f, 2.59603170e-04f, 1.65601224e-02f },
      { -6.84372336e-02f, -2.34750453e-02f, 4.52774437e-03f, -1.61894131e-02f, -4.14652079e-02f },
      { -3.32069881e-02f, -8.40902627e-02f, -6.92188665e-02f, -9.90766510e-02f, 1.45807229e-02f },
    },
    {
      { 1.07351113e-02f, 1.69223584e-02f, -5.84613308e-02f, 3.33983637e-02f, 4.14753221e-02f },
      { -5.85366301e-02f, -8.10554475e-02f, -4.53981534e-02f, -6.14088960e-02f, 1.27565460e-02f },
      { -1.85263194e-02f, -1.90295465e-02f, -1.32190678e-02f, 2.16446351e-02f, -4.09145355e-02f },
      { -6.14282750e-02f, -4.07088585e-02f, -5.66151664e-02f, -3.46340761e-02f, -2.98805740e-02f },
      { 1.12126544e-02f, 1.61580723e-02f, -1.50833558e-03f, -2.95602269e-02f, -4.40852754e-02f },
    },
    {
      { -2.16428488e-02f, -5.83182015e-02f, -5.53772673e-02f, -4.88766432e-02f, 2.34008040e-02f },
      { -2.40188409e-02f, -5.12859672e-02f, 4.38639312e-04f, -6.44866377e-02f, -9.63314623e-02f },
      { -3.18807513e-02f, -5.63371181e-02f, 9.96429008e-03f, -6.18351847e-02f, -2.04916485e-02f },
      { -8.86618942e-02f, -4.33494411e-02f, -7.45012835e-02f, -6.77046180e-02f, -4.32781465e-02f },
      { -1.26735661e-02f, -8.95350054e-02f, -7.02998266e-02f, 2.33064014e-02f, -3.13512385e-02f },
    },
    {
      { -5.12142014e-03f, -6.27567321e-02f, -4.22044471e-02f, -5.41927032e-02f, 7.04381093e-02f },
      { 2.35008020e-02f, -6.98885471e-02f, -8.16264302e-02f, -6.98498562e-02f, 5.20001613e-02f },
      { 6.73274249e-02f, -4.31915633e-02f, 3.52669954e-02f, 2.24919803e-03f, -5.10153137e-02f },
      { -7.84570724e-02f, -2.10564602e-02f, 1.83566343e-02f, 5.22384457e-02f, 6.57920390e-02f },
      { -1.26924012e-02f, -2.76600029e-02f, -9.83718131e-03f, -6.15709797e-02f, 3.24808210e-02f },
    },
    {
      { -6.17060289e-02f, 6.26574131e-03f, -2.86799874e-02f, -5.62126152e-02f, -6.47675395e-02f },
      { -9.84465107e-02f, -5.01824282e-02f, -9.56909657e-02f, 2.44180355e-02f, -2.12506820e-02f },
      { -2.78974348e-03f, -3.44205908e-02f, -7.54274651e-02f, -7.89014995e-02f, -5.91161177e-02f },
      { -3.58538851e-02f, -4.13982645e-02f, -3.75550576e-02f, -7.15366751e-02f, -7.58268833e-02f },
      { -8.64643455e-02f, -7.21718520e-02f, -5.56599759e-02f, -3.69206667e-02f, -5.24542965e-02f },
    },
    {
      { -8.89019817e-02f, -8.56208131e-02f, -9.53315198e-03f, 2.01240610e-02f, 1.36731183e-02f },
      { -2.07000636e-02f, 1.97636001e-02f, 2.73290072e-02f, -2.12192126e-02f, -7.44205043e-02f },
      { -5.71444370e-02f, -3.04219760e-02f, -7.91832730e-02f, 1.04487669e-02f, 2.79809884e-03f },
      { -8.01570639e-02f, 2.54153162e-02f, -1.11026242e-02f, 1.54530974e-02f, -7.72775635e-02f },
      { -4.42556366e-02f, -5.02741262e-02f, -6.46560043e-02f, 1.34582617e-04f, -6.77400976e-02f },
    },
    {
      { -2.67615542e-03f, -6.55074939e-02f, 1.10141607e-03f, -3.92638780e-02f, -3.77157964e-02f },
      { -1.33840637e-02f, 2.36592647e-02f, -7.58196507e-03f, -7.43807703e-02f, 3.36669683e-02f },
      { -5.06264914e-04f, 2.40228660e-02f, -7.32147098e-02f, -1.89889427e-02f, -3.35346423e-02f },
      { -7.29805753e-02f, -3.69504020e-02f, -4.67636436e-02f, -1.98191945e-02f, -9.36122015e-02f },
      { 8.25636834e-03f, -3.85340229e-02f, -2.33304612e-02f, -7.22216964e-02f, -3.27694416e-02f },
    },
    {
      { 3.28961983e-02f, -5.40725738e-02f, 7.70260207e-03f, -6.82600215e-02f, 1.57179926e-02f },
      { -4.24161889e-02f, -7.82555193e-02f, -5.04960231e-02f, -5.74463867e-02f, 1.69070438e-02f },
      { -5.37201129e-02f, -1.32369837e-02f, 1.29827084e-02f, 8.25115712e-04f, -5.88522255e-02f },
      { 4.17499989e-02f, 1.36448136e-02f, 6.36118371e-03f, -8.17355290e-02f, -1.86107960e-02f },
      { -7.70994276e-02f, -9.10629034e-02f, -8.52687955e-02f, 1.27032688e-02f, -5.93532324e-02f },
    },
    {
      { -3.66617665e-02f, -4.12184894e-02f, 3.54241803e-02f, 8.61353613e-03f, 3.72551680e-02f },
      { -1.48831569e-02f, -1.19825993e-02f, 1.00435484e-02f, -5.55292219e-02f, 5.18262424e-02f },
      { -2.13748962e-03f, 2.54229400e-02f, -9.18458477e-02f, -6.59186691e-02f, -2.11685635e-02f },
      { 4.94133160e-02f, -2.12918222e-02f, 1.51291313e-02f, -9.00252908e-02f, -6.21798001e-02f },
      { 2.64479648e-02f, -8.57644379e-02f, -1.66075751e-02f, 4.28836187e-03f, -6.80131316e-02f },
    },
    {
      { -2.69423909e-02f, -3.47899869e-02f, 1.56594031e-02f, -3.84164625e-03f, -8.62397719e-03f },
      { -8.73502418e-02f, -7.62056485e-02f, 4.66935395e-04f, -7.97438398e-02f, 3.02649643e-02f },
      { -6.40996918e-02f, -5.35617732e-02f, -4.54341397e-02f, 9.91906598e-03f, -7.11407885e-02f },
      { -1.14738010e-01f, -5.20802587e-02f, -2.01493800e-02f, -6.99683055e-02f, -3.23943235e-02f },
      { -1.90415457e-02f, -4.77366447e-02f, -9.16045159e-02f, -8.00772980e-02f, -3.35366018e-02f },
    },
    {
      { -7.47383609e-02f, -1.13075092e-01f, -3.63299735e-02f, 6.54920645e-04f, -1.16054807e-02f },
      { -2.14872975e-02f, -4.50656153e-02f, -4.81801927e-02f, -6.78186491e-02f, 1.16554182e-03f },
      { -2.14126948e-02f, -3.53515781e-02f, -4.50560153e-02f, 3.46941650e-02f, -1.54392431e-02f },
      { -1.07469587e-02f, 7.23453006e-03f, -4.52351682e-02f, 1.56220663e-02f, -4.71143462e-02f },
      { 6.57221526e-02f, -9.15927999e-03f, -6.17317893e-02f, 4.46007438e-02f, 4.00253236e-02f },
    },
    {
      { 4.59403768e-02f, -4.41328064e-02f, -2.94140559e-02f, -4.54308065e-05f, -2.51871776e-02f },
      { 5.56641109e-02f, -3.70364375e-02f, -1.17426198e-02f, -6.57733902e-02f, 5.52044809e-02f },
      { -4.51189242e-02f, -4.45523709e-02f, -3.73735167e-02f, -9.11512412e-03f, 1.25318663e-02f },
      { -1.87670495e-02f, -3.40689197e-02f, 4.01694737e-02f, -5.25174774e-02f, -3.90323661e-02f },
      { 4.10991795e-02f, 5.50600253e-02f, -1.63734797e-02f, -4.52610329e-02f, -2.67848112e-02f },
    },
    {
      { -7.06321076e-02f, -8.35355744e-02f, 2.84582656e-02f, -8.02332610e-02f, 6.67390926e-03f },
      { 1.88568104e-02f, 3.22749019e-02f, 2.32139546e-02f, -6.60456717e-02f, -6.83791563e-02f },
      { 2.41571963e-02f, -5.28134145e-02f, 1.45221744e-02f, 2.32395753e-02f, 6.88173622e-03f },
      { 9.91454162e-03f, -2.84252991e-03f, 1.56188030e-02f, -3.06165088e-02f, -4.85029630e-02f },
      { 5.26211224e-02f, 5.67255318e-02f, 5.31805195e-02f, -5.90432771e-02f, 4.72713597e-02f },
    },
    {
      { -8.12553018e-02f, 4.37326320e-02f, 6.92739338e-03f, 3.57301123e-02f, -5.81118762e-02f },
      { -5.39012291e-02f, 2.64648371e-03f, -1.25984699e-02f, 5.18229790e-02f, -2.55153291e-02f },
      { -4.49082209e-03f, 6.03266060e-02f, 4.68815528e-02f, 1.41431512e-02f, -8.90067071e-02f },
      { -9.20935650e-04f, 5.25408573e-02f, 7.43928254e-02f, -3.93000012e-03f, 3.92907858e-02f },
      { 6.56968262e-03f, 3.37973125e-02f, 5.34994341e-02f, 6.01290315e-02f, 1.62129551e-02f },
    },
  },
  {
    {
      { 5.99725284e-02f, 2.03807831e-01f, 1.86852723e-01f, -2.32227035e-02f, 8.44226703e-02f },
      { -1.36119604e-01f, 1.71355605e-01f, 1.18294455e-01f, -1.13104425e-01f, -8.44651684e-02f },
      { -1.23049863e-01f, 1.06559001e-01f, 1.42526507e-01f, 1.90192312e-01f, -2.10269634e-02f },
      { -4.30246666e-02f, 4.86459173e-02f, 2.90218085e-01f, 1.94083050e-01f, 1.47844162e-02f },
      { -9.92633253e-02f, 6.49138689e-02f, 1.25805676e-01f, 9.55417752e-02f, 2.46461015e-02f },
    },
    {
      { -5.85729778e-02f, -7.79550076e-02f, 2.18854427e-01f, 2.14884114e-02f, -1.86036035e-01f },
      { -2.07163379e-01f, 3.17508504e-02f, 3.17016006e-01f, -3.24540526e-01f, 2.39176676e-02f },
      { -2.52395302e-01f, 3.13339055e-01f, 1.89577520e-01f, -2.84761727e-01f, -2.34947400e-03f },
      { -9.22836214e-02f, 3.50935668e-01f, 4.27139476e-02f, -1.37176752e-01f, -1.08307756e-01f },
      { -1.40181202e-02f, -5.48350683e-04f, -2.18330361e-02f, -1.68699294e-01f, -1.65516272e-01f },
    },
    {
      { -1.77083582e-01f, -1.35542870e-01f, -1.85221399e-03f, -3.51241201e-01f, -1.52791619e-01f },
      { -2.64561027e-01f, 1.81294516e-01f, 1.18484996e-01f, -2.92686850e-01f, -4.41963151e-02f },
      { -5.62765896e-02f, 3.17638874e-01f, 2.23706231e-01f, -1.33362815e-01f, -8.20755810e-02f },
      { -1.56472802e-01f, 9.82288718e-02f, -3.75516992e-03f, -1.04640745e-01f, 1.59767829e-02f },
      { 8.18114504e-02f, -3.83441411e-02f, -3.65804434e-02f, -2.17255503e-01f, -1.43738955e-01f },
    },
    {
      { 1.77766606e-01f, 2.17224255e-01f, -9.43951458e-02f, 1.57762989e-01f, 8.20316300e-02f },
      { 3.36828291e-01f, 2.08387703e-01f, -9.98771191e-02f, 2.57190496e-01f, -6.25265669e-03f },
      { 2.64293164e-01f, -1.54909655e-01f, -6.72764704e-02f, 1.40835837e-01f, -1.45626783e-01f },
      { 1.15483128e-01f, -1.32606938e-01f, 3.33491005e-02f, 7.42918067e-03f, -6.76996633e-02f },
      { -6.81630820e-02f, -6.91958740e-02f, -1.47305466e-02f, -5.66223785e-02f, -6.94765449e-02f },
    },
    {
      { -1.51141491e-02f, 2.26082522e-02f, -1.00146547e-01f, 3.31930891e-02f, 1.87720614e-03f },
      { 1.08918615e-01f, 1.37487680e-01f, -1.05311260e-01f, 3.88503484e-02f, 5.09097837e-02f },
      { 2.21793860e-01f, 1.20184772e-01f, -1.09808989e-01f, 2.49688476e-01f, 6.78706244e-02f },
      { 1.05301566e-01f, -1.01523846e-01f, 3.84759381e-02f, 7.47523382e-02f, 7.31632784e-02f },
      { 2.61843409e-02f, 7.35715106e-02f, 4.56784815e-02f, 4.36061323e-02f, 8.42108727e-02f },
    },
    {
      { -1.88894093e-01f, -1.06938705e-01f, -2.36720622e-01f, 2.10219231e-02f, -1.41128659e-01f },
      { -8.67775381e-02f, 2.18028296e-02f, 5.14606386e-02f, 2.62497872e-01f, -1.52239740e-01f },
      { 1.26691014e-02f, 5.28610013e-02f, 1.91437930e-01f, 2.66864598e-01f, 2.06571948e-02f },
      { -1.87910930e-03f, -1.01189740e-01f, 4.18984657e-03f, 1.07391559e-01f, -1.23809673e-01f },
      { 1.03161931e-01f, 1.15556762e-01f, 1.53451666e-01f, 2.92895567e-02f, -1.38050392e-01f },
    },
    {
      { -3.33366692e-02f, -4.62488607e-02f, 2.07661003e-01f, -2.65513152e-01f, 1.68817732e-02f },
      { -2.53637165e-01f, 3.78167540e-01f, 3.27629000e-01f, -3.12341332e-01f, 2.52328783e-01f },
      { -3.11027467e-01f, 5.01623213e-01f, 2.30555013e-01f, -4.47993934e-01f, 3.13381732e-01f },
      { -1.90763444e-01f, 4.15345371e-01f, -2.69285381e-01f, -2.83400267e-01f, -4.83071171e-02f },
      { -1.80571765e-01f, 5.85215688e-02f, -1.47249356e-01f, -2.88609087e-01f, -6.21559396e-02f },
    },
    {
      { -1.90372113e-02f, -3.29783186e-02f, 1.10881485e-01f, -1.09289885e-01f, -9.81805697e-02f },
      { -2.08691046e-01f, 2.47856200e-01f, 2.46408761e-01f, -2.26143271e-01f, 5.89784309e-02f },
      { -1.86591536e-01f, 3.45442891e-01f, 1.34519085e-01f, -3.47505331e-01f, 1.12810560e-01f },
      { -1.27549961e-01f, 1.97054505e-01f, -1.85594425e-01f, -2.76315212e-01f, -1.69846285e-02f },
      { -3.42711173e-02f, -3.15326825e-02f, 2.70727668e-02f, -1.40023708e-01f, -4.55398038e-02f },
    },
    {
      { -9.86767337e-02f, -4.28228825e-02f, 1.68890342e-01f, -1.60030574e-02f, -1.68507904e-01f },
      { -1.76164925e-01f, 7.04356655e-02f, 2.56719291e-01f, -2.56633550e-01f, -1.94288507e-01f },
      { -1.64414078e-01f, -8.42487812e-02f, 1.96743548e-01f, -7.55838975e-02f, -1.78449810e-01f },
      { -7.69123584e-02f, 7.32326834e-03f, 4.32267696e-01f, 6.42949864e-02f, -1.63155988e-01f },
      { -8.34994912e-02f, -1.73870549e-01f, 7.81688318e-02f, 3.40038426e-02f, -1.08604811e-01f },
    },
    {
      { -2.32883263e-02f, 4.50786874e-02f, -1.56631112e-01f, 2.43028458e-02f, -2.52348185e-02f },
      { 3.67562734e-02f, 4.76874970e-02f, -1.54417917e-01f, 2.60947466e-01f, 7.03334482e-03f },
      { -9.50007327e-03f, -1.38034508e-01f, 7.49633089e-02f, 2.82050431e-01f, -7.26854429e-02f },
      { -2.70965695e-02f, -2.13096142e-02f, -1.03934415e-01f, 5.42608760e-02f, -1.32620856e-01f },
      { -3.70291732e-02f, 4.42355014e-02f, -3.45368087e-02f, 4.00666893e-02f, -2.28702962e-01f },
    },
    {
      { -1.02149047e-01f, -1.59190580e-01f, -2.11012885e-01f, -1.04336269e-01f, -2.54091248e-02f },
      { -2.36388355e-01f, 3.42038162e-02f, 4.76799756e-02f, 3.85020822e-02f, -1.40658259e-01f },
      { -5.84053062e-02f, 8.97776634e-02f, 1.75037518e-01f, 8.02550837e-02f, 3.33105847e-02f },
      { 4.73437048e-02f, -1.49994446e-02f, -6.08936548e-02f, -4.26538773e-02f, 1.13338649e-01f },
      { 6.70573115e-02f, 1.27757758e-01f, 1.32726915e-02f, 1.65965687e-02f, 4.86917906e-02f },
    },
    {
      { 3.39714028e-02f, 1.59989730e-01f, -1.06305992e-02f, 4.05212902e-02f, -1.41860424e-02f },
      { 1.13521114e-01f, 1.13135666e-01f, -9.60999951e-02f, -8.82679075e-02f, -1.59359798e-02f },
      { 2.94322409e-02f, -1.67841986e-01f, -2.23334748e-02f, 1.37119368e-01f, -1.37972122e-03f },
      { -1.34130359e-01f, 3.59981619e-02f, 2.18246296e-01f, 1.97315618e-01f, -2.29103304e-03f },
      { -1.96425632e-01f, -7.72772655e-02f, 2.64080800e-02f, 1.02404714e-01f, -5.16355000e-02f },
    },
    {
      { -1.87081620e-01f, 8.34490508e-02f, 2.02528879e-01f, -1.86656654e-01f, 1.09659061e-02f },
      { -1.26474917e-01f, 2.36420140e-01f, 1.14574127e-01f, -2.89525330e-01f, 1.20701812e-01f },
      { -3.47080752e-02f, 1.29537836e-01f, -5.72541021e-02f, -9.95689183e-02f, -8.91557708e-03f },
      { -1.35175228e-01f, 5.06218476e-03f, 1.03638005e-02f, -4.26259376e-02f, -1.07292652e-01f },
      { -1.53004184e-01f, -6.52462170e-02f, -1.00752391e-01f, -1.96276739e-01f, -5.19227348e-02f },
    },
    {
      { -1.03503600e-01f, -3.74900587e-02f, 1.25272945e-01f, -1.35162503e-01f, -9.81825367e-02f },
      { -2.75059909e-01f, 1.47921607e-01f, 2.66624689e-01f, -3.17782015e-01f, 6.82485476e-02f },
      { -1.71654150e-01f, 2.10747615e-01f, 2.62213588e-01f, -3.93023223e-01f, 3.20585705e-02f },
      { -1.05538040e-01f, 3.01433474e-01f, 1.54457733e-01f, -1.91343367e-01f, 4.85145440e-03f },
      { -1.92238912e-02f, 1.63914207e-02f, -1.80235803e-01f, -2.36269251e-01f, -1.96994990e-01f },
    },
    {
      { -1.27533753e-03f, 3.25430669e-02f, 4.15608399e-02f, 3.40045467e-02f, -7.05960020e-02f },
      { 1.48608927e-02f, 1.93172565e-03f, -4.03912142e-02f, 4.06490937e-02f, -4.92929332e-02f },
      { -6.01560622e-02f, 5.51933534e-02f, -1.67161692e-02f, -2.08348483e-02f, -4.82458435e-02f },
      { 4.11656275e-02f, -2.62303092e-02f, -4.91063632e-02f, 1.74656622e-02f, -2.17620153e-02f },
      { 5.74733969e-03f, -3.42229870e-03f, -6.48365691e-02f, 4.62085493e-02f, -1.11915413e-02f },
    },
    {
      { -5.45800216e-02f, -1.03565515e-03f, 3.62794921e-02f, -7.18451291e-02f, -3.87185067e-02f },
      { -4.24134843e-02f, 3.30500901e-02f, 2.99930200e-02f, -5.97665086e-02f, 5.78917153e-02f },
      { 1.74134225e-02f, 5.32038547e-02f, 2.75158118e-02f, -9.53487009e-02f, 8.48054960e-02f },
      { 1.05679203e-02f, 5.76829016e-02f, -1.09273002e-01f, -7.82472864e-02f, -1.03781400e-02f },
      { -3.33334096e-02f, -1.04085421e-02f, -1.19698711e-01f, -8.76321346e-02f, -1.92360263e-02f },
    },
    {
      { 1.29869685e-01f, -5.19587621e-02f, 4.21747863e-02f, -2.82653384e-02f, -5.11315130e-02f },
      { -9.57504660e-03f, -6.39304072e-02f, -5.65303229e-02f, -5.08388388e-04f, 2.66384184e-02f },
      { 1.97141292e-03f, -5.98623650e-03f, -2.66439263e-02f, -1.31115377e-01f, -7.64273480e-03f },
      { 6.21040678e-03f, -6.10932671e-02f, -4.38460568e-03f, -4.15518023e-02f, 1.56580746e-01f },
      { 2.93225795e-03f, -6.77876920e-02f, -5.14810421e-02f, 4.18045260e-02f, 9.81421471e-02f },
    },
    {
      { -1.15276389e-01f, -6.78545190e-03f, -4.25343178e-02f, -5.36630414e-02f, 1.13520278e-02f },
      { -8.50713253e-02f, 7.05186054e-02f, -6.40629753e-02f, -4.64056619e-02f, 9.40965675e-03f },
      { -1.10939346e-01f, 1.04957938e-01f, -1.27174526e-01f, 1.03150504e-02f, 7.61902630e-02f },
      { 5.11129270e-04f, -2.87060793e-02f, -1.37758568e-01f, -4.47224826e-02f, -1.00011183e-02f },
      { -6.80399984e-02f, -7.87874311e-03f, -8.12574923e-02f, -9.10486132e-02f, -3.87584455e-02f },
    },
    {
      { 6.19864836e-02f, -2.24557951e-01f, -1.43812895e-01f, 1.46369468e-02f, 2.14045476e-02f },
      { -1.21463150e-01f, -1.30106911e-01f, 4.09189835e-02f, 1.44626126e-01f, -1.69810563e-01f },
      { -1.17230006e-01f, 5.38434386e-02f, 1.40854567e-01f, 1.12139143e-01f, -6.90666400e-03f },
      { -7.07760965e-03f, 5.71635028e-04f, 1.05315156e-01f, 1.05743684e-01f, 1.30300850e-01f },
      { 1.46280658e-02f, 7.06635192e-02f, 9.49121490e-02f, 1.19936422e-01f, 1.00749634e-01f },
    },
    {
      { 2.17004325e-02f, 2.28208359e-02f, 3.67136411e-02f, -4.35971618e-02f, -8.03724676e-02f },
      { 1.19855784e-01f, 7.23973364e-02f, -7.42456838e-02f, -6.01535812e-02f, -1.08456230e-02f },
      { 1.21744968e-01f, -8.11760724e-02f, -8.16873163e-02f, -2.72645485e-02f, -3.14844660e-02f },
      { 2.22548544e-02f, -1.24267071e-01f, 2.51678247e-02f, -6.99416269e-03f, 1.19040214e-01f },
      { 9.10669938e-02f, -2.12692451e-02f, 2.39637811e-02f, -5.01429029e-02f, 1.03813626e-01f },
    },
    {
      { 8.88408050e-02f, 1.54408202e-01f, 1.39765963e-01f, -9.31899529e-03f, 1.32058784e-01f },
      { 7.43309185e-02f, 1.48583516e-01f, -1.06339775e-01f, -4.02599834e-02f, -1.99108589e-02f },
      { 5.15187485e-03f, -1.09587908e-01f, -1.30806729e-01f, -4.35419418e-02f, -1.19119696e-01f },
      { -1.20195903e-01f, 4.28826595e-03f, 1.01974681e-01f, 2.99123153e-02f, -6.13355972e-02f },
      { -1.98135316e-01f, -4.11388017e-02f, 3.56645286e-02f, 3.78709808e-02f, -9.10428986e-02f },
    },
    {
      { -2.23165274e-01f, 1.24341436e-01f, 1.40508115e-02f, -7.82706738e-02f, -2.94163704e-01f },
      { -4.06549573e-02f, 2.15767220e-01f, 9.50982943e-02f, -6.12875819e-02f, -2.85584420e-01f },
      { -2.22712979e-01f, -1.31631210e-01f, 1.08399726e-01f, -7.35130236e-02f, -1.92769974e-01f },
      { -3.75468254e-01f, -1.20179340e-01f, -9.81407687e-02f, 7.82846287e-02f, -2.26044767e-02f },
      { -8.83983672e-02f, -1.97067842e-01f, -9.26474035e-02f, 2.15337891e-02f, -2.69470811e-01f },
    },
    {
      { 2.27268748e-02f, -1.84196513e-02f, 2.12712809e-02f, 8.15571919e-02f, -6.62928447e-02f },
      { -3.67636792e-02f, -4.04310273e-03f, 1.03888690e-01f, 6.75043836e-02f, -5.67575619e-02f },
      { -3.42527181e-02f, 2.66105495e-02f, 1.36994749e-01f, 1.20701917e-01f, 7.43099600e-02f },
      { -1.05746910e-01f, 5.40055446e-02f, 1.89186588e-01f, 1.97840124e-01f, 3.40997837e-02f },
      { 7.96792358e-02f, 8.28863308e-02f, 7.84586892e-02f, 8.22372362e-02f, -6.64626732e-02f },
    },
    {
      { -8.16359073e-02f, -9.25930962e-03f, 1.12845793e-01f, -1.61120966e-01f, 2.52646003e-02f },
      { -1.63133994e-01f, 1.78343669e-01f, 5.20453341e-02f, -2.41094679e-01f, 1.14253692e-01f },
      { -1.33184731e-01f, 2.37910166e-01f, -9.73266065e-02f, -1.02610573e-01f, 6.22619130e-02f },
      { 1.03844563e-02f, 1.52953193e-01f, -1.29173964e-01f, -8.86788964e-02f, -6.01799786e-02f },
      { -1.52585432e-01f, -1.99257918e-02f, -1.22328341e-01f, -1.24424398e-01f, -1.00348979e-01f },
    },
    {
      { -7.68850893e-02f, -2.27644265e-01f, -2.40998521e-01f, -7.91536793e-02f, -1.44948527e-01f },
      { -1.73069894e-01f, -5.02197654e-04f, 9.24818590e-02f, 2.08292492e-02f, -1.01724006e-01f },
      { -6.34192154e-02f, 3.36416289e-02f, 1.37799293e-01f, -4.61071124e-03f, -2.89018210e-02f },
      { -7.00996965e-02f, -2.90328283e-02f, -5.37117012e-02f, -9.33880582e-02f, -1.33432942e-02f },
      { -4.69677709e-02f, 6.96492475e-03f, 4.32568230e-02f, -6.70890808e-02f, -5.10965427e-03f },
    },
    {
      { 6.97981752e-03f, -1.45056039e-01f, 1.18540376e-01f, 1.09657841e-02f, -3.07607595e-02f },
      { -1.56685039e-01f, 1.68369398e-01f, 2.82781124e-01f, -1.39359683e-01f, -5.08842692e-02f },
      { -1.91099063e-01f, 2.57426769e-01f, 2.77184367e-01f, -1.74848378e-01f, 2.17065945e-01f },
      { 2.46685855e-02f, 2.74826288e-01f, 3.75783481e-02f, 6.95385039e-02f, 1.49599954e-01f },
      { 8.18061735e-03f, 1.24085195e-01f, 1.02947421e-01f, 3.96855325e-02f, -9.90824997e-02f },
    },
    {
      { 4.75444719e-02f, -3.31250019e-02f, -6.63302168e-02f, -6.87575014e-03f, -5.29126823e-02f },
      { -4.79734056e-02f, -8.79868641e-02f, -1.12646632e-01f, -4.85162847e-02f, 4.74051200e-03f },
      { 1.61791015e-02f, -3.24217938e-02f, -2.14850903e-02f, -3.14301588e-02f, 2.85369512e-02f },
      { 8.25188356e-04f, -8.05392787e-02f, -9.42591503e-02f, -5.23891672e-02f, 1.46544352e-01f },
      { 5.45267910e-02f, -3.92480157e-02f, -5.48437387e-02f, -3.26944441e-02f, 8.32488760e-03f },
    },
    {
      { -8.43240321e-02f, 5.93997501e-02f, -2.18692869e-02f, -4.08914648e-02f, -6.70555830e-02f },
      { 1.25053339e-02f, 1.03950389e-01f, -2.19372043e-04f, 6.39552400e-02f, 3.68299410e-02f },
      { 6.75194189e-02f, 1.01970747e-01f, 9.45147686e-03f, 2.30194584e-01f, 7.18598142e-02f },
      { 5.25567855e-04f, -5.97234517e-02f, -5.48130870e-02f, 1.73270345e-01f, -4.66006100e-02f },
      { -2.05522347e-02f, 1.67837329e-02f, -2.44206078e-02f, 7.85559474e-04f, -1.46520540e-01f },
    },
    {
      { 6.00007884e-02f, 2.25855932e-01f, 1.29297629e-01f, 1.03208004e-02f, 1.35198891e-01f },
      { 1.88693061e-01f, 9.30583999e-02f, -1.89003497e-01f, -2.22617477e-01f, -1.27091378e-01f },
      { -1.45827621e-01f, -2.24145994e-01f, -9.34111848e-02f, -3.91412154e-02f, -8.02184120e-02f },
      { -2.15837076e-01f, -1.71876270e-02f, 1.88807115e-01f, 1.72950342e-01f, -1.17875682e-02f },
      { -1.92459702e-01f, -6.59209490e-03f, -3.15942541e-02f, 7.26789832e-02f, -1.88378002e-02f },
    },
    {
      { -1.28681362e-02f, -6.73499182e-02f, 1.09768789e-02f, 4.58048237e-03f, -4.20360118e-02f },
      { 4.04819883e-02f, -1.16524205e-03f, 2.38770116e-02f, 9.28187184e-03f, 1.15096923e-02f },
      { -9.95261827e-04f, 2.53562760e-02f, -2.91333608e-02f, 4.84948941e-02f, -1.39369164e-03f },
      { -1.29473964e-02f, -3.71226817e-02f, 1.50032081e-02f, 5.21130003e-02f, 4.42346744e-02f },
      { 3.89533602e-02f, -1.01884697e-02f, 1.66577045e-02f, -1.52811417e-02f, -5.59855253e-03f },
    },
    {
      { -2.56481729e-02f, 3.49916071e-02f, 2.96600573e-02f, -8.78407136e-02f, -5.77095039e-02f },
      { -9.65808257e-02f, -3.12965028e-02f, 1.74153760e-01f, -1.53453067e-01f, -1.00580610e-01f },
      { -2.43498206e-01f, 1.83832403e-02f, 2.46798694e-01f, -2.02435926e-01f, 3.26501764e-02f },
      { -1.73126042e-01f, 2.92833477e-01f, 1.80821329e-01f, -5.77414641e-03f, 4.62003276e-02f },
      { -1.26750872e-01f, -2.36800369e-02f, -4.28071730e-02f, -4.59997989e-02f, -4.52022702e-02f },
    },
    {
      { 2.03765720e-01f, -3.60117666e-02f, 2.19698682e-01f, 1.46220207e-01f, -1.21092305e-01f },
      { -2.43213400e-02f, 1.78169131e-01f, 3.75278145e-01f, -8.26215073e-02f, -3.69753368e-04f },
      { -2.38956317e-01f, 2.34472498e-01f, 2.93364197e-01f, -3.20774585e-01f, 1.50608616e-02f },
      { -2.46868972e-02f, 2.40998268e-01f, -1.51066529e-02f, -3.39029163e-01f, -5.06456755e-02f },
      { -6.99839666e-02f, 4.31733131e-02f, -1.72922295e-02f, -1.24481007e-01f, -1.12945572e-01f },
    },
  },
  {
    {
      { -1.78968329e-02f, 1.42487716e-02f, 1.44013409e-02f, -1.62429102e-02f, -3.75765637e-02f },
      { 1.75034404e-02f, -3.93934064e-02f, 1.09643033e-02f, -2.49058027e-02f, 3.33596803e-02f },
      { -7.28871673e-03f, -1.67799853e-02f, -4.27671708e-02f, -1.86429843e-02f, -3.30226533e-02f },
      { 2.39335019e-02f, -5.99063523e-02f, -3.26394886e-02f, -4.91473265e-02f, 2.24699918e-02f },
      { -5.04045524e-02f, -2.24056821e-02f, 7.28144404e-03f, -4.65319492e-03f, 3.43473442e-02f },
    },
    {
      { 1.35578085e-02f, -3.86028290e-02f, 9.86750331e-03f, 1.88385528e-02f, -1.70467165e-03f },
      { 9.07079130e-03f, -5.84479347e-02f, -2.45979577e-02f, -2.76536252e-02f, -7.35042384e-03f },
      { -6.67457879e-02f, 1.56766959e-02f, 2.28844155e-02f, -6.13908693e-02f, 1.17919231e-02f },
      { -5.45379855e-02f, -2.69193929e-02f, 7.49745546e-03f, -6.22215234e-02f, -1.31971557e-02f },
      { 3.22929434e-02f, 4.58129682e-02f, -6.49324059e-02f, -1.92785896e-02f, -1.49156516e-02f },
    },
    {
      { 1.02946963e-02f, -2.30545606e-02f, -1.27658239e-02f, -5.18635474e-02f, -9.39863361e-03f },
      { -2.33050808e-02f, 1.41822477e-03f, -2.41324939e-02f, -5.29401824e-02f, -2.02681907e-02f },
      { -6.31571608e-03f, 5.09212762e-02f, 6.38526082e-02f, -1.81558244e-02f, -2.02111509e-02f },
      { 3.82114365e-03f, 1.19492253e-02f, -3.30732428e-02f, 1.12079494e-02f, 1.10697551e-02f },
      { -1.44367269e-03f, -6.38246685e-02f, -4.00214121e-02f, -7.50130275e-03f, 6.17529452e-02f },
    },
    {
      { -6.98886216e-02f, 3.11162714e-02f, 2.28742082e-02f, 1.96366105e-02f, 2.94174626e-02f },
      { -2.99400147e-02f, -2.75409482e-02f, -5.11252768e-02f, -1.07229892e-02f, -5.46387248e-02f },
      { 4.60369326e-02f, 4.42572683e-02f, -4.62293513e-02f, -4.92668562e-02f, 6.86537242e-03f },
      { 3.28198895e-02f, -2.10994612e-02f, 8.55008233e-03f, -3.97628434e-02f, 1.66158862e-02f },
      { -1.12900510e-02f, -3.70402299e-02f, -5.78268357e-02f, 2.17432119e-02f, -3.10952514e-02f },
    },
    {
      { -5.66541543e-03f, -1.96657097e-03f, 3.65527943e-02f, -5.53983189e-02f, 4.32843193e-02f },
      { 2.33406406e-02f, -9.14337859e-03f, -4.16489355e-02f, -5.94382845e-02f, -3.77162844e-02f },
      { 1.39172627e-02f, -3.32974121e-02f, -8.95259378e-04f, -4.53590564e-02f, -3.95598039e-02f },
      { 4.73471507e-02f, 3.49767841e-02f, 5.37852868e-02f, -3.94648649e-02f, 3.77486199e-02f },
      { -1.62476879e-02f, 2.57511903e-02f, 2.51247361e-02f, -2.51782611e-02f, 5.14191985e-02f },
    },
    {
      { 2.48341244e-02f, 3.12165003e-02f, -6.39756490e-03f, -6.27923086e-02f, -6.08079955e-02f },
      { -4.24820818e-02f, 7.13150436e-03f, 2.27931049e-02f, -1.49920280e-03f, 9.03546251e-03f },
      { -2.38470212e-02f, -3.51657532e-02f, 3.95483561e-02f, 5.02424575e-02f, -5.28991632e-02f },
      { -5.30257113e-02f, 4.96594012e-02f, 4.33099009e-02f, 2.73127016e-02f, -5.29930033e-02f },
      { -1.84274595e-02f, 2.82644536e-02f, -3.18233892e-02f, 4.50581283e-05f, 4.62046359e-03f },
    },
    {
      { -3.45745347e-02f, 2.52044424e-02f, -3.32859159e-03f, -2.17041257e-03f, -3.17766741e-02f },
      { 2.39403266e-02f, 3.79083008e-02f, -5.97336562e-03f, 3.61278914e-02f, 1.43717241e-03f },
      { -4.19632085e-02f, -3.30963009e-03f, -4.34415713e-02f, 5.76194711e-02f, -4.70125265e-02f },
      { -2.15489417e-02f, 4.65695374e-03f, -3.80431153e-02f, -1.99888218e-02f, 2.93839574e-02f },
      { -3.96645777e-02f, -4.07377183e-02f, -6.96329623e-02f, -2.05819607e-02f, -6.78854585e-02f },
    },
    {
      { -2.27154028e-02f, -5.04013002e-02f, -4.03066836e-02f, 2.06389837e-02f, 3.56801823e-02f },
      { 4.49307375e-02f, 2.26849969e-02f, 2.78456472e-02f, -4.72826213e-02f, -5.31572737e-02f },
      { -4.48627844e-02f, -5.12099862e-02f, -6.05936907e-02f, -6.38110414e-02f, 2.23330935e-04f },
      { 8.51112534e-04f, -4.37565111e-02f, 1.03853010e-02f, 9.99879651e-03f, -4.12032343e-02f },
      { -4.43486832e-02f, -1.65380482e-02f, -4.51269969e-02f, -2.25346349e-02f, -5.13014086e-02f },
    },
    {
      { 5.09813614e-02f, -2.76260693e-02f, -4.24773991e-03f, -4.20482196e-02f, 6.48718327e-02f },
      { -2.25107912e-02f, -3.40477340e-02f, -6.11751452e-02f, 5.15017882e-02f, -5.41608371e-02f },
      { -3.52169760e-02f, 4.87685762e-02f, 5.25964312e-02f, 2.35053226e-02f, -3.23564038e-02f },
      { -5.12694158e-02f, -2.83167679e-02f, 1.75532140e-02f, 2.84986589e-02f, -1.76468622e-02f },
      { 5.03924191e-02f, -5.24788946e-02f, 1.75863449e-02f, -4.17994522e-02f, 2.95663960e-02f },
    },
    {
      { -3.64318602e-02f, -5.59462458e-02f, -3.16741653e-02f, -1.74672436e-02f, 5.35502806e-02f },
      { -2.31792703e-02f, 2.98412833e-02f, 4.68999557e-02f, 1.52295120e-02f, -2.41850670e-02f },
      { 5.65628931e-02f, -1.85234584e-02f, 1.39487106e-02f, 1.54056903e-02f, 4.50364985e-02f },
      { -3.61508084e-03f, 2.46914872e-03f, 4.35945876e-02f, 1.53736714e-02f, -3.19999531e-02f },
      { -1.38565237e-02f, -1.27432626e-02f, -5.39491326e-02f, 7.64752692e-03f, 8.56616907e-03f },
    },
    {
      { -3.11918487e-03f, -2.92219426e-02f, 4.43723276e-02f, -3.61433364e-02f, 2.47938670e-02f },
      { 2.07833406e-02f, -1.69115961e-02f, 4.86628897e-02f, 6.07521227e-03f, -1.61033211e-04f },
      { -4.03303578e-02f, -6.41023442e-02f, -6.58295974e-02f, -5.61006702e-02f, 3.61568183e-02f },
      { -2.57123485e-02f, -4.64387201e-02f, -9.21238121e-03f, -1.34028075e-02f, -5.78465424e-02f },
      { -6.01706505e-02f, -1.22183533e-02f, 1.04026757e-02f, -9.58541036e-03f, -6.23662770e-02f },
    },
    {
      { 3.37880142e-02f, -2.20516268e-02f, -3.89821418e-02f, -3.55104394e-02f, -1.62543748e-02f },
      { 4.03286070e-02f, 3.22162993e-02f, 1.41584384e-03f, -1.90419666e-02f, 5.01160584e-02f },
      { 2.64036702e-03f, 2.61237565e-02f, 3.83989401e-02f, 1.16185462e-02f, -6.61916509e-02f },
      { -3.39869037e-02f, 2.05264799e-02f, -2.54735979e-03f, -4.56907079e-02f, 2.64986437e-02f },
      { 4.24645841e-02f, -2.91806702e-02f, -5.47094494e-02f, -1.10644037e-02f, -5.24112731e-02f },
    },
    {
      { 3.18609960e-02f, -5.43283038e-02f, -1.12587791e-02f, 3.03016864e-02f, -7.84639455e-03f },
      { -3.01888324e-02f, 3.75676751e-02f, 1.52668282e-02f, -1.65694952e-02f, 4.59965691e-02f },
      { -6.67036325e-02f, 2.98528913e-02f, 3.38183716e-02f, 2.29749978e-02f, -5.66298962e-02f },
      { 1.27788521e-02f, 1.49777019e-02f, 3.64810564e-02f, -3.27567086e-02f, 1.64047368e-02f },
      { -3.79107855e-02f, -2.18482707e-02f, -3.25103290e-02f, 4.18870486e-02f, -1.40904272e-02f },
    },
    {
      { -3.40333171e-02f, -5.73692238e-03f, -5.00773117e-02f, 2.86952145e-02f, 3.96019295e-02f },
      { 1.83309782e-02f, -4.98472936e-02f, 2.67640073e-02f, -3.65514457e-02f, -5.61196804e-02f },
      { 3.60241644e-02f, -3.94520313e-02f, 7.22195208e-03f, -2.77159195e-02f, -1.02768801e-02f },
      { 3.31190638e-02f, 1.22877918e-02f, -1.06665762e-02f, 3.73513624e-02f, -5.33769988e-02f },
      { 4.83241938e-02f, -6.05343562e-03f, -4.78666984e-02f, -9.21079423e-03f, 5.23014478e-02f },
    },
    {
      { -1.94885619e-02f, 5.61977699e-02f, 7.10549532e-03f, 7.72905676e-03f, 2.19201483e-02f },
      { 2.70639639e-02f, 3.24222855e-02f, -4.21886481e-02f, -5.21511398e-02f, 3.47498618e-02f },
      { -5.43335676e-02f, -2.58725509e-02f, -5.16190827e-02f, -2.79913768e-02f, -1.14718033e-02f },
      { -2.74384618e-02f, -8.09034985e-03f, 4.84438837e-02f, -3.19790505e-02f, 3.25559042e-02f },
      { -6.24679774e-02f, -6.52529672e-02f, 3.22526917e-02f, 6.12028725e-02f, -1.51021210e-02f },
    },
    {
      { -5.36575615e-02f, -2.22974867e-02f, -5.84451035e-02f, -7.64878700e-03f, -6.42011613e-02f },
      { 2.83496305e-02f, 3.79472971e-02f, -1.71480572e-03f, 2.94789821e-02f, -2.12791227e-02f },
      { -5.98636903e-02f, 1.66527892e-03f, -4.87519465e-02f, 5.15072756e-02f, -2.62538325e-02f },
      { -1.28658796e-02f, 1.85281020e-02f, -1.90202880e-03f, -2.73097716e-02f, -7.05557968e-03f },
      { 5.76729048e-03f, 4.22987193e-02f, -6.09026626e-02f, 4.93510440e-02f, -2.57128733e-03f },
    },
    {
      { 3.04954015e-02f, 2.32106801e-02f, -5.58898300e-02f, 2.80600581e-02f, -1.99199524e-02f },
      { 1.89889949e-02f, 8.44709110e-03f, 3.49191576e-02f, 2.25024577e-02f, -5.71617447e-02f },
      { -1.81912258e-02f, -2.41179820e-02f, 8.42291955e-03f, -2.47065648e-02f, -6.47808909e-02f },
      { 4.61964048e-02f, 1.57251544e-02f, -4.03868034e-02f, 1.95151381e-03f, -2.98278946e-02f },
      { 4.79913056e-02f, 4.71915491e-02f, -1.69312470e-02f, -1.82707123e-02f, 9.51846247e-04f },
    },
    {
      { -2.33622547e-03f, 4.95709144e-02f, 3.69115695e-02f, -1.68716852e-02f, 8.96238256e-03f },
      { -2.36629937e-02f, -5.44563830e-02f, 1.50630968e-02f, 2.61435118e-02f, 5.10930866e-02f },
      { 4.36391383e-02f, -3.40244621e-02f, 1.86066590e-02f, 5.96962729e-03f, -4.37540114e-02f },
      { 5.24576977e-02f, 5.15313521e-02f, 1.60469348e-03f, 2.98645440e-03f, 1.00968489e-02f },
      { 1.66162662e-02f, -3.85078378e-02f, 5.21311909e-03f, -5.65773472e-02f, 4.65732515e-02f },
    },
    {
      { -3.52242514e-02f, 2.08247770e-02f, -3.38780880e-02f, -6.28786220e-04f, -5.31172678e-02f },
      { -1.32612428e-02f, 4.15016059e-03f, 1.32716820e-02f, -5.51470108e-02f, 3.44603322e-02f },
      { -3.93451340e-02f, 4.95874472e-02f, 6.06031535e-05f, -4.52576391e-02f, -1.25017427e-02f },
      { 2.88779940e-02f, 3.76956910e-02f, 1.30096423e-02f, -2.95954514e-02f, 2.28684619e-02f },
      { 3.09807360e-02f, -4.35639210e-02f, 7.38598313e-03f, -2.11693943e-02f, 4.94381152e-02f },
    },
    {
      { -5.74507564e-02f, 2.71713231e-02f, -3.42431315e-03f, -3.35809551e-02f, 4.87220101e-02f },
      { 1.42629351e-02f, -5.98565936e-02f, -1.67362988e-02f, -2.78301742e-02f, -1.93236154e-02f },
      { -4.10030410e-02f, 3.87007669e-02f, -5.32962121e-02f, -3.90921086e-02f, -5.98809347e-02f },
      { -2.52595805e-02f, 4.46146056e-02f, 4.79257368e-02f, 3.44804004e-02f, 1.54749043e-02f },
      { -5.55440858e-02f, -4.49631624e-02f, -5.97416684e-02f, 3.77530493e-02f, 1.48271294e-02f },
    },
    {
      { 2.20904127e-02f, 2.19990611e-02f, 2.62390869e-03f, -2.88032694e-03f, 3.59898247e-02f },
      { -6.11699447e-02f, -2.46373639e-02f, -4.24328782e-02f, 3.45846601e-02f, -4.65324782e-02f },
      { 2.95739062e-02f, 7.07697449e-03f, 4.03908938e-02f, -1.95537284e-02f, -9.69921146e-03f },
      { -8.51056445e-03f, -6.31410107e-02f, 7.94949289e-03f, -2.68061440e-02f, -5.08778691e-02f },
      { 2.14803442e-02f, 4.93435301e-02f, 8.40311963e-03f, -6.56346185e-03f, -7.15998840e-03f },
    },
    {
      { -5.24745584e-02f, 1.30365917e-03f, -6.80968398e-03f, 4.65329140e-02f, 5.17390929e-02f },
      { 3.87511291e-02f, -1.56448279e-02f, 5.11298403e-02f, -4.43691984e-02f, -5.74300401e-02f },
      { 1.50056314e-02f, 4.92914692e-02f, -4.52167280e-02f, 2.12296136e-02f, 5.84756471e-02f },
      { -7.85252079e-03f, -4.53395434e-02f, -1.46858916e-02f, 3.45014893e-02f, 2.74422579e-02f },
      { -1.79540664e-02f, -5.41063547e-02f, -5.71215563e-02f, 7.51897227e-03f, -2.37489045e-02f },
    },
    {
      { -3.82368378e-02f, 9.31501202e-03f, 1.79387126e-02f, 4.58716303e-02f, 3.49809937e-02f },
      { 8.60930595e-05f, 5.34703806e-02f, -3.69150639e-02f, -6.02266379e-02f, 3.42301466e-02f },
      { -3.69128734e-02f, -2.38797329e-02f, -1.16390893e-02f, 4.15242054e-02f, -2.57798005e-03f },
      { -6.34162202e-02f, 3.48004065e-02f, 3.30120958e-02f, -3.04631479e-02f, 1.31236957e-02f },
      { -5.77684268e-02f, -6.10650294e-02f, -2.70850956e-02f, -6.08501434e-02f, 5.04456870e-02f },
    },
    {
      { 9.64630302e-03f, -5.70050441e-02f, -6.40481189e-02f, 5.03838025e-02f, -5.36223017e-02f },
      { -5.52862361e-02f, 2.12614648e-02f, -1.26680601e-02f, -4.37243022e-02f, -4.17760909e-02f },
      { 8.58708750e-03f, -3.68763320e-02f, 3.28756906e-02f, -5.75248264e-02f, -6.24496769e-03f },
      { 2.74882577e-02f, 4.26710173e-02f, 4.78168614e-02f, 4.62301411e-02f, 2.50499547e-02f },
      { -1.45874778e-03f, 2.91820206e-02f, -3.06216329e-02f, 2.07603592e-02f, -2.93034315e-02f },
    },
    {
      { -5.02129197e-02f, -5.39461412e-02f, -4.56791371e-02f, -6.52122796e-02f, 1.97783802e-02f },
      { -5.44073880e-02f, -3.25960107e-02f, -4.10409532e-02f, -5.74103743e-03f, 5.92589611e-03f },
      { 5.24406172e-02f, 2.25271960e-03f, -5.84267043e-02f, -4.00301861e-03f, -7.72832800e-03f },
      { -3.50039117e-02f, 1.38656963e-02f, -5.42864986e-02f, -3.95080820e-02f, -1.46879684e-02f },
      { 2.44530626e-02f, -3.58641148e-02f, -6.08640537e-02f, 4.35722508e-02f, 1.32018048e-03f },
    },
    {
      { 2.21845638e-02f, 2.22172383e-02f, -4.35776152e-02f, 2.78948639e-02f, -7.61588058e-03f },
      { 1.18741821e-02f, -3.48946638e-02f, 3.43557075e-02f, 3.56047712e-02f, -3.07110474e-02f },
      { -3.78078260e-02f, -3.15023959e-02f, 2.81296503e-02f, 5.47418781e-02f, -3.80464755e-02f },
      { 4.95892763e-02f, 6.19979464e-02f, -1.97293386e-02f, 3.82800810e-02f, -5.64571880e-02f },
      { -6.21863790e-02f, 4.48375866e-02f, -1.05387997e-02f, -3.92973125e-02f, 3.63432057e-02f },
    },
    {
      { 1.77006777e-02f, -2.73992680e-02f, -7.67560443e-03f, -3.49846780e-02f, 4.66151983e-02f },
      { 7.45946541e-03f, 1.55342836e-02f, -4.67089675e-02f, -4.22479548e-02f, -2.75518559e-02f },
      { -6.70358166e-02f, 3.66333202e-02f, -4.34131585e-02f, 7.51601253e-03f, -5.09652458e-02f },
      { -6.69382438e-02f, 6.66600931e-03f, -4.93217818e-02f, 3.80586348e-02f, -5.03159165e-02f },
      { -1.31519372e-02f, -6.51053637e-02f, 3.37429880e-03f, -2.26482190e-02f, 3.45009044e-02f },
    },
    {
      { -4.47636433e-02f, -6.81685358e-02f, 2.61608418e-02f, 1.66865054e-03f, 4.74127643e-02f },
      { -7.02128634e-02f, -4.15041819e-02f, -4.48590331e-02f, -1.41613260e-02f, -2.31245887e-02f },
      { 5.58415335e-03f, 8.29182845e-03f, -2.69571431e-02f, -1.70377679e-02f, -3.04220300e-02f },
      { 2.83109155e-02f, 1.37144504e-02f, 3.70101482e-02f, -1.02056954e-02f, 4.77990508e-02f },
      { 4.58340868e-02f, 4.34254855e-02f, -2.03711428e-02f, -2.65697576e-02f, 5.33224195e-02f },
    },
    {
      { -4.82239276e-02f, 1.67773180e-02f, -4.87870760e-02f, -2.87362542e-02f, 4.10819314e-02f },
      { 3.21817361e-02f, -1.92158576e-02f, -4.53479365e-02f, -1.32374214e-02f, -5.22406250e-02f },
      { 1.92729700e-02f, 3.44182514e-02f, -2.68307645e-02f, 3.62864360e-02f, -4.07381915e-02f },
      { 1.57297533e-02f, -2.81253345e-02f, -1.40932873e-02f, -8.95904005e-03f, -2.59604007e-02f },
      { -3.81324280e-05f, -5.24925105e-02f, 3.33390869e-02f, 7.06706382e-03f, -2.85385121e-02f },
    },
    {
      { 4.94286679e-02f, 1.19854966e-02f, 4.13727798e-02f, 1.94990877e-02f, -8.82431585e-03f },
      { -9.31292959e-03f, 2.74290424e-02f, 6.18968112e-03f, 1.10380286e-02f, 6.37184903e-02f },
      { -6.54983521e-02f, -6.44893423e-02f, -3.25439349e-02f, -3.97799490e-03f, -5.63734435e-02f },
      { 4.22877856e-02f, -1.47761721e-02f, 4.93799895e-02f, -4.41449620e-02f, -2.89050955e-02f },
      { -2.80300435e-02f, -8.99264007e-04f, -6.50516972e-02f, -3.62819843e-02f, -4.13655937e-02f },
    },
    {
      { -5.23717441e-02f, -3.20844688e-02f, -3.36448699e-02f, 5.34017831e-02f, -5.55669516e-02f },
      { -2.39398167e-03f, -1.38459040e-03f, -2.05359161e-02f, -5.53263463e-02f, 4.86092493e-02f },
      { 4.13946249e-02f, -3.17705832e-02f, 3.39256629e-04f, 3.59933600e-02f, 5.59735112e-02f },
      { -6.34630993e-02f, -4.05871496e-02f, 5.50370105e-03f, -2.92290710e-02f, -2.44256724e-02f },
      { 2.61046384e-02f, -4.80978265e-02f, -3.47099304e-02f, -3.17669101e-02f, -2.08968353e-02f },
    },
    {
      { -3.89529131e-02f, 4.56566885e-02f, 4.33615372e-02f, 6.33849902e-03f, -5.48536927e-02f },
      { 2.11606957e-02f, 1.37882838e-02f, -2.41173487e-02f, -2.34393077e-03f, 5.82575686e-02f },
      { -2.67814733e-02f, 1.50920674e-02f, -4.05736305e-02f, -6.53787851e-02f, -2.64783446e-02f },
      { -1.16212647e-02f, -2.25622039e-02f, -5.68815358e-02f, -6.14270344e-02f, -7.04523548e-03f },
      { -1.92435551e-02f, -3.23829837e-02f, -5.81112765e-02f, -2.48986837e-02f, 4.59062196e-02f },
    },
  },
  {
    {
      { -5.26396446e-02f, -2.44251397e-02f, 3.34945470e-02f, -2.07346529e-02f, 7.47575751e-03f },
      { -2.30546854e-02f, 2.25397144e-02f, -4.22733231e-03f, 2.61126868e-02f, -7.15708509e-02f },
      { -6.85583204e-02f, -1.26716243e-02f, -6.04823790e-02f, 4.18789573e-02f, -4.55119200e-02f },
      { -5.37069105e-02f, -1.25669055e-02f, -1.09927570e-02f, 4.46764491e-02f, -5.03728539e-02f },
      { -6.57669678e-02f, 7.74874166e-03f, -2.80518923e-02f, -3.23678367e-02f, -5.85648157e-02f },
    },
    {
      { 3.88285778e-02f, 4.57704477e-02f, 3.10844891e-02f, 4.57612835e-02f, -5.14523350e-02f },
      { -2.46242303e-02f, 4.09448184e-02f, 8.68664309e-03f, 4.86081280e-02f, -9.33856517e-03f },
      { -6.33723568e-03f, -3.11667193e-02f, -3.48723084e-02f, 1.23240391e-03f, 1.18867420e-02f },
      { 4.33151722e-02f, 5.45485690e-03f, 2.50998046e-03f, -6.53379560e-02f, 3.81244831e-02f },
      { -6.26865551e-02f, -3.36140245e-02f, -5.80810085e-02f, 2.39431448e-02f, -4.10018079e-02f },
    },
    {
      { -7.10599273e-02f, -3.93689163e-02f, -2.63901278e-02f, -2.22400669e-02f, 2.89726555e-02f },
      { 2.26782560e-02f, 1.94511923e-03f, 3.81307653e-03f, -4.75675426e-02f, -3.28253210e-02f },
      { 1.67320464e-02f, -6.53258115e-02f, -6.73332140e-02f, -8.04974064e-02f, -4.87419330e-02f },
      { -2.20127329e-02f, -2.41737030e-02f, 3.01452782e-02f, -8.23787004e-02f, -6.35563508e-02f },
      { 1.04633709e-02f, 3.35491113e-02f, 5.02073057e-02f, 1.49392737e-02f, -4.70664203e-02f },
    },
    {
      { -8.70626327e-03f, -1.27039559e-03f, 4.67891432e-03f, -2.87495069e-02f, 4.05372381e-02f },
      { -2.57782936e-02f, 5.89183019e-03f, -2.07785591e-02f, 2.86939256e-02f, -4.20431979e-02f },
      { -3.80862541e-02f, -2.96845455e-02f, 2.39049122e-02f, -5.21699078e-02f, 4.73754071e-02f },
      { 2.74288077e-02f, 3.17188241e-02f, -4.82636839e-02f, 1.65215321e-02f, -6.39279336e-02f },
      { 2.35673115e-02f, -3.05971340e-03f, -5.94467148e-02f, -2.49939375e-02f, -3.44745480e-02f },
    },
    {
      { 4.12182100e-02f, 3.00319698e-02f, 6.44020364e-03f, 1.61125455e-02f, 1.39519377e-02f },
      { 2.79353298e-02f, -4.12197746e-02f, 3.43127921e-02f, 1.25980452e-02f, 2.51463754e-03f },
      { -4.56588306e-02f, -3.00751403e-02f, -3.42302658e-02f, 4.20108587e-02f, -6.22522235e-02f },
      { 1.53506612e-02f, 4.12964225e-02f, -1.35353841e-02f, 1.10219028e-02f, -6.59312904e-02f },
      { 4.89027500e-02f, 1.73321944e-02f, -1.06317019e-02f, 1.68953426e-02f, 5.06546535e-02f },
    },
    {
      { 6.02465728e-03f, -4.23952080e-02f, -5.28976619e-02f, -4.20913026e-02f, 1.68514755e-02f },
      { -3.05208378e-03f, 3.37246470e-02f, 3.50899994e-04f, -4.05529514e-03f, -1.00708697e-02f },
      { -5.15416171e-03f, -1.74410585e-02f, -3.93899642e-02f, -1.48076154e-02f, 2.22872123e-02f },
      { 4.42973413e-02f, 6.11173771e-02f, -2.07496085e-03f, -4.93749604e-03f, 3.94171327e-02f },
      { 1.43018328e-02f, 2.98392046e-02f, -2.57351380e-02f, -1.74988769e-02f, 4.28982601e-02f },
    },
    {
      { -1.69975609e-02f, -1.81760099e-02f, 1.69856008e-02f, -5.64620383e-02f, -2.57007033e-02f },
      { -7.56320357e-03f, 2.73816884e-02f, -5.29880486e-02f, 2.92761642e-02f, 4.17053476e-02f },
      { 3.16532180e-02f, 1.54262278e-02f, 3.58965322e-02f, 4.08998132e-02f, -4.79779430e-02f },
      { -5.40287197e-02f, -1.35881593e-02f, -7.12147355e-02f, 6.31938875e-02f, -2.54223379e-03f },
      { 8.67036730e-03f, -3.58763430e-03f, -2.03310102e-02f, 3.13100182e-02f, -4.92973477e-02f },
    },
    {
      { 1.09830229e-02f, -3.73127614e-03f, 2.27474980e-02f, 6.44118562e-02f, -2.06068307e-02f },
      { -6.00514971e-02f, -5.03307441e-04f, 4.57671508e-02f, 5.13471998e-02f, -4.66815270e-02f },
      { 4.99483608e-02f, -9.75411269e-04f, 4.07841839e-02f, -2.72234175e-02f, 2.15569977e-02f },
      { 4.61908244e-02f, 2.64758486e-02f, 2.18465794e-02f, 4.08641389e-03f, 3.34129892e-02f },
      { -4.56790067e-02f, 1.27270166e-02f, 5.14226127e-03f, 3.14279199e-02f, -4.05112915e-02f },
    },
    {
      { 2.50102226e-02f, 1.38210868e-02f, -3.92557159e-02f, -6.99366629e-02f, 2.36611273e-02f },
      { 1.16428193e-02f, 4.53694128e-02f, -9.01326239e-02f, -8.55661482e-02f, -5.43754548e-02f },
      { -5.30501567e-02f, 1.19026629e-02f, -2.05844101e-02f, -2.21657231e-02f, -6.75112605e-02f },
      { 3.07199433e-02f, 4.48362827e-02f, -4.28884067e-02f, 2.23075040e-03f, -5.14093926e-03f },
      { 3.02650444e-02f, 1.32469730e-02f, -5.02210036e-02f, -4.59743328e-02f, 2.79960688e-02f },
    },
    {
      { -4.40418273e-02f, -3.54762711e-02f, -4.00800928e-02f, 2.84597743e-02f, -9.19552520e-03f },
      { -4.69582481e-03f, 2.45644432e-02f, -3.45250480e-02f, -4.83735241e-02f, -2.57375240e-02f },
      { -1.20665636e-02f, -5.20001799e-02f, 1.60983019e-02f, -5.48073910e-02f, -8.04742798e-02f },
      { 1.39830252e-02f, -6.41525537e-02f, 5.10387793e-02f, -7.60679021e-02f, 1.99882891e-02f },
      { -6.80135912e-04f, -3.33781056e-02f, 5.20896027e-03f, -5.79374805e-02f, 8.34541675e-03f },
    },
    {
      { -4.51815575e-02f, -7.12066563e-03f, 1.19143277e-02f, -2.60416791e-02f, -4.57867309e-02f },
      { 1.19947670e-02f, -2.75213066e-02f, -2.89665367e-02f, -3.07544768e-02f, 4.52757925e-02f },
      { -1.36700999e-02f, -5.28220572e-02f, -6.79869624e-03f, -5.50707467e-02f, 4.60835882e-02f },
      { -5.24564795e-02f, 3.34789939e-02f, 3.22276577e-02f, 2.53638178e-02f, -5.88648692e-02f },
      { -8.35782290e-03f, -4.86565419e-02f, -3.34636346e-02f, -5.95911853e-02f, -1.64400283e-02f },
    },
    {
      { 2.31079310e-02f, 7.57697411e-03f, -2.59507485e-02f, -2.38354132e-02f, -6.51080906e-03f },
      { -5.43266684e-02f, 1.78839415e-02f, -6.22181147e-02f, -6.83090985e-02f, 4.33486737e-02f },
      { -6.55512065e-02f, -5.06503657e-02f, 4.85893292e-03f, 4.44361977e-02f, -3.11404057e-02f },
      { 4.51917946e-02f, 1.57661680e-02f, -2.73484597e-03f, 1.17457714e-02f, 8.30764230e-03f },
      { -1.90770496e-02f, -3.63755561e-02f, -2.62390003e-02f, -4.31238487e-03f, -3.99878286e-02f },
    },
    {
      { -3.16555472e-03f, 7.81331863e-03f, -5.45595773e-03f, 3.19702104e-02f, 3.90342101e-02f },
      { -2.38338839e-02f, -6.31441129e-03f, -9.63632297e-03f, -5.73420078e-02f, -3.98531817e-02f },
      { -4.43841778e-02f, 3.04227471e-02f, -1.99739672e-02f, -5.20586409e-02f, -3.45916115e-02f },
      { -1.13016516e-02f, -2.91755702e-02f, -3.15310434e-02f, 1.75920278e-02f, -6.10829219e-02f },
      { -2.38697957e-02f, 3.21208164e-02f, -4.89257053e-02f, -1.29539194e-03f, -3.46255787e-02f },
    },
    {
      { -1.70102790e-02f, -4.04221863e-02f, -5.22388220e-02f, -5.22647332e-03f, 4.13103439e-02f },
      { 2.88490970e-02f, 3.91469672e-02f, 4.88201492e-02f, -1.19880429e-02f, 3.12377196e-02f },
      { 5.13774017e-03f, -6.94254413e-02f, 2.89091151e-02f, -1.46393478e-03f, -5.58338687e-02f },
      { -5.27490750e-02f, 3.03798728e-02f, -1.95011105e-02f, 3.48806977e-02f, 3.26075815e-02f },
      { -2.84834336e-02f, -4.32485901e-02f, -2.31417753e-02f, 2.27796938e-03f, 3.82811129e-02f },
    },
    {
      { 3.98814119e-02f, -5.15384339e-02f, 1.44725945e-02f, -5.04996255e-02f, 6.11419715e-02f },
      { -5.79391122e-02f, 1.38276052e-02f, -3.05420831e-02f, -6.22822456e-02f, 3.54756080e-02f },
      { -8.95316340e-03f, -4.36872989e-02f, -3.81398983e-02f, -4.35037352e-02f, -2.10967492e-02f },
      { 6.93916529e-02f, 3.10260169e-02f, 5.18103689e-02f, -4.22403961e-02f, -4.03098539e-02f },
      { 1.06302667e-02f, 1.35601563e-02f, 4.74586152e-02f, -5.84008358e-02f, 4.52553704e-02f },
    },
    {
      { -6.54402971e-02f, -3.25340079e-03f, -4.81722318e-02f, -3.10846837e-04f, -3.13603170e-02f },
      { -2.80522127e-02f, -4.10779721e-05f, 4.62894812e-02f, -6.88518360e-02f, -4.02889624e-02f },
      { -3.94410230e-02f, 7.90775375e-05f, 1.86488349e-02f, -5.55388071e-02f, -2.43694615e-02f },
      { -5.44845723e-02f, -2.30485294e-02f, 5.00179343e-02f, -4.83723506e-02f, -6.99169468e-03f },
      { 3.02185249e-02f, 6.49752142e-03f, -6.98891506e-02f, -4.36861739e-02f, 3.16555239e-02f },
    },
    {
      { 5.01666889e-02f, -6.99933618e-02f, -1.64510291e-02f, -2.33397167e-02f, 1.33926598e-02f },
      { -2.75028553e-02f, 6.47373637e-03f, -2.95183938e-02f, 3.75758149e-02f, -1.49793131e-02f },
      { -5.02963811e-02f, 1.59407649e-02f, 3.83143732e-03f, -3.80482338e-02f, -5.31844124e-02f },
      { 1.21053550e-02f, 8.73822346e-03f, 5.21629234e-04f, -2.96280850e-02f, 1.71533078e-02f },
      { 1.59554109e-02f, -4.52507809e-02f, 5.28906956e-02f, 1.70567427e-02f, 3.30687426e-02f },
    },
    {
      { -8.87279026e-03f, 1.91518068e-02f, -6.45861700e-02f, 2.78069936e-02f, 3.48246284e-02f },
      { 1.03872444e-03f, -5.09314835e-02f, -5.90229519e-02f, 1.14267673e-02f, -2.21919175e-02f },
      { -6.16059192e-02f, -3.54449556e-04f, 4.07068804e-02f, -6.45118812e-03f, -7.51672452e-03f },
      { -4.27358747e-02f, -3.86074334e-02f, -5.08691221e-02f, -7.76249357e-03f, -5.88585027e-02f },
      { -6.00471944e-02f, 1.12476153e-03f, 5.62480232e-03f, 1.66769251e-02f, 2.60899644e-02f },
    },
    {
      { -4.88427989e-02f, -4.91614118e-02f, -3.93685810e-02f, -3.24279666e-02f, -4.40900810e-02f },
      { -5.61243743e-02f, -3.90213616e-02f, -4.05759923e-02f, 1.83359627e-02f, -6.17771447e-02f },
      { 1.67693049e-02f, -4.82272543e-02f, -6.26792163e-02f, 5.03347777e-02f, 1.05065666e-02f },
      { -3.57149616e-02f, 3.99830146e-03f, -4.50130105e-02f, -3.10116746e-02f, -2.53571104e-03f },
      { 2.29633711e-02f, -5.99163473e-02f, 1.76197272e-02f, 3.19249146e-02f, 2.29998939e-02f },
    },
    {
      { 1.53150912e-02f, 3.45146097e-02f, 2.96049826e-02f, 2.73547266e-02f, -2.28138454e-02f },
      { 1.36670396e-02f, -3.80368233e-02f, -1.94043629e-02f, -3.44934990e-03f, -3.28609757e-02f },
      { -2.98398715e-02f, -4.66110371e-02f, 1.50104957e-02f, 3.73969935e-02f, 4.52506430e-02f },
      { 5.45758614e-03f, -1.70357265e-02f, 4.78575900e-02f, -6.52461424e-02f, -3.50917429e-02f },
      { 4.73677590e-02f, -6.97507476e-03f, -1.93765499e-02f, 3.50875854e-02f, 3.17622647e-02f },
    },
    {
      { 8.84892978e-03f, 5.78878075e-03f, 1.82354823e-02f, -2.18708301e-03f, 2.62024868e-02f },
      { -5.99983223e-02f, 1.08870361e-02f, 2.86581255e-02f, -1.71235611e-03f, 1.34852082e-02f },
      { -4.15312164e-02f, 4.05346937e-02f, -2.58228872e-02f, 5.10406606e-02f, -6.75614774e-02f },
      { 3.73793319e-02f, -1.69174913e-02f, -4.78511862e-02f, 2.50649229e-02f, 2.98203807e-02f },
      { -1.64672807e-02f, 1.43604847e-02f, -1.55071523e-02f, -1.09132500e-02f, -5.52031100e-02f },
    },
    {
      { 2.94146873e-02f, 6.00241534e-02f, 4.39330377e-02f, 4.93243709e-02f, -7.37402067e-02f },
      { -4.64759432e-02f, -3.73685658e-02f, 2.77043693e-02f, 4.66141328e-02f, 7.99188856e-03f },
      { 4.81908098e-02f, -3.08052581e-02f, -4.24264409e-02f, 2.39976346e-02f, -1.71646923e-02f },
      { -5.60920825e-03f, 6.61098585e-02f, -2.35269796e-02f, -5.75459655e-03f, -5.17775416e-02f },
      { -1.48225036e-02f, -4.74658050e-02f, -1.86311938e-02f, 2.68645566e-02f, 1.09853772e-02f },
    },
    {
      { -3.71426088e-03f, 3.40610668e-02f, -6.28988892e-02f, -9.32297111e-03f, 2.75833141e-02f },
      { -1.51091255e-02f, 5.44928983e-02f, -5.64598888e-02f, -1.97280534e-02f, -2.08017174e-02f },
      { -4.61705104e-02f, -5.25963828e-02f, 5.51381074e-02f, -1.29886260e-02f, -2.23632455e-02f },
      { -5.10858186e-02f, -2.06061359e-03f, 2.38793995e-02f, 4.33903150e-02f, 2.35468149e-02f },
      { 1.36687681e-02f, -2.12783758e-02f, -8.67917296e-03f, 1.69573538e-02f, 1.79503225e-02f },
    },
    {
      { -4.96225879e-02f, 5.19561283e-02f, 2.58478755e-03f, -6.18526638e-02f, 2.38847807e-02f },
      { 3.21645662e-02f, -2.87593435e-02f, -4.37686332e-02f, 3.32951397e-02f, 1.67033579e-02f },
      { -3.64427269e-02f, -1.78944916e-02f, 1.24275060e-02f, -1.15826447e-02f, -5.54304905e-02f },
      { -1.51153523e-02f, 3.51751707e-02f, 5.07281311e-02f, 5.34820966e-02f, -3.68058234e-02f },
      { 4.69622910e-02f, -6.19965531e-02f, -3.82230766e-02f, -2.36962680e-02f, -5.51200174e-02f },
    },
    {
      { 3.35480459e-02f, -2.45900126e-03f, 5.03830127e-02f, 2.73226853e-03f, 1.09383985e-02f },
      { 2.36920826e-02f, -6.44677058e-02f, 4.90696542e-02f, -3.28107327e-02f, 2.60077929e-03f },
      { 3.95952091e-02f, 9.18223336e-03f, -2.60010064e-02f, -3.52587812e-02f, -6.35337681e-02f },
      { 4.08449695e-02f, 2.45379377e-02f, 3.36120464e-02f, -5.10990322e-02f, 3.92657928e-02f },
      { -2.58420035e-02f, 1.96013320e-02f, 4.54982743e-02f, -1.60745140e-02f, -2.78709102e-02f },
    },
    {
      { 4.07109186e-02f, 2.83749290e-02f, -1.24774892e-02f, 2.22716555e-02f, -9.77541879e-03f },
      { 7.24634016e-03f, 1.42628243e-02f, 1.17676575e-02f, -2.47338805e-02f, -2.81705149e-02f },
      { -6.61606714e-02f, -2.14281324e-02f, -5.38136549e-02f, 3.89288925e-02f, -3.05324737e-02f },
      { -5.94814308e-02f, -2.30648611e-02f, -4.42415290e-02f, -3.64084207e-02f, 4.16076258e-02f },
      { -6.66038832e-03f, 4.44386639e-02f, -3.04834656e-02f, -2.01635081e-02f, 1.91154312e-02f },
    },
    {
      { -8.04031733e-03f, -5.27089760e-02f, 2.14254092e-02f, 6.32889895e-03f, -6.03331737e-02f },
      { 1.69674307e-02f, 4.12660241e-02f, -5.42179383e-02f, -5.66605590e-02f, 3.49339913e-03f },
      { -9.71311238e-03f, 3.83728556e-02f, -1.48326932e-02f, -1.08457534e-02f, -1.08024208e-02f },
      { 2.96323448e-02f, -2.16278303e-02f, 4.52385247e-02f, 5.24591394e-02f, -3.14074308e-02f },
      { 5.18843867e-02f, -5.93628436e-02f, 1.65067930e-02f, 1.00317290e-02f, -3.73038538e-02f },
    },
    {
      { -5.77957816e-02f, -8.22112057e-03f, 1.35135483e-02f, 2.21742839e-02f, -1.01812854e-02f },
      { 4.96018678e-02f, 1.78980071e-03f, 4.37372178e-02f, -4.46883924e-02f, -8.94220918e-03f },
      { -5.71025759e-02f, 4.72556613e-02f, 2.34963428e-02f, 3.93637531e-02f, -6.50321878e-03f },
      { 2.97037922e-02f, -3.35647576e-02f, -2.73804925e-02f, -7.19230846e-02f, 2.54097674e-02f },
      { -5.57824690e-03f, -1.72702838e-02f, 4.95401435e-02f, 1.62465833e-02f, -5.46328053e-02f },
    },
    {
      { -3.32754627e-02f, -5.60453832e-02f, 1.23772118e-03f, -8.44064541e-03f, 3.14888246e-02f },
      { -5.31036034e-02f, 4.46818164e-03f, -3.45843472e-02f, -2.36116946e-02f, -3.13590206e-02f },
      { 2.20979378e-02f, 9.00839083e-03f, 4.19798903e-02f, -5.41378260e-02f, -5.62842488e-02f },
      { 1.85499992e-02f, 1.49575826e-02f, 1.97625123e-02f, -6.39518201e-02f, 2.08410546e-02f },
      { -3.77388783e-02f, 4.59923409e-02f, 4.19022627e-02f, -9.65900999e-03f, 3.03497165e-02f },
    },
    {
      { -3.35231759e-02f, -1.55768925e-02f, -5.87401129e-02f, -1.62614472e-02f, 1.29120583e-02f },
      { -1.52363069e-02f, -5.47276065e-02f, 7.63959251e-03f, 5.56032173e-02f, 1.71586722e-02f },
      { -3.31729725e-02f, -1.64216291e-02f, -2.65560672e-03f, -3.26321572e-02f, 4.97193784e-02f },
      { -2.19970047e-02f, -3.51408087e-02f, -5.89849949e-02f, -5.02811559e-02f, -2.64181197e-02f },
      { 4.68934290e-02f, 2.18391176e-02f, 4.52926531e-02f, -2.60757073e-03f, -2.58437032e-03f },
    },
    {
      { -1.07990224e-02f, 4.77562211e-02f, -4.53731827e-02f, -3.51139926e-03f, 8.69806297e-03f },
      { -4.45267446e-02f, -1.71254668e-02f, -2.16359869e-02f, -1.64742135e-02f, -3.11746728e-02f },
      { -2.36637294e-02f, -2.94182356e-02f, -2.67802719e-02f, -2.16022898e-02f, 2.56698523e-02f },
      { -7.46443402e-03f, 2.06016209e-02f, -5.99484146e-03f, 4.93494086e-02f, -4.09486704e-02f },
      { -7.26531819e-03f, 2.78854202e-02f, 4.10669632e-02f, 1.38165453e-03f, -5.45890965e-02f },
    },
    {
      { 2.74525303e-02f, 8.70327745e-03f, 3.82221751e-02f, -4.68918011e-02f, -2.04391945e-02f },
      { 4.45115715e-02f, 1.31022288e-02f, -4.27185073e-02f, -1.68297708e-03f, -2.71734949e-02f },
      { -4.29013632e-02f, 2.32776627e-02f, -3.36450860e-02f, -4.78289239e-02f, -1.38075519e-02f },
      { -6.85085207e-02f, 2.36508413e-03f, -2.40303781e-02f, -1.78862847e-02f, -1.38532883e-02f },
      { -4.67275754e-02f, 2.35368684e-03f, -5.71736246e-02f, 5.68869710e-02f, 6.46057054e-02f },
    },
  },
  {
    {
      { -2.50212550e-01f, -3.27895522e-01f, -1.75782174e-01f, 8.34912956e-02f, 1.37280717e-01f },
      { 1.48969680e-01f, 2.63235837e-01f, -2.79275686e-01f, -2.97715425e-01f, 5.49359843e-02f },
      { -5.41602224e-02f, 2.05230862e-01f, 2.18799159e-01f, -8.92421454e-02f, -1.24608718e-01f },
      { -2.58743435e-01f, -2.00068682e-01f, 1.95812836e-01f, 1.64752185e-01f, -8.62757862e-02f },
      { -6.92029446e-02f, -6.11422434e-02f, 3.47863585e-02f, 2.70178497e-01f, 1.09851234e-01f },
    },
    {
      { -2.24078193e-01f, -2.35110059e-01f, 1.33428220e-02f, 7.98918456e-02f, -4.49634995e-03f },
      { 1.28150642e-01f, 1.62182957e-01f, -8.13077390e-02f, -7.31357858e-02f, 1.08288750e-01f },
      { 1.47779258e-02f, 1.98401824e-01f, 2.03913540e-01f, -1.21505283e-01f, -1.41212955e-01f },
      { -3.12005840e-02f, 4.99131531e-02f, 1.48018450e-01f, 1.08621761e-01f, -5.41171059e-02f },
      { -9.82796401e-02f, -3.37516740e-02f, 7.14671314e-02f, 7.79462978e-02f, 3.85612436e-03f },
    },
    {
      { -1.28581062e-01f, -2.67120779e-01f, -2.00967833e-01f, -1.45368040e-01f, -8.90388936e-02f },
      { 5.50716231e-03f, 2.14022294e-01f, 2.34531403e-01f, 3.52212265e-02f, -3.66736390e-02f },
      { -2.29448989e-01f, 3.57893370e-02f, 2.58584321e-01f, 2.13399664e-01f, -3.96260247e-03f },
      { -6.54577371e-03f, -3.29960622e-02f, 2.91752852e-02f, 1.87672332e-01f, 9.79933962e-02f },
      { -6.30234033e-02f, 3.14686000e-02f, 1.02925867e-01f, 3.70826907e-02f, 2.29536891e-02f },
    },
    {
      { 1.42392352e-01f, 1.06882431e-01f, 1.00582652e-01f, -3.78942825e-02f, -2.07861960e-01f },
      { 1.15837269e-01f, -1.32953629e-01f, -1.02592111e-02f, 2.69270055e-02f, -2.58750290e-01f },
      { 8.62395912e-02f, -4.05327864e-02f, -2.57469386e-01f, -1.12695463e-01f, -9.46488753e-02f },
      { 1.67212412e-01f, -1.93092646e-03f, -3.13505143e-01f, -2.66611338e-01f, -4.94929701e-02f },
      { 1.68555573e-01f, 1.05952904e-01f, -1.67348146e-01f, -1.90343007e-01f, 3.97031270e-02f },
    },
    {
      { 1.53955087e-01f, 1.07975237e-01f, 4.47386242e-02f, -6.68677986e-02f, 1.47907296e-02f },
      { 1.78807691e-01f, 1.59058213e-01f, 1.29664496e-01f, -1.65059231e-02f, -1.32971434e-02f },
      { 6.01191930e-02f, -1.70680448e-01f, -1.47164240e-02f, 8.21160246e-03f, -2.84876022e-02f },
      { 1.65688545e-01f, 2.96960343e-02f, -3.12368423e-01f, -1.39181450e-01f, -3.88287343e-02f },
      { 1.07361473e-01f, 1.79869875e-01f, -6.22936711e-02f, -3.54933798e-01f, -3.88162322e-02f },
    },
    {
      { 8.72654393e-02f, 1.21862881e-01f, 4.82400064e-04f, -1.17115729e-01f, -6.51861578e-02f },
      { -2.14979813e-01f, -1.37851748e-03f, 2.14334697e-01f, 6.27383217e-02f, -8.27777386e-02f },
      { -1.59311920e-01f, -3.36564183e-01f, 1.75714381e-02f, 1.60491094e-01f, 1.26633033e-01f },
      { 7.75975809e-02f, -4.00502197e-02f, -3.01928937e-01f, -1.82259828e-03f, 1.05693944e-01f },
      { -7.01122219e-03f, 1.17310055e-01f, -9.15752202e-02f, -1.62723750e-01f, 8.31416324e-02f },
    },
    {
      { 1.33852467e-01f, -1.10803230e-03f, 1.45417750e-01f, 7.95181692e-02f, 2.24104077e-02f },
      { 1.30334035e-01f, -2.61167362e-02f, -5.66978008e-02f, -1.00869283e-01f, 3.50090535e-03f },
      { 2.51694918e-01f, 1.28440261e-01f, -3.10465157e-01f, -4.85103309e-01f, 6.35194778e-02f },
      { 1.02122523e-01f, 1.87549070e-01f, 7.93098062e-02f, -3.48079741e-01f, -9.85864624e-02f },
      { -3.75113338e-02f, -3.72479632e-02f, 3.15725505e-02f, -9.00586024e-02f, -3.60078365e-01f },
    },
    {
      { -2.70708255e-03f, -2.95650456e-02f, -4.55591343e-02f, 5.92353242e-03f, 4.29436490e-02f },
      { -4.10391279e-02f, -7.36188004e-03f, 5.52908219e-02f, -5.28312959e-02f, 5.34920990e-02f },
      { -1.23722069e-01f, 5.18036485e-02f, -6.91471547e-02f, -8.71925876e-02f, 7.87871853e-02f },
      { -9.63534787e-02f, 8.40697512e-02f, 5.53064831e-02f, 9.26844776e-03f, -1.31354317e-01f },
      { -4.29303758e-02f, -4.81744297e-02f, 6.59504309e-02f, 8.90392140e-02f, -1.74476087e-01f },
    },
    {
      { -3.59444708e-01f, -4.00544554e-01f, -2.06305563e-01f, 9.49934274e-02f, 3.04700166e-01f },
      { 2.32235845e-02f, 3.16699356e-01f, -1.60438329e-01f, -4.59220856e-01f, -5.18585742e-02f },
      { -1.52250797e-01f, 3.23503166e-01f, 3.41626972e-01f, -2.64692277e-01f, -4.39672917e-01f },
      { -2.99669653e-01f, -1.05057754e-01f, 2.56695479e-01f, 1.83556110e-01f, -2.24055782e-01f },
      { -6.70490637e-02f, -9.06996056e-02f, -4.67774570e-02f, 1.17310405e-01f, 9.44984704e-03f },
    },
    {
      { -1.83325354e-02f, 6.72130361e-02f, -5.95946386e-02f, -4.72613797e-02f, -2.03945830e-01f },
      { -7.84694627e-02f, -8.50991160e-02f, 1.18026379e-02f, 6.10282309e-02f, -1.03413025e-02f },
      { 2.37742923e-02f, -1.18216015e-01f, -1.55579537e-01f, 7.39473626e-02f, 6.72370270e-02f },
      { 8.47699195e-02f, 1.11968406e-02f, -1.40416920e-01f, -6.98812306e-02f, 1.39774933e-01f },
      { 1.40725644e-02f, 5.88053651e-02f, -2.94330269e-02f, -3.87275852e-02f, 8.11624452e-02f },
    },
    {
      { 6.94161579e-02f, 1.09050423e-01f, 8.83526653e-02f, -9.24941897e-02f, 1.04603765e-03f },
      { -2.01959670e-01f, 5.95295317e-02f, 2.15662643e-01f, 1.23972945e-01f, -9.17581096e-02f },
      { -2.28760362e-01f, -4.63581115e-01f, -4.25500050e-02f, 9.32108834e-02f, 2.85806693e-02f },
      { 7.23026767e-02f, -1.18181203e-02f, -2.86688924e-01f, -2.29386106e-01f, -1.52712194e-02f },
      { 1.19435064e-01f, 7.68930167e-02f, -1.29672782e-02f, -2.61896521e-01f, -4.82430346e-02f },
    },
    {
      { -2.04154000e-01f, -9.87522975e-02f, 1.35646609e-03f, 3.56711783e-02f, 2.09519751e-02f },
      { 2.21449602e-02f, -7.43520111e-02f, -1.66394770e-01f, -7.61842057e-02f, -5.98010328e-03f },
      { 1.41272679e-01f, 1.58015072e-01f, 9.90011320e-02f, -5.45383757e-03f, -1.20000690e-01f },
      { -6.71320409e-02f, 1.13433011e-01f, 7.74881542e-02f, 5.72792254e-02f, 7.28428438e-02f },
      { 1.73101071e-02f, -5.34551404e-02f, 7.59766400e-02f, 1.90431252e-01f, 1.56190932e-01f },
    },
    {
      { -1.60857424e-01f, -1.86233580e-01f, -8.48859698e-02f, 8.03956762e-02f, 1.88407376e-02f },
      { -1.60969384e-02f, 4.62270975e-02f, -1.13528341e-01f, -1.67072624e-01f, -6.50464147e-02f },
      { 4.40955609e-02f, 1.50985688e-01f, 2.50254661e-01f, -3.20580378e-02f, -1.18948571e-01f },
      { -1.46364108e-01f, 2.24802196e-02f, 2.39457428e-01f, 1.33448467e-01f, -6.17715865e-02f },
      { -7.10414648e-02f, -9.89186317e-02f, 6.91360459e-02f, 2.30826735e-01f, 8.52615163e-02f },
    },
    {
      { -1.72854081e-01f, -2.11662218e-01f, 6.21497817e-02f, 1.28506824e-01f, 2.00931970e-02f },
      { 1.10944994e-01f, 4.28769067e-02f, -1.21327579e-01f, -8.35264549e-02f, 2.70415172e-02f },
      { 5.34000173e-02f, 2.54730433e-01f, 2.17526048e-01f, -1.79286584e-01f, -7.08740503e-02f },
      { -1.46532044e-01f, 1.59036562e-01f, 3.01497430e-01f, -7.86235090e-03f, -1.25306070e-01f },
      { -1.33667246e-01f, -2.08272189e-02f, 4.47590537e-02f, 1.20637007e-01f, -4.65551727e-02f },
    },
    {
      { -6.18707314e-02f, -1.17910374e-02f, 5.05410768e-02f, 3.80364247e-02f, -3.41485552e-02f },
      { -4.71075699e-02f, 5.43129817e-02f, 4.19124924e-02f, -4.85079288e-02f, 7.86003657e-04f },
      { -1.46076120e-02f, -4.26742947e-03f, -3.09678353e-02f, 3.34037617e-02f, -8.87698121e-03f },
      { -2.16202270e-02f, -1.67697761e-03f, 4.05776016e-02f, -1.78409591e-02f, 1.20399147e-02f },
      { -6.36959299e-02f, 7.72203365e-03f, 8.38538166e-03f, -4.86501083e-02f, -6.60004690e-02f },
    },
    {
      { 2.43944302e-02f, -2.13600099e-02f, 4.27210853e-02f, -1.18675111e-02f, -3.13086994e-02f },
      { 4.40139957e-02f, -4.28381898e-02f, -8.44264552e-02f, 4.43736278e-02f, -2.22058706e-02f },
      { 5.76025690e-04f, 6.87322989e-02f, 3.15396930e-03f, -5.15208133e-02f, 2.51373425e-02f },
      { 8.49534497e-02f, 1.06719151e-01f, 5.11953272e-02f, -7.44027868e-02f, -4.19551088e-03f },
      { 6.33020326e-02f, 9.67117585e-03f, 2.71666348e-02f, -2.18419973e-02f, 5.43132536e-02f },
    },
    {
      { 3.41875404e-02f, 3.27971876e-02f, -1.31209083e-02f, 6.33251444e-02f, 2.82489266e-02f },
      { 7.39144627e-04f, 1.59548856e-02f, -4.77875173e-02f, -1.60396763e-03f, 2.30943807e-03f },
      { 5.53585961e-02f, -3.59140411e-02f, -6.73000664e-02f, -1.23231426e-01f, -5.99720702e-02f },
      { 1.15023479e-01f, 6.51751980e-02f, -1.65252183e-02f, -3.83247025e-02f, -3.02173365e-02f },
      { 8.87689367e-02f, 3.26037705e-02f, 1.86757129e-02f, -7.48862885e-03f, 1.01729631e-02f },
    },
    {
      { 1.78472027e-02f, 6.71660602e-02f, 8.80627185e-02f, -8.79155397e-02f, -3.00987046e-02f },
      { -8.44839886e-02f, 1.97599046e-02f, 9.80613157e-02f, -3.00220922e-02f, 3.23488330e-03f },
      { 7.67939305e-03f, -1.37119070e-01f, -4.32904996e-02f, 3.24409604e-02f, -2.03302056e-02f },
      { 4.08037640e-02f, 9.73398462e-02f, -1.00003503e-01f, -1.62274182e-01f, -1.06191330e-01f },
      { 9.02047977e-02f, 1.30016997e-01f, 8.82140175e-02f, -1.19988680e-01f, -7.07116723e-02f },
    },
    {
      { 1.46979332e-01f, 1.13434710e-01f, 8.54745060e-02f, -6.27874509e-02f, -5.05187735e-03f },
      { -2.08842590e-01f, 8.28614831e-03f, 8.36617798e-02f, 9.33172852e-02f, -4.01054733e-02f },
      { -1.10669926e-01f, -3.57460797e-01f, -2.88249910e-01f, -8.66013486e-03f, 1.93359703e-02f },
      { 3.74329835e-02f, 7.43026957e-02f, -2.33650267e-01f, -2.04369888e-01f, -1.51368245e-01f },
      { 1.99031726e-01f, 1.04670458e-01f, 1.13788359e-01f, -1.33751780e-01f, -3.38611752e-02f },
    },
    {
      { 8.92629921e-02f, 8.13434198e-02f, 8.82222727e-02f, 1.41609430e-01f, 1.81731984e-01f },
      { 1.14085779e-01f, 1.21543370e-01f, -3.26204225e-02f, -5.67004234e-02f, 3.08852438e-02f },
      { -8.91596079e-03f, -7.54199699e-02f, -9.48739722e-02f, -1.46853656e-01f, -1.07202612e-01f },
      { 2.45370492e-02f, -4.87499982e-02f, -1.72781080e-01f, -8.51901025e-02f, -1.93438724e-01f },
      { 9.10011306e-02f, 5.26439324e-02f, -1.65286824e-01f, -8.85439888e-02f, -1.18208289e-01f },
    },
    {
      { -7.11650122e-03f, 1.39433015e-02f, 1.35913104e-01f, 6.64601997e-02f, -2.04398427e-02f },
      { 8.30171444e-03f, -5.55508733e-02f, -1.33245990e-01f, -8.78826082e-02f, -8.57952982e-02f },
      { 7.81124011e-02f, 9.13600847e-02f, 6.15017600e-02f, -9.47255567e-02f, -1.01661451e-01f },
      { 4.87164706e-02f, 8.02593529e-02f, 5.03342077e-02f, -1.04796201e-01f, -6.26848787e-02f },
      { 3.51261608e-02f, 1.82493310e-02f, 4.59334478e-02f, 1.26892487e-02f, 6.06863126e-02f },
    },
    {
      { -1.29161524e-02f, -1.71158373e-01f, -9.88139734e-02f, -7.73391202e-02f, -9.12471265e-02f },
      { 1.27164572e-01f, -4.23746705e-02f, -1.19977951e-01f, -1.84536219e-01f, 2.84457076e-02f },
      { -1.10248081e-01f, 2.23160367e-02f, 1.12715751e-01f, 1.21351600e-01f, 1.47413746e-01f },
      { -3.62962127e-01f, -2.60743707e-01f, -2.06794709e-01f, 5.36811016e-02f, 1.03137419e-01f },
      { -2.64309406e-01f, -2.04378352e-01f, 2.02845708e-02f, 4.03510109e-02f, 1.26185477e-01f },
    },
    {
      { 3.48127671e-02f, -9.50821415e-02f, -1.01046130e-01f, -1.02328658e-01f, -7.32632261e-03f },
      { -2.72507779e-02f, 1.21266700e-01f, 1.13387406e-01f, 2.55550686e-02f, -1.79693121e-02f },
      { 2.99047455e-02f, -5.45081124e-02f, 1.23353593e-01f, 1.53978333e-01f, 6.14057519e-02f },
      { 9.90452915e-02f, -5.20887971e-03f, 3.63402553e-02f, 1.67456731e-01f, 1.10045075e-01f },
      { -6.35364372e-03f, 4.31334674e-02f, 1.09642416e-01f, 9.69458371e-02f, 2.39868194e-01f },
    },
    {
      { -7.68934861e-02f, -2.94749644e-02f, -2.24561896e-03f, 7.94821903e-02f, 4.04348597e-02f },
      { -7.97218736e-03f, 1.18470974e-02f, -6.47047088e-02f, -1.65559631e-02f, -1.04013709e-02f },
      { 3.70246582e-02f, 7.18079358e-02f, 5.45038749e-03f, -1.45305380e-01f, 3.79637592e-02f },
      { -6.82155648e-03f, 8.85775983e-02f, 4.63651419e-02f, -4.64236923e-02f, -9.99833792e-02f },
      { -1.44316778e-02f, -3.04764919e-02f, 9.21927989e-02f, 5.62320389e-02f, -4.17746045e-02f },
    },
    {
      { 5.74778579e-02f, -2.33468320e-03f, 7.66264088e-03f, -1.19231209e-01f, -9.82799456e-02f },
      { -1.48595557e-01f, -3.21272612e-02f, 1.67218164e-01f, 1.73396841e-02f, -2.04988308e-02f },
      { -1.35020480e-01f, -2.91422755e-01f, -1.33954108e-01f, 1.49808312e-02f, 3.30975233e-03f },
      { 3.73073742e-02f, 4.84440476e-03f, -1.22892477e-01f, -7.11804926e-02f, -5.56791835e-02f },
      { 9.65565443e-02f, 1.01120979e-01f, 1.44946948e-01f, -1.85117368e-02f, -1.94984321e-02f },
    },
    {
      { 8.34431350e-02f, 5.50662838e-02f, 1.07420631e-01f, 6.02811016e-02f, 1.81266163e-02f },
      { -1.31476045e-01f, 1.22130699e-02f, 5.59774004e-02f, 4.48298007e-02f, 2.40627863e-02f },
      { 3.44054997e-02f, -4.54007043e-03f, 8.76172911e-03f, 7.64726251e-02f, 9.51908901e-02f },
      { 7.99170956e-02f, 8.26804191e-02f, 1.58641830e-01f, -8.23143404e-03f, -2.58856378e-02f },
      { 1.11477152e-02f, 3.97478007e-02f, 1.56991392e-01f, 7.55542666e-02f, 9.95087102e-02f },
    },
    {
      { -1.96102299e-02f, 7.37388581e-02f, 8.57056528e-02f, 4.40817932e-03f, -4.75660106e-03f },
      { -4.17902470e-02f, -5.05969562e-02f, 4.21776734e-02f, -4.41076383e-02f, -2.17084102e-02f },
      { 5.85989021e-02f, -6.29197434e-02f, -1.69230983e-01f, -1.16753832e-01f, -1.34283751e-02f },
      { 1.26146004e-01f, 6.06936142e-02f, -4.24935557e-02f, -1.25783220e-01f, -1.25998586e-01f },
      { 1.35920495e-01f, 1.62651062e-01f, 1.23078570e-01f, -1.20886587e-01f, -3.69886272e-02f },
    },
    {
      { -7.04860687e-02f, -4.50808294e-02f, 2.14876533e-02f, -1.08469523e-01f, -8.66800547e-02f },
      { 1.01929896e-01f, 1.57031998e-01f, 1.54183552e-01f, 1.17654920e-01f, 5.37928939e-02f },
      { 3.29235718e-02f, 2.16355864e-02f, 1.35184810e-01f, 1.42098606e-01f, 1.01054378e-01f },
      { 2.06879899e-02f, 3.40469135e-03f, -4.45161015e-02f, 1.04750961e-01f, 1.64798841e-01f },
      { -2.35661883e-02f, 6.88353106e-02f, -2.03199461e-02f, -2.00016070e-02f, 1.29150063e-01f },
    },
    {
      { -9.33075771e-02f, -1.21963017e-01f, 6.01239176e-03f, 1.49573579e-01f, 1.34071872e-01f },
      { 1.50554568e-01f, -4.46672775e-02f, -4.15272653e-01f, -3.27976763e-01f, -1.15233786e-01f },
      { 1.66899353e-01f, 2.47415632e-01f, 6.92400038e-02f, -3.32080811e-01f, -3.16367745e-01f },
      { -8.89554918e-02f, 1.14110455e-01f, 1.55793592e-01f, -4.81313132e-02f, -1.21773228e-01f },
      { -2.48600673e-02f, -1.09532326e-01f, 1.10334605e-02f, 1.00117035e-01f, 5.48206717e-02f },
    },
    {
      { 9.72202327e-03f, -4.68958495e-03f, 4.68705632e-02f, 1.00022135e-02f, 4.07641940e-02f },
      { -2.41609514e-02f, 5.04044183e-02f, 5.62762506e-02f, -2.73490716e-02f, -4.03984264e-03f },
      { 2.81410124e-02f, 3.26228775e-02f, 3.46564949e-02f, 5.34149855e-02f, -2.61042640e-02f },
      { 2.40029078e-02f, -5.69026805e-02f, -4.94252741e-02f, -5.90349995e-02f, 1.51852751e-02f },
      { -3.20114456e-02f, 5.60365431e-02f, -3.38570066e-02f, -1.85178686e-02f, -1.07557131e-02f },
    },
    {
      { -1.25144735e-01f, -2.24184901e-01f, 7.08338693e-02f, 2.61592567e-01f, 1.32921249e-01f },
      { 1.84168369e-01f, 8.37990567e-02f, -2.55798250e-01f, -1.81932092e-01f, 8.20282102e-02f },
      { -8.10916349e-02f, 2.53274202e-01f, 1.38539210e-01f, -3.62607628e-01f, -1.60804987e-01f },
      { -1.49173796e-01f, 6.36703223e-02f, 1.04552992e-01f, 1.27269630e-03f, -1.40645251e-01f },
      { -4.07424234e-02f, -1.55848712e-01f, 1.24092065e-02f, 3.65792885e-02f, -1.02116749e-01f },
    },
    {
      { 1.82527274e-01f, 7.47188255e-02f, -9.80362948e-03f, 6.02008887e-02f, 5.24362922e-02f },
      { 2.01764610e-02f, 5.37043326e-02f, 1.95847685e-03f, -1.02281161e-01f, 1.41196474e-01f },
      { -2.73954775e-02f, 2.01890647e-01f, -8.25836957e-02f, -3.34292978e-01f, 1.16439043e-02f },
      { 4.55566496e-02f, 6.45453706e-02f, 1.31839678e-01f, -1.83960751e-01f, -1.21686533e-01f },
      { -3.28495055e-02f, -2.03941166e-01f, 4.49952073e-02f, 2.41024792e-02f, -7.48124048e-02f },
    },
  },
  {
    {
      { -2.23278571e-02f, -6.53580055e-02f, -3.58209386e-02f, -3.47861871e-02f, -6.60773590e-02f },
      { -8.00388008e-02f, 4.41546959e-04f, -1.38379419e-02f, -8.17339346e-02f, 2.03798618e-02f },
      { 3.26727517e-02f, 1.90475639e-02f, 2.86197141e-02f, -6.84179440e-02f, -2.52955835e-02f },
      { -1.78756285e-02f, -7.30451643e-02f, 3.37027796e-02f, -1.41077582e-03f, -6.64335787e-02f },
      { -5.02190590e-02f, -3.04566398e-02f, -1.43045688e-03f, -3.30768190e-02f, -4.92440313e-02f },
    },
    {
      { 5.27441362e-03f, 1.57056004e-02f, -6.14352897e-02f, -4.30819914e-02f, 3.32495831e-02f },
      { -3.82196382e-02f, -1.84595436e-02f, -4.07158062e-02f, -4.67199124e-02f, -4.68642591e-03f },
      { 5.46779856e-02f, 2.61615738e-02f, -3.88334431e-02f, 3.34166512e-02f, -4.82807085e-02f },
      { -2.21085306e-02f, -2.33748071e-02f, -7.22248759e-03f, -6.02118373e-02f, 4.48683836e-02f },
      { 2.78195590e-02f, -4.81591299e-02f, -5.16132116e-02f, 1.33838551e-02f, 5.03566153e-02f },
    },
    {
      { -4.43897583e-02f, 3.41205895e-02f, 3.51234153e-02f, -4.51402031e-02f, 1.53518906e-02f },
      { -7.55488575e-02f, 1.55578312e-02f, 2.68354686e-03f, 1.18722511e-03f, 5.58992801e-03f },
      { -1.12014981e-02f, 3.97533702e-04f, 4.64069918e-02f, -5.24892379e-03f, 2.41648536e-02f },
      { -5.23218066e-02f, -4.79229093e-02f, -2.36500539e-02f, 3.62364040e-03f, 4.13227156e-02f },
      { -1.83974449e-02f, -3.53470966e-02f, -5.80651797e-02f, -2.49593817e-02f, -3.71029675e-02f },
    },
    {
      { 8.75461753e-03f, 1.21691562e-02f, 3.73662785e-02f, -4.50296216e-02f, -6.66082501e-02f },
      { 3.84806618e-02f, 4.93268520e-02f, 1.02863731e-02f, -5.58307255e-03f, 2.85318680e-03f },
      { -6.59370124e-02f, 2.61196140e-02f, -1.81049109e-02f, 4.05486450e-02f, -3.40734012e-02f },
      { 4.93483804e-02f, -4.61694598e-02f, 2.35416014e-02f, -2.00790986e-02f, 4.02624197e-02f },
      { 3.92425805e-03f, -5.27473204e-02f, -2.36278661e-02f, -3.84074524e-02f, 5.54546900e-02f },
    },
    {
      { -3.24931485e-03f, 3.80855449e-03f, -5.34843765e-02f, -5.63077442e-02f, -6.13527484e-02f },
      { 4.93307635e-02f, -5.34074344e-02f, 1.34905884e-02f, 3.33338715e-02f, -3.56863588e-02f },
      { -1.54512208e-02f, -2.42442023e-02f, 4.05469500e-02f, -2.64517982e-02f, -5.79497889e-02f },
      { -1.43083017e-02f, 1.84004009e-02f, -2.59894356e-02f, -2.51640007e-02f, -2.31821090e-02f },
      { -4.02649976e-02f, -5.64567931e-02f, 9.85598750e-03f, -4.58214693e-02f, 2.67968457e-02f },
    },
    {
      { 1.68752316e-02f, -6.43127486e-02f, -1.73052913e-03f, -4.15354148e-02f, -5.16747907e-02f },
      { -2.43146365e-04f, -2.98703846e-04f, 6.24283254e-02f, -4.57513221e-02f, -2.53460091e-02f },
      { 4.33710031e-02f, -4.48103882e-02f, -1.07384818e-02f, 5.72400093e-02f, 2.13151909e-02f },
      { -9.92810470e-04f, 2.43980978e-02f, -2.07362734e-02f, -6.16069511e-02f, 3.09175905e-02f },
      { -6.01067655e-02f, -4.79189306e-02f, -9.39427875e-03f, 8.22467078e-03f, 3.90767045e-02f },
    },
    {
      { 4.08149511e-02f, -5.10720871e-02f, 5.14662378e-02f, -4.17415202e-02f, 6.13206439e-02f },
      { -6.09367229e-02f, -3.03218327e-02f, 4.42750081e-02f, 5.34729753e-03f, -5.11509888e-02f },
      { -3.78560610e-02f, -2.15578452e-02f, 2.20916886e-02f, -1.61838010e-02f, 5.54617830e-02f },
      { 3.10235154e-02f, -4.23877388e-02f, -3.72448340e-02f, 2.02243347e-02f, -4.62699458e-02f },
      { -2.37174518e-02f, -8.44510365e-03f, 2.91556660e-02f, -2.16778852e-02f, 4.23637778e-02f },
    },
    {
      { 1.21303564e-02f, -3.63444425e-02f, 1.77741293e-02f, 6.41417224e-03f, -6.30080551e-02f },
      { -3.24425660e-02f, 2.59177331e-02f, -4.75366488e-02f, -2.85591534e-03f, 3.78976837e-02f },
      { 4.67223972e-02f, 4.19551581e-02f, 3.35487649e-02f, -3.89991105e-02f, -3.71076749e-03f },
      { -3.64568122e-02f, 1.96826253e-02f, -6.23839907e-02f, 6.33503944e-02f, -2.81033502e-03f },
      { 5.10891639e-02f, -2.08298862e-02f, 2.63225008e-02f, 1.97750260e-03f, -1.62463933e-02f },
    },
    {
      { -6.48273015e-03f, 1.01914778e-02f, -6.66731745e-02f, 4.56595374e-03f, -6.45658076e-02f },
      { 1.40584363e-02f, -4.40583155e-02f, 3.88193019e-02f, 1.58032365e-02f, -3.05127760e-04f },
      { 2.52793022e-02f, -3.28288078e-02f, -3.64623144e-02f, -3.35455127e-02f, 1.14635304e-02f },
      { 1.02129597e-02f, 7.15029053e-03f, -1.26798404e-02f, 2.16627866e-02f, 2.09221132e-02f },
      { -5.21092303e-02f, 2.44778972e-02f, 2.26006261e-03f, -2.08339803e-02f, -6.84014782e-02f },
    },
    {
      { 3.79173420e-02f, 1.04493275e-02f, -4.71257903e-02f, -2.21066419e-02f, 2.73311716e-02f },
      { -2.78361123e-02f, -1.11018801e-02f, -2.40495112e-02f, -4.39345650e-02f, -2.94836890e-02f },
      { -6.30127359e-03f, 4.07871045e-02f, 2.92433612e-03f, -2.08097249e-02f, -3.63934180e-03f },
      { -5.76157449e-03f, -1.46836275e-02f, 2.72372104e-02f, 7.71806226e-04f, 3.52227353e-02f },
      { -6.32144585e-02f, -5.33664338e-02f, 1.53588317e-03f, -6.03153110e-02f, -5.58596067e-02f },
    },
    {
      { 4.15223613e-02f, -5.83649911e-02f, 5.29970303e-02f, 5.04293032e-02f, -1.39170149e-02f },
      { 5.15939817e-02f, 4.00070474e-02f, -9.47171450e-03f, 9.90704354e-03f, -4.78570722e-02f },
      { -5.10054603e-02f, -4.16639484e-02f, -5.95132224e-02f, 9.27243527e-05f, 4.21720408e-02f },
      { -4.25006859e-02f, -5.89627363e-02f, 1.06501020e-03f, -4.21399064e-02f, 2.38000788e-02f },
      { -1.03216060e-02f, 3.69071700e-02f, 5.36975674e-02f, 3.48812751e-02f, -3.75567488e-02f },
    },
    {
      { 2.35603787e-02f, 4.54932079e-02f, 3.53975333e-02f, 3.26881581e-03f, 2.95236874e-02f },
      { 4.42612581e-02f, -5.95936887e-02f, -4.30940539e-02f, 2.61987299e-02f, 3.32100540e-02f },
      { -3.58830579e-02f, 1.38195455e-02f, -4.98225726e-02f, -4.13726047e-02f, 3.45263667e-02f },
      { -6.33206889e-02f, 4.32260633e-02f, 4.73192371e-02f, 2.24587950e-03f, -5.26433364e-02f },
      { 1.82725973e-02f, 2.04578806e-02f, -5.13805188e-02f, -9.21770744e-03f, -1.64485183e-02f },
    },
    {
      { -1.14134904e-02f, 1.84654184e-02f, 1.03845913e-02f, 2.04567034e-02f, 3.43516134e-02f },
      { 2.94890571e-02f, -2.84497105e-02f, 9.81992949e-03f, -3.30451988e-02f, -6.43740520e-02f },
      { 2.67576687e-02f, 8.04673228e-03f, -4.66739275e-02f, -8.41137674e-03f, -2.89584808e-02f },
      { 2.56998856e-02f, 1.81834176e-02f, -3.84945944e-02f, -4.66501042e-02f, 5.56880608e-02f },
      { 5.49498349e-02f, 2.89681051e-02f, -4.49599735e-02f, -2.25114487e-02f, -5.59658483e-02f },
    },
    {
      { -6.12970926e-02f, -6.26110956e-02f, 2.59400941e-02f, 4.59951088e-02f, 1.97549481e-02f },
      { -2.83747241e-02f, 1.03673087e-02f, -2.25476921e-02f, 9.21926647e-03f, 3.03541813e-02f },
      { -1.82410683e-02f, -3.56103145e-02f, 5.21239303e-02f, -3.61003331e-03f, -5.81158325e-02f },
      { -5.71715459e-02f, 3.69823612e-02f, -1.82328429e-02f, -6.12905212e-02f, -2.61890087e-02f },
      { -6.80511147e-02f, -4.26862985e-02f, 3.29940161e-03f, -4.99407426e-02f, -3.59152593e-02f },
    },
    {
      { 1.61790673e-03f, -2.56330073e-02f, -3.95152606e-02f, -5.98027892e-02f, -6.02269396e-02f },
      { 1.39458468e-02f, 2.34305635e-02f, 5.51704243e-02f, -2.01824028e-02f, 7.49388197e-03f },
      { -3.60619306e-04f, -4.11605872e-02f, 4.41987701e-02f, 3.24817300e-02f, 3.61554474e-02f },
      { 3.72183472e-02f, -2.67349239e-02f, 1.64259765e-02f, -4.74469773e-02f, 2.72004362e-02f },
      { -4.40998524e-02f, 2.61117853e-02f, 5.66186197e-02f, 1.22797564e-02f, 3.05437818e-02f },
    },
    {
      { -2.19641197e-02f, 3.13619990e-03f, -7.14024808e-03f, 8.35650880e-03f, 3.47556435e-02f },
      { 2.59315446e-02f, -9.87337902e-04f, 3.66147682e-02f, -6.51507974e-02f, -5.77218421e-02f },
      { 6.75564259e-03f, 3.54428105e-02f, -6.81818556e-03f, -2.79169884e-02f, -5.52442409e-02f },
      { 3.87775190e-02f, -1.23477811e-02f, -5.14220409e-02f, 3.72837484e-02f, -5.86602241e-02f },
      { -5.81824780e-02f, -5.47115877e-02f, -2.07507033e-02f, 1.14313737e-02f, -4.38637137e-02f },
    },
    {
      { 2.88084168e-02f, -1.59987602e-02f, 1.90286301e-02f, -1.10293711e-02f, -4.85600345e-02f },
      { -1.10897282e-02f, -4.66237366e-02f, -4.05354016e-02f, -6.72269613e-02f, 1.08181024e-02f },
      { 3.00343018e-02f, 4.51031402e-02f, 4.69251424e-02f, 1.58948172e-02f, 2.79139578e-02f },
      { -3.32650132e-02f, 3.31680551e-02f, 1.06011599e-03f, 1.85464360e-02f, 2.32149754e-02f },
      { -2.09177826e-02f, -3.23660001e-02f, 5.60136884e-03f, 5.67023270e-02f, 3.23482044e-02f },
    },
    {
      { -9.26204957e-03f, -2.92985346e-02f, 1.84717402e-02f, -6.08506426e-02f, 2.11535674e-02f },
      { -3.70128490e-02f, -3.86766754e-02f, -5.91013394e-02f, -1.57607719e-02f, -1.98271889e-02f },
      { -2.90570743e-02f, 3.08190770e-02f, -1.06760822e-02f, -5.76987024e-03f, -2.95295771e-02f },
      { -1.85788870e-02f, -1.20411795e-02f, -1.77280698e-02f, 4.17820141e-02f, -4.73591127e-02f },
      { -4.17035557e-02f, 6.72695553e-03f, -5.24051152e-02f, -2.17567664e-02f, 4.52580303e-02f },
    },
    {
      { -6.02399111e-02f, -4.96789031e-02f, -4.67775688e-02f, 4.17657904e-02f, 1.44086741e-02f },
      { 1.93186710e-03f, -6.14446439e-02f, 1.75232708e-03f, -4.48452346e-02f, 2.97838934e-02f },
      { -1.39291177e-03f, 3.25020705e-03f, 5.20122945e-02f, -4.97486293e-02f, 3.82176489e-02f },
      { -9.96077340e-03f, -1.25811370e-02f, 1.54348277e-02f, 2.51850151e-02f, -2.26302333e-02f },
      { 5.34138232e-02f, -1.54948905e-02f, 4.16698381e-02f, -5.37047461e-02f, -3.36675122e-02f },
    },
    {
      { 3.13618146e-02f, -3.42770815e-02f, -4.14768979e-02f, 4.71728034e-02f, 8.14311206e-03f },
      { 3.75124589e-02f, -4.12131846e-02f, 2.33889390e-02f, -6.29018527e-03f, -2.66504753e-02f },
      { 4.53771241e-02f, 2.15824172e-02f, 5.30458353e-02f, 1.88093185e-02f, 2.97592860e-02f },
      { -5.18950112e-02f, 3.30395577e-03f, 3.66291925e-02f, 2.88966484e-02f, -5.19359298e-02f },
      { -3.93717475e-02f, -8.75303615e-03f, -2.31651254e-02f, 2.83382852e-02f, 2.67157573e-02f },
    },
    {
      { 4.30068821e-02f, -7.56843481e-03f, -6.60396833e-03f, -3.13685574e-02f, -4.40286547e-02f },
      { 2.74128672e-02f, -4.30370606e-02f, 3.72034498e-02f, 2.05081124e-02f, 2.57794987e-02f },
      { 2.92024128e-02f, 5.36618792e-02f, -4.39482220e-02f, -1.25680445e-02f, -6.04570135e-02f },
      { 3.25831734e-02f, 2.96429917e-02f, 4.43868302e-02f, -1.64091755e-02f, 4.84207757e-02f },
      { 2.29020193e-02f, 3.18037309e-02f, -1.87824443e-02f, 3.70144546e-02f, 2.24631559e-02f },
    },
    {
      { 1.56359971e-02f, -4.92798211e-03f, -4.33451198e-02f, -1.14817899e-02f, 2.19616164e-02f },
      { 1.13390740e-02f, 2.40202695e-02f, -4.62636910e-02f, 3.51684019e-02f, 4.29723226e-03f },
      { 3.94493453e-02f, 1.14434380e-02f, -1.41322743e-02f, 1.19349035e-02f, -4.14152555e-02f },
      { -1.76871214e-02f, 6.57886565e-02f, 1.94677040e-02f, 4.05523144e-02f, 1.16788018e-02f },
      { 4.53856960e-02f, 3.38370502e-02f, -1.91328097e-02f, 3.07172406e-02f, 1.94092263e-02f },
    },
    {
      { 2.75406651e-02f, -3.67546417e-02f, -4.37579639e-02f, 4.29927744e-02f, 4.64944281e-02f },
      { 1.68878138e-02f, 4.80181724e-02f, 8.61927215e-03f, -1.90241784e-02f, -3.94714028e-02f },
      { -3.62601243e-02f, -2.12244387e-03f, 1.37472358e-02f, 6.17781766e-02f, -4.44864482e-02f },
      { -4.64640558e-02f, -6.92970958e-03f, -2.54563335e-02f, -5.52755073e-02f, -7.31780827e-02f },
      { 5.32721877e-02f, -2.07324307e-02f, -4.41530347e-02f, -4.67455611e-02f, 4.00810018e-02f },
    },
    {
      { -6.28309548e-02f, 2.40513980e-02f, -2.10009683e-02f, -8.05506855e-03f, -2.04888098e-02f },
      { 3.33342999e-02f, -2.26021968e-02f, -4.08598892e-02f, -5.39885052e-02f, 8.74726195e-03f },
      { -4.54915501e-02f, 1.21769942e-02f, -1.02235116e-02f, -4.48687300e-02f, -2.65550148e-02f },
      { -5.43886274e-02f, -9.75821074e-03f, 1.33782560e-02f, 3.62894572e-02f, 3.04587511e-03f },
      { -8.14437680e-03f, 4.89295460e-02f, 1.78371314e-02f, 2.75763907e-02f, -8.26929137e-03f },
    },
    {
      { -9.15607717e-03f, -5.81857227e-02f, -3.58555652e-02f, 2.30002031e-02f, -4.39094147e-03f },
      { -1.18229752e-02f, -1.03676785e-02f, -1.54037271e-02f, -3.48819271e-02f, -1.08120814e-02f },
      { -1.55894235e-02f, -4.08379734e-02f, -2.71513779e-02f, -6.55629933e-02f, -1.39254071e-02f },
      { 1.46129299e-02f, -2.96392012e-02f, -3.65737379e-02f, -4.45914380e-02f, -5.45986630e-02f },
      { -1.58805512e-02f, 3.77891064e-02f, -7.59995729e-03f, -4.34468202e-02f, 2.88895331e-02f },
    },
    {
      { 2.03061588e-02f, 1.02738505e-02f, -3.34311165e-02f, -8.37805793e-02f, -5.71056269e-02f },
      { 1.62978414e-02f, -2.14175470e-02f, -5.82005084e-02f, 4.26257625e-02f, 3.08718495e-02f },
      { 3.31198312e-02f, -4.38273214e-02f, -5.68700172e-02f, -5.30821532e-02f, 2.69074608e-02f },
      { 1.75809022e-02f, 5.90211572e-03f, -1.47939101e-03f, 1.00823054e-02f, -3.32566500e-02f },
      { 1.48821315e-02f, 6.51253462e-02f, -2.04231553e-02f, -5.60924411e-02f, -3.25036570e-02f },
    },
    {
      { 1.58815812e-02f, -1.45826833e-02f, -1.99925862e-02f, 2.85541583e-02f, -6.56286776e-02f },
      { 4.44900692e-02f, -8.06582568e-04f, 1.33003592e-02f, -5.11417463e-02f, -4.17776257e-02f },
      { -9.15625971e-03f, -4.26799357e-02f, 4.20223735e-02f, 1.42808910e-03f, 6.95464993e-03f },
      { -2.07700506e-02f, -3.53108735e-05f, 3.51353660e-02f, 1.67840049e-02f, -6.25341609e-02f },
      { 1.86435599e-02f, -2.01060083e-02f, -4.82341237e-02f, 3.10406694e-03f, 3.74099724e-02f },
    },
    {
      { -2.58429516e-02f, -5.36547378e-02f, -4.34874222e-02f, -3.04727871e-02f, -3.60276066e-02f },
      { -3.55816744e-02f, 1.94873903e-02f, 1.82313491e-02f, 3.79506797e-02f, 1.20626213e-02f },
      { -5.15016690e-02f, -5.55336289e-02f, -1.89968701e-02f, 2.79534310e-02f, 4.31050593e-03f },
      { -6.18613660e-02f, -2.03807987e-02f, 1.52059011e-02f, -3.83811444e-02f, -8.87427945e-04f },
      { 1.25406794e-02f, 3.98359410e-02f, -3.52574716e-05f, 1.45230014e-02f, -2.79210266e-02f },
    },
    {
      { -7.35674948e-02f, 3.22306976e-02f, -1.11824581e-02f, 2.42032371e-02f, -1.32435393e-02f },
      { -6.16454631e-02f, -4.19924147e-02f, -3.15612480e-02f, -4.97405417e-02f, 1.04348846e-02f },
      { -2.83881389e-02f, -6.10991865e-02f, -2.29246374e-02f, 1.19048753e-03f, -3.11753922e-03f },
      { 4.46688058e-03f, -2.79840380e-02f, -2.84653977e-02f, -4.97791544e-02f, -4.07766476e-02f },
      { -5.03703542e-02f, -1.85603946e-02f, 9.57268197e-03f, -9.87092964e-03f, 8.95431638e-03f },
    },
    {
      { 4.74468730e-02f, -4.86747101e-02f, -1.13584800e-02f, 1.33648720e-02f, 5.36311418e-02f },
      { 2.62627266e-02f, 2.12458652e-02f, 2.58333725e-03f, 1.43374829e-02f, 5.25507182e-02f },
      { -3.23168077e-02f, -5.99237084e-02f, 1.60595812e-02f, -3.64255197e-02f, -4.76508737e-02f },
      { -1.14740096e-02f, -2.05491036e-02f, 8.50647874e-03f, -5.26699610e-02f, 2.65677758e-02f },
      { -4.13721018e-02f, 4.36241403e-02f, -2.89030205e-02f, -1.61273293e-02f, -1.25093879e-02f },
    },
    {
      { -5.01535311e-02f, -2.18035076e-02f, 4.54107672e-02f, 6.60212785e-02f, -4.23102118e-02f },
      { -4.65724580e-02f, -2.99820229e-02f, -4.09006029e-02f, -2.30509192e-02f, 5.60675599e-02f },
      { -5.78564592e-02f, 3.63389589e-02f, 1.03761172e-02f, -5.89599572e-02f, -4.71062101e-02f },
      { 4.95725721e-02f, -5.26760295e-02f, 1.84970554e-02f, -3.12102102e-02f, 3.04576755e-02f },
      { -5.68905920e-02f, -6.95197433e-02f, 1.95669606e-02f, -1.25026032e-02f, -5.48927970e-02f },
    },
    {
      { 4.35476899e-02f, 3.40618901e-02f, 5.89491874e-02f, -5.36810793e-02f, -6.76367432e-04f },
      { -5.18756509e-02f, -3.43217812e-02f, -2.32120510e-02f, -3.78865562e-02f, -4.28521931e-02f },
      { 1.87019110e-02f, 1.30895118e-04f, 3.08288690e-02f, -1.19545180e-02f, 5.22874855e-02f },
      { 5.22772558e-02f, 1.36657720e-02f, 1.31637705e-02f, -2.27848943e-02f, -4.23593298e-02f },
      { 2.89752241e-02f, -2.81968759e-03f, -4.83075231e-02f, 7.99547695e-03f, -5.74915521e-02f },
    },
  },
  {
    {
      { -1.08732305e-01f, -3.78544070e-02f, -9.71654058e-03f, -1.00667097e-01f, 3.53091322e-02f },
      { -4.82320748e-02f, -5.32258190e-02f, -8.49332064e-02f, -6.22894913e-02f, -7.81971142e-02f },
      { -5.69221377e-02f, -7.66899511e-02f, -1.03692994e-01f, -4.21644524e-02f, 2.15201546e-02f },
      { -3.12792622e-02f, 4.04322566e-03f, -3.67548503e-02f, -1.99756827e-02f, -8.09328035e-02f },
      { -3.66169438e-02f, -5.36534935e-05f, -5.64016737e-02f, -2.51288451e-02f, -5.94345033e-02f },
    },
    {
      { -3.18585858e-02f, -1.52587797e-02f, 5.68324700e-02f, 1.04513280e-02f, -7.47345015e-02f },
      { -2.40613464e-02f, -4.53786924e-02f, 1.32208290e-02f, -6.48021027e-02f, -1.80426408e-02f },
      { 2.80769095e-02f, 6.87337015e-03f, -1.24364560e-02f, -1.48643367e-02f, -7.05087259e-02f },
      { -8.07746127e-03f, -3.93856317e-02f, -8.31487328e-02f, 3.74762639e-02f, -1.23459874e-02f },
      { 1.56176882e-02f, 6.11990578e-02f, 2.00697593e-02f, 3.06708850e-02f, -9.45413932e-02f },
    },
    {
      { -4.42344807e-02f, 2.88265999e-02f, 4.53392379e-02f, -3.23329940e-02f, 4.65178601e-02f },
      { -3.04194018e-02f, 5.60286827e-02f, -1.03890579e-02f, -4.31798361e-02f, 1.96806956e-02f },
      { -6.32168278e-02f, 1.81997120e-02f, 2.98166405e-02f, -8.27272534e-02f, -1.64215211e-02f },
      { -1.36877084e-02f, -1.34182172e-02f, 8.75660125e-03f, -4.39488627e-02f, 3.61961685e-02f },
      { -2.87393387e-02f, -1.20372372e-02f, -3.89222838e-02f, -9.55561176e-03f, -5.24398871e-02f },
    },
    {
      { 1.07171806e-02f, -3.32374610e-02f, 4.90545388e-03f, 2.84039751e-02f, -9.47560295e-02f },
      { -5.11634760e-02f, -1.30077628e-02f, 3.24130654e-02f, -3.95578258e-02f, -3.28374282e-02f },
      { -9.43196267e-02f, -7.80330002e-02f, -1.78735405e-02f, -5.17586730e-02f, -4.38029412e-03f },
      { 3.18413638e-02f, 1.50352178e-04f, -6.51291981e-02f, 1.96942408e-02f, -5.02799973e-02f },
      { -4.81845066e-02f, -6.96242303e-02f, 1.73092249e-03f, -4.21960093e-02f, -4.11122926e-02f },
    },
    {
      { -6.12993427e-02f, -7.41541386e-02f, -7.90893435e-02f, 2.54557636e-02f, 6.20433930e-05f },
      { -7.92676806e-02f, -7.11185113e-02f, -2.16206070e-02f, 8.98481160e-03f, -8.01926404e-02f },
      { -5.92363328e-02f, -8.11495334e-02f, -1.28020644e-02f, -3.50293629e-02f, -8.64653140e-02f },
      { 1.97667982e-02f, 8.99840705e-03f, -2.52517052e-02f, -8.06638002e-02f, -3.26169245e-02f },
      { 3.05905882e-02f, 2.07682066e-02f, 9.57999006e-03f, -4.04917784e-02f, -3.09032612e-02f },
    },
    {
      { 2.83222143e-02f, -3.59543823e-02f, -2.50757746e-02f, 1.35901067e-02f, -1.00174136e-02f },
      { 7.00564962e-03f, 4.58774623e-03f, 2.30596364e-02f, 1.22928740e-02f, -7.49310181e-02f },
      { -9.03574973e-02f, -7.11774528e-02f, -3.87563519e-02f, 3.96153964e-02f, -3.89027107e-03f },
      { -4.81550731e-02f, -9.46129560e-02f, 1.26022864e-02f, -5.28647238e-03f, 1.14572123e-02f },
      { -6.82473481e-02f, 3.71461138e-02f, -1.11829154e-02f, 2.12691072e-03f, 2.24987809e-02f },
    },
    {
      { -2.11497117e-02f, 1.35348206e-02f, -1.03998054e-02f, -9.51727331e-02f, -6.91909669e-03f },
      { -2.60602068e-02f, 3.27459723e-02f, 2.34627351e-02f, -8.82125422e-02f, -3.37804258e-02f },
      { 4.23630774e-02f, 6.43328577e-02f, 1.02772284e-02f, -3.42530981e-02f, -3.92350964e-02f },
      { -3.45825613e-03f, 1.43926032e-02f, -9.70197320e-02f, -2.33701207e-02f, -1.09330840e-01f },
      { 5.75109990e-03f, -4.29039970e-02f, -3.94665226e-02f, 1.20114367e-02f, -2.07621474e-02f },
    },
    {
      { -8.25131964e-03f, -1.30804684e-02f, 3.60451499e-03f, 4.32138927e-02f, -5.06474301e-02f },
      { 1.64057035e-02f, 3.48473638e-02f, 4.37816866e-02f, -2.92383600e-02f, -4.83265296e-02f },
      { 4.09845077e-02f, 5.53812642e-05f, -4.64691408e-02f, 6.79656072e-03f, -2.35290397e-02f },
      { -3.01524848e-02f, 4.21333387e-02f, -1.21770598e-01f, -7.97084123e-02f, -7.42607787e-02f },
      { 2.71564424e-02f, 1.71534065e-02f, -1.31093105e-02f, -5.92108220e-02f, -7.12026954e-02f },
    },
    {
      { -1.43897096e-02f, 6.30491786e-03f, -1.38212740e-02f, -4.52593900e-02f, 1.49423629e-02f },
      { -6.59946799e-02f, -2.02609152e-02f, -6.40173331e-02f, 2.19723452e-02f, -5.73241748e-02f },
      { -3.67478654e-02f, 7.04568485e-03f, -3.87464240e-02f, -7.03713149e-02f, -6.91104308e-02f },
      { -6.13675490e-02f, -7.37093091e-02f, -5.50801270e-02f, -8.20518136e-02f, 1.24398228e-02f },
      { -2.13644188e-02f, 2.26285104e-02f, 4.10827212e-02f, -2.41905507e-02f, -2.24507153e-02f },
    },
    {
      { -4.37028110e-02f, -3.05751041e-02f, 1.09423567e-02f, 2.98986509e-02f, -4.95140366e-02f },
      { 1.46141499e-02f, 1.65821407e-02f, 2.63951663e-02f, -7.14178160e-02f, -3.78680862e-02f },
      { -7.52538890e-02f, -2.52260156e-02f, 5.52059598e-02f, -9.86441784e-03f, 3.13231237e-02f },
      { -1.05186878e-02f, -5.48055768e-02f, -7.91496038e-03f, -2.38925014e-02f, -2.96029262e-02f },
      { 4.73853350e-02f, -3.82246263e-03f, 2.75200550e-02f, 2.46344805e-02f, -4.21248563e-02f },
    },
    {
      { -4.54234518e-02f, 2.72534788e-02f, 8.69456027e-03f, 5.50482832e-02f, 1.63086038e-02f },
      { -8.33250135e-02f, 8.51481862e-04f, -2.08498873e-02f, 6.82615209e-03f, -2.06635837e-02f },
      { -8.82001668e-02f, -8.65776911e-02f, -8.41442645e-02f, -5.85109554e-02f, -6.17819801e-02f },
      { -7.81651959e-02f, -5.10131083e-02f, -4.04770188e-02f, -9.59057268e-03f, -3.69777083e-02f },
      { -5.57043925e-02f, -2.85052508e-02f, 3.44499610e-02f, 3.39114666e-02f, 6.73143775e-04f },
    },
    {
      { -7.62750441e-03f, 1.84109528e-02f, -6.42371327e-02f, -8.21487084e-02f, -8.48524645e-02f },
      { -3.81870344e-02f, -6.12407662e-02f, -1.79214627e-02f, -7.08743185e-02f, -2.76108924e-03f },
      { -2.36364119e-02f, -9.16646868e-02f, -6.42648339e-02f, -5.03081642e-03f, 3.25407237e-02f },
      { -4.34925556e-02f, -6.40188903e-03f, -8.12287182e-02f, -1.23930536e-02f, 6.40709884e-03f },
      { -2.59985048e-02f, -9.99402348e-03f, -5.19385710e-02f, -2.15719342e-02f, -6.83718771e-02f },
    },
    {
      { -7.19004273e-02f, 8.71126074e-03f, 2.29793079e-02f, -6.50386438e-02f, -1.12813115e-02f },
      { 3.77929173e-02f, 4.99453023e-02f, 6.02573808e-03f, -9.53347012e-02f, -6.95096105e-02f },
      { 1.79225150e-02f, -4.43106890e-02f, 9.96256061e-03f, 8.84705782e-03f, 1.31301191e-02f },
      { -4.13331483e-03f, 4.46519960e-04f, -1.46141862e-02f, -7.71151409e-02f, -4.88558263e-02f },
      { 3.29056941e-02f, 4.14938815e-02f, -2.24144924e-02f, -5.65543547e-02f, -4.54011858e-02f },
    },
    {
      { -5.92337921e-02f, -5.44349030e-02f, -1.15263090e-02f, -3.45506147e-02f, -4.49157692e-03f },
      { -3.73419672e-02f, 2.95523498e-02f, -4.06001657e-02f, -9.32908282e-02f, -8.44199210e-03f },
      { 2.77894717e-02f, 1.58942286e-02f, -5.07294051e-02f, 6.25719270e-03f, -1.46586820e-02f },
      { 4.51171249e-02f, -1.75236277e-02f, -6.28379136e-02f, -7.16947317e-02f, -3.93238924e-02f },
      { 4.46966588e-02f, 5.15028238e-02f, 1.59785971e-02f, 4.02434170e-02f, -8.25714022e-02f },
    },
    {
      { -4.14492504e-04f, -2.37875879e-02f, 3.48913893e-02f, 8.98070261e-03f, -2.30452418e-02f },
      { 3.31367627e-02f, 3.86243016e-02f, 3.69749293e-02f, -2.62550358e-02f, 6.43795263e-03f },
      { 8.98688566e-03f, -5.98982573e-02f, -2.56585553e-02f, -1.65933687e-02f, -5.27635142e-02f },
      { -3.51894535e-02f, -4.31251079e-02f, 4.81675602e-02f, 2.21034922e-02f, 3.27302814e-02f },
      { -2.68686228e-02f, -5.32949604e-02f, -6.23346455e-02f, -2.55064443e-02f, 1.03841079e-02f },
    },
    {
      { -4.94170822e-02f, -6.09265678e-02f, 3.52700949e-02f, -9.57088694e-02f, -8.40744153e-02f },
      { -5.69358878e-02f, -8.07609875e-03f, 2.85386909e-02f, -8.16522390e-02f, -6.37776405e-03f },
      { 1.26264626e-02f, -4.35032845e-02f, -8.49065185e-02f, -8.58580247e-02f, -8.88975412e-02f },
      { -2.24065930e-02f, 4.09862921e-02f, -1.70231313e-02f, -1.59392692e-02f, -7.09506497e-02f },
      { -4.71192449e-02f, -1.22214323e-02f, -1.22180851e-02f, -3.89375575e-02f, -5.44953644e-02f },
    },
    {
      { 6.19835546e-03f, -5.42906001e-02f, -7.12160394e-02f, 6.51287846e-03f, 4.34686569e-03f },
      { -6.60805330e-02f, -7.24400906e-03f, -1.08221015e-02f, -4.43355255e-02f, -1.01824082e-01f },
      { -3.11695784e-02f, 1.25239175e-02f, -8.44435915e-02f, -4.65698130e-02f, -2.67566685e-02f },
      { -2.74009127e-02f, -1.34835457e-02f, -4.87308502e-02f, -7.81157389e-02f, -4.14567208e-03f },
      { -8.08026716e-02f, 1.28747951e-02f, -6.49636686e-02f, -8.96119513e-03f, -1.00185722e-01f },
    },
    {
      { -1.52883800e-02f, 3.24106626e-02f, 2.04091556e-02f, 3.17606702e-02f, -3.60073522e-02f },
      { -3.66666578e-02f, 2.35599782e-02f, -1.30066462e-02f, 1.31633794e-02f, -8.99392962e-02f },
      { -5.88282347e-02f, 4.25608363e-03f, -9.53149796e-02f, 1.47178499e-02f, -3.97952422e-02f },
      { 5.02402801e-03f, -6.50130883e-02f, -4.30013053e-02f, -2.05114596e-02f, -6.86429963e-02f },
      { -5.95760383e-02f, -3.27581428e-02f, -9.12560970e-02f, -5.20322882e-02f, -1.34497881e-02f },
    },
    {
      { -1.98781081e-02f, -2.26562694e-02f, -3.76911089e-02f, -6.94881827e-02f, -4.01409715e-02f },
      { -6.04408421e-02f, -2.39492282e-02f, 8.81186686e-03f, -6.20486215e-02f, -7.27672130e-02f },
      { -9.67278425e-03f, -1.75680220e-02f, -4.01612371e-03f, -2.34932378e-02f, -3.53408754e-02f },
      { -7.16872960e-02f, -3.72877233e-02f, -5.46992309e-02f, -1.45354541e-02f, 2.02432219e-02f },
      { -6.03452772e-02f, -1.62365194e-02f, -1.21960863e-02f, 1.18834097e-02f, 6.82158675e-03f },
    },
    {
      { 1.42081687e-02f, 8.15629121e-03f, -4.51796725e-02f, 1.48057975e-02f, 1.18454555e-02f },
      { -9.36190411e-02f, -3.31857055e-02f, -2.99352761e-02f, -3.44330147e-02f, -6.45927805e-03f },
      { -2.81019136e-02f, -8.11534002e-02f, -3.90008837e-02f, -6.66836724e-02f, -4.98109907e-02f },
      { -3.52395996e-02f, -6.45322278e-02f, -7.70068914e-02f, -1.79581773e-02f, -2.36932207e-02f },
      { -9.45908278e-02f, -1.10456562e-02f, -3.24232467e-02f, -7.41337463e-02f, -1.35300457e-02f },
    },
    {
      { -4.09663394e-02f, -7.03567863e-02f, -4.08803076e-02f, -6.59763515e-02f, -4.18924727e-02f },
      { -3.74837220e-02f, -9.11462083e-02f, 1.16690490e-02f, 1.25518152e-02f, -6.67975917e-02f },
      { -6.96647093e-02f, -5.36302514e-02f, -4.66678478e-02f, 3.57785486e-02f, -1.84396096e-02f },
      { -2.42167786e-02f, -6.56461269e-02f, -5.82340658e-02f, 8.79220315e-04f, -1.85272153e-02f },
      { 2.27550026e-02f, 3.89004089e-02f, -7.77021423e-03f, -8.29164609e-02f, -9.69224796e-02f },
    },
    {
      { 1.99757665e-02f, -1.03910759e-01f, 3.21650431e-02f, -9.87109635e-03f, 4.55538444e-02f },
      { -2.52046976e-02f, 7.96273001e-04f, 4.05262783e-02f, -4.86166729e-03f, -5.88585176e-02f },
      { 4.27043475e-02f, 2.29001679e-02f, 3.42341624e-02f, -2.08620597e-02f, -1.84092633e-02f },
      { -5.13041504e-02f, 1.50993904e-02f, 7.83751812e-03f, -6.25672787e-02f, 4.82439995e-02f },
      { 2.74744835e-02f, 4.48601842e-02f, 1.05812863e-01f, 2.55360920e-03f, -6.59472262e-03f },
    },
    {
      { -3.22575420e-02f, -5.71719781e-02f, -3.49160023e-02f, 7.08419783e-03f, 1.73380710e-02f },
      { 2.26178896e-02f, 3.55184115e-02f, -6.52836189e-02f, -5.12032136e-02f, 5.81571134e-03f },
      { -2.96061765e-02f, 3.58854905e-02f, -1.87016781e-02f, 3.42334099e-02f, -8.03153440e-02f },
      { -1.22763123e-02f, 2.20333189e-02f, -1.03877913e-02f, -6.14147037e-02f, -1.64830852e-02f },
      { -3.40513289e-02f, 4.01420183e-02f, 2.15866510e-02f, -2.67331228e-02f, 1.61291324e-02f },
    },
    {
      { -6.16230480e-02f, -6.57181740e-02f, -6.65560067e-02f, -1.07913561e-01f, -6.44488111e-02f },
      { -4.57757972e-02f, 1.96796078e-02f, 3.85165326e-02f, -2.76220404e-02f, -5.59281446e-02f },
      { -1.88114084e-02f, -5.88498786e-02f, -1.23025023e-03f, -5.36249764e-02f, -8.77527222e-02f },
      { 4.24855798e-02f, -4.33044173e-02f, -6.26167208e-02f, -8.49044472e-02f, -9.36737880e-02f },
      { 9.65464208e-03f, 1.54748885e-03f, -5.22846840e-02f, -1.13990083e-02f, -6.97447360e-02f },
    },
    {
      { -2.08763797e-02f, 3.84603292e-02f, -4.53192890e-02f, 1.29939793e-02f, -1.26992939e-02f },
      { -6.53591901e-02f, 1.71678364e-02f, 8.52015335e-03f, 8.19956977e-03f, -6.49308339e-02f },
      { -9.38683525e-02f, -5.26697980e-03f, -8.10868740e-02f, -1.04848936e-01f, -2.98792385e-02f },
      { 1.72457621e-02f, 2.76320819e-02f, -3.79786752e-02f, -3.58099211e-03f, -4.13469300e-02f },
      { -2.80670132e-02f, -2.77462285e-02f, 1.50295505e-02f, 6.07851334e-03f, -6.07888512e-02f },
    },
    {
      { -6.39003590e-02f, 5.00454940e-02f, -1.40142720e-02f, -2.85709687e-02f, -4.97163571e-02f },
      { 2.44857445e-02f, -1.21023422e-02f, 2.83898972e-02f, -9.07235518e-02f, 2.89964173e-02f },
      { -3.38438363e-03f, 1.95638798e-02f, -7.02314004e-02f, -5.23722395e-02f, -6.62899986e-02f },
      { 4.13081311e-02f, 3.59924287e-02f, -1.14021134e-02f, 2.56679785e-02f, -6.45659044e-02f },
      { -3.19294333e-02f, -9.78404656e-03f, -7.51302093e-02f, -1.31397927e-02f, -7.83970729e-02f },
    },
    {
      { -5.32572456e-02f, 3.64468731e-02f, -4.14597280e-02f, -3.89354713e-02f, -4.61783484e-02f },
      { -6.12784140e-02f, -8.31626505e-02f, -5.61956607e-04f, 1.63385253e-02f, -2.15157513e-02f },
      { -2.98614185e-02f, -8.30525011e-02f, -4.73768711e-02f, -8.62962753e-02f, -6.96361959e-02f },
      { -4.48613577e-02f, -6.08023740e-02f, 1.61181204e-02f, -2.89760195e-02f, 9.40953847e-03f },
      { -2.21551079e-02f, -7.58373290e-02f, -7.98924118e-02f, -3.45648527e-02f, -8.82495642e-02f },
    },
    {
      { 2.36625541e-02f, 3.21887769e-02f, -5.32566849e-03f, 9.87617299e-03f, -3.73559818e-02f },
      { 2.48292671e-03f, 2.82055605e-03f, -2.87892111e-02f, -5.73350675e-02f, -7.04574492e-03f },
      { -4.69352603e-02f, -9.31476429e-02f, 1.16076358e-02f, 4.23823148e-02f, 4.39055683e-03f },
      { 2.10196152e-02f, 1.67724155e-02f, -1.35082044e-02f, -2.93332692e-02f, -1.53286895e-02f },
      { -5.26291244e-02f, 2.20328290e-02f, -7.50831217e-02f, 2.84545850e-02f, 3.44828218e-02f },
    },
    {
      { -1.12429023e-01f, -1.05336688e-01f, -6.80577382e-02f, -6.41463250e-02f, -1.95476990e-02f },
      { -4.99153063e-02f, -4.96882461e-02f, -1.09509289e-01f, 4.30944795e-03f, 1.86697952e-02f },
      { -3.72323045e-03f, -3.78051735e-02f, -1.48467198e-02f, -6.70968294e-02f, -7.82848373e-02f },
      { -5.65452911e-02f, -5.15241548e-02f, -9.04462412e-02f, 1.29886037e-02f, -9.72312614e-02f },
      { -4.77767773e-02f, 4.04075794e-02f, -1.70930009e-02f, 2.84499899e-02f, 3.67303402e-03f },
    },
    {
      { -6.56263083e-02f, -1.18191703e-03f, 3.91307212e-02f, -2.28799731e-02f, -1.90516431e-02f },
      { 3.96397375e-02f, 7.40271946e-03f, -6.01706803e-02f, 2.38340292e-02f, -1.06563792e-02f },
      { -1.09369699e-02f, -1.49137089e-02f, -5.19908480e-02f, 2.88394261e-02f, -1.93448924e-02f },
      { 4.38217334e-02f, 1.94951819e-04f, 1.83896590e-02f, -2.08029039e-02f, -4.70749661e-02f },
      { 6.02388717e-02f, 3.72901745e-02f, 7.13228201e-03f, -2.13118736e-02f, -5.41177914e-02f },
    },
    {
      { -1.03391357e-01f, -4.98453416e-02f, 2.72655841e-02f, -5.08058518e-02f, -5.64617291e-02f },
      { -3.76011170e-02f, -1.93166565e-02f, -4.26809955e-03f, 3.26240920e-02f, -6.95959330e-02f },
      { -3.72889973e-02f, 1.01152537e-02f, -4.07752639e-04f, -3.51307616e-02f, -6.55234680e-02f },
      { 2.92404201e-02f, 2.70926747e-02f, -4.15325575e-02f, -4.98433262e-02f, -1.14164234e-03f },
      { -1.20080877e-02f, 4.28896174e-02f, 4.20826301e-02f, -1.10514136e-02f, -4.04918741e-04f },
    },
    {
      { -3.69630083e-02f, -3.04910261e-03f, 3.69551629e-02f, 2.12659631e-02f, -3.43366265e-02f },
      { -4.58050072e-02f, -1.60755068e-02f, -1.64715871e-02f, -1.56011516e-02f, -9.09115225e-02f },
      { -5.46306670e-02f, 5.31060211e-02f, 2.82209236e-02f, -2.42939442e-02f, -5.93000129e-02f },
      { 6.43532276e-02f, 7.02471659e-02f, -3.03529706e-02f, -8.80661979e-02f, -8.08857754e-02f },
      { -1.73810944e-02f, 4.37974110e-02f, -4.70121903e-03f, -5.80403879e-02f, -4.18292768e-02f },
    },
  },
  {
    {
      { -1.45457283e-01f, -5.85752614e-02f, 1.86584339e-01f, 8.34755003e-02f, 1.01395980e-01f },
      { -2.02727057e-02f, -1.89421713e-01f, 1.27223909e-01f, 2.74731010e-01f, 1.43652067e-01f },
      { -3.23901832e-01f, -3.41879964e-01f, -1.55320615e-01f, 4.06170487e-02f, 2.34866247e-01f },
      { -2.59653598e-01f, -3.06268781e-01f, -3.66546959e-01f, -9.32182968e-02f, 2.45997891e-01f },
      { 2.77017197e-03f, -1.64516494e-02f, -1.30126134e-01f, -1.37599960e-01f, -2.06115730e-02f },
    },
    {
      { 5.21570295e-02f, 1.71817958e-01f, 1.03159651e-01f, -7.13783056e-02f, 1.11848898e-02f },
      { 1.62739366e-01f, 7.55383447e-02f, 5.95873892e-02f, 1.26389772e-01f, -7.44532570e-02f },
      { 1.01129301e-01f, -2.18927875e-01f, -4.22829986e-02f, 1.58548683e-01f, -5.92411421e-02f },
      { -1.59587562e-01f, -3.19538504e-01f, -5.88977188e-02f, -5.69227748e-02f, 1.13951996e-01f },
      { -7.54395723e-02f, -7.41150230e-02f, -1.07746795e-01f, -3.64243209e-01f, -1.11464299e-01f },
    },
    {
      { 2.75240660e-01f, 2.91104436e-01f, 1.98801041e-01f, 4.76139858e-02f, -2.12599877e-02f },
      { 2.97155380e-01f, 1.32073358e-01f, 2.85340659e-03f, -4.92676161e-02f, -2.31080160e-01f },
      { 2.17863187e-01f, 1.24063089e-01f, 1.35406211e-01f, -1.05939262e-01f, -2.47190312e-01f },
      { 1.35841876e-01f, 1.03569105e-01f, 1.90191135e-01f, -2.69251674e-01f, -4.24523741e-01f },
      { 2.17735380e-01f, 2.45904684e-01f, 1.30253732e-01f, 5.18345386e-02f, -1.77654430e-01f },
    },
    {
      { -1.51659176e-01f, -1.29916877e-01f, -1.93943471e-01f, -1.14873186e-01f, -2.34474614e-02f },
      { -1.74348265e-01f, -5.75418472e-02f, -1.63983405e-01f, -1.25713095e-01f, 5.06663658e-02f },
      { -1.75742358e-01f, -1.18002412e-03f, -1.03855520e-01f, -8.27564374e-02f, 7.71527216e-02f },
      { -1.37411654e-01f, -2.34141089e-02f, -9.97358933e-02f, 5.19816950e-02f, 1.88690692e-01f },
      { -1.52510270e-01f, -2.25696355e-01f, -1.17901631e-01f, 1.56971037e-01f, 2.07099728e-02f },
    },
    {
      { -9.54217538e-02f, -1.60367563e-01f, -9.34071615e-02f, 1.26025945e-01f, 3.72352004e-02f },
      { -2.48210713e-01f, -1.93857059e-01f, -2.35770643e-01f, 1.18011810e-01f, 2.24092767e-01f },
      { -2.53284872e-01f, -5.71538061e-02f, -2.76725683e-02f, 2.96388939e-02f, 2.49613270e-01f },
      { -1.76991761e-01f, -6.73877150e-02f, 5.38797723e-03f, 7.25236237e-02f, 2.68972963e-01f },
      { 2.23745927e-02f, -2.17829924e-02f, 1.03901504e-02f, 1.12862967e-01f, 2.51346499e-01f },
    },
    {
      { 1.79939643e-01f, 2.13106573e-01f, 1.24736004e-01f, 1.15485586e-01f, -8.81868154e-02f },
      { 3.30337919e-02f, 2.86925018e-01f, 5.09794429e-02f, -7.33006299e-02f, -7.16847330e-02f },
      { 1.87761392e-02f, 2.49756172e-01f, 1.22142814e-01f, -2.89872169e-01f, -2.14741662e-01f },
      { 5.81178665e-02f, 1.94732428e-01f, 1.48206338e-01f, -1.30353674e-01f, -1.46267340e-01f },
      { 3.59661765e-02f, 1.10905461e-01f, 3.06732263e-02f, 1.86134130e-01f, 3.28313336e-02f },
    },
    {
      { -4.83207963e-02f, -7.23320693e-02f, -2.44971991e-01f, -2.27868766e-01f, -5.00560291e-02f },
      { -5.26805520e-02f, -2.21983299e-01f, 6.26591817e-02f, -1.23874381e-01f, -2.89193336e-02f },
      { -9.59280208e-02f, -5.47050714e-01f, 6.48924783e-02f, 4.14374359e-02f, 2.37274426e-03f },
      { -1.84756041e-01f, -4.38231230e-01f, 1.00481339e-01f, 1.19213194e-01f, 2.34778941e-01f },
      { -3.99060607e-01f, -4.06231314e-01f, -2.89529145e-01f, -1.36146143e-01f, 1.83936805e-01f },
    },
    {
      { 1.04383975e-01f, -1.77362766e-02f, 1.00684538e-02f, -9.86674204e-02f, -8.20012242e-02f },
      { -1.30107291e-02f, -2.20046699e-01f, 4.03780341e-02f, 3.22281010e-02f, -1.55306548e-01f },
      { -1.43536869e-02f, -3.00207466e-01f, 2.93658655e-02f, 6.52976334e-02f, -1.58239171e-01f },
      { -2.73359716e-02f, -1.33059204e-01f, 5.02137206e-02f, -9.60621238e-03f, -8.49954113e-02f },
      { -2.10280731e-01f, -4.91347946e-02f, -4.01967131e-02f, -1.53142586e-01f, -7.89632555e-03f },
    },
    {
      { -2.23416165e-02f, -2.22010841e-03f, 7.44839087e-02f, 8.70168358e-02f, -6.84096739e-02f },
      { 2.23364636e-01f, 2.97314338e-02f, 1.09363552e-02f, 1.87946171e-01f, 4.78099771e-02f },
      { 1.23554347e-02f, -1.79999098e-01f, -2.14686930e-01f, 1.35401756e-01f, 7.71565288e-02f },
      { -3.50173593e-01f, -2.42191002e-01f, -4.73740816e-01f, -2.18638927e-01f, 1.74164310e-01f },
      { -5.21983393e-02f, -1.06745316e-02f, -4.72958565e-01f, -6.91212595e-01f, -2.54626542e-01f },
    },
    {
      { 1.11225992e-01f, 2.00168088e-01f, 1.27793670e-01f, 7.22576305e-02f, -4.81153354e-02f },
      { 2.16992237e-02f, 1.84106305e-01f, 8.24284852e-02f, -1.21681519e-01f, -9.23852772e-02f },
      { -1.13680810e-02f, 1.90823972e-01f, 1.27165094e-01f, -2.75205404e-01f, -2.03867808e-01f },
      { 5.95903583e-02f, 5.80096953e-02f, 5.73222488e-02f, -3.95481624e-02f, -1.04398377e-01f },
      { 6.33309558e-02f, -1.18470825e-01f, -6.66299015e-02f, -6.07662797e-02f, -9.39689353e-02f },
    },
    {
      { 9.98776872e-03f, 1.02682240e-01f, -2.65564993e-02f, 6.77376240e-03f, 8.17379728e-02f },
      { -1.99481860e-01f, -5.49121611e-02f, -1.81104019e-01f, -1.32058278e-01f, -1.38763105e-02f },
      { -1.40588552e-01f, -4.55398895e-02f, 5.20840054e-04f, -1.09261982e-01f, 5.89890108e-02f },
      { -6.27666013e-03f, 3.13443458e-03f, 8.59836191e-02f, 7.18785822e-02f, -5.20040058e-02f },
      { -3.77763249e-02f, 1.70498844e-02f, 6.99282661e-02f, 7.91850537e-02f, 1.32201314e-01f },
    },
    {
      { -2.22836323e-02f, 9.46530402e-02f, 2.04891875e-01f, 1.37274668e-01f, 5.49029633e-02f },
      { 1.35484442e-01f, 2.14434385e-01f, 2.61426419e-01f, 4.13128063e-02f, -7.42032677e-02f },
      { 1.23210669e-01f, 1.16810657e-01f, 9.99694690e-02f, -5.11907600e-02f, -1.73748672e-01f },
      { 8.24114233e-02f, 3.91747393e-02f, -9.19363201e-02f, -7.16655180e-02f, 3.25204805e-02f },
      { 1.03430666e-01f, 4.80935648e-02f, -6.24520034e-02f, -2.13320985e-01f, -1.79448009e-01f },
    },
    {
      { 7.34521970e-02f, 1.22212753e-01f, 1.98906019e-01f, 3.48786004e-02f, -1.81513447e-02f },
      { 1.76698968e-01f, 2.76150033e-02f, 1.27931595e-01f, 1.70677811e-01f, -2.13338375e-01f },
      { 1.68365195e-01f, 7.41140626e-04f, 1.45770296e-01f, 1.03090569e-01f, -1.02956444e-01f },
      { 4.87226341e-03f, -6.21437281e-03f, -1.33667663e-01f, -1.42148912e-01f, 7.73639977e-02f },
      { 7.46532232e-02f, 3.94757316e-02f, -1.19962484e-01f, -3.36248785e-01f, -1.17523313e-01f },
    },
    {
      { 2.77813175e-03f, 2.73938049e-02f, 6.23042211e-02f, -8.04191513e-04f, 2.02957820e-02f },
      { 5.88451177e-02f, -1.12032173e-02f, 1.57502070e-01f, 6.57886639e-02f, -9.36610848e-02f },
      { -2.49439175e-03f, -2.90077835e-01f, -3.15412842e-02f, 7.36554936e-02f, -1.03517532e-01f },
      { -1.54833004e-01f, -3.21594000e-01f, -9.46251079e-02f, 9.06823669e-03f, 1.01257794e-01f },
      { -8.13480094e-03f, -2.10506078e-02f, -1.30911022e-01f, -1.78482413e-01f, -1.01926208e-01f },
    },
    {
      { -3.46806087e-02f, -1.83980260e-02f, 2.50368863e-02f, 2.61675473e-02f, -2.28640158e-02f },
      { 1.89121198e-02f, -1.80206932e-02f, 3.06847245e-02f, 3.60188186e-02f, -2.50133350e-02f },
      { 1.24754114e-02f, 4.19688933e-02f, -1.61708388e-02f, 5.95103875e-02f, -4.20239046e-02f },
      { 9.66662448e-03f, 2.74457107e-03f, 6.50322363e-02f, 4.37905714e-02f, 5.27091697e-02f },
      { 8.94878618e-03f, 3.83392572e-02f, 5.09057865e-02f, -3.34005207e-02f, 6.52434258e-03f },
    },
    {
      { -7.60589540e-02f, -6.14799820e-02f, 1.13634234e-02f, -2.13549268e-02f, -1.60589758e-02f },
      { -7.44166300e-02f, 2.68401038e-02f, 5.76735623e-02f, -1.85202975e-02f, 7.63905495e-02f },
      { 8.46654177e-03f, -4.10740525e-02f, 8.22788477e-02f, 3.61474715e-02f, 1.69732254e-02f },
      { -1.71691831e-02f, -1.75495856e-02f, 4.42245863e-02f, 4.54777665e-02f, 8.42846185e-02f },
      { -9.35358331e-02f, -2.54844390e-02f, 9.26579908e-03f, -4.90683317e-02f, 1.04561053e-01f },
    },
    {
      { -7.16849789e-02f, -9.05564278e-02f, 2.32784040e-02f, 5.65813184e-02f, 1.23447888e-01f },
      { -2.17127129e-01f, -1.63550407e-01f, -9.83701199e-02f, 1.30248800e-01f, 1.04188561e-01f },
      { -7.70257488e-02f, -9.05574933e-02f, -6.93670362e-02f, 1.01060554e-01f, 1.53809711e-01f },
      { -1.51868969e-01f, -1.18343532e-01f, 9.95688490e-04f, 7.16658458e-02f, 2.60288101e-02f },
      { -1.23006329e-01f, -3.09947543e-02f, -3.19403969e-02f, 2.55973102e-03f, 5.18049300e-02f },
    },
    {
      { -6.30123764e-02f, -6.03305958e-02f, 5.49951904e-02f, -8.49628448e-02f, -7.39969835e-02f },
      { -1.25788689e-01f, -1.01945549e-01f, -2.33502034e-02f, 3.16128805e-02f, -2.84641031e-02f },
      { -4.19801660e-02f, -4.92765009e-02f, 8.36126059e-02f, -5.90746589e-02f, -9.73290130e-02f },
      { -1.03823915e-01f, 1.25647420e-02f, 1.30183131e-01f, -1.91369578e-02f, -2.39488650e-02f },
      { -1.27795383e-01f, 1.35111902e-02f, -4.68732938e-02f, -3.20282727e-02f, 5.46957813e-02f },
    },
    {
      { -1.01482689e-01f, -7.57749602e-02f, -2.43259557e-02f, 8.32581669e-02f, 1.06912330e-01f },
      { -3.66193950e-01f, -1.79511011e-01f, -1.43767685e-01f, -6.21629646e-03f, 7.56527483e-02f },
      { -1.74905792e-01f, -1.08369872e-01f, -3.17769684e-02f, 5.76380603e-02f, 5.05943745e-02f },
      { -6.10030964e-02f, -1.06579378e-01f, -5.31244725e-02f, 3.97815881e-03f, -8.47569779e-02f },
      { -1.42490998e-01f, 3.44677269e-02f, 2.73644794e-02f, 1.00098096e-01f, 2.56886743e-02f },
    },
    {
      { -7.64663666e-02f, -7.28759989e-02f, -3.12268566e-02f, 1.08875178e-01f, 7.42744505e-02f },
      { -4.80630323e-02f, -1.63141742e-01f, -5.06559387e-02f, 1.75087243e-01f, 1.96365684e-01f },
      { -1.90245345e-01f, -1.72195837e-01f, -1.07386552e-01f, 6.06847629e-02f, 2.39625916e-01f },
      { -2.06571057e-01f, -1.43830463e-01f, -2.01864332e-01f, 5.49446978e-02f, 2.20859498e-01f },
      { -6.32408038e-02f, -9.62404832e-02f, -1.06455170e-01f, 9.71781313e-02f, 1.37296945e-01f },
    },
    {
      { -7.43105169e-03f, 3.88886817e-02f, 3.53008881e-02f, -5.22493683e-02f, -2.35774685e-02f },
      { 4.60495688e-02f, 1.08261630e-01f, 1.57998055e-01f, 2.93254443e-02f, -6.51227012e-02f },
      { -8.84606130e-03f, 5.85565530e-02f, 1.32518575e-01f, -3.36359106e-02f, -5.13601936e-02f },
      { -4.86702323e-02f, -2.30729878e-02f, -3.01585980e-02f, 8.62365887e-02f, 5.60043715e-02f },
      { -6.35883063e-02f, -1.38135046e-01f, -2.12800384e-01f, -3.43921743e-02f, 3.14026512e-02f },
    },
    {
      { 1.34457216e-01f, 1.03839375e-01f, 1.26758486e-01f, -4.89366874e-02f, -1.33001387e-01f },
      { -6.53805062e-02f, -1.34474769e-01f, 2.80929804e-02f, -2.37655863e-01f, -2.70374149e-01f },
      { -1.16857894e-01f, -3.93961966e-02f, 2.43490450e-02f, -1.79721802e-01f, -1.00996815e-01f },
      { -2.25465223e-02f, 8.14052895e-02f, 5.47003821e-02f, -1.25765711e-01f, -1.75302431e-01f },
      { -8.52615610e-02f, -3.89025137e-02f, -8.67613330e-02f, -1.00850306e-01f, -1.75759777e-01f },
    },
    {
      { 1.84960961e-01f, 2.81409502e-01f, 3.38579476e-01f, 3.15135628e-01f, 1.56259730e-01f },
      { 2.91395932e-01f, 3.64282459e-01f, 3.29233229e-01f, 1.52111918e-01f, 3.42473313e-02f },
      { 2.84446269e-01f, 3.74745548e-01f, 2.92606086e-01f, 8.16123933e-02f, -1.43880427e-01f },
      { 2.18104631e-01f, 3.29581201e-01f, 1.52670622e-01f, 1.84457880e-02f, -1.22350797e-01f },
      { 2.77796715e-01f, 3.08985621e-01f, 1.92935750e-01f, 9.30266902e-02f, -3.06741204e-02f },
    },
    {
      { -5.88232558e-03f, 2.87238532e-03f, 3.66003662e-02f, -5.54848351e-02f, 3.24417427e-02f },
      { 1.49531765e-02f, -5.47775999e-02f, 1.16999760e-01f, 2.81004813e-02f, -8.47266316e-02f },
      { -6.80227503e-02f, -4.04320471e-02f, 9.34020877e-02f, 4.30708863e-02f, -7.06863105e-02f },
      { 6.54855045e-03f, -3.62113789e-02f, 1.14407362e-02f, -4.03064042e-02f, 8.97166133e-02f },
      { -1.12715445e-01f, -5.05828634e-02f, -5.14747016e-02f, -1.06807016e-01f, -2.03324426e-02f },
    },
    {
      { 3.47514488e-02f, 1.40985072e-01f, 2.50696652e-02f, 9.09661055e-02f, 9.08274204e-02f },
      { -3.51630471e-04f, -5.86025305e-02f, -2.76148114e-02f, -6.62089810e-02f, -4.89388965e-03f },
      { -8.07951484e-03f, -3.11223622e-02f, 8.93916115e-02f, -9.66019481e-02f, -3.05009186e-02f },
      { 6.37675673e-02f, -5.73610328e-02f, -3.13587859e-02f, -1.72958355e-02f, -6.31796569e-03f },
      { -6.65677860e-02f, -1.28242187e-02f, 1.18538678e-01f, 7.58009404e-02f, 6.05854020e-02f },
    },
    {
      { 1.25757635e-01f, 1.30141154e-01f, 8.46710578e-02f, 1.91369690e-02f, 2.08838418e-01f },
      { 6.64872676e-02f, -7.87839070e-02f, 6.99078888e-02f, 8.00851882e-02f, 1.30406156e-01f },
      { 2.44052708e-01f, 4.00347300e-02f, 1.48075730e-01f, 1.47304237e-01f, 2.53120605e-02f },
      { 1.35122210e-01f, 2.06544083e-02f, 1.80372611e-01f, 4.94041555e-02f, 1.91499311e-02f },
      { -3.03173400e-02f, 1.29903093e-01f, 1.59820080e-01f, 1.39186546e-01f, 1.86544821e-01f },
    },
    {
      { -1.43778577e-01f, -1.06803045e-01f, -6.69705346e-02f, 4.48566191e-02f, 1.28194794e-01f },
      { -2.76495218e-01f, -1.80758134e-01f, -1.29578397e-01f, 8.57316330e-02f, 1.68552160e-01f },
      { -1.90995067e-01f, -7.01086689e-03f, -3.04879975e-02f, 6.70635924e-02f, 2.00026348e-01f },
      { -1.56072155e-01f, -2.02756654e-02f, -8.19923505e-02f, 5.98769523e-02f, 3.49940173e-02f },
      { -6.68335110e-02f, -9.98483878e-03f, -7.20320046e-02f, -1.08052297e-02f, 1.14981510e-01f },
    },
    {
      { 2.50387162e-01f, 1.77958578e-01f, 2.92081237e-01f, 1.15973294e-01f, -2.77378615e-02f },
      { 1.97146103e-01f, 2.93157697e-01f, 1.60712004e-01f, 6.78188121e-03f, -1.57467112e-01f },
      { 2.08602861e-01f, 1.99936330e-01f, 1.99751988e-01f, -2.00494125e-01f, -2.33245328e-01f },
      { 1.75891474e-01f, 2.51952678e-01f, 1.23097554e-01f, -1.53039515e-01f, -1.82511851e-01f },
      { 1.86963290e-01f, 1.21023349e-01f, 5.18178977e-02f, 3.47945616e-02f, -9.18320566e-02f },
    },
    {
      { -2.26548538e-02f, 3.29633942e-03f, 8.18003193e-02f, -1.62225356e-03f, -6.55683205e-02f },
      { 9.18696541e-03f, 3.32328305e-02f, 1.10916205e-01f, 6.32060096e-02f, -2.94245537e-02f },
      { -7.15720281e-02f, 4.84445598e-03f, -3.26384753e-02f, -1.50880516e-02f, 6.44008070e-02f },
      { -2.02066973e-01f, -2.01265037e-01f, -2.11019814e-01f, -5.57694212e-03f, 1.50307730e-01f },
      { -9.57636461e-02f, -1.94705024e-01f, -3.10187817e-01f, -1.28866658e-01f, 3.60216834e-02f },
    },
    {
      { -1.35875046e-02f, -2.29079016e-02f, 4.11826856e-02f, 2.99175195e-02f, -3.88565883e-02f },
      { -4.48433158e-04f, 3.66984271e-02f, 9.82622150e-04f, -3.49797867e-02f, -2.07128115e-02f },
      { -7.93116982e-04f, 1.08336629e-02f, -3.25665362e-02f, 2.47925753e-03f, 2.64706202e-02f },
      { 3.53754237e-02f, -4.26009968e-02f, 6.32605106e-02f, 1.28987608e-02f, -2.91993879e-02f },
      { -8.97683483e-03f, 2.08264757e-02f, 3.71685103e-02f, 4.36980389e-02f, -3.05271447e-02f },
    },
    {
      { -9.48968977e-02f, -2.06064824e-02f, 1.36520192e-01f, 3.51333455e-03f, 6.99250624e-02f },
      { 1.79065913e-02f, -1.94266513e-02f, 8.73124227e-02f, 9.96598899e-02f, -6.89541083e-03f },
      { -1.08206071e-01f, -2.34984919e-01f, -1.12933248e-01f, 1.62786305e-01f, 8.60867500e-02f },
      { -2.94201672e-01f, -4.45529997e-01f, -1.44759178e-01f, 9.78027880e-02f, 1.64998546e-01f },
      { -3.01389471e-02f, -4.68917526e-02f, -1.73440605e-01f, -1.12402350e-01f, 1.01740576e-01f },
    },
    {
      { -1.57549098e-01f, -1.07131302e-01f, -9.51017886e-02f, -1.28049761e-01f, -9.50890109e-02f },
      { -1.75481796e-01f, -4.13846970e-01f, -6.29647747e-02f, 2.33961344e-02f, 4.28394899e-02f },
      { -7.70498514e-02f, -4.61097598e-01f, -1.09368362e-01f, 2.45500743e-01f, 9.89835113e-02f },
      { -1.45058617e-01f, -4.61363912e-01f, -4.15780842e-02f, 8.15608203e-02f, 1.58500642e-01f },
      { -3.85178655e-01f, -2.56920815e-01f, -1.01540819e-01f, -1.73084587e-01f, 1.47046134e-01f },
    },
  },
  {
    {
      { 2.03428745e-01f, 1.12341918e-01f, 1.33753315e-01f, 4.91471663e-02f, 3.42156552e-02f },
      { 4.09897566e-02f, 8.06229189e-02f, -8.62007439e-02f, -1.29462371e-03f, 5.32925203e-02f },
      { -1.71838135e-01f, 6.28939122e-02f, -9.12074521e-02f, -2.17748389e-01f, -2.27882788e-02f },
      { -2.98605829e-01f, -3.43327643e-03f, -3.67685407e-02f, -5.32436073e-02f, -2.12787032e-01f },
      { -1.09822825e-01f, -2.94295675e-03f, -4.54397090e-02f, 1.04988880e-01f, -1.58648923e-01f },
    },
    {
      { 1.33579075e-01f, -4.63156402e-02f, -5.24494611e-02f, 2.54207030e-02f, -2.88252123e-02f },
      { 1.01081043e-01f, 1.15659364e-01f, -9.96040180e-02f, -5.73331229e-02f, 3.34740020e-02f },
      { 8.26895088e-02f, 2.51903027e-01f, 6.72223121e-02f, -2.68059552e-01f, 1.16349794e-01f },
      { -8.57328549e-02f, 2.58545578e-01f, -1.67833187e-03f, -1.41293570e-01f, -3.27883624e-02f },
      { -6.43711686e-02f, 1.45681560e-01f, -1.35533199e-01f, -8.76437351e-02f, 3.51160876e-02f },
    },
    {
      { -7.88340624e-03f, 6.68228418e-02f, 1.06038421e-01f, 8.09718296e-03f, -6.74386546e-02f },
      { 5.34222089e-02f, 3.02346200e-01f, 2.13836327e-01f, -5.12653291e-02f, -9.85527784e-02f },
      { 3.12354565e-02f, 3.35172296e-01f, 1.61092356e-01f, -1.22958049e-01f, -1.02961874e-02f },
      { -1.22880459e-01f, -1.01642427e-03f, -2.71167606e-02f, -4.02488597e-02f, 5.56834601e-02f },
      { 6.39613718e-02f, -3.86897437e-02f, -1.92324549e-01f, -1.51361555e-01f, -1.85752176e-02f },
    },
    {
      { -4.69312221e-02f, -1.26706228e-01f, -9.52588841e-02f, -4.61089276e-02f, 1.24490261e-01f },
      { -7.96996951e-02f, -2.44952261e-01f, -1.53477564e-01f, 2.62220297e-02f, 2.24307068e-02f },
      { 7.62435496e-02f, -3.55433971e-01f, 2.53687482e-02f, 2.15472460e-01f, 8.91162753e-02f },
      { 3.71926688e-02f, -1.97118372e-01f, 9.85838100e-02f, 1.37222037e-01f, 5.31600341e-02f },
      { 9.19348150e-02f, -1.05328768e-01f, 1.70676649e-01f, 9.62177739e-02f, -1.26307295e-03f },
    },
    {
      { 1.83047412e-03f, -2.77525391e-02f, -7.27970451e-02f, -3.11215371e-02f, 6.39156923e-02f },
      { -1.17042875e-02f, -1.92973375e-01f, -1.09106310e-01f, -9.72408801e-02f, -8.89756344e-03f },
      { -3.71836014e-02f, -3.44482005e-01f, -1.80972055e-01f, -5.36014475e-02f, -1.66997854e-02f },
      { 1.39992684e-01f, -2.27603287e-01f, -1.97937608e-01f, -4.29188982e-02f, 7.35654384e-02f },
      { 1.29425347e-01f, 4.56639938e-02f, -1.81099977e-02f, 9.93956625e-02f, 6.96018040e-02f },
    },
    {
      { 5.53544015e-02f, 2.08151601e-02f, 5.47971837e-02f, 4.83376160e-02f, 3.47721875e-02f },
      { -8.26980162e-04f, 7.24235326e-02f, 2.28452399e-01f, 1.21126883e-01f, 6.35950044e-02f },
      { -1.36585981e-01f, -1.99721739e-01f, 1.37751490e-01f, 2.60839343e-01f, 3.51566672e-02f },
      { 8.45030323e-02f, -2.50374943e-01f, -3.04798782e-02f, 1.89113230e-01f, -1.57400947e-02f },
      { -1.15788719e-02f, -1.43196315e-01f, -1.17914721e-01f, -6.08586296e-02f, -2.05572322e-01f },
    },
    {
      { -7.31502101e-02f, -2.90878769e-02f, -2.50249237e-01f, -1.14305206e-01f, -5.11404425e-02f },
      { -3.82735021e-02f, 1.32914945e-01f, -1.52889833e-01f, -3.23536783e-01f, -9.76830050e-02f },
      { -1.54739758e-02f, 1.48234665e-01f, -4.18925256e-01f, -3.10369551e-01f, 3.09341587e-02f },
      { -5.65137938e-02f, 2.92713732e-01f, -5.86136103e-01f, -1.15850464e-01f, 1.94193125e-01f },
      { -3.51713188e-02f, 9.51695889e-02f, -3.05043161e-01f, 8.82070884e-02f, 2.60649055e-01f },
    },
    {
      { -4.86894138e-02f, -6.52003884e-02f, 8.78498610e-03f, -5.35088126e-03f, -2.42316239e-02f },
      { -5.22584729e-02f, 4.43491265e-02f, -1.27540668e-02f, -1.17096722e-01f, -1.89048409e-01f },
      { 4.04632045e-03f, 1.29309744e-01f, -1.20601609e-01f, -2.37274900e-01f, -4.06876728e-02f },
      { -1.19981118e-01f, 1.05444521e-01f, -2.01240346e-01f, -1.40310079e-01f, 2.15165645e-01f },
      { -7.57193044e-02f, 6.15524836e-02f, -1.32273600e-01f, -1.10431731e-01f, 5.79314008e-02f },
    },
    {
      { 3.67185682e-01f, 1.56268746e-01f, 3.54320034e-02f, 1.91380195e-02f, -2.59773694e-02f },
      { 1.63631454e-01f, 2.47038543e-01f, -2.11201273e-02f, -1.02637708e-01f, -9.40280780e-02f },
      { -5.10768332e-02f, 1.68285877e-01f, 1.39205426e-01f, -2.82672524e-01f, 8.48163664e-02f },
      { -3.25301886e-01f, 1.31842107e-01f, 1.81656063e-01f, -2.05849484e-01f, -1.21753827e-01f },
      { -1.18895685e-02f, -4.16261442e-02f, 5.15805325e-03f, -4.74279895e-02f, -9.39983577e-02f },
    },
    {
      { -2.88009085e-02f, -1.99857317e-02f, -6.86834902e-02f, 3.70451920e-02f, 8.09728205e-02f },
      { -6.11262210e-02f, -5.40257096e-02f, 5.99168912e-02f, 1.87048793e-01f, 5.98000959e-02f },
      { 5.83461523e-02f, -1.60781547e-01f, 1.88189000e-01f, 3.16054165e-01f, 5.44064157e-02f },
      { 6.34724945e-02f, -1.18774332e-01f, -1.10366168e-02f, 1.61817893e-01f, -2.72903964e-02f },
      { 7.99596123e-03f, -6.66651269e-03f, 2.23741084e-02f, 5.75814582e-02f, -3.88578549e-02f },
    },
    {
      { -1.01303555e-01f, -1.67625286e-02f, 4.27982956e-02f, -7.23743811e-02f, 4.44412380e-02f },
      { -1.67149723e-01f, 2.40356959e-02f, 3.69480215e-02f, 2.43008230e-03f, -1.53597727e-01f },
      { -1.28769711e-01f, -3.02669615e-01f, -2.30107725e-01f, -1.18546650e-01f, -1.85973436e-01f },
      { 1.55094162e-01f, -1.81622833e-01f, -3.78311574e-01f, -2.25224271e-01f, -6.64484128e-02f },
      { 1.73858367e-02f, -6.96036741e-02f, -4.26138155e-02f, -1.59561262e-01f, -1.51238842e-02f },
    },
    {
      { 9.97225940e-02f, 5.26478365e-02f, 7.29407221e-02f, -2.56174188e-02f, 3.33072767e-02f },
      { 9.12570357e-02f, -4.02696915e-02f, -1.88613292e-02f, 1.27918050e-01f, 1.34502769e-01f },
      { -1.04324399e-02f, -3.60311475e-03f, 6.91321418e-02f, 1.98579699e-01f, 2.09528193e-01f },
      { -1.85325816e-02f, 2.48301048e-02f, 1.07716411e-01f, 1.79847017e-01f, 4.38075699e-02f },
      { 1.94865800e-02f, -2.36535463e-02f, 1.61928520e-01f, 9.43756923e-02f, -5.77023365e-02f },
    },
    {
      { 2.49350630e-02f, -6.15779636e-03f, 1.91355981e-02f, -1.94659997e-02f, -1.34729117e-01f },
      { 1.05750695e-01f, 1.32115215e-01f, 4.45548110e-02f, -1.28456756e-01f, 3.89277972e-02f },
      { 8.44215751e-02f, 2.25699529e-01f, 3.62041071e-02f, -6.55809939e-02f, 1.67726547e-01f },
      { -6.80484921e-02f, 1.50667354e-01f, 9.38765407e-02f, -8.39175074e-04f, 2.69773193e-02f },
      { 4.75064851e-02f, -5.88589311e-02f, -7.02714100e-02f, 7.81340003e-02f, 2.25516856e-02f },
    },
    {
      { 1.01466641e-01f, -8.46084859e-03f, -5.01668826e-02f, -1.57226279e-01f, -2.94665042e-02f },
      { 1.30878702e-01f, 3.23244743e-02f, -1.37981683e-01f, -1.52684525e-01f, -6.92669600e-02f },
      { 9.44514275e-02f, 3.01393300e-01f, -4.42870520e-02f, -2.52506882e-01f, 7.03375712e-02f },
      { 2.72806571e-03f, 2.40354657e-01f, 2.91926134e-02f, -2.20204979e-01f, 5.73689081e-02f },
      { -1.77206099e-02f, 1.63740546e-01f, -8.27889983e-03f, 1.23425601e-02f, 8.42023939e-02f },
    },
    {
      { 1.19707594e-02f, -4.15681675e-02f, -1.91977043e-02f, -2.62242034e-02f, 3.78195010e-02f },
      { 4.77015562e-02f, 5.23801148e-03f, -1.44095449e-02f, 6.20486252e-02f, -3.48481932e-04f },
      { -5.43023013e-02f, 5.46723567e-02f, -5.51857091e-02f, -1.07699865e-02f, -5.79034770e-03f },
      { 5.45317903e-02f, 7.26389699e-03f, -1.30759599e-03f, -3.05984430e-02f, 1.71334725e-02f },
      { 2.09597908e-02f, -2.50995830e-02f, 4.96045165e-02f, -4.17979918e-02f, -6.12663180e-02f },
    },
    {
      { -8.20163041e-02f, -1.01963781e-01f, -6.88667595e-02f, -3.64257507e-02f, 1.23193180e-02f },
      { -5.49451597e-02f, -3.19336839e-02f, -1.19335636e-01f, -5.13355285e-02f, -3.36991958e-02f },
      { -9.33209434e-03f, 7.42072463e-02f, -1.12198077e-01f, -5.58264740e-02f, 1.31909683e-01f },
      { -2.95418873e-02f, 4.75577414e-02f, -3.08814328e-02f, 2.33798921e-02f, 1.08314648e-01f },
      { 4.62526530e-02f, -6.72970759e-03f, -8.92151520e-03f, 1.20214902e-01f, 1.18149064e-01f },
    },
    {
      { -1.61742736e-02f, -2.21706294e-02f, -6.05184212e-02f, 2.93467455e-02f, -7.94047862e-02f },
      { -1.77731570e-02f, -7.68164545e-02f, -1.52319342e-01f, -6.54121488e-02f, -7.23449737e-02f },
      { -2.32724436e-02f, -1.49149001e-01f, -1.19583540e-01f, -9.46451947e-02f, -2.65867934e-02f },
      { 6.69575948e-03f, -1.78667437e-02f, -1.23541579e-01f, -8.61045439e-03f, 6.74352944e-02f },
      { 4.44330387e-02f, 7.41198584e-02f, 7.73347914e-02f, 1.07431903e-01f, 1.10241696e-01f },
    },
    {
      { -2.71454416e-02f, -7.02058300e-02f, 1.79550201e-02f, -5.89878373e-02f, 4.67744842e-03f },
      { -7.03469068e-02f, -6.82165548e-02f, -9.28067937e-02f, -1.08476669e-01f, -3.96881625e-02f },
      { -2.05884632e-02f, -1.59798786e-01f, -1.93880573e-01f, -4.24525850e-02f, -4.27988620e-04f },
      { 8.18333030e-02f, -8.36796537e-02f, -2.77017474e-01f, 1.71677824e-02f, 9.55949351e-02f },
      { 2.28936952e-02f, 3.19399051e-02f, -1.05078414e-01f, 7.90326111e-03f, 2.96513885e-02f },
    },
    {
      { -9.21908617e-02f, -4.44700681e-02f, 2.01648334e-03f, 4.51635793e-02f, 4.55935076e-02f },
      { -1.39136940e-01f, -2.04606459e-01f, -3.54135595e-02f, 7.73587497e-04f, -1.11213975e-01f },
      { -1.50674477e-01f, -3.43704909e-01f, -3.05033118e-01f, -1.30550042e-01f, -2.16801092e-01f },
      { 1.05469212e-01f, -5.36254160e-02f, -2.43560627e-01f, -1.29264489e-01f, -4.03991081e-02f },
      { -4.86519821e-02f, 2.83692917e-03f, 7.11912587e-02f, 1.49463257e-02f, -4.14951853e-02f },
    },
    {
      { 1.09496385e-01f, 8.92378166e-02f, -4.09471430e-02f, -3.65740657e-02f, 1.11296643e-02f },
      { 9.15090144e-02f, -4.61450964e-02f, -1.46461815e-01f, -1.08952358e-01f, 2.52226070e-02f },
      { 2.69197673e-03f, -1.32827044e-01f, -2.17061475e-01f, -9.42887887e-02f, -1.21438932e-02f },
      { 4.49130014e-02f, -1.33588374e-01f, -7.92326182e-02f, -1.29868969e-01f, 2.09462568e-02f },
      { 1.27045557e-01f, -4.49090824e-03f, -1.57427639e-02f, 3.41911130e-02f, 1.06335357e-01f },
    },
    {
      { 4.43053469e-02f, 8.33896548e-03f, -1.56622231e-02f, -4.62664180e-02f, 6.99776709e-02f },
      { 8.81440192e-02f, -7.60043412e-02f, -5.67621328e-02f, 3.62751223e-02f, 1.25556245e-01f },
      { 2.51211673e-02f, -1.20107062e-01f, 8.11853819e-03f, 1.66728690e-01f, 8.00342634e-02f },
      { 6.61746114e-02f, -2.90046856e-02f, 9.60961804e-02f, 8.10874104e-02f, -1.81272607e-02f },
      { -2.97536198e-02f, -7.75107695e-03f, 1.17000662e-01f, 8.61617550e-02f, -9.38734785e-02f },
    },
    {
      { 1.46337450e-01f, -4.08421680e-02f, -1.39570236e-01f, -1.57061890e-01f, -1.31929472e-01f },
      { 1.26342803e-01f, -7.92889744e-02f, -3.68619375e-02f, -7.85956457e-02f, 1.91320386e-02f },
      { -6.74040765e-02f, -2.08202988e-01f, -6.11607507e-02f, 1.12698659e-01f, 8.06676447e-02f },
      { -4.46549118e-01f, -2.73391157e-01f, -1.25920564e-01f, -5.39917499e-02f, 4.36051898e-02f },
      { -3.11053991e-01f, -2.35046402e-01f, -1.32807657e-01f, -6.11135503e-03f, -3.55679505e-02f },
    },
    {
      { 4.44425158e-02f, 1.02051809e-01f, 1.41555607e-01f, 8.68995190e-02f, 1.09349914e-01f },
      { 6.90083671e-03f, 8.55690539e-02f, 1.56745613e-01f, 1.94619000e-01f, 1.74983531e-01f },
      { 2.81012282e-02f, 1.21358894e-01f, 1.71364516e-01f, 2.08605453e-01f, 1.06676996e-01f },
      { 4.55555019e-05f, 3.61542553e-02f, 1.07861295e-01f, 2.42967814e-01f, 1.34859681e-01f },
      { -1.83390789e-02f, 3.27357613e-02f, 1.30074695e-02f, 5.88481985e-02f, 9.20249596e-02f },
    },
    {
      { -3.66932899e-02f, -1.03385679e-01f, -7.06642047e-02f, -1.20459080e-01f, -1.23557851e-01f },
      { -2.58188657e-02f, -2.29130518e-02f, -1.09737225e-01f, -1.26919538e-01f, -2.85451338e-02f },
      { 9.90362838e-02f, 6.72825053e-02f, -3.26873660e-02f, -4.73847575e-02f, 1.31979153e-01f },
      { 9.07176137e-02f, 9.88367796e-02f, -9.55915526e-02f, 8.88150856e-02f, 1.09934680e-01f },
      { 2.08374392e-02f, -1.56773999e-02f, 4.05249707e-02f, 1.15187675e-01f, 1.53324470e-01f },
    },
    {
      { -9.42520797e-02f, -5.29167876e-02f, 3.63354832e-02f, -2.52773110e-02f, -8.35621506e-02f },
      { 3.93022783e-02f, -1.02704121e-02f, 6.26961812e-02f, -7.55369663e-02f, -7.97948390e-02f },
      { 1.11059041e-03f, -1.23323902e-01f, -1.52569816e-01f, -1.69729143e-01f, -2.02691391e-01f },
      { 1.08775860e-02f, 5.65211335e-03f, -2.26639733e-01f, -7.38181770e-02f, -2.35446952e-02f },
      { 3.37675028e-02f, -3.70560810e-02f, 2.85467841e-02f, -1.49215702e-02f, -4.12072018e-02f },
    },
    {
      { -5.65049797e-02f, 4.76185605e-03f, 7.41553977e-02f, 3.04793157e-02f, -1.24502145e-02f },
      { -4.47770860e-03f, 4.39557843e-02f, 1.17399238e-01f, -9.23843980e-02f, -8.34566057e-02f },
      { -3.53082158e-02f, 1.12063199e-01f, 2.87116738e-03f, -2.06749156e-01f, -5.80612123e-02f },
      { 4.13548797e-02f, 2.55514562e-01f, -7.71192610e-02f, -7.90420547e-02f, 1.86661065e-01f },
      { -1.16925442e-03f, 4.97599430e-02f, 2.47200648e-03f, -6.83285221e-02f, 1.25040427e-01f },
    },
    {
      { -3.73121793e-03f, 5.94997639e-03f, -7.21477941e-02f, -1.79860741e-02f, -6.71344623e-02f },
      { 2.79009733e-02f, -1.71136543e-01f, -7.68256858e-02f, -1.14770360e-01f, -6.55016750e-02f },
      { 2.95394454e-02f, -2.07015246e-01f, -1.67484149e-01f, -1.66393146e-01f, -1.56149473e-02f },
      { 1.49132952e-01f, 2.68372074e-02f, -8.63571689e-02f, -1.34928867e-01f, -3.81048070e-03f },
      { 2.97733378e-02f, 1.77767631e-02f, 1.50026187e-01f, 3.77239585e-02f, 5.67958020e-02f },
    },
    {
      { 6.52579665e-02f, 4.68874723e-02f, 3.18164285e-03f, 4.10466082e-02f, 7.63939694e-02f },
      { 2.81006079e-02f, 1.64261982e-01f, 2.34111264e-01f, 2.19310880e-01f, 6.05291948e-02f },
      { 9.65668038e-02f, 1.20193377e-01f, 2.15088397e-01f, 3.38860422e-01f, 1.97507396e-01f },
      { 1.63254123e-02f, -9.70642194e-02f, 1.23295344e-01f, 2.74113119e-01f, 5.49481548e-02f },
      { 6.01351298e-02f, -6.75007179e-02f, -3.39086652e-02f, 1.15790047e-01f, -2.36370526e-02f },
    },
    {
      { 1.00866430e-01f, 5.23298420e-02f, 4.17794362e-02f, 8.46634954e-02f, 1.53147146e-01f },
      { 1.06229715e-01f, -1.99986324e-02f, -1.85728759e-01f, -7.02215009e-04f, 1.52122766e-01f },
      { 2.37841886e-02f, -6.60007522e-02f, -1.24995008e-01f, 1.69009846e-02f, 1.08784109e-01f },
      { -2.97678597e-02f, 3.18359695e-02f, 3.94945219e-02f, 5.92408553e-02f, -9.23745036e-02f },
      { -3.99559475e-02f, -7.25748539e-02f, 3.94874476e-02f, 1.02862552e-01f, -8.65624100e-02f },
    },
    {
      { -3.56285535e-02f, 9.35374876e-04f, 3.05534396e-02f, -5.65297343e-02f, -6.33433685e-02f },
      { -5.67493401e-02f, 5.91479242e-03f, -2.07245182e-02f, 4.32641990e-02f, -5.96670099e-02f },
      { -3.26081626e-02f, 3.46057862e-02f, -2.00005434e-02f, 1.88365523e-02f, -2.50235181e-02f },
      { -6.11160742e-03f, -2.72030514e-02f, -1.07172541e-02f, 5.93186803e-02f, 5.85685596e-02f },
      { -3.27611007e-02f, 4.29576486e-02f, 3.75401191e-02f, -1.86957549e-02f, -8.46474804e-03f },
    },
    {
      { 1.42531753e-01f, 5.70070669e-02f, -4.50359210e-02f, 3.79194021e-02f, 1.01060808e-01f },
      { 1.07871510e-01f, -5.74465655e-02f, -1.59275845e-01f, -8.24387521e-02f, 1.16698472e-02f },
      { 6.34400696e-02f, 1.22590862e-01f, -1.41923815e-01f, -1.86715543e-01f, 5.68728633e-02f },
      { -1.12227477e-01f, 2.09516704e-01f, 1.09060910e-02f, -1.99334592e-01f, -1.71331987e-01f },
      { 8.65451396e-02f, 3.33480872e-02f, -3.97315361e-02f, -4.32267860e-02f, 3.10308021e-02f },
    },
    {
      { 2.97611784e-02f, -1.46333724e-01f, -1.60846964e-01f, -9.86165628e-02f, 8.44475161e-03f },
      { -6.39890507e-02f, -9.02916864e-02f, -1.95489809e-01f, -2.37722516e-01f, -2.12601528e-01f },
      { -7.14167356e-02f, 1.39399990e-02f, -1.79587454e-01f, -3.91643524e-01f, -5.90377413e-02f },
      { -2.85288412e-02f, 1.55977175e-01f, -1.72589943e-01f, -2.77387738e-01f, 9.55630094e-02f },
      { -3.93105969e-02f, 1.34432599e-01f, -1.02631032e-01f, 4.05091420e-02f, 1.12141274e-01f },
    },
  },
  {
    {
      { 4.35900781e-03f, 3.77735049e-02f, 5.59699386e-02f, 6.16799146e-02f, -6.03456125e-02f },
      { -2.40379885e-01f, -2.17378065e-01f, -3.03252012e-01f, -2.54840076e-01f, -2.07157031e-01f },
      { -2.41646811e-01f, -3.72709662e-01f, -3.14592361e-01f, -2.15242296e-01f, 3.39389965e-02f },
      { 3.97407971e-02f, 2.48079583e-01f, 2.51885474e-01f, 3.72541726e-01f, 3.44787449e-01f },
      { 2.90546954e-01f, 1.72007561e-01f, 2.77162999e-01f, 2.49714449e-01f, 1.86866358e-01f },
    },
    {
      { 3.94911729e-02f, -7.61432573e-03f, 9.31826904e-02f, 3.73811275e-02f, 5.76013327e-02f },
      { -1.28908187e-01f, -1.07517786e-01f, -6.76624253e-02f, -1.35247726e-02f, -6.17337450e-02f },
      { -5.11091016e-02f, -2.68962741e-01f, -2.22429320e-01f, -1.18022785e-01f, -2.59360343e-01f },
      { 4.02276218e-02f, 3.75241158e-03f, 9.71365720e-02f, 1.18508581e-02f, -8.53768960e-02f },
      { -8.04237556e-03f, -3.63878310e-02f, 3.99656780e-02f, 2.99659115e-03f, 2.32111719e-02f },
    },
    {
      { -1.37767568e-01f, -1.97735742e-01f, -4.71674502e-02f, 1.70570016e-01f, 1.63133323e-01f },
      { -4.79310006e-02f, 3.26286815e-02f, 4.01392719e-03f, 1.05964303e-01f, -1.53914085e-02f },
      { 1.51741952e-01f, 1.51840776e-01f, 1.09673508e-01f, -4.06390019e-02f, -2.03466594e-01f },
      { 1.39615759e-01f, 1.32802546e-01f, 6.37595430e-02f, -1.87494114e-01f, -1.88869044e-01f },
      { 7.59894103e-02f, -6.58546090e-02f, -1.45388603e-01f, -1.91662148e-01f, 5.14438376e-02f },
    },
    {
      { 1.31559685e-01f, 1.73391551e-02f, -1.66337147e-01f, -1.47277892e-01f, -6.71115741e-02f },
      { 1.22611523e-01f, 2.00835578e-02f, -1.29574701e-01f, -1.46557167e-01f, 3.79696898e-02f },
      { 4.53904942e-02f, -2.42570471e-02f, -2.20631093e-01f, -3.95463295e-02f, 1.45144731e-01f },
      { -4.76839654e-02f, -3.61860506e-02f, -2.00746268e-01f, 9.66296718e-02f, 1.76977947e-01f },
      { 2.31502503e-02f, -9.07640252e-03f, 3.59474979e-02f, 2.07089365e-01f, 5.29521927e-02f },
    },
    {
      { -2.08998211e-02f, -5.16955480e-02f, -6.85996786e-02f, -8.48038122e-02f, -4.85922955e-02f },
      { -3.76095739e-03f, -7.78363198e-02f, -6.73753396e-02f, -4.33926918e-02f, 2.44672354e-02f },
      { 1.70077473e-01f, 1.34705871e-01f, 1.50119349e-01f, 9.56483185e-02f, 2.20940396e-01f },
      { 6.37038285e-03f, 2.37497203e-02f, -2.23200247e-02f, 6.62425440e-03f, 1.98867396e-01f },
      { 5.27752284e-03f, -1.68033633e-02f, -9.75565910e-02f, 4.46043871e-02f, 1.33368567e-01f },
    },
    {
      { -1.60051942e-01f, -1.67641014e-01f, -7.94828311e-02f, -4.13467027e-02f, 7.48889595e-02f },
      { 5.46152703e-02f, -4.88542602e-04f, -1.05605286e-04f, -5.41043282e-03f, 5.51337041e-02f },
      { 1.42285407e-01f, 2.21352607e-01f, 1.01619676e-01f, 5.47539927e-02f, 3.89376283e-02f },
      { 6.75776899e-02f, -4.04421911e-02f, -1.18893765e-01f, -1.90840587e-01f, -1.83477476e-02f },
      { -2.38028020e-02f, -1.77078613e-03f, -1.33122176e-01f, 6.84040890e-04f, 1.09697945e-01f },
    },
    {
      { -1.99641418e-02f, -1.19304441e-01f, -2.16048658e-01f, 1.02200666e-02f, 2.19853416e-01f },
      { -2.16996651e-02f, -1.30016506e-01f, -3.41959372e-02f, 3.88392732e-02f, 3.23481709e-02f },
      { -1.04708821e-01f, -1.62299097e-01f, -6.22371547e-02f, 4.28905189e-02f, -6.98443502e-02f },
      { 1.56817045e-02f, -1.07458189e-01f, -7.49818608e-02f, -2.88514376e-01f, -8.24305937e-02f },
      { -9.03845057e-02f, -1.31235301e-01f, -1.70238212e-01f, -1.72133893e-01f, 4.94539887e-02f },
    },
    {
      { 1.25401923e-02f, -1.33574501e-01f, -1.21420003e-01f, 7.10395947e-02f, 1.39062494e-01f },
      { 1.45664498e-01f, 4.36862819e-02f, 1.66118801e-01f, 2.16971084e-01f, -1.65346768e-02f },
      { 1.62899211e-01f, 1.29500791e-01f, 2.38926858e-01f, 1.52594462e-01f, -1.53935999e-01f },
      { 1.01955391e-01f, 1.70000475e-02f, -3.40394005e-02f, -2.02359781e-01f, -4.06767845e-01f },
      { -8.05884376e-02f, -1.74505897e-02f, -5.65303452e-02f, -2.10721493e-01f, -7.11118430e-02f },
    },
    {
      { 2.25285832e-02f, -5.84601015e-02f, 3.09080724e-02f, 1.09072849e-02f, 8.53887424e-02f },
      { -1.04611851e-01f, -2.33846888e-01f, -1.63848668e-01f, -1.39822543e-01f, -7.43189156e-02f },
      { -1.59796476e-01f, -5.65804839e-01f, -5.65152586e-01f, -3.45831007e-01f, -3.38979363e-01f },
      { 4.23606634e-02f, -6.74885139e-02f, 1.06434882e-01f, 9.41068213e-03f, 1.38167709e-01f },
      { 5.76248765e-02f, -1.02106621e-02f, 2.06174031e-01f, 1.12773068e-01f, 2.22075582e-01f },
    },
    {
      { -6.34243432e-03f, -3.88378315e-02f, 1.38085568e-03f, -6.50563762e-02f, 2.84412727e-02f },
      { 5.28407469e-02f, 6.87177852e-02f, 1.81114394e-02f, -3.15329172e-02f, -4.06318754e-02f },
      { -3.91885564e-02f, -2.29514809e-03f, -1.14426978e-01f, -2.05869749e-02f, 1.23703577e-01f },
      { 8.97096097e-03f, 2.11709458e-02f, -9.36736017e-02f, -2.60699317e-02f, 7.51852170e-02f },
      { -4.25268672e-02f, 5.61403073e-02f, -4.52862084e-02f, -8.46304372e-02f, -6.46970943e-02f },
    },
    {
      { -1.92925960e-01f, -2.61861116e-01f, -1.66312605e-01f, -9.11516473e-02f, 5.94410524e-02f },
      { 6.12272285e-02f, 1.07371271e-01f, 5.08664548e-02f, 1.13413684e-01f, 5.31804748e-02f },
      { 2.76270330e-01f, 1.89971820e-01f, 2.36343980e-01f, 1.76099092e-01f, 1.76757768e-01f },
      { 1.96230978e-01f, 1.53587714e-01f, -1.99423712e-02f, -7.08947107e-02f, -1.51021779e-01f },
      { -1.52046353e-01f, -7.47900531e-02f, -1.96170032e-01f, -1.04192503e-01f, 2.99535096e-02f },
    },
    {
      { 1.11179918e-01f, 9.38483775e-02f, 7.01015815e-02f, 2.22251262e-03f, -2.82965554e-03f },
      { 1.09508581e-01f, 1.27620503e-01f, 1.03310896e-02f, -3.89095931e-03f, -4.86052856e-02f },
      { -2.01517418e-01f, -3.23429525e-01f, -4.30426508e-01f, -3.37507784e-01f, -1.16151407e-01f },
      { -1.99801996e-01f, -1.12251185e-01f, -4.52573523e-02f, 8.18827078e-02f, 1.03751794e-01f },
      { 1.00044403e-02f, 1.44044071e-01f, 1.02843985e-01f, 8.97340924e-02f, 1.25709906e-01f },
    },
    {
      { 3.54282707e-02f, 1.13996856e-01f, 1.73174918e-01f, 1.19643122e-01f, 8.55780318e-02f },
      { -1.24336584e-02f, 7.55206123e-02f, 2.63615157e-02f, -1.53394071e-02f, -5.44374101e-02f },
      { 8.91925991e-02f, -9.76796895e-02f, -1.41805232e-01f, -2.90696621e-01f, -2.67463773e-01f },
      { 5.84896514e-03f, -9.23652500e-02f, -8.24245512e-02f, -8.78653228e-02f, -5.97565770e-02f },
      { -3.16587836e-02f, 3.17144617e-02f, -8.59209746e-02f, 6.49851486e-02f, 1.00644201e-01f },
    },
    {
      { -1.43527407e-02f, -6.76484965e-03f, 2.25608312e-02f, 6.52472302e-02f, 1.41796216e-01f },
      { -6.54509515e-02f, -4.29188348e-02f, 2.34984700e-02f, 1.55541152e-01f, 4.94017899e-02f },
      { -1.40122086e-01f, -2.51138568e-01f, -1.34715170e-01f, -1.89111024e-01f, -2.65831709e-01f },
      { 8.93756598e-02f, -9.35476869e-02f, -1.00269949e-03f, 2.88800113e-02f, -1.17388695e-01f },
      { -2.13989746e-02f, -6.67960569e-02f, -1.38642704e-02f, -5.95117249e-02f, 1.15031907e-02f },
    },
    {
      { -3.88486199e-02f, -4.33400273e-02f, 1.50029976e-02f, 6.34062216e-02f, 1.26152691e-02f },
      { 5.27487956e-02f, -4.84772511e-02f, 4.42090109e-02f, 1.63047742e-02f, -1.08859390e-02f },
      { -4.96244766e-02f, -1.45893535e-02f, 1.57470349e-02f, -3.38375606e-02f, 4.81074080e-02f },
      { -1.52702455e-03f, 4.73888442e-02f, 4.63172756e-02f, 3.51785123e-02f, -3.65704559e-02f },
      { 6.23330027e-02f, 2.18748581e-02f, 2.97632962e-02f, 1.28741586e-03f, 3.72634124e-04f },
    },
    {
      { 8.84108394e-02f, 4.66024727e-02f, 2.58499794e-02f, 3.90656218e-02f, 1.21949323e-01f },
      { 5.83227724e-02f, 8.67578015e-02f, 1.02902576e-01f, 8.56377184e-02f, -1.07580854e-03f },
      { 1.35280108e-02f, 2.14176923e-02f, 2.12694407e-02f, 7.64092151e-03f, 2.42733047e-03f },
      { -7.50431567e-02f, -6.32866770e-02f, -3.25607620e-02f, -1.14533380e-01f, 2.87216832e-03f },
      { -3.83975469e-02f, -1.50739346e-02f, -5.60569614e-02f, -2.29009567e-03f, -2.08470635e-02f },
    },
    {
      { 6.82653412e-02f, -2.18870640e-02f, 4.79947105e-02f, -1.10488823e-02f, 4.64514680e-02f },
      { -1.69350486e-02f, 3.44245993e-02f, 4.23810333e-02f, 2.66109239e-02f, 1.08556055e-01f },
      { 8.93673822e-02f, 4.11432721e-02f, 4.87472117e-02f, 6.32615387e-02f, 7.34297559e-02f },
      { 1.17689325e-02f, -4.57251444e-02f, 2.51218136e-02f, -1.31721655e-02f, 4.53618467e-02f },
      { -6.10219650e-02f, 9.05698538e-03f, -1.98081974e-02f, 2.33875662e-02f, 1.08652629e-01f },
    },
    {
      { -8.21389779e-02f, -4.70023938e-02f, -4.25969027e-02f, -1.45611272e-03f, -2.44333148e-02f },
      { 8.56129006e-02f, 1.18588984e-01f, 1.04327425e-01f, 1.06119225e-02f, -1.25017688e-02f },
      { 1.89220756e-01f, 1.55622169e-01f, 2.06669971e-01f, 1.11513115e-01f, 2.54760273e-02f },
      { -5.71521111e-02f, 1.24248788e-02f, -1.20234959e-01f, -2.32006073e-01f, -1.91286474e-01f },
      { -1.32133380e-01f, -6.05526492e-02f, -6.77378923e-02f, -4.90229018e-02f, 4.36513610e-02f },
    },
    {
      { -4.34192941e-02f, -1.91526219e-01f, -1.68714821e-01f, -3.65343094e-02f, -2.47121118e-02f },
      { 1.66402627e-02f, 1.82584543e-02f, 4.27288637e-02f, 8.80998820e-02f, 1.74837202e-01f },
      { 1.70976028e-01f, 2.52599180e-01f, 2.95820773e-01f, 2.61744916e-01f, 2.56228834e-01f },
      { 7.40114227e-02f, 1.61326560e-03f, -6.59911707e-02f, -6.21975102e-02f, -1.55934066e-01f },
      { -1.20656297e-01f, -6.16071783e-02f, -8.43562484e-02f, 4.90441360e-03f, 2.82249674e-02f },
    },
    {
      { 1.18499123e-01f, 3.86614725e-02f, -8.23632926e-02f, -1.10408245e-02f, -1.38675228e-01f },
      { 1.66872926e-02f, -4.75575030e-02f, -6.50466932e-03f, -8.38749558e-02f, -8.47636536e-02f },
      { 7.89189897e-03f, -8.75006616e-02f, -1.38519615e-01f, 2.91710608e-02f, 1.01896092e-01f },
      { -3.74623537e-02f, 6.68836897e-03f, 5.33393510e-02f, 1.54853910e-01f, 1.74267158e-01f },
      { 1.97552871e-02f, -1.88893508e-02f, 7.76327355e-03f, 6.49772212e-02f, 1.12638749e-01f },
    },
    {
      { 1.78206176e-01f, 2.01016128e-01f, 1.06030136e-01f, -1.70606002e-02f, -7.68599138e-02f },
      { 9.29420888e-02f, 1.41029909e-01f, -5.00946939e-02f, -9.85577777e-02f, -3.29439119e-02f },
      { -2.01286316e-01f, -3.22753459e-01f, -3.71179223e-01f, -2.50173926e-01f, -9.54040661e-02f },
      { -1.71023190e-01f, -1.72122881e-01f, -1.06149442e-01f, 4.49613333e-02f, 1.07951976e-01f },
      { -7.27175847e-02f, 3.74535397e-02f, 5.08453436e-02f, 1.00979842e-01f, 1.53171599e-01f },
    },
    {
      { -1.01719365e-01f, -1.74046412e-01f, -1.75648108e-01f, -1.95397183e-01f, -1.09742843e-01f },
      { 4.64823190e-03f, -7.22500402e-03f, -1.88242778e-01f, -2.06246078e-01f, -9.24070738e-03f },
      { 2.03774437e-01f, 1.25630751e-01f, -1.20730236e-01f, -4.79974113e-02f, -1.80079043e-01f },
      { -9.43246186e-02f, -1.38628572e-01f, -1.70486599e-01f, -7.30070025e-02f, -3.58597301e-02f },
      { -6.17603213e-03f, -1.51850581e-01f, -2.20451400e-01f, -2.16114357e-01f, -2.44834840e-01f },
    },
    {
      { -4.38281596e-02f, -5.57638295e-02f, 8.76690522e-02f, 1.97413266e-01f, 8.34842399e-02f },
      { 9.52306390e-02f, 1.12779707e-01f, 1.77344397e-01f, 9.67496410e-02f, 7.93728083e-02f },
      { 1.48110777e-01f, 1.17015317e-01f, 6.53211400e-02f, 6.11129664e-02f, -3.44203599e-02f },
      { 3.85986418e-02f, 1.28463298e-01f, 3.60181294e-02f, 2.74431873e-02f, -1.00820363e-01f },
      { 8.53836983e-02f, 1.28901765e-01f, 8.97412524e-02f, -7.46359900e-02f, -6.64837509e-02f },
    },
    {
      { -3.71789262e-02f, 2.04729121e-02f, 1.28112704e-01f, 1.65328756e-01f, 3.70008424e-02f },
      { 1.56033393e-02f, 1.09327421e-01f, 1.29845381e-01f, 8.67523253e-02f, 3.23757008e-02f },
      { 3.68649103e-02f, -9.61476788e-02f, 1.83781814e-02f, -7.14256018e-02f, -9.08097476e-02f },
      { -9.00552198e-02f, -1.00068256e-01f, -1.26335591e-01f, -9.52242538e-02f, -6.74395412e-02f },
      { -4.89487909e-02f, -6.77938983e-02f, -3.23956646e-02f, -6.03372343e-02f, 7.75225982e-02f },
    },
    {
      { -6.15678690e-02f, -8.11908618e-02f, 3.53136286e-02f, 3.37526500e-02f, 2.93257572e-02f },
      { -4.12105204e-04f, 7.26528689e-02f, 7.96086714e-02f, 3.99488918e-02f, 8.79517049e-02f },
      { 7.10471272e-02f, 9.78412032e-02f, 1.88575074e-01f, 1.93715602e-01f, 3.85626890e-02f },
      { 1.29479036e-01f, 4.29958329e-02f, 1.67458076e-02f, -7.88585097e-02f, -1.84412554e-01f },
      { -7.80199021e-02f, -1.23019919e-01f, -1.56249776e-01f, -9.34118181e-02f, 4.66902778e-02f },
    },
    {
      { 2.12600958e-02f, -1.21290274e-01f, -6.06586039e-02f, 1.10057026e-01f, 2.05385268e-01f },
      { 1.66738942e-01f, 1.03250660e-01f, 1.16339125e-01f, 1.66899309e-01f, 1.83228001e-01f },
      { 2.52330333e-01f, 2.08004326e-01f, 2.12989166e-01f, 1.71514019e-01f, 2.72541828e-02f },
      { 8.83344784e-02f, -1.81094296e-02f, -3.13401781e-02f, -2.13368073e-01f, -2.17366591e-01f },
      { 7.12222159e-02f, 1.94367412e-02f, 1.60188135e-02f, -5.38616404e-02f, 5.02333716e-02f },
    },
    {
      { -1.18973814e-02f, -1.06109060e-01f, -7.56546389e-03f, 6.41601607e-02f, 7.86581859e-02f },
      { 1.71386581e-02f, 6.22218363e-02f, 1.60698351e-02f, 1.19819075e-01f, 1.68313771e-01f },
      { 1.18914498e-02f, 1.33234769e-01f, 1.24866866e-01f, 8.93921927e-02f, 1.63238600e-01f },
      { -2.31874194e-02f, -9.39137414e-02f, -3.84258032e-02f, -4.62043583e-02f, -3.19420360e-02f },
      { -3.38330492e-02f, -3.56082828e-03f, -5.31875975e-02f, -5.02908491e-02f, 2.43237545e-03f },
    },
    {
      { 1.36721274e-03f, -2.29989756e-02f, 3.06720170e-03f, 3.80404666e-02f, 5.12309000e-02f },
      { 1.22044124e-01f, 2.81472374e-02f, -5.08799367e-02f, -8.30734596e-02f, -4.66855653e-02f },
      { 3.14778052e-02f, 1.06273711e-01f, -3.82935628e-02f, -2.00411648e-01f, -1.03868715e-01f },
      { 2.88978424e-02f, 1.19368233e-01f, -5.19855395e-02f, -6.12526089e-02f, 2.24319045e-02f },
      { -2.99533340e-03f, 4.20629345e-02f, -5.20119704e-02f, -1.86406113e-02f, 4.03876454e-02f },
    },
    {
      { 1.97772563e-01f, 1.93145290e-01f, 9.44791436e-02f, 7.44450511e-03f, -4.03035767e-02f },
      { 2.02796496e-02f, 1.57900658e-02f, -1.22850887e-01f, -1.70591727e-01f, -3.25255729e-02f },
      { -3.46081674e-01f, -6.04418695e-01f, -6.48377478e-01f, -3.75769526e-01f, -6.58972710e-02f },
      { -2.41859049e-01f, -1.38044998e-01f, -2.95478869e-02f, 2.22939700e-01f, 2.73500860e-01f },
      { -1.49852959e-02f, 1.25275046e-01f, 1.82444230e-01f, 2.61063963e-01f, 1.65409118e-01f },
    },
    {
      { 7.01801712e-03f, 2.57408489e-02f, 5.31791076e-02f, -2.62832940e-02f, 9.32632759e-03f },
      { 4.27272059e-02f, 3.23163867e-02f, -3.81438285e-02f, 4.40520011e-02f, -5.25683947e-02f },
      { -5.04412130e-02f, -3.81973684e-02f, 4.72783148e-02f, 2.17192899e-02f, -2.84197740e-03f },
      { 2.64397860e-02f, -1.56355347e-03f, -1.30806249e-02f, -2.46641375e-02f, -1.02161309e-02f },
      { -5.56316748e-02f, 1.71636473e-02f, 5.53127378e-02f, 3.00781038e-02f, 2.33059991e-02f },
    },
    {
      { -3.12719084e-02f, -4.42351736e-02f, 5.52227236e-02f, -3.15025672e-02f, 1.12360353e-02f },
      { -4.63295951e-02f, -9.43764150e-02f, -1.06585450e-01f, -1.73430275e-02f, -3.14918719e-02f },
      { -2.14222938e-01f, -4.46254104e-01f, -3.19866985e-01f, -1.22066021e-01f, -9.19583663e-02f },
      { -1.48581723e-02f, 1.67387649e-02f, 2.01620176e-01f, 2.17257023e-01f, 1.00817695e-01f },
      { -1.81141123e-02f, -1.37621267e-02f, 9.40961316e-02f, 1.36939019e-01f, 6.97534606e-02f },
    },
    {
      { 3.24141011e-02f, -1.77425742e-01f, -2.88889050e-01f, 4.60101850e-02f, 7.13528246e-02f },
      { 1.82261709e-02f, -1.07919082e-01f, 1.12851121e-04f, 1.79465681e-01f, 9.89892632e-02f },
      { 1.55138656e-01f, -9.37692225e-02f, 1.21627599e-01f, 2.73725659e-01f, -6.04529344e-02f },
      { 1.08782947e-01f, -1.67647362e-01f, 3.95560861e-02f, -1.03634922e-02f, -2.97852159e-01f },
      { 2.82709580e-03f, -6.25234172e-02f, 2.59359144e-02f, -1.27166227e-01f, -5.36836125e-02f },
    },
  },
  {
    {
      { -3.54056247e-02f, 9.43395495e-02f, -1.70478359e-01f, 1.10747904e-01f, 2.46061862e-01f },
      { -1.43901452e-01f, 3.67550999e-02f, -9.30686966e-02f, 1.24926999e-01f, 2.17760429e-01f },
      { -3.02663356e-01f, -3.88510197e-01f, 1.20685257e-01f, 3.88002098e-01f, -1.70672219e-02f },
      { 3.51278321e-03f, -5.12098102e-03f, 3.18021208e-01f, 4.32556957e-01f, 7.83977360e-02f },
      { 1.81749780e-02f, 2.55038321e-01f, -2.62480080e-02f, 1.33965865e-01f, 1.66910768e-01f },
    },
    {
      { -8.44101682e-02f, -1.51316896e-01f, 3.88269424e-02f, 3.82372364e-02f, -1.46662056e-01f },
      { 3.88513617e-02f, 1.53082281e-01f, -1.07112534e-01f, -1.33674234e-01f, 1.22164398e-01f },
      { -1.83489523e-03f, 8.48729461e-02f, -4.50099760e-04f, 1.71970904e-01f, -8.74367207e-02f },
      { 2.59337753e-01f, 8.43956843e-02f, 1.48090020e-01f, 3.01816016e-01f, 1.86163876e-02f },
      { -4.49599698e-02f, -5.29443994e-02f, -4.71132621e-02f, 1.15387462e-01f, -5.17627969e-02f },
    },
    {
      { 1.38681009e-01f, 1.28194138e-01f, -4.84760739e-02f, -1.66594237e-01f, -1.73672289e-01f },
      { 1.04332037e-01f, 3.47572118e-01f, 2.38154128e-01f, 7.18739331e-02f, -5.27748838e-02f },
      { 1.80991232e-01f, 7.84049854e-02f, -3.59377102e-03f, 1.42870277e-01f, -5.76473586e-02f },
      { 3.54015566e-02f, -3.59025933e-02f, -2.99991488e-01f, -1.05512720e-02f, 5.82267307e-02f },
      { -2.83281505e-01f, -3.03090751e-01f, -6.14043362e-02f, 2.98413113e-02f, -3.48958641e-01f },
    },
    {
      { -1.12590957e-02f, -1.99288186e-02f, -5.41444905e-02f, 5.20095415e-03f, 7.11934194e-02f },
      { 5.08386865e-02f, -2.11354166e-01f, -1.65580019e-01f, -4.62121256e-02f, 3.58702801e-02f },
      { -1.47207335e-01f, 1.04596252e-02f, -6.41226247e-02f, -2.29707241e-01f, -2.73176320e-02f },
      { -1.64333105e-01f, 6.54240698e-02f, 7.03034848e-02f, -3.07362556e-01f, -9.05249715e-02f },
      { -7.18545169e-03f, 1.93564132e-01f, 1.11584693e-01f, -2.48968080e-01f, -7.18422059e-04f },
    },
    {
      { 9.87930372e-02f, 6.16445765e-02f, 1.50141478e-01f, 2.72392742e-02f, 2.21853480e-01f },
      { -6.22995868e-02f, -2.44794711e-01f, 4.40104585e-03f, -5.14007779e-03f, 5.92311099e-02f },
      { 1.86815947e-01f, -3.02600086e-01f, -2.36795962e-01f, 2.66283862e-02f, 1.80767607e-02f },
      { 1.08897872e-01f, -4.18916233e-02f, -4.11567017e-02f, -1.84520707e-01f, 7.65607581e-02f },
      { 9.31903124e-02f, 1.31393403e-01f, 1.04328826e-01f, -3.32588926e-02f, -7.44983479e-02f },
    },
    {
      { -6.27531782e-02f, 2.05763608e-01f, 1.06119283e-01f, -9.53678787e-02f, 1.34728208e-01f },
      { -2.97786808e-03f, -5.00465669e-02f, 1.86754242e-01f, 1.13450505e-01f, -3.09929140e-02f },
      { -4.87242639e-02f, 2.27267779e-02f, 5.60171865e-02f, 1.58985585e-01f, 1.21602327e-01f },
      { -2.10966617e-01f, -3.85757834e-02f, -7.88584873e-02f, -2.95382619e-01f, -1.34341687e-01f },
      { -2.66890526e-01f, -7.99642224e-03f, -3.11610959e-02f, -2.90139049e-01f, -3.84337664e-01f },
    },
    {
      { 7.88742229e-02f, -1.46079972e-01f, 2.66255915e-01f, -7.73819536e-03f, -7.21272686e-03f },
      { 9.45661962e-02f, 1.27804786e-01f, 6.02323860e-02f, -1.55888602e-01f, 5.32335378e-02f },
      { 1.67374685e-01f, 8.63378495e-02f, -3.02353650e-01f, -3.49429101e-01f, -1.17137665e-02f },
      { 1.77485958e-01f, -2.80110121e-01f, -1.60079524e-02f, 1.13162715e-02f, -2.77500689e-01f },
      { -3.16640623e-02f, -1.76164567e-01f, 7.71639049e-02f, 2.22105771e-01f, -1.63184047e-01f },
    },
    {
      { 1.00369908e-01f, 3.05689573e-02f, 1.16430506e-01f, 6.69117719e-02f, -1.39204055e-01f },
      { -4.89703473e-03f, 7.57433549e-02f, -4.58768234e-02f, -1.33755103e-01f, -3.70072201e-02f },
      { 1.01928852e-01f, 1.86863765e-01f, -2.63963372e-01f, -1.59940511e-01f, -1.09313093e-01f },
      { 4.44802120e-02f, -2.46577159e-01f, -2.52071083e-01f, -4.52473015e-02f, 2.95774196e-03f },
      { -2.13926315e-01f, -2.08096951e-01f, -2.99555510e-02f, 2.96751291e-01f, -8.15290213e-02f },
    },
    {
      { -2.16422915e-01f, 2.81276032e-02f, -1.29471749e-01f, 7.49553517e-02f, 7.91561827e-02f },
      { -2.44095460e-01f, 1.70910001e-01f, -7.42202103e-02f, -1.87312499e-01f, -1.60189513e-02f },
      { -7.74051622e-02f, -1.85776174e-01f, -1.26898721e-01f, 1.76247060e-01f, -1.32050827e-01f },
      { -1.01933345e-01f, 6.95978627e-02f, 6.44966736e-02f, 4.50528175e-01f, 2.14299768e-01f },
      { -1.01757325e-01f, 1.37819856e-01f, 4.93116491e-03f, 3.11791841e-02f, 1.96833998e-01f },
    },
    {
      { -6.64411336e-02f, -2.93727871e-02f, 6.32546097e-02f, -5.01203537e-03f, 1.61132868e-02f },
      { 7.38764629e-02f, -7.20101893e-02f, 1.50469868e-02f, 1.55253783e-01f, 8.86807591e-02f },
      { -7.17436597e-02f, 2.55908556e-02f, 1.90420672e-01f, 9.40838456e-02f, 1.04483426e-01f },
      { -2.25045800e-01f, 4.66900580e-02f, 2.47718096e-01f, -1.46407247e-01f, -1.45705149e-01f },
      { -2.26422295e-01f, -8.82715806e-02f, 6.28206646e-04f, -1.13425948e-01f, -1.43825144e-01f },
    },
    {
      { -3.00277993e-02f, 1.08771786e-01f, 2.10413694e-01f, -2.04656981e-02f, 3.30043696e-02f },
      { -1.95536733e-01f, -2.47239098e-01f, -4.84586544e-02f, -2.91357692e-02f, -1.21759444e-01f },
      { -2.78267693e-02f, -1.74997792e-01f, -2.30081111e-01f, -1.67931333e-01f, 4.85665612e-02f },
      { 8.08998942e-03f, -1.22970313e-01f, -2.35643178e-01f, -3.86886209e-01f, -1.52391478e-01f },
      { -3.51318642e-02f, -1.11466125e-02f, 1.20860226e-02f, -3.34357582e-02f, -2.56999612e-01f },
    },
    {
      { -7.58387148e-02f, -1.93771839e-01f, -1.77531585e-01f, -1.51808962e-01f, -9.21505243e-02f },
      { -5.02670817e-02f, -8.01673066e-03f, -9.35106948e-02f, -6.13663904e-02f, -9.37139168e-02f },
      { -6.40246719e-02f, -2.11132076e-02f, 6.96029216e-02f, 1.69089571e-01f, 4.07162718e-02f },
      { -7.25225508e-02f, 2.10037246e-01f, 3.68164718e-01f, 2.09351718e-01f, 3.52176391e-02f },
      { 2.07298528e-02f, 1.65698007e-01f, 1.83999255e-01f, -3.69319245e-02f, 3.34846377e-02f },
    },
    {
      { 4.48516384e-02f, -1.60652846e-02f, -7.26037994e-02f, -1.11694776e-01f, -1.07295744e-01f },
      { 1.06015857e-02f, 1.56045154e-01f, -1.08494544e-02f, -1.73517913e-01f, 5.50629906e-02f },
      { 9.50046033e-02f, 2.70756893e-02f, 9.85923409e-03f, 1.32356465e-01f, 1.28852529e-02f },
      { -5.81503920e-02f, -7.96838477e-02f, 2.45963186e-01f, 2.91363865e-01f, 2.93946899e-02f },
      { -2.65391201e-01f, 2.82297819e-03f, 7.38655105e-02f, 7.59498402e-02f, -3.85086723e-02f },
    },
    {
      { -4.01829630e-02f, -3.32803801e-02f, -9.22408700e-02f, 3.72840501e-02f, -1.59778506e-01f },
      { 8.43546540e-02f, 8.99586603e-02f, -4.18710634e-02f, -3.36418711e-02f, 1.23042621e-01f },
      { 3.50558721e-02f, 2.32360754e-02f, -6.30730093e-02f, 8.27086419e-02f, 1.61383711e-02f },
      { 1.83068797e-01f, -4.04936820e-02f, 8.50825310e-02f, 3.47408533e-01f, 8.53647515e-02f },
      { -6.62411451e-02f, -1.65400892e-01f, -6.25833794e-02f, 1.56462640e-01f, 7.55107254e-02f },
    },
    {
      { 5.71092637e-03f, 2.04805704e-03f, -3.15719619e-02f, 3.05765085e-02f, -7.25670904e-03f },
      { -7.38698104e-03f, 6.18175566e-02f, -2.16272455e-02f, 5.35117276e-02f, 5.88455843e-03f },
      { -3.24782394e-02f, -7.05906982e-03f, 4.02265713e-02f, 3.02125048e-02f, 4.19195816e-02f },
      { 3.45376693e-02f, 3.14498730e-02f, 1.00769214e-02f, -2.44974345e-02f, -3.32507654e-03f },
      { 3.35887633e-03f, 3.10381241e-02f, -3.91054749e-02f, -5.01631089e-02f, 3.26682664e-02f },
    },
    {
      { -8.17296728e-02f, -5.79481572e-02f, -7.15379417e-02f, -3.58413421e-02f, -8.62526074e-02f },
      { -4.09796871e-02f, -6.75722733e-02f, -2.57343706e-02f, -6.53554359e-03f, 4.51840982e-02f },
      { -2.80348342e-02f, -9.76967812e-02f, -8.86476859e-02f, 3.05120591e-02f, 6.73105493e-02f },
      { -3.68672274e-02f, -7.65626803e-02f, 1.09630257e-01f, 1.38785526e-01f, 7.24113137e-02f },
      { 5.19828917e-03f, 3.30397747e-02f, 1.11946486e-01f, 1.39225289e-01f, -2.15334874e-02f },
    },
    {
      { 3.05898692e-02f, 3.13633820e-03f, -3.41878384e-02f, 4.18198109e-02f, 4.43751132e-03f },
      { -1.09827116e-01f, -1.71147853e-01f, -2.27239296e-01f, -7.05821589e-02f, -3.86778452e-02f },
      { 8.08945447e-02f, 1.26843033e-02f, -1.62920907e-01f, -1.23273104e-01f, -6.02752343e-02f },
      { 8.02514255e-02f, 3.34234945e-02f, -6.55037984e-02f, 1.95186026e-02f, 1.05396286e-01f },
      { 1.83995053e-01f, 1.70471206e-01f, 1.73466519e-01f, 1.34223312e-01f, 8.81650895e-02f },
    },
    {
      { -5.53771816e-02f, 1.07114941e-01f, 8.47163349e-02f, 3.14102992e-02f, -3.81907001e-02f },
      { -1.01655528e-01f, -1.01801343e-01f, -2.92757098e-02f, -3.09408661e-02f, -5.67670539e-02f },
      { 4.73750606e-02f, -2.05195382e-01f, -1.78811103e-01f, -6.10231943e-02f, 2.53664702e-02f },
      { -2.96742376e-02f, -1.03070796e-01f, -7.91138336e-02f, 3.80907021e-02f, 6.77055195e-02f },
      { -4.74954471e-02f, -8.14717170e-03f, 2.45537236e-02f, -6.34096330e-03f, -1.17473416e-01f },
    },
    {
      { -1.33252382e-01f, 5.79169812e-03f, 5.76692186e-02f, 6.96178228e-02f, 8.42512622e-02f },
      { -2.64675677e-01f, -3.18716466e-01f, -2.35530064e-01f, -1.50657624e-01f, -1.31976038e-01f },
      { 2.16927752e-03f, -1.22052301e-02f, -2.51414418e-01f, -1.87459379e-01f, 1.65058166e-01f },
      { 5.88992573e-02f, 6.62877187e-02f, -1.24485284e-01f, -1.27502620e-01f, -1.30510647e-02f },
      { 1.70859024e-01f, 1.16162516e-01f, 2.13814825e-01f, 1.70835868e-01f, 1.21775642e-02f },
    },
    {
      { 1.04761496e-01f, 4.04749252e-02f, 9.49000791e-02f, 2.11889312e-01f, 1.38103023e-01f },
      { -1.88098792e-02f, -4.46661860e-02f, -1.42436847e-01f, 1.38427354e-02f, 6.09065071e-02f },
      { -3.85932513e-02f, -1.82927087e-01f, -2.36144960e-01f, -1.16819203e-01f, -4.50460725e-02f },
      { 1.65352356e-02f, -1.04624787e-02f, -9.64013860e-02f, -5.74190505e-02f, 5.17958999e-02f },
      { 2.13585705e-01f, 2.61699200e-01f, 9.38832313e-02f, -2.28510480e-02f, 1.14761181e-01f },
    },
    {
      { 5.00867926e-02f, -1.38962507e-01f, -1.29152492e-01f, -8.49124119e-02f, -3.85366417e-02f },
      { -5.80220781e-02f, -1.54797792e-01f, -1.64739981e-01f, -7.25084618e-02f, -5.88258766e-02f },
      { -1.16793931e-01f, -1.87305719e-01f, 4.11027595e-02f, -1.56176575e-02f, -3.95997725e-02f },
      { -1.70392349e-01f, 1.22163750e-01f, 2.87265897e-01f, 4.81917597e-02f, -1.39826715e-01f },
      { 4.72960956e-02f, 1.39043257e-01f, 2.00525790e-01f, 2.29488742e-02f, -5.83812874e-03f },
    },
    {
      { 1.49641171e-01f, 9.15821567e-02f, 2.29615539e-01f, 3.90785225e-02f, 1.08509265e-01f },
      { 1.78575024e-01f, 2.48822808e-01f, 1.76808864e-01f, 4.18620296e-02f, -3.23601300e-03f },
      { -1.78078145e-01f, -8.68661236e-03f, -1.22872211e-01f, -1.09117471e-01f, 1.40701141e-03f },
      { -1.68024123e-01f, -9.91839170e-02f, -1.70395717e-01f, -2.57983238e-01f, -9.24687535e-02f },
      { -4.33369614e-02f, -1.13713004e-01f, -1.43552944e-01f, -1.18526846e-01f, 4.02797833e-02f },
    },
    {
      { -4.35543768e-02f, 1.04296813e-02f, -4.43526456e-04f, -1.18564487e-01f, -1.24025166e-01f },
      { 1.20405138e-01f, 2.03266010e-01f, 2.44679675e-01f, 5.88834621e-02f, 5.91181852e-02f },
      { 1.02046892e-01f, 7.83670545e-02f, 2.87766069e-01f, 1.78936511e-01f, 9.79684517e-02f },
      { -5.62759526e-02f, 1.18701160e-01f, 2.47838944e-01f, 2.24390715e-01f, 8.11590329e-02f },
      { -6.06262870e-03f, 5.39489370e-03f, 6.50004447e-02f, 2.96884831e-02f, -3.94704752e-02f },
    },
    {
      { 2.57706698e-02f, -6.97483867e-02f, -8.48137140e-02f, -1.55633643e-01f, -1.09785080e-01f },
      { 7.51722530e-02f, -3.99494134e-02f, -5.52099012e-02f, -9.81435403e-02f, -3.73237301e-03f },
      { 6.90092221e-02f, 1.45118274e-02f, -9.35099274e-02f, -9.49118286e-03f, 2.08955407e-02f },
      { 9.85245481e-02f, -7.34436139e-02f, 1.41551316e-01f, 1.47611603e-01f, 2.89159846e-02f },
      { -9.42317322e-02f, -9.23752263e-02f, 9.11459178e-02f, 1.07233845e-01f, -8.92706066e-02f },
    },
    {
      { -7.21585378e-02f, -7.44008878e-03f, 7.60594755e-02f, -9.39869732e-02f, -2.80943786e-05f },
      { -9.66481194e-02f, -1.92221478e-01f, -5.09576015e-02f, -4.50537482e-04f, -1.46888226e-01f },
      { -5.08735329e-02f, -1.42913256e-02f, -1.87946409e-01f, -1.62530214e-01f, -4.12416272e-02f },
      { -8.25623646e-02f, -2.00063013e-03f, -1.73914656e-01f, -2.15792999e-01f, -1.31515548e-01f },
      { -3.66259776e-02f, 8.84915353e-04f, 2.57899426e-02f, 6.62302179e-03f, -1.67538941e-01f },
    },
    {
      { 6.25818595e-02f, 4.87249270e-02f, 1.59280047e-01f, 4.92975041e-02f, -1.65322935e-03f },
      { -2.00330354e-02f, 4.38012443e-02f, -3.57984267e-02f, 3.70042585e-02f, -1.09542213e-01f },
      { 1.95853621e-01f, 3.55257481e-01f, -1.26381204e-01f, 4.13204059e-02f, 7.19020665e-02f },
      { 2.55792886e-01f, -1.60532326e-01f, -4.27364605e-03f, 4.31035124e-02f, 5.89239076e-02f },
      { 7.97777995e-02f, -6.90610185e-02f, 9.48676914e-02f, 2.36730620e-01f, -4.40947665e-03f },
    },
    {
      { -3.30163352e-02f, -5.19615710e-02f, -6.08748104e-03f, 3.84141207e-02f, 2.82647144e-02f },
      { -7.35504180e-02f, -2.84344584e-01f, -1.81916714e-01f, -1.70427427e-01f, -1.40671600e-02f },
      { 8.82213190e-03f, -1.00956492e-01f, -2.32070148e-01f, -2.00755760e-01f, -3.09959520e-02f },
      { 1.12664044e-01f, 3.65931205e-02f, -5.52164242e-02f, -5.79589466e-03f, 8.79340991e-02f },
      { 8.87562037e-02f, 1.69188395e-01f, 9.36671272e-02f, 5.62772863e-02f, 9.39657390e-02f },
    },
    {
      { -9.12549626e-03f, 1.29833847e-01f, 1.14171632e-01f, -5.24415039e-02f, -1.22270817e-02f },
      { 1.00984797e-01f, 1.70776799e-01f, 2.01915205e-01f, 1.61070019e-01f, 9.17331874e-02f },
      { 4.69463579e-02f, 4.90200557e-02f, 1.66643739e-01f, 2.51757801e-01f, 1.19083010e-01f },
      { -9.78045315e-02f, -3.67951691e-02f, 1.27410203e-01f, 8.07036087e-02f, 6.36846796e-02f },
      { -2.16700271e-01f, -9.79413167e-02f, 3.17602828e-02f, -2.01532915e-01f, -2.90002048e-01f },
    },
    {
      { -2.79425513e-02f, -1.74746826e-01f, -1.36908039e-01f, -5.50855920e-02f, 2.17773337e-02f },
      { -8.94887447e-02f, -1.24713846e-01f, -2.73538023e-01f, -1.36931419e-01f, -4.14675139e-02f },
      { -1.93904281e-01f, -3.00752848e-01f, -8.45565721e-02f, -3.14557441e-02f, -1.70082346e-01f },
      { -8.47282410e-02f, 7.85297006e-02f, 3.13398123e-01f, 1.71575934e-01f, -3.48235965e-02f },
      { 4.76419218e-02f, 1.91714481e-01f, 1.29039064e-01f, 1.21512197e-01f, 4.02760729e-02f },
    },
    {
      { -7.02898018e-04f, -3.25841196e-02f, 2.95500644e-02f, 6.25429153e-02f, 3.27636153e-02f },
      { -3.07040736e-02f, 1.38756707e-02f, -2.03935280e-02f, -4.88829836e-02f, -4.70622405e-02f },
      { -4.14533392e-02f, -5.28326780e-02f, 9.31852218e-03f, 5.46307117e-02f, 3.17794830e-02f },
      { 1.62586477e-02f, 1.45832151e-02f, -5.25632538e-02f, 3.97448875e-02f, 1.93560757e-02f },
      { -1.97944231e-02f, -2.67142374e-02f, 4.86673675e-02f, -5.34277316e-03f, -2.11814307e-02f },
    },
    {
      { -1.38358876e-01f, -9.16299373e-02f, 7.69223040e-03f, 1.34861439e-01f, -5.83517142e-02f },
      { -1.31415101e-02f, -3.19294259e-03f, -2.07322329e-01f, -1.42336100e-01f, 2.05667138e-01f },
      { -2.84276217e-01f, -2.17523783e-01f, -4.90198992e-02f, 1.30251378e-01f, -1.71005040e-01f },
      { 1.79429829e-01f, 1.08111696e-02f, 1.85853064e-01f, 3.45854402e-01f, -8.90401367e-04f },
      { 1.66695267e-01f, -4.96578664e-02f, -6.68550804e-02f, 7.83929005e-02f, 1.07178189e-01f },
    },
    {
      { 1.26893759e-01f, 2.50048675e-02f, 1.53986409e-01f, 6.25794306e-02f, -8.92144516e-02f },
      { -4.25015576e-02f, 7.57454485e-02f, -1.23257399e-01f, -1.69809520e-01f, 3.84532921e-02f },
      { 9.02457908e-02f, 1.55414805e-01f, -2.20321506e-01f, -2.18905747e-01f, 1.17492281e-01f },
      { 9.57968310e-02f, -2.49529444e-02f, -3.00880164e-01f, 5.75551204e-02f, 5.88975586e-02f },
      { 2.56636236e-02f, -9.24465805e-02f, -1.37901515e-01f, 2.55849063e-01f, 9.57205966e-02f },
    },
  },
  {
    {
      { -1.73385153e-04f, 9.16062575e-03f, -5.36907092e-02f, 4.74544317e-02f, -3.47088138e-03f },
      { 9.73261613e-03f, 1.76903345e-02f, -8.44733603e-03f, -4.64367047e-02f, -1.58162788e-02f },
      { 3.44814360e-02f, -6.22088462e-02f, -1.36187803e-02f, 1.89348608e-02f, -1.84283555e-02f },
      { 2.24172566e-02f, 1.30101182e-02f, -2.69623902e-02f, -4.25776057e-02f, 5.47873303e-02f },
      { 5.41722216e-02f, 1.44254761e-02f, 6.48826966e-03f, -1.97592191e-03f, -1.41034210e-02f },
    },
    {
      { 2.84308698e-02f, -5.21742553e-02f, 1.86573919e-02f, -5.20654470e-02f, -3.61496955e-02f },
      { 1.68375373e-02f, 4.40230556e-02f, -3.18881795e-02f, -4.46313769e-02f, 5.24295568e-02f },
      { -3.93323302e-02f, -3.79044227e-02f, -3.14127491e-03f, -4.24905634e-03f, 5.34635261e-02f },
      { 4.49332930e-02f, 4.16934192e-02f, -1.75660979e-02f, -2.22793818e-02f, -6.54816702e-02f },
      { 4.55673132e-03f, 4.24036905e-02f, -3.36287208e-02f, -5.86312525e-02f, 1.26201874e-02f },
    },
    {
      { 4.17359099e-02f, -5.76303601e-02f, -6.21077158e-02f, -7.12084919e-02f, -1.81677882e-02f },
      { -6.80237487e-02f, 2.47000363e-02f, 3.06562968e-02f, 2.03564726e-02f, 1.17464480e-03f },
      { 3.76225300e-02f, 4.83610965e-02f, -1.55688338e-02f, -1.84718072e-02f, 5.34304492e-02f },
      { -2.95679383e-02f, -3.42285261e-02f, -3.45603786e-02f, -4.19135988e-02f, -4.30199504e-02f },
      { -4.59005795e-02f, 4.55471165e-02f, 8.97074677e-03f, 4.94772010e-02f, 2.75100814e-03f },
    },
    {
      { 3.06365956e-02f, 1.47697041e-02f, 3.12403031e-02f, 9.58386809e-03f, -4.85030748e-02f },
      { -3.25598828e-02f, 4.30260040e-02f, 9.65200178e-03f, 5.23941172e-03f, -5.83091080e-02f },
      { -2.42097192e-02f, -3.62821412e-03f, 3.20580266e-02f, -1.19407307e-02f, -2.78474260e-02f },
      { -4.01584134e-02f, -5.81947807e-03f, -2.78493781e-02f, -6.64209574e-02f, 1.87258944e-02f },
      { 3.18531357e-02f, 5.16639613e-02f, 2.44059563e-02f, -5.57749495e-02f, -3.24706454e-03f },
    },
    {
      { -3.83511111e-02f, -1.46086514e-02f, 3.84091809e-02f, -5.41708730e-02f, 1.40494974e-02f },
      { -5.26450155e-03f, -5.76901250e-02f, 3.92939337e-02f, -5.21043688e-02f, 2.74419300e-02f },
      { -6.34151325e-02f, -5.90027273e-02f, -2.88829878e-02f, -6.35952875e-02f, -3.65557745e-02f },
      { 3.92758250e-02f, -2.17443611e-02f, 5.02311683e-04f, -5.41653112e-02f, -7.89100188e-04f },
      { 2.72974670e-02f, -1.65314246e-02f, -3.05679291e-02f, -2.86476854e-02f, -8.36151280e-03f },
    },
    {
      { 1.16571495e-02f, -6.13670349e-02f, -4.66107279e-02f, -6.00801110e-02f, -2.14334814e-05f },
      { -1.00416569e-02f, 7.20256520e-03f, -2.56164721e-03f, -1.36700226e-02f, -4.62735370e-02f },
      { -3.07948794e-02f, -1.35387592e-02f, -8.58547445e-03f, 6.95573818e-03f, -4.01480384e-02f },
      { 4.73885098e-03f, -5.31274378e-02f, -7.18240961e-02f, -2.70302948e-02f, 2.91469563e-02f },
      { -3.63576971e-02f, 1.16211893e-02f, 3.43591981e-02f, 5.32358512e-02f, -4.40639928e-02f },
    },
    {
      { -5.71504757e-02f, -4.10812423e-02f, 2.84282193e-02f, 2.80242376e-02f, 1.20339338e-02f },
      { 4.52817455e-02f, -5.42001389e-02f, 4.51630866e-03f, 2.54658666e-02f, 6.28779363e-03f },
      { -3.62231955e-02f, 3.05592362e-02f, -2.30158288e-02f, 4.68899868e-03f, -5.02289087e-02f },
      { -4.16619107e-02f, 1.69167109e-02f, 4.34322990e-02f, -2.85736248e-02f, 9.99951363e-03f },
      { -3.10093574e-02f, -5.21683432e-02f, -1.25056962e-02f, -6.35524765e-02f, 3.73875201e-02f },
    },
    {
      { 3.01598124e-02f, 4.19539250e-02f, -2.18670946e-02f, 6.69530826e-03f, -3.20483074e-02f },
      { -5.17777242e-02f, -1.36241550e-03f, 1.50311447e-03f, -2.98186131e-02f, -5.43676168e-02f },
      { -1.49605470e-02f, 3.33173685e-02f, -2.76676845e-02f, -6.80884942e-02f, 5.06838709e-02f },
      { -7.22149760e-02f, 4.64470461e-02f, -4.29137461e-02f, -3.02936938e-02f, -6.01183772e-02f },
      { -1.81281194e-02f, 3.32158022e-02f, -7.70737678e-02f, -3.59808914e-02f, -6.36034831e-02f },
    },
    {
      { 3.04642655e-02f, -5.70972301e-02f, 4.73126844e-02f, 5.71425725e-03f, -7.57075846e-02f },
      { 1.78238973e-02f, -5.20869978e-02f, -6.57979539e-03f, -5.01268953e-02f, 5.25476085e-03f },
      { -6.27501160e-02f, 4.89421748e-02f, 4.87073213e-02f, -9.11403354e-03f, 4.51038452e-03f },
      { -5.61553575e-02f, -4.59222198e-02f, -6.26614364e-03f, -2.58458462e-02f, -8.41638539e-03f },
      { 1.66645069e-02f, 3.76442894e-02f, -1.54055655e-02f, 1.71908196e-02f, 2.31211036e-02f },
    },
    {
      { -2.04685144e-02f, 3.78316194e-02f, -4.12014090e-02f, -1.16250683e-02f, -3.33777182e-02f },
      { 3.68826948e-02f, -6.89536007e-03f, -2.85243429e-02f, -3.68346907e-02f, 4.71166633e-02f },
      { -4.69220392e-02f, 4.27752472e-02f, -3.22098881e-02f, 3.71189304e-02f, -6.20963983e-02f },
      { -5.22082075e-02f, 8.41825095e-04f, 2.61688754e-02f, 1.42591875e-02f, -5.24497628e-02f },
      { -6.86986744e-02f, 5.15702032e-02f, 4.92303073e-02f, -5.12260608e-02f, -2.92114280e-02f },
    },
    {
      { -3.79621983e-02f, 4.35956605e-02f, -5.56906164e-02f, -5.97110614e-02f, 3.31099927e-02f },
      { 1.59461927e-02f, 2.20765397e-02f, -4.30829823e-02f, 1.73178893e-02f, -5.38683981e-02f },
      { -2.72264164e-02f, -3.86338271e-02f, -5.38359210e-02f, -5.38480049e-03f, -2.98972391e-02f },
      { 1.04804942e-02f, 3.35886627e-02f, 5.05104885e-02f, 4.76110764e-02f, -6.60457313e-02f },
      { -4.30127792e-02f, -2.25479621e-02f, 5.30182943e-02f, -3.78850512e-02f, 7.37663126e-03f },
    },
    {
      { 4.97583002e-02f, -3.73486280e-02f, -1.09037757e-02f, -4.40744534e-02f, 4.90217842e-02f },
      { 5.31081669e-02f, -6.39569461e-02f, -2.73648817e-02f, -1.24852629e-02f, 3.40435915e-02f },
      { -3.04513201e-02f, -3.54570970e-02f, 8.34494550e-03f, -6.03176244e-02f, -5.00842631e-02f },
      { 1.10597536e-02f, 4.15068120e-03f, -1.76196359e-02f, -5.32708466e-02f, -2.57143658e-02f },
      { 5.27373813e-02f, -3.41716744e-02f, 4.77932841e-02f, 2.72264630e-02f, 3.39180976e-02f },
    },
    {
      { 4.91119083e-03f, 3.82455885e-02f, -1.65769663e-02f, -4.33773734e-02f, -6.59162551e-02f },
      { 3.93574089e-02f, -1.87573861e-02f, 5.11415377e-02f, -3.57776769e-02f, 2.91134603e-02f },
      { -1.51804872e-02f, -2.48726495e-02f, -3.91361080e-02f, -3.80569845e-02f, -5.12439422e-02f },
      { 3.48339714e-02f, -3.52864340e-02f, 2.72813104e-02f, 4.95223776e-02f, -3.72228189e-03f },
      { 4.30990420e-02f, -5.79523183e-02f, -4.59943675e-02f, -6.10324042e-03f, 1.26849171e-02f },
    },
    {
      { -4.38090488e-02f, -5.43026216e-02f, 5.25516681e-02f, -1.36715397e-02f, 1.80227645e-02f },
      { -6.52859658e-02f, -3.29471268e-02f, -6.69693062e-03f, 3.51552777e-02f, 1.44031569e-02f },
      { -5.92200756e-02f, -1.11037716e-02f, 5.63029293e-03f, 4.82048206e-02f, -3.90914008e-02f },
      { 4.03399877e-02f, 2.75378972e-02f, -5.62864542e-02f, 3.93150114e-02f, -4.24072240e-03f },
      { 5.08949673e-03f, -3.28504294e-02f, 2.38828380e-02f, 3.50314602e-02f, -1.33205475e-02f },
    },
    {
      { -8.71586613e-03f, -6.39750063e-02f, 5.97018283e-03f, -1.40950112e-02f, -3.18816677e-02f },
      { 3.42722870e-02f, -6.08395562e-02f, 4.09372970e-02f, 2.64552142e-02f, 3.04176416e-02f },
      { -2.81546637e-02f, -6.30402714e-02f, -5.50644435e-02f, -1.90814808e-02f, 1.51976543e-02f },
      { -3.34853120e-02f, -1.02811670e-02f, -5.12747690e-02f, 4.57199514e-02f, 4.05445993e-02f },
      { -1.35875558e-02f, 4.45001684e-02f, -5.76756038e-02f, -3.14077698e-02f, 3.61533929e-03f },
    },
    {
      { 2.51086056e-02f, -5.23475073e-02f, -2.93212123e-02f, 1.99192651e-02f, 3.73463891e-02f },
      { -2.43858173e-02f, -8.57271627e-03f, 2.96774060e-02f, 1.13673024e-02f, 1.03934500e-02f },
      { 2.68270541e-02f, 3.27090845e-02f, -6.65152352e-03f, -5.68257943e-02f, -5.79984684e-04f },
      { -4.59217727e-02f, 2.83710491e-02f, -5.52030951e-02f, 1.30453231e-02f, -4.95316796e-02f },
      { -4.87113148e-02f, 8.05559510e-04f, 1.79589782e-02f, -5.01297228e-03f, -4.99377362e-02f },
    },
    {
      { 5.49539402e-02f, 4.00307216e-02f, -5.36949188e-02f, 1.90203264e-02f, -2.91585382e-02f },
      { 1.05948020e-02f, -4.67970669e-02f, 2.90927608e-02f, -1.04125682e-02f, 1.83898322e-02f },
      { -3.45766656e-02f, 6.98726112e-03f, 4.37927842e-02f, -1.34892212e-02f, -1.61569994e-02f },
      { 3.56836282e-02f, -1.37267560e-02f, 3.89421657e-02f, 2.42521241e-03f, -8.42769805e-04f },
      { -2.81290952e-02f, -7.72807281e-04f, -2.01984309e-02f, -5.78443743e-02f, 3.69753614e-02f },
    },
    {
      { -5.24997711e-02f, -6.74449429e-02f, 1.11026829e-02f, -2.71272194e-02f, 1.94505211e-02f },
      { -6.42505959e-02f, -2.01069401e-03f, -3.99020594e-03f, 3.90704572e-02f, 4.46039662e-02f },
      { -5.03481552e-02f, 8.54146853e-03f, -6.95190672e-03f, 5.30545190e-02f, 4.06217203e-02f },
      { 4.41900045e-02f, 3.88938300e-02f, 3.00824596e-03f, -6.54938892e-02f, -2.92836409e-02f },
      { 1.61295142e-02f, 3.98987066e-03f, 4.58750874e-03f, -5.25572300e-02f, -4.59619090e-02f },
    },
    {
      { 3.76849957e-02f, -3.49513292e-02f, 1.48786511e-02f, 5.12132086e-02f, 3.53348069e-02f },
      { -4.27399650e-02f, 5.39808124e-02f, -3.88252027e-02f, 5.31648621e-02f, 3.79183404e-02f },
      { -1.53095471e-02f, 1.49702409e-03f, 5.31102754e-02f, 3.07743400e-02f, -5.13417348e-02f },
      { -1.70506444e-02f, 5.78820286e-03f, 2.24788990e-02f, -2.24657822e-02f, 4.73811626e-02f },
      { 2.44380347e-02f, -3.61139663e-02f, -3.97429429e-02f, -2.78776828e-02f, 7.51810567e-03f },
    },
    {
      { -1.98477730e-02f, 6.03872398e-03f, 3.87770273e-02f, -1.66789594e-03f, 7.23661901e-03f },
      { -1.02315750e-02f, -2.88938787e-02f, 1.51762208e-02f, 3.98882926e-02f, -2.89082117e-02f },
      { -5.28537221e-02f, -4.20789681e-02f, -1.74730970e-03f, -1.95666440e-02f, 5.29613309e-02f },
      { -6.16697147e-02f, 4.39208560e-02f, 4.86830771e-02f, -5.77345025e-03f, -2.67574638e-02f },
      { -5.39015904e-02f, -5.68070114e-02f, -3.81021276e-02f, -5.21824658e-02f, -1.47877354e-02f },
    },
    {
      { -4.01826836e-02f, 9.72520001e-03f, -3.78715955e-02f, -4.39778008e-02f, -6.71485662e-02f },
      { -8.43462907e-03f, 6.95715239e-03f, -1.84259526e-02f, 4.84699346e-02f, -5.32625467e-02f },
      { -5.15525006e-02f, -1.70651954e-02f, 4.99831736e-02f, -6.41229302e-02f, 2.26904023e-02f },
      { 4.85666795e-04f, 4.40278687e-02f, -5.11241369e-02f, -2.63178408e-05f, -9.73123498e-03f },
      { -5.28651662e-02f, -9.08666663e-03f, 4.87113148e-02f, -1.19510461e-02f, 5.01280557e-03f },
    },
    {
      { -2.47226562e-02f, -3.53977196e-02f, -4.93817665e-02f, -1.67575348e-02f, -4.48754011e-03f },
      { -1.31627107e-02f, -5.00182472e-02f, -4.62763198e-02f, 5.27593978e-02f, 5.41426986e-03f },
      { 3.40862409e-03f, 4.09964211e-02f, 4.55059037e-02f, 7.32891914e-03f, -2.89695337e-02f },
      { -4.00094129e-02f, -4.34411950e-02f, 7.17086345e-03f, -4.74471264e-02f, 3.44319046e-02f },
      { -1.07476823e-02f, 1.41810197e-02f, -6.18268773e-02f, 2.32668966e-02f, -6.22021370e-02f },
    },
    {
      { 2.99821533e-02f, -2.43645845e-04f, 4.28552292e-02f, 4.50879037e-02f, -4.41936553e-02f },
      { -7.34837214e-03f, 3.08370739e-02f, 1.58601627e-02f, -2.85384618e-02f, -2.11755820e-02f },
      { -6.14638254e-02f, 4.24037874e-02f, 4.68560345e-02f, -4.98951748e-02f, -1.56869777e-02f },
      { -6.63857386e-02f, 4.15514931e-02f, -8.54050647e-03f, -5.89856841e-02f, 3.96741517e-02f },
      { -5.02116233e-02f, -8.62441398e-03f, 2.49401294e-02f, 1.52872894e-02f, 3.02474387e-02f },
    },
    {
      { 3.08595747e-02f, 2.51999535e-02f, -2.27336176e-02f, -2.04138681e-02f, -1.17699159e-02f },
      { 2.58416403e-02f, 2.10344000e-03f, 3.29440236e-02f, -5.42737097e-02f, -6.66563511e-02f },
      { -2.15095282e-02f, 2.07889330e-04f, -5.12914136e-02f, -2.12215483e-02f, 1.71977878e-02f },
      { 4.94305394e-04f, -1.09761776e-02f, -3.17783356e-02f, 6.88884780e-03f, -2.16654595e-02f },
      { 1.75357312e-02f, 1.35971829e-02f, -1.87980235e-02f, 1.16408467e-02f, -4.93939482e-02f },
    },
    {
      { -2.12451965e-02f, -4.42282222e-02f, -3.93309630e-02f, 5.20189293e-03f, -1.60027444e-02f },
      { 3.37942652e-02f, -3.59166525e-02f, -9.96401813e-03f, 4.30888496e-02f, -1.42168440e-02f },
      { 4.57552448e-02f, -6.13535158e-02f, 4.51485254e-02f, -5.91090582e-02f, 2.42577051e-03f },
      { -4.93280357e-03f, 8.13057926e-03f, -8.09467584e-03f, -1.78159345e-02f, -6.20975606e-02f },
      { -4.47435416e-02f, -1.89641714e-02f, -5.87144457e-02f, 1.30010815e-02f, -2.33583879e-02f },
    },
    {
      { 2.17810255e-02f, -3.84415686e-02f, -2.39470936e-02f, -6.24422096e-02f, 3.37535106e-02f },
      { -6.35413080e-02f, -3.98365147e-02f, -1.37131345e-02f, 2.16913484e-02f, 3.64873335e-02f },
      { -7.63103589e-02f, -3.74087431e-02f, -6.50311783e-02f, -4.37745191e-02f, -2.45954338e-02f },
      { 1.49656208e-02f, 3.02221421e-02f, 1.10083469e-03f, 2.35426091e-02f, -5.72754443e-02f },
      { 3.48971561e-02f, 6.56074136e-02f, -4.83410284e-02f, 5.00690192e-02f, 2.06873491e-02f },
    },
    {
      { 2.21777577e-02f, -4.71829884e-02f, 7.18069915e-03f, 1.54396249e-02f, -5.29517010e-02f },
      { -1.77028868e-02f, 3.67630124e-02f, 2.69887298e-02f, -4.93890047e-02f, 4.94268574e-02f },
      { 4.69409227e-02f, 3.31878699e-02f, -5.96769564e-02f, -1.08644650e-04f, -2.48400914e-03f },
      { -5.33897942e-03f, 2.73384564e-02f, 3.64317186e-02f, 9.14824940e-03f, -5.49730696e-02f },
      { -3.60382982e-02f, -5.06217927e-02f, 2.07877420e-02f, 1.64785180e-02f, -4.36118059e-03f },
    },
    {
      { -3.61826755e-02f, 3.78060602e-02f, -1.87969720e-03f, 2.17190031e-02f, -5.24189547e-02f },
      { -4.46509607e-02f, -6.00390062e-02f, -2.16546059e-02f, -5.36840409e-02f, 5.95334359e-02f },
      { -6.67734295e-02f, -6.14854135e-02f, -4.00707535e-02f, 1.00228908e-02f, -4.64406163e-02f },
      { 4.40877527e-02f, 1.11655397e-02f, -2.13874672e-02f, 3.68253551e-02f, -2.84351576e-02f },
      { 3.00071221e-02f, -6.26542047e-02f, 4.98784445e-02f, -5.85954450e-02f, 6.60488941e-03f },
    },
    {
      { -1.95365250e-02f, 1.88280642e-02f, -5.87187000e-02f, 3.76188345e-02f, -1.37508372e-02f },
      { 2.09483132e-02f, 4.28056009e-02f, 4.06838134e-02f, 4.72891368e-02f, 4.43744548e-02f },
      { -2.95683206e-03f, 3.90695892e-02f, -2.58541526e-03f, 5.44483401e-03f, -3.25067528e-03f },
      { -2.78150719e-02f, 9.53782722e-03f, 2.35905666e-02f, 3.63354362e-03f, 2.75445823e-02f },
      { 3.64610255e-02f, 3.20021026e-02f, -2.63662226e-02f, 2.22093426e-02f, 4.41951910e-03f },
    },
    {
      { 5.36523238e-02f, -3.83452438e-02f, 4.02148105e-02f, -1.22834686e-02f, 1.80627182e-02f },
      { 1.98247265e-02f, -3.54191251e-02f, 6.70115580e-04f, 4.37995382e-02f, -4.41136509e-02f },
      { 3.00836414e-02f, 4.48060371e-02f, 5.29674143e-02f, 5.37187606e-02f, -1.20379468e-02f },
      { -3.00982855e-02f, -4.08291705e-02f, -6.45211637e-02f, -5.42364791e-02f, 2.83914357e-02f },
      { 1.75056495e-02f, 4.28384133e-02f, 1.32105304e-02f, 2.13460438e-03f, 3.72513989e-03f },
    },
    {
      { -1.95486881e-02f, -1.95218865e-02f, -7.35074328e-03f, 4.62958179e-02f, 5.26687093e-02f },
      { 4.14587483e-02f, -1.39347473e-02f, 1.67664420e-02f, -1.43138152e-02f, -6.03277683e-02f },
      { -6.79218099e-02f, 1.50396116e-02f, 2.23276671e-02f, 3.61077562e-02f, -2.94817537e-02f },
      { -2.95437966e-02f, -5.73399179e-02f, 5.26336990e-02f, -3.81629020e-02f, 5.39047271e-03f },
      { -1.39499654e-03f, -4.46500629e-02f, -3.50393020e-02f, -6.01873733e-03f, 3.78149413e-02f },
    },
    {
      { 2.50057634e-02f, 4.60726991e-02f, -2.26893406e-02f, -1.91446878e-02f, -3.56049947e-02f },
      { 6.99274102e-03f, 3.36285681e-02f, -2.17171926e-02f, -5.93790151e-02f, -1.53789707e-02f },
      { -6.88586310e-02f, -6.22109026e-02f, 2.31062695e-02f, 3.76847200e-02f, -2.08638832e-02f },
      { -9.78426449e-03f, -2.09176671e-02f, -1.48961721e-02f, 1.85840316e-02f, -7.40413144e-02f },
      { 4.47810702e-02f, -8.78262520e-03f, 9.80583951e-03f, 1.26341488e-02f, -1.74483079e-02f },
    },
  },
  {
    {
      { 3.41861695e-02f, -9.06343833e-02f, -8.85682479e-02f, -3.12169548e-02f, 5.67609328e-04f },
      { -2.16852110e-02f, -7.15314597e-02f, 3.90209048e-03f, -6.82468787e-02f, -2.63047870e-02f },
      { -4.18811552e-02f, 1.54367881e-02f, 6.58901874e-03f, -3.97774801e-02f, 5.90295624e-03f },
      { -2.27432493e-02f, -7.48730376e-02f, -1.66691355e-02f, -5.71215292e-03f, -6.42049611e-02f },
      { -8.41139406e-02f, -7.64345527e-02f, -7.09582642e-02f, -2.81582456e-02f, -4.25508171e-02f },
    },
    {
      { -3.91522683e-02f, -3.53418454e-03f, -9.30060595e-02f, 5.78134321e-02f, 5.30311931e-03f },
      { -2.51263790e-02f, -8.71794000e-02f, -5.23816384e-02f, 1.88236944e-02f, 1.53686590e-02f },
      { -3.35546620e-02f, 7.02738948e-03f, -2.87311431e-02f, 2.24305931e-02f, -1.10283610e-03f },
      { -3.92737053e-03f, -9.11897346e-02f, 2.49721445e-02f, -3.85077146e-04f, -5.53540699e-02f },
      { -6.96144849e-02f, -7.15578869e-02f, -2.61785705e-02f, 1.63585600e-02f, 1.78588666e-02f },
    },
    {
      { -3.68233398e-02f, -1.83502287e-02f, -4.11047153e-02f, -3.10205705e-02f, -2.39259452e-02f },
      { -9.61975567e-03f, -7.04394728e-02f, 3.14694084e-02f, -1.20980758e-02f, -4.48688632e-03f },
      { 1.40476301e-02f, -6.21571541e-02f, -1.01939896e-02f, 7.15246750e-03f, 2.77318563e-02f },
      { -2.54964326e-02f, -3.94295044e-02f, -2.27429532e-02f, -7.63217509e-02f, 2.03749351e-02f },
      { 2.19071377e-02f, 3.83586884e-02f, 9.75722354e-03f, 1.49624720e-02f, 1.63062997e-02f },
    },
    {
      { -8.54617208e-02f, 1.28494082e-02f, -6.05912805e-02f, -1.74683202e-02f, -8.89289565e-03f },
      { -4.85371500e-02f, -8.09561014e-02f, -7.25890696e-02f, -3.33681842e-03f, 1.18883103e-02f },
      { 4.14299630e-02f, 2.23784577e-02f, -2.62204185e-02f, -7.64947459e-02f, -1.32733313e-02f },
      { -2.18465216e-02f, -3.55759170e-03f, 7.42650242e-04f, 3.45674180e-03f, -4.07561846e-02f },
      { -2.66006943e-02f, -6.77138641e-02f, 6.38544234e-03f, -3.42554785e-02f, 4.14995216e-02f },
    },
    {
      { 1.40699074e-02f, -8.82121772e-02f, -7.23633170e-02f, -1.80338032e-03f, -1.50254171e-03f },
      { -4.39731590e-02f, -2.56792014e-03f, 4.71174810e-03f, -7.56381452e-02f, -6.44309744e-02f },
      { -6.43417414e-04f, 2.45738570e-02f, -1.75983552e-02f, 2.52006948e-02f, -7.39522427e-02f },
      { 1.73961446e-02f, -2.53078472e-02f, 2.83524003e-02f, 1.19778526e-03f, -8.44690576e-02f },
      { 4.12662998e-02f, -4.19180207e-02f, -8.18542298e-03f, -2.63096839e-02f, -4.75956723e-02f },
    },
    {
      { -2.66409349e-02f, -2.55088471e-02f, 2.20498350e-03f, -2.56169438e-02f, -1.52554968e-02f },
      { -5.91338687e-02f, 3.21296044e-02f, -4.40415218e-02f, -8.79374370e-02f, -2.05433182e-02f },
      { -8.29253644e-02f, -7.83778727e-02f, -7.99047500e-02f, -5.76033909e-03f, -6.60760030e-02f },
      { -1.51268616e-02f, -2.01860233e-03f, 1.21904733e-02f, -4.32783738e-02f, -6.29406497e-02f },
      { -3.99169885e-02f, -4.57005501e-02f, 5.21185575e-03f, -9.21852514e-03f, 1.94970313e-02f },
    },
    {
      { -7.81727508e-02f, 2.63581774e-03f, -5.20783886e-02f, -1.24528017e-02f, -2.62713246e-02f },
      { -9.95893683e-03f, -4.59109358e-02f, -4.76635210e-02f, 2.10876353e-02f, -5.90596497e-02f },
      { -7.89565966e-02f, 4.07444537e-02f, 4.33043391e-02f, -1.81785348e-04f, 1.65774785e-02f },
      { 5.00109456e-02f, 9.31992475e-03f, 5.69587909e-02f, -7.01839253e-02f, -8.78183693e-02f },
      { 3.12584005e-02f, 4.50326912e-02f, -1.01326331e-02f, 1.31816547e-02f, -1.24349883e-02f },
    },
    {
      { 4.82917484e-03f, -5.20784669e-02f, -3.33279707e-02f, -2.80382633e-02f, -3.42059582e-02f },
      { -1.69946868e-02f, -3.92502770e-02f, 4.06971760e-02f, 4.36541438e-02f, -5.61724566e-02f },
      { -9.38269496e-03f, 4.39402312e-02f, -5.76649234e-02f, 2.96731610e-02f, 3.29914317e-02f },
      { -6.67212754e-02f, 2.62136422e-02f, 2.05468051e-02f, -1.45117361e-02f, -2.02380363e-02f },
      { -4.08905745e-02f, -5.77960201e-02f, -2.85754143e-03f, -2.04110350e-02f, 8.13463796e-03f },
    },
    {
      { 2.95204762e-02f, 2.73254216e-02f, -4.12239134e-02f, -5.61817586e-02f, 9.30351904e-04f },
      { -6.40513152e-02f, 2.37528346e-02f, -6.68808147e-02f, 2.09900131e-03f, 1.79437771e-02f },
      { -3.08067761e-02f, -4.24973555e-02f, -6.03359453e-02f, -5.77346701e-03f, 1.28588723e-02f },
      { -4.23914455e-02f, 3.68690235e-03f, -5.31047918e-02f, -5.44872507e-03f, 4.25901543e-03f },
      { 1.71557791e-03f, -8.17295983e-02f, -8.48801527e-03f, -6.59360811e-02f, -8.36740732e-02f },
    },
    {
      { 3.10841538e-02f, -1.65756438e-02f, -5.96137065e-03f, 3.17338631e-02f, -7.46204406e-02f },
      { -2.54880600e-02f, -7.28671327e-02f, -8.75200331e-02f, 3.30013335e-02f, 3.63756046e-02f },
      { -2.69604735e-02f, 1.62722298e-03f, 3.79741378e-02f, -4.92951460e-02f, -4.80486453e-02f },
      { 3.48273888e-02f, -5.16404621e-02f, 3.03384159e-02f, 1.88762639e-02f, 5.12011163e-02f },
      { -3.32938246e-02f, -4.26682606e-02f, 1.06585966e-02f, -2.37383670e-03f, 4.54064496e-02f },
    },
    {
      { -3.86182070e-02f, 2.04693116e-02f, -2.03026328e-02f, -5.36822751e-02f, -2.81967260e-02f },
      { -2.09623557e-02f, -2.93339835e-03f, -4.93683666e-03f, -5.91590293e-02f, -7.48017505e-02f },
      { -3.58131453e-02f, -4.73197438e-02f, -5.34018688e-02f, 1.10146096e-02f, -6.48837686e-02f },
      { -7.34295249e-02f, -2.50510196e-03f, -1.21598681e-02f, -7.10217804e-02f, -6.45996481e-02f },
      { -2.45990008e-02f, -7.91563988e-02f, 3.40317376e-02f, -5.09417653e-02f, -3.84718850e-02f },
    },
    {
      { -3.67593169e-02f, 2.96419542e-02f, 3.19506824e-02f, -1.25824362e-02f, -5.32153100e-02f },
      { -6.32019415e-02f, 2.36522350e-02f, -8.41239616e-02f, -2.57802866e-02f, -2.00626273e-02f },
      { 2.45580934e-02f, -3.13006788e-02f, -3.28292176e-02f, 2.71490589e-02f, -5.70353419e-02f },
      { 1.05382986e-02f, -4.99084480e-02f, -2.87538450e-02f, -1.21617978e-02f, 1.72765423e-02f },
      { -2.42813397e-02f, 2.95214374e-02f, 5.12978621e-03f, -3.91792357e-02f, 2.34759953e-02f },
    },
    {
      { 2.25073677e-02f, -1.46672102e-02f, -1.51639199e-02f, -4.75569852e-02f, 1.71146113e-02f },
      { -5.60559146e-02f, -8.69708136e-02f, -6.67477176e-02f, 2.38820575e-02f, 1.16102416e-02f },
      { 1.45505201e-02f, 1.07947597e-02f, -4.87861522e-02f, -6.56794831e-02f, -4.46330383e-02f },
      { -3.19156311e-02f, -5.05104177e-02f, -3.31089161e-02f, -7.00775534e-02f, 1.74159277e-02f },
      { -9.22518410e-03f, 4.04514596e-02f, 4.73687649e-02f, -6.98931813e-02f, -2.11970974e-03f },
    },
    {
      { -7.29686022e-02f, 1.31894108e-02f, -6.15692660e-02f, -4.71623391e-02f, -2.49264315e-02f },
      { -3.58080380e-02f, 1.25230094e-02f, 4.19673808e-02f, 1.43747805e-02f, 1.54945115e-02f },
      { 4.88234870e-03f, -3.00225224e-02f, 3.86295654e-02f, 1.53683349e-02f, 2.51135360e-02f },
      { -6.90371916e-02f, 8.77238251e-03f, -7.09906826e-03f, -5.48182055e-02f, 2.42616460e-02f },
      { -4.05427590e-02f, -4.11728881e-02f, -5.71061037e-02f, -1.10654095e-02f, -3.26057412e-02f },
    },
    {
      { 9.19505022e-03f, 1.80882271e-02f, 2.01508440e-02f, -2.97849178e-02f, 2.57153045e-02f },
      { 4.98298891e-02f, 1.00217322e-02f, -3.04631870e-02f, -2.77096611e-02f, -5.80568314e-02f },
      { -5.88583164e-02f, -4.42001298e-02f, 6.46654400e-04f, -1.14665029e-03f, 2.89350674e-02f },
      { -3.70273665e-02f, 3.13811228e-02f, 6.72072098e-02f, -4.03153598e-02f, 3.97779606e-02f },
      { 8.69094394e-03f, 5.80488257e-02f, -4.63756695e-02f, 1.17016048e-03f, 1.64370351e-02f },
    },
    {
      { -3.68429869e-02f, -6.79943711e-02f, -4.27686609e-02f, -2.62400648e-03f, -3.34843695e-02f },
      { 4.71023396e-02f, 8.52392986e-03f, -1.49416747e-02f, -2.34881928e-03f, 1.53227504e-02f },
      { 6.60100370e-04f, 3.48290242e-02f, 5.61243445e-02f, 5.39337471e-02f, 1.04099009e-02f },
      { -8.38178769e-03f, 3.98943499e-02f, -1.35714635e-02f, -9.21260715e-02f, 2.31173467e-02f },
      { -2.63224691e-02f, 5.89188933e-02f, 2.05445234e-02f, -3.79886874e-03f, -7.60102719e-02f },
    },
    {
      { -4.67851572e-02f, -6.27994090e-02f, -3.87101481e-03f, -6.73482791e-02f, -1.81634966e-02f },
      { 3.53327841e-02f, -3.17311659e-02f, 2.81194337e-02f, -3.51862125e-02f, -1.75673198e-02f },
      { 5.27994074e-02f, -2.66896263e-02f, -3.40274610e-02f, -4.81007621e-02f, 4.73386720e-02f },
      { 4.30971496e-02f, 8.38126801e-03f, 5.46698179e-03f, -3.30737010e-02f, 2.41676415e-03f },
      { 2.38744281e-02f, -5.05923331e-02f, -5.91291077e-02f, -2.38715075e-02f, 4.74519283e-02f },
    },
    {
      { -5.06412350e-02f, -5.66410385e-02f, 7.32128136e-03f, -1.37801841e-02f, -9.46867559e-03f },
      { 2.79264012e-03f, -1.02192312e-02f, -2.64039449e-02f, 2.18701325e-02f, -6.69534057e-02f },
      { -5.80210239e-02f, -2.57470850e-02f, -4.65418166e-03f, -5.36724366e-02f, -5.13099656e-02f },
      { 2.26961095e-02f, -4.15238403e-02f, -4.69044372e-02f, -2.82860305e-02f, -5.10042906e-02f },
      { -2.22131871e-02f, 2.91940905e-02f, 5.54669425e-02f, -7.33713657e-02f, -2.09583361e-02f },
    },
    {
      { 1.71225406e-02f, 8.68397392e-03f, -7.57176280e-02f, -7.05032563e-03f, -6.71859533e-02f },
      { 7.52486195e-03f, -7.64668137e-02f, 2.78000012e-02f, 1.55458031e-02f, -8.50124937e-03f },
      { -4.37968643e-03f, 1.44935334e-02f, -1.11929849e-02f, 2.11799704e-02f, 1.32298041e-02f },
      { -5.15759513e-02f, 6.32822746e-03f, -7.84324929e-02f, 2.21431106e-02f, 2.15004440e-02f },
      { 1.92866363e-02f, -2.06578430e-02f, -5.05568050e-02f, 4.99522276e-02f, -8.45431015e-02f },
    },
    {
      { -1.99624766e-02f, -3.83138470e-02f, -9.34375077e-02f, 2.03794651e-02f, -2.61690095e-02f },
      { -3.06248907e-02f, -7.98187256e-02f, -8.36252868e-02f, -8.01435634e-02f, -6.60527945e-02f },
      { -6.08064234e-02f, 1.37433270e-02f, -4.11275551e-02f, -7.53252581e-02f, 2.63429917e-02f },
      { 2.54665017e-02f, -5.48996553e-02f, -2.81873289e-02f, -2.93342229e-02f, -4.07256372e-02f },
      { -5.21286018e-02f, -7.85115585e-02f, -4.51312251e-02f, -8.56954679e-02f, -3.49776298e-02f },
    },
    {
      { -5.31887971e-02f, -4.66100797e-02f, -7.53436685e-02f, -7.61772096e-02f, -3.46767120e-02f },
      { -6.50100932e-02f, -7.71526992e-02f, 1.46140205e-02f, -9.06798244e-02f, -2.19905581e-02f },
      { -2.25560945e-02f, 1.01808924e-02f, -9.72215203e-04f, -9.24840104e-03f, -5.49257621e-02f },
      { -7.44631961e-02f, -8.35561752e-02f, -6.15549870e-02f, -4.71749343e-03f, -5.52175492e-02f },
      { -5.51662501e-03f, -1.04527408e-02f, -1.80879049e-02f, -2.57763136e-02f, 2.93159764e-02f },
    },
    {
      { 1.79219134e-02f, -4.01163362e-02f, 1.96992364e-02f, -3.67746055e-02f, -1.33178486e-02f },
      { 4.72543165e-02f, -1.25271855e-02f, -3.81285846e-02f, -7.86859617e-02f, 2.69540437e-02f },
      { -3.93217579e-02f, 5.55400401e-02f, 1.85330138e-02f, -5.51825874e-02f, -1.74529050e-02f },
      { -8.78253579e-03f, 3.50343809e-02f, -3.56046073e-02f, -5.83678111e-02f, -4.45024632e-02f },
      { 3.04478817e-02f, 1.36861214e-02f, -2.30875462e-02f, 2.46634427e-02f, -1.60158351e-02f },
    },
    {
      { 1.50262390e-03f, -9.72491801e-02f, -7.23638162e-02f, -9.90788639e-02f, -6.77926317e-02f },
      { 1.30302468e-02f, -2.91658640e-02f, -8.78971294e-02f, -8.69216099e-02f, -5.01650348e-02f },
      { -4.16952595e-02f, -3.58459540e-02f, 4.98390151e-03f, -1.59136008e-03f, -1.19100995e-02f },
      { -2.59370040e-02f, -9.55077112e-02f, 1.43137099e-02f, 5.26205450e-02f, 4.32339206e-04f },
      { -3.22773494e-02f, 2.51410641e-02f, 2.36983150e-02f, -1.77073907e-02f, 1.08929407e-02f },
    },
    {
      { -6.10735007e-02f, 2.02679969e-02f, 4.32027690e-03f, -3.87927219e-02f, -3.40108462e-02f },
      { -5.90175800e-02f, 1.28919948e-02f, 5.17259678e-03f, 4.97524738e-02f, -6.77814260e-02f },
      { -5.72509542e-02f, -6.00653924e-02f, -4.35017236e-02f, -6.80909604e-02f, 1.14438031e-02f },
      { -1.66926906e-02f, -4.24919091e-02f, -6.44149557e-02f, -8.98366794e-02f, -3.21805328e-02f },
      { -5.76842763e-03f, -1.47196092e-03f, -2.98152156e-02f, -8.31133947e-02f, -2.79314537e-02f },
    },
    {
      { -9.21047926e-02f, -6.41656518e-02f, -1.06727984e-03f, -6.10378683e-02f, -2.91074421e-02f },
      { -7.40201548e-02f, -1.61120426e-02f, 5.82289184e-04f, -2.49384660e-02f, 2.94127446e-02f },
      { -8.29598587e-03f, -5.23362420e-02f, 3.96345966e-02f, 3.81977186e-02f, -1.92363467e-02f },
      { 1.74640156e-02f, -6.52213171e-02f, -2.98566744e-02f, -9.09427833e-03f, -2.04311637e-03f },
      { -8.24894682e-02f, -3.35948169e-02f, 4.35619894e-03f, 4.00679372e-02f, -5.40221855e-03f },
    },
    {
      { 8.03682487e-03f, -8.73367563e-02f, -7.61088391e-04f, -3.60359661e-02f, 5.63600846e-02f },
      { 2.04974562e-02f, 1.15403784e-02f, 1.48080976e-03f, -6.88505359e-03f, 7.50351418e-03f },
      { -3.72466668e-02f, -2.14633923e-02f, -9.22899619e-02f, -4.62834612e-02f, -6.33699493e-03f },
      { -4.24661115e-02f, -8.16724524e-02f, -2.40631532e-02f, -2.58229263e-02f, -4.86211255e-02f },
      { -5.63904755e-02f, -6.81956634e-02f, 9.26341675e-03f, -8.28611106e-02f, -5.55749461e-02f },
    },
    {
      { -4.98671690e-03f, -6.72860742e-02f, -4.16645445e-02f, -8.46280456e-02f, 1.47434417e-02f },
      { -7.84306079e-02f, -4.99497540e-02f, -3.81393395e-02f, 2.21223012e-02f, -4.03142981e-02f },
      { 7.08445068e-03f, -1.75833013e-02f, -3.26366052e-02f, -1.95163046e-03f, -7.44884163e-02f },
      { 2.25337390e-02f, 3.16268541e-02f, 6.34086924e-03f, -8.85458142e-02f, -6.16837814e-02f },
      { -5.77187948e-02f, 2.29369439e-02f, 1.61395390e-02f, -9.49695799e-03f, -8.67720544e-02f },
    },
    {
      { -8.16734433e-02f, -2.00534444e-02f, -4.46276180e-02f, -4.82621789e-02f, -1.99522078e-02f },
      { -7.96873122e-02f, -7.35621303e-02f, -6.27185926e-02f, -3.36125083e-02f, -4.76743095e-02f },
      { 3.15349773e-02f, -5.46417683e-02f, -6.79595768e-02f, -3.05668619e-02f, -7.14605451e-02f },
      { -1.76737588e-02f, 1.74090564e-02f, -5.76976053e-02f, -9.14469287e-02f, -5.71878552e-02f },
      { -7.77000189e-02f, -8.92853662e-02f, -6.70184568e-02f, 1.99929327e-02f, 1.53831057e-02f },
    },
    {
      { -8.55155364e-02f, -8.07575881e-02f, -4.26294394e-02f, -6.47305548e-02f, -4.96139340e-02f },
      { -1.70894153e-02f, 5.20983851e-03f, 3.48142274e-02f, -2.31711306e-02f, 1.62345951e-03f },
      { -5.41310012e-02f, -5.45652062e-02f, -4.23439443e-02f, -5.77227809e-02f, -7.56547302e-02f },
      { -5.55614643e-02f, 3.47876139e-02f, -3.56667377e-02f, -2.76327804e-02f, -6.95272982e-02f },
      { -1.76880248e-02f, -5.15973866e-02f, -7.61487633e-02f, 2.26531923e-02f, 3.68061438e-02f },
    },
    {
      { -6.07300401e-02f, -2.69598812e-02f, -3.77947316e-02f, -3.56301516e-02f, 1.25081353e-02f },
      { -6.30069152e-03f, -4.81778905e-02f, 2.31468584e-03f, 6.05269484e-02f, 5.54443039e-02f },
      { 4.14987430e-02f, -1.67150293e-02f, -3.54478508e-02f, 5.09807356e-02f, -6.03620820e-02f },
      { 2.93544028e-02f, -5.32518029e-02f, -1.60921793e-02f, -3.61809954e-02f, -2.90036220e-02f },
      { -4.21880856e-02f, -1.14258127e-02f, -8.87146499e-03f, 2.82408334e-02f, -3.32187675e-02f },
    },
    {
      { -2.66480278e-02f, -8.26366469e-02f, -2.54630558e-02f, -5.96215762e-02f, -3.76834422e-02f },
      { -2.86123739e-03f, -7.54900947e-02f, -8.51687416e-02f, -7.00992867e-02f, -6.40533939e-02f },
      { -5.64318486e-02f, 1.45458542e-02f, -4.91007529e-02f, -8.02259520e-02f, -6.56925216e-02f },
      { -4.30188887e-03f, 6.50383439e-03f, -3.03878766e-02f, -3.50216292e-02f, -5.94300516e-02f },
      { 3.18607269e-03f, 7.94622023e-03f, -6.85924739e-02f, 2.74789054e-02f, -4.16381471e-02f },
    },
    {
      { -2.21944600e-02f, 1.88627206e-02f, -6.78636804e-02f, 1.18982559e-02f, -1.05656888e-02f },
      { 5.28468285e-03f, 1.69706978e-02f, -1.92703237e-03f, -3.15889120e-02f, -6.61413297e-02f },
      { -3.75381000e-02f, -4.10588086e-02f, 2.58244318e-03f, -5.17665818e-02f, 5.93506079e-03f },
      { -3.54721807e-02f, -2.13404637e-04f, 1.17046703e-02f, 6.20665587e-03f, -8.03759918e-02f },
      { -7.56040066e-02f, 2.20438261e-02f, 2.95745358e-02f, -3.04429103e-02f, -3.34853157e-02f },
    },
  },
};

static const float CONV2_B[32] = { -6.66631199e-03f, 3.60889696e-02f, -7.76760373e-03f, 9.08902735e-02f, 1.20832928e-01f, 1.13073848e-01f, 3.36280242e-02f, -1.31016728e-02f, 1.37137309e-01f, -1.54991103e-02f, 8.25923905e-02f, -4.19563800e-03f, 1.64006025e-01f, -2.84935702e-02f, 1.26547888e-01f, -1.02228886e-02f, 1.19942196e-01f, 1.96260020e-01f, 1.50374323e-01f, -3.34675647e-02f, 1.26657829e-01f, -7.37301121e-03f, -6.43289881e-03f, 8.19962546e-02f, -3.72818019e-03f, -3.32392938e-02f, 2.47047916e-01f, 4.34767008e-02f, 6.85050040e-02f, 6.84835613e-02f, -6.65552961e-03f, -3.81805226e-02f };


extern void conv2(float X[32][14][14], float Y[32][(14 -5 +1)][(14 -5 +1)]);
# 6 "conv2d_layer2.cpp" 2








void conv2(float X[32][14][14], float Y[32][(14 -5 +1)][(14 -5 +1)]) {

#pragma HLS bind_storage variable=CONV2_W type=RAM_1P impl=bram
#pragma HLS bind_storage variable=CONV2_B type=ROM_1P impl=bram


#pragma HLS ARRAY_PARTITION variable=CONV2_W dim=2 complete
#pragma HLS ARRAY_PARTITION variable=CONV2_W dim=3 complete
#pragma HLS ARRAY_PARTITION variable=CONV2_W dim=4 complete
#pragma HLS ARRAY_PARTITION variable=X dim=1 complete
#pragma HLS INTERFACE mode=ap_memory port=X depth=32*14*14
#pragma HLS INTERFACE mode=ap_memory port=Y depth=32*(14 -5 +1)*(14 -5 +1)

#pragma HLS PIPELINE II=1
 M_: for (int m = 0; m < 32; m++) {
  Y_: for (int y = 0; y < (14 -5 +1); y++) {
   X_ : for (int x = 0; x < (14 -5 +1); x++) {
    float acc = CONV2_B[m];
    C_ : for (int c = 0; c < 32; c++) {
     KY_ : for (int ky = 0; ky < 5; ky++) {
      KX_ : for (int kx = 0; kx < 5; kx++) {
       acc += X[c][y+ky][x+kx] * CONV2_W[m][c][ky][kx];
      }
     }
    }

    if (acc < 0.0f) {
     Y[m][y][x] = 0.0f;
    }
    else {
     Y[m][y][x] = acc;
    }
   }
  }
 }
}
